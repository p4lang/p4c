#!/usr/bin/env python
# Copyright 2016-present Barefoot Networks, Inc. 
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# This script generates a "unified" C++ source file which simply #include's
# other source files specified on the command line. The idea is that rather than
# compiling the original source files, we compile only the unified file, which
# greatly reduces compilation overhead in terms of I/O, duplicate template
# instantiations, and the like. This makes compiling the project much faster.
#
# Only '.c' and '.cpp' files should be passed to this script; other kinds of
# files will be ignored.
#
# For example, `gen-unified-sources.py foo.cpp bar.cpp baz.cpp`
# generates on stdout:
#   #include "foo.cpp"
#   #include "bar.cpp"
#   #include "baz.cpp"

from __future__ import print_function
import sys
import os
import stat

def generate_preamble(script_name):
    print('///////////////////////////////////////////////////////////////////')
    print('// Unified source file.')
    print('// Generated by:', script_name)
    print('// DO NOT EDIT. Changes will be overwritten.')
    print('///////////////////////////////////////////////////////////////////')
    print()

def generate_include(file_name):
    (_, extension) = os.path.splitext(file_name)
    if extension in ['.h', '.hpp']:
        print('// WARNING: Skipping header file:', file_name)
        return
    if extension not in ['.c', '.cpp']:
        print('// WARNING: Skipping non-C/C++ source file:', file_name)
        return

    print('#include "{}"'.format(file_name))
        
def main(argv):
    generate_preamble(argv[0])

    for arg in xrange(1, len(argv)):
        generate_include(argv[arg])
    
if __name__ == "__main__":
    main(sys.argv)
