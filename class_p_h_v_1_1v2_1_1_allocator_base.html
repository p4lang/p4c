<!-- HTML header for doxygen 1.13.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>P4 Compiler Documentation (P4C): PHV::v2::AllocatorBase Class Reference</title>
<link rel="icon" href="p4-fav.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!--  Add link to paragraphs   -->
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
  DoxygenAwesomeParagraphLink.init()
</script>
<!-- Add copy button to code fragments  -->
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
  DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add dark mode toggle -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
  DoxygenAwesomeDarkModeToggle.init()
</script>
<!-- Add interactive TOC -->
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
  DoxygenAwesomeInteractiveToc.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-interactive-toc.js" rel="stylesheet" type="text/css"/>
<link href="cards.css" rel="stylesheet" type="text/css"/>
<link href="flow.css" rel="stylesheet" type="text/css"/>
<link href="p4c_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="p4-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">P4C
   </div>
   <div id="projectbrief">The P4 Compiler</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_p_h_v_1_1v2_1_1_allocator_base.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_p_h_v_1_1v2_1_1_allocator_base-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">PHV::v2::AllocatorBase Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="allocator__base_8h_source.html">allocator_base.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PHV::v2::AllocatorBase:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_p_h_v_1_1v2_1_1_allocator_base__inherit__graph.svg" width="398" height="110"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_h_v_1_1v2_1_1_allocator_base_1_1_dfs_lists_allocator.html">DfsListsAllocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_h_v_1_1v2_1_1_allocator_base_1_1_dfs_state.html">DfsState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3754ab089e8ae1c76dd69fd4ea515f9e" id="r_a3754ab089e8ae1c76dd69fd4ea515f9e"><td class="memItemLeft" align="right" valign="top"><a id="a3754ab089e8ae1c76dd69fd4ea515f9e" name="a3754ab089e8ae1c76dd69fd4ea515f9e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AllocatorBase</b> (const <a class="el" href="struct_p_h_v_1_1v2_1_1_phv_kit.html">PhvKit</a> &amp;kit)</td></tr>
<tr class="separator:a3754ab089e8ae1c76dd69fd4ea515f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5745d0e64c03b0fe67871fb211d65ab" id="r_aa5745d0e64c03b0fe67871fb211d65ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p_h_v_1_1_transaction.html">PHV::Transaction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5745d0e64c03b0fe67871fb211d65ab">alloc_deparser_zero_cluster</a> (const <a class="el" href="class_p_h_v_1_1v2_1_1_score_context.html">ScoreContext</a> &amp;ctx, const <a class="el" href="class_p_h_v_1_1_allocation.html">PHV::Allocation</a> &amp;alloc, const <a class="el" href="class_p_h_v_1_1_super_cluster.html">PHV::SuperCluster</a> *sc, <a class="el" href="class_phv_info.html">PhvInfo</a> &amp;phv) const</td></tr>
<tr class="separator:aa5745d0e64c03b0fe67871fb211d65ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0eed40f5f4c367101599a90fb8f2ded" id="r_ac0eed40f5f4c367101599a90fb8f2ded"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_p_h_v_1_1v2_1_1_alloc_result.html">AllocResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0eed40f5f4c367101599a90fb8f2ded">alloc_strided_super_clusters</a> (const <a class="el" href="class_p_h_v_1_1v2_1_1_score_context.html">ScoreContext</a> &amp;ctx, const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;alloc, const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *sc, const ContainerGroupsBySize &amp;groups, <a class="el" href="class_p_h_v_1_1v2_1_1_allocator_metrics.html">AllocatorMetrics</a> &amp;alloc_metrics, const int max_n_slicings=64) const</td></tr>
<tr class="separator:ac0eed40f5f4c367101599a90fb8f2ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39381cf2e304bb5c2eab40bd8e8be7a5" id="r_a39381cf2e304bb5c2eab40bd8e8be7a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_p_h_v_1_1v2_1_1_alloc_result.html">AllocResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39381cf2e304bb5c2eab40bd8e8be7a5">try_sliced_super_cluster</a> (const <a class="el" href="class_p_h_v_1_1v2_1_1_score_context.html">ScoreContext</a> &amp;ctx, const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;alloc, const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *sc, const ContainerGroupsBySize &amp;groups, <a class="el" href="class_p_h_v_1_1v2_1_1_allocator_metrics.html">AllocatorMetrics</a> &amp;alloc_metrics) const</td></tr>
<tr class="memdesc:a39381cf2e304bb5c2eab40bd8e8be7a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">ALLOCATION functions common to trivial and greedy allocation.  <br /></td></tr>
<tr class="separator:a39381cf2e304bb5c2eab40bd8e8be7a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-types" name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:aee78b3f77214bcdcfce8b32e9343f04f" id="r_aee78b3f77214bcdcfce8b32e9343f04f"><td class="memItemLeft" align="right" valign="top"><a id="aee78b3f77214bcdcfce8b32e9343f04f" name="aee78b3f77214bcdcfce8b32e9343f04f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>DfsAllocCb</b> = std::function&lt;bool(const <a class="el" href="class_p_h_v_1_1_transaction.html">Transaction</a> &amp;)&gt;</td></tr>
<tr class="memdesc:aee78b3f77214bcdcfce8b32e9343f04f"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal type of callback. <br /></td></tr>
<tr class="separator:aee78b3f77214bcdcfce8b32e9343f04f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a37cd280273f8de614f615700f4bb3df9" id="r_a37cd280273f8de614f615700f4bb3df9"><td class="memItemLeft" align="right" valign="top"><a id="a37cd280273f8de614f615700f4bb3df9" name="a37cd280273f8de614f615700f4bb3df9"></a>
<a class="el" href="struct_p_h_v_1_1v2_1_1_alloc_result.html">AllocResult</a>&#160;</td><td class="memItemRight" valign="bottom"><b>alloc_stride</b> (const <a class="el" href="class_p_h_v_1_1v2_1_1_score_context.html">ScoreContext</a> &amp;ctx, const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;alloc, const std::vector&lt; <a class="el" href="class_p_h_v_1_1_field_slice.html">FieldSlice</a> &gt; &amp;stride, const ContainerGroupsBySize &amp;groups, <a class="el" href="class_p_h_v_1_1v2_1_1_allocator_metrics.html">AllocatorMetrics</a> &amp;alloc_metrics) const</td></tr>
<tr class="separator:a37cd280273f8de614f615700f4bb3df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaac0a080923600c9038bcd82c2873c8" id="r_aeaac0a080923600c9038bcd82c2873c8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_p_h_v_1_1v2_1_1_alloc_error.html">AllocError</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeaac0a080923600c9038bcd82c2873c8">check_container_scope_constraints</a> (const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;alloc, const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &gt; &amp;candidates, const <a class="el" href="class_p_h_v_1_1_container.html">Container</a> &amp;c) const</td></tr>
<tr class="separator:aeaac0a080923600c9038bcd82c2873c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060368723f64ebb31bcdc0a5b26c8f01" id="r_a060368723f64ebb31bcdc0a5b26c8f01"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="namespace_p_h_v.html#a3ff115c4ef9dcfb7a3565ddc263f0ece">PHV::Size</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a060368723f64ebb31bcdc0a5b26c8f01">compute_valid_container_sizes</a> (const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *sc) const</td></tr>
<tr class="separator:a060368723f64ebb31bcdc0a5b26c8f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa39be8a2bcdc418e990e4c8009b420" id="r_a0fa39be8a2bcdc418e990e4c8009b420"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_p_h_v_1_1v2_1_1_alloc_error.html">AllocError</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0fa39be8a2bcdc418e990e4c8009b420">is_container_bytes_ok</a> (const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;alloc, const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &gt; &amp;candidates, const <a class="el" href="class_p_h_v_1_1_container.html">Container</a> &amp;c) const</td></tr>
<tr class="separator:a0fa39be8a2bcdc418e990e4c8009b420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a874e205e39a00ab516aeac0533462052" id="r_a874e205e39a00ab516aeac0533462052"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_p_h_v_1_1v2_1_1_alloc_error.html">AllocError</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a874e205e39a00ab516aeac0533462052">is_container_gress_ok</a> (const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;alloc, const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &amp;sl, const <a class="el" href="class_p_h_v_1_1_container.html">Container</a> &amp;c) const</td></tr>
<tr class="separator:a874e205e39a00ab516aeac0533462052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d9480df75fd7754233358510e79b5b" id="r_a55d9480df75fd7754233358510e79b5b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_p_h_v_1_1v2_1_1_alloc_error.html">AllocError</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55d9480df75fd7754233358510e79b5b">is_container_solitary_ok</a> (const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;alloc, const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &amp;candidate, const <a class="el" href="class_p_h_v_1_1_container.html">Container</a> &amp;c) const</td></tr>
<tr class="separator:a55d9480df75fd7754233358510e79b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d61123d926efc9b603d211fbf86cee" id="r_ae6d61123d926efc9b603d211fbf86cee"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_p_h_v_1_1v2_1_1_alloc_error.html">AllocError</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6d61123d926efc9b603d211fbf86cee">is_container_type_ok</a> (const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &amp;sl, const <a class="el" href="class_p_h_v_1_1_container.html">Container</a> &amp;c) const</td></tr>
<tr class="memdesc:ae6d61123d926efc9b603d211fbf86cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">CONSTRAINT CHECKING Functions common to trivial and greedy allocation.  <br /></td></tr>
<tr class="separator:ae6d61123d926efc9b603d211fbf86cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9154a1de0ac22d117a8697c5cf380bf" id="r_ab9154a1de0ac22d117a8697c5cf380bf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_p_h_v_1_1v2_1_1_alloc_error.html">AllocError</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9154a1de0ac22d117a8697c5cf380bf">is_container_write_mode_ok</a> (const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;alloc, const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &amp;sl, const <a class="el" href="class_p_h_v_1_1_container.html">Container</a> &amp;c) const</td></tr>
<tr class="separator:ab9154a1de0ac22d117a8697c5cf380bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb4332040f2167739065956e9048a32" id="r_a1cb4332040f2167739065956e9048a32"><td class="memItemLeft" align="right" valign="top">std::vector&lt; const SuperCluster::SliceList * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1cb4332040f2167739065956e9048a32">make_alloc_order</a> (const <a class="el" href="class_p_h_v_1_1v2_1_1_score_context.html">ScoreContext</a> &amp;ctx, const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *sc, const <a class="el" href="namespace_p_h_v.html#a3ff115c4ef9dcfb7a3565ddc263f0ece">PHV::Size</a> width) const</td></tr>
<tr class="separator:a1cb4332040f2167739065956e9048a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c34f31dc4dcc0af7b630cb8f0155fd" id="r_a53c34f31dc4dcc0af7b630cb8f0155fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p_h_v_1_1_transaction.html">Transaction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53c34f31dc4dcc0af7b630cb8f0155fd">make_speculated_alloc</a> (const <a class="el" href="class_p_h_v_1_1v2_1_1_score_context.html">ScoreContext</a> &amp;ctx, const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;alloc, const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *sc, const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &gt; &amp;candidates, const <a class="el" href="class_p_h_v_1_1_container.html">Container</a> &amp;candidates_cont) const</td></tr>
<tr class="separator:a53c34f31dc4dcc0af7b630cb8f0155fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58a8c2ef56c1493bed01d530ec02eab" id="r_ac58a8c2ef56c1493bed01d530ec02eab"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac58a8c2ef56c1493bed01d530ec02eab">make_start_positions</a> (const <a class="el" href="class_p_h_v_1_1v2_1_1_score_context.html">ScoreContext</a> &amp;ctx, const SuperCluster::SliceList *sl, const <a class="el" href="namespace_p_h_v.html#a3ff115c4ef9dcfb7a3565ddc263f0ece">PHV::Size</a> width) const</td></tr>
<tr class="separator:ac58a8c2ef56c1493bed01d530ec02eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4507a5a412176d3195393265cd685d" id="r_a3c4507a5a412176d3195393265cd685d"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="class_p_h_v_1_1_transaction.html">Transaction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c4507a5a412176d3195393265cd685d">try_hints</a> (const <a class="el" href="class_p_h_v_1_1v2_1_1_score_context.html">ScoreContext</a> &amp;ctx, const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;alloc, const <a class="el" href="class_p_h_v_1_1_container_group.html">ContainerGroup</a> &amp;group, const <a class="el" href="class_p4_1_1ordered__map.html">ActionSourceCoPackMap</a> &amp;action_hints_map, <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_field_slice.html">PHV::FieldSlice</a> &gt; &amp;allocated, <a class="el" href="struct_p_h_v_1_1v2_1_1_sc_alloc_alignment.html">ScAllocAlignment</a> &amp;hint_enforced_alignments, <a class="el" href="class_p_h_v_1_1v2_1_1_allocator_metrics.html">AllocatorMetrics</a> &amp;alloc_metrics) const</td></tr>
<tr class="separator:a3c4507a5a412176d3195393265cd685d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed7d89a4550ed4684cc8d65e63f96cc" id="r_aaed7d89a4550ed4684cc8d65e63f96cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_p_h_v_1_1v2_1_1_some_cont_scope_alloc_result.html">SomeContScopeAllocResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaed7d89a4550ed4684cc8d65e63f96cc">try_slices_adapter</a> (const <a class="el" href="class_p_h_v_1_1v2_1_1_score_context.html">ScoreContext</a> &amp;ctx, const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;alloc, const <a class="el" href="class_p4_1_1ordered__map.html">FieldSliceAllocStartMap</a> &amp;fs_starts, const <a class="el" href="class_p_h_v_1_1_container_group.html">ContainerGroup</a> &amp;group, std::optional&lt; <a class="el" href="class_p_h_v_1_1_container.html">Container</a> &gt; c, <a class="el" href="class_p_h_v_1_1v2_1_1_allocator_metrics.html">AllocatorMetrics</a> &amp;alloc_metrics) const</td></tr>
<tr class="separator:aaed7d89a4550ed4684cc8d65e63f96cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33a6c927f57ff3a2757dc94d4e5491d" id="r_aa33a6c927f57ff3a2757dc94d4e5491d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_p_h_v_1_1v2_1_1_cont_scope_alloc_result.html">ContScopeAllocResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa33a6c927f57ff3a2757dc94d4e5491d">try_slices_to_container</a> (const <a class="el" href="class_p_h_v_1_1v2_1_1_score_context.html">ScoreContext</a> &amp;ctx, const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;alloc, const <a class="el" href="class_p4_1_1ordered__map.html">FieldSliceAllocStartMap</a> &amp;fs_starts, const <a class="el" href="class_p_h_v_1_1_container.html">Container</a> &amp;c, <a class="el" href="class_p_h_v_1_1v2_1_1_allocator_metrics.html">AllocatorMetrics</a> &amp;alloc_metrics, const bool skip_mau_checks=false) const</td></tr>
<tr class="separator:aa33a6c927f57ff3a2757dc94d4e5491d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf7ea3a442d4d717499e510b81fdc460" id="r_adf7ea3a442d4d717499e510b81fdc460"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_p_h_v_1_1v2_1_1_some_cont_scope_alloc_result.html">SomeContScopeAllocResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf7ea3a442d4d717499e510b81fdc460">try_slices_to_container_group</a> (const <a class="el" href="class_p_h_v_1_1v2_1_1_score_context.html">ScoreContext</a> &amp;ctx, const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;alloc, const <a class="el" href="class_p4_1_1ordered__map.html">FieldSliceAllocStartMap</a> &amp;fs_starts, const <a class="el" href="class_p_h_v_1_1_container_group.html">ContainerGroup</a> &amp;group, <a class="el" href="class_p_h_v_1_1v2_1_1_allocator_metrics.html">AllocatorMetrics</a> &amp;alloc_metrics) const</td></tr>
<tr class="separator:adf7ea3a442d4d717499e510b81fdc460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fdb425138ff0ee6cfb28bfa83002661" id="r_a8fdb425138ff0ee6cfb28bfa83002661"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_p_h_v_1_1v2_1_1_alloc_result.html">AllocResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8fdb425138ff0ee6cfb28bfa83002661">try_super_cluster_to_container_group</a> (const <a class="el" href="class_p_h_v_1_1v2_1_1_score_context.html">ScoreContext</a> &amp;ctx, const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;alloc, const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *sc, const <a class="el" href="class_p_h_v_1_1_container_group.html">ContainerGroup</a> &amp;group, <a class="el" href="class_p_h_v_1_1v2_1_1_allocator_metrics.html">AllocatorMetrics</a> &amp;alloc_metrics) const</td></tr>
<tr class="separator:a8fdb425138ff0ee6cfb28bfa83002661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4b2f42fd2c1837d5ed098a51b2520a" id="r_ade4b2f42fd2c1837d5ed098a51b2520a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_p_h_v_1_1v2_1_1_alloc_result.html">AllocResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade4b2f42fd2c1837d5ed098a51b2520a">try_wide_arith_slices_to_container_group</a> (const <a class="el" href="class_p_h_v_1_1v2_1_1_score_context.html">ScoreContext</a> &amp;ctx, const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;alloc, const <a class="el" href="struct_p_h_v_1_1v2_1_1_sc_alloc_alignment.html">ScAllocAlignment</a> &amp;alignment, const SuperCluster::SliceList *lo, const SuperCluster::SliceList *hi, const <a class="el" href="class_p_h_v_1_1_container_group.html">ContainerGroup</a> &amp;group, <a class="el" href="class_p_h_v_1_1v2_1_1_allocator_metrics.html">AllocatorMetrics</a> &amp;alloc_metrics) const</td></tr>
<tr class="separator:ade4b2f42fd2c1837d5ed098a51b2520a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453ba4a9aa4dca3f9ee6394697a0fc03" id="r_a453ba4a9aa4dca3f9ee6394697a0fc03"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_p_h_v_1_1v2_1_1_alloc_error.html">AllocError</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a453ba4a9aa4dca3f9ee6394697a0fc03">verify_can_pack</a> (const <a class="el" href="class_p_h_v_1_1v2_1_1_score_context.html">ScoreContext</a> &amp;ctx, const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;alloc, const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *sc, const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &gt; &amp;candidates, const <a class="el" href="class_p_h_v_1_1_container.html">Container</a> &amp;c, <a class="el" href="class_p4_1_1ordered__map.html">ActionSourceCoPackMap</a> &amp;co_pack_hints) const</td></tr>
<tr class="separator:a453ba4a9aa4dca3f9ee6394697a0fc03"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:acf366ea67a6166f61a4d2477ccf57e52" id="r_acf366ea67a6166f61a4d2477ccf57e52"><td class="memItemLeft" align="right" valign="top"><a id="acf366ea67a6166f61a4d2477ccf57e52" name="acf366ea67a6166f61a4d2477ccf57e52"></a>
const <a class="el" href="struct_p_h_v_1_1v2_1_1_phv_kit.html">PhvKit</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>kit_i</b></td></tr>
<tr class="separator:acf366ea67a6166f61a4d2477ccf57e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>AllocatorBase contains all reusable functions for PHV allocation, mostly 3 categories: (1) constraint checking functions that their names usually start with is_. (2) helper functions starts with make_* or compute_*. (3) allocation functions: const-qualified functions that returns an AllocResult. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aa5745d0e64c03b0fe67871fb211d65ab" name="aa5745d0e64c03b0fe67871fb211d65ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5745d0e64c03b0fe67871fb211d65ab">&#9670;&#160;</a></span>alloc_deparser_zero_cluster()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p_h_v_1_1_transaction.html">PHV::Transaction</a> PHV::v2::AllocatorBase::alloc_deparser_zero_cluster </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1v2_1_1_score_context.html">ScoreContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_allocation.html">PHV::Allocation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_super_cluster.html">PHV::SuperCluster</a> *</td>          <td class="paramname"><span class="paramname"><em>sc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_phv_info.html">PhvInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>phv</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function will always successfully allocate fieldslices of <code class="param">sc</code> to deparser zero optimization containers, which are B0 for ingress, B16 for egress. phv.addZeroContainer() will be called to add used deparser-zero containers. NOTE: if <code class="param">sc</code> is fully-clot allocated, it will be ignored. premise: (1) <code class="param">sc</code> must be deparser-zero optimization candidate. </p>

</div>
</div>
<a id="ac0eed40f5f4c367101599a90fb8f2ded" name="ac0eed40f5f4c367101599a90fb8f2ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0eed40f5f4c367101599a90fb8f2ded">&#9670;&#160;</a></span>alloc_strided_super_clusters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_p_h_v_1_1v2_1_1_alloc_result.html">AllocResult</a> PHV::v2::AllocatorBase::alloc_strided_super_clusters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1v2_1_1_score_context.html">ScoreContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *</td>          <td class="paramname"><span class="paramname"><em>sc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerGroupsBySize &amp;</td>          <td class="paramname"><span class="paramname"><em>groups</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p_h_v_1_1v2_1_1_allocator_metrics.html">AllocatorMetrics</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc_metrics</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>max_n_slicings</em></span><span class="paramdefsep"> = </span><span class="paramdefval">64</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Try to allocate stride super cluster <code class="param">sc</code>, without further slicing, to <code class="param">groups</code>. Premise: (1) DO NOT pass non-strided super cluster to this function. </p>

</div>
</div>
<a id="aeaac0a080923600c9038bcd82c2873c8" name="aeaac0a080923600c9038bcd82c2873c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaac0a080923600c9038bcd82c2873c8">&#9670;&#160;</a></span>check_container_scope_constraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_p_h_v_1_1v2_1_1_alloc_error.html">AllocError</a> * PHV::v2::AllocatorBase::check_container_scope_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>candidates</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_container.html">Container</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>error if violating any of the above is_container_* constraint. </dd></dl>

</div>
</div>
<a id="a060368723f64ebb31bcdc0a5b26c8f01" name="a060368723f64ebb31bcdc0a5b26c8f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a060368723f64ebb31bcdc0a5b26c8f01">&#9670;&#160;</a></span>compute_valid_container_sizes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; <a class="el" href="namespace_p_h_v.html#a3ff115c4ef9dcfb7a3565ddc263f0ece">PHV::Size</a> &gt; PHV::v2::AllocatorBase::compute_valid_container_sizes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *</td>          <td class="paramname"><span class="paramname"><em>sc</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a set of container sizes that are okay for <code class="param">sc</code>. </dd></dl>

</div>
</div>
<a id="a0fa39be8a2bcdc418e990e4c8009b420" name="a0fa39be8a2bcdc418e990e4c8009b420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fa39be8a2bcdc418e990e4c8009b420">&#9670;&#160;</a></span>is_container_bytes_ok()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_p_h_v_1_1v2_1_1_alloc_error.html">AllocError</a> * PHV::v2::AllocatorBase::is_container_bytes_ok </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>candidates</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_container.html">Container</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>error if violating max container bytes constraints on some field. </dd></dl>

</div>
</div>
<a id="a874e205e39a00ab516aeac0533462052" name="a874e205e39a00ab516aeac0533462052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a874e205e39a00ab516aeac0533462052">&#9670;&#160;</a></span>is_container_gress_ok()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_p_h_v_1_1v2_1_1_alloc_error.html">AllocError</a> * PHV::v2::AllocatorBase::is_container_gress_ok </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_container.html">Container</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>error when <code class="param">sl</code> does not have the same gress assignment as <code class="param">c</code>. </dd></dl>

</div>
</div>
<a id="a55d9480df75fd7754233358510e79b5b" name="a55d9480df75fd7754233358510e79b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55d9480df75fd7754233358510e79b5b">&#9670;&#160;</a></span>is_container_solitary_ok()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_p_h_v_1_1v2_1_1_alloc_error.html">AllocError</a> * PHV::v2::AllocatorBase::is_container_solitary_ok </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>candidate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_container.html">Container</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>error when trying to pack a field with solitary constraint with other fields. </dd></dl>

</div>
</div>
<a id="ae6d61123d926efc9b603d211fbf86cee" name="ae6d61123d926efc9b603d211fbf86cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d61123d926efc9b603d211fbf86cee">&#9670;&#160;</a></span>is_container_type_ok()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_p_h_v_1_1v2_1_1_alloc_error.html">AllocError</a> * PHV::v2::AllocatorBase::is_container_type_ok </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_container.html">Container</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>CONSTRAINT CHECKING Functions common to trivial and greedy allocation. </p>
<dl class="section return"><dt>Returns</dt><dd>error when <code class="param">sl</code> cannot fit the container type constraint of <code class="param">c</code>. </dd></dl>

</div>
</div>
<a id="ab9154a1de0ac22d117a8697c5cf380bf" name="ab9154a1de0ac22d117a8697c5cf380bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9154a1de0ac22d117a8697c5cf380bf">&#9670;&#160;</a></span>is_container_write_mode_ok()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_p_h_v_1_1v2_1_1_alloc_error.html">AllocError</a> * PHV::v2::AllocatorBase::is_container_write_mode_ok </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_container.html">Container</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>error when there is the parser write mode of <code class="param">sl</code> is different from other slices allocated in containers of the same parser group. </dd></dl>
<p>ignore deparser zero candidates if their extracts have been removed.</p>

</div>
</div>
<a id="a1cb4332040f2167739065956e9048a32" name="a1cb4332040f2167739065956e9048a32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb4332040f2167739065956e9048a32">&#9670;&#160;</a></span>make_alloc_order()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; const SuperCluster::SliceList * &gt; * PHV::v2::AllocatorBase::make_alloc_order </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1v2_1_1_score_context.html">ScoreContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *</td>          <td class="paramname"><span class="paramname"><em>sc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_p_h_v.html#a3ff115c4ef9dcfb7a3565ddc263f0ece">PHV::Size</a></td>          <td class="paramname"><span class="paramname"><em>width</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a vector of slice list that covers all field slices of <code class="param">sc</code>. SliceLists are sorted in the order of suggested allocation by (1) slice list with fixed alignment. </dd></dl>

</div>
</div>
<a id="a53c34f31dc4dcc0af7b630cb8f0155fd" name="a53c34f31dc4dcc0af7b630cb8f0155fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53c34f31dc4dcc0af7b630cb8f0155fd">&#9670;&#160;</a></span>make_speculated_alloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p_h_v_1_1_transaction.html">Transaction</a> PHV::v2::AllocatorBase::make_speculated_alloc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1v2_1_1_score_context.html">ScoreContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *</td>          <td class="paramname"><span class="paramname"><em>sc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>candidates</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_container.html">Container</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>candidates_cont</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate pseudo AllocSlices for field slices that have not been allocated, but their allocation can be speculated upfront: when there is only one valid starting position. </p><dl class="section return"><dt>Returns</dt><dd>a transaction that contains the pseudo AllocSlices. we can infer that field slices will be allocated to a container with corresponding starting positions. This will allow can_pack function to check constraints from action reading(writing) side, even if destination(source) has not been allocated yet. </dd></dl>

</div>
</div>
<a id="ac58a8c2ef56c1493bed01d530ec02eab" name="ac58a8c2ef56c1493bed01d530ec02eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac58a8c2ef56c1493bed01d530ec02eab">&#9670;&#160;</a></span>make_start_positions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; PHV::v2::AllocatorBase::make_start_positions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1v2_1_1_score_context.html">ScoreContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SuperCluster::SliceList *</td>          <td class="paramname"><span class="paramname"><em>sl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_p_h_v.html#a3ff115c4ef9dcfb7a3565ddc263f0ece">PHV::Size</a></td>          <td class="paramname"><span class="paramname"><em>width</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a vector a starting postions for <code class="param">sl</code> in <code class="param">width-sized</code> containers. The starting positions might be sorted for more efficient searching, see implementation. </dd></dl>

</div>
</div>
<a id="a3c4507a5a412176d3195393265cd685d" name="a3c4507a5a412176d3195393265cd685d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c4507a5a412176d3195393265cd685d">&#9670;&#160;</a></span>try_hints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="class_p_h_v_1_1_transaction.html">Transaction</a> &gt; PHV::v2::AllocatorBase::try_hints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1v2_1_1_score_context.html">ScoreContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_container_group.html">ContainerGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1ordered__map.html">ActionSourceCoPackMap</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>action_hints_map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_field_slice.html">PHV::FieldSlice</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>allocated</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_p_h_v_1_1v2_1_1_sc_alloc_alignment.html">ScAllocAlignment</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>hint_enforced_alignments</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p_h_v_1_1v2_1_1_allocator_metrics.html">AllocatorMetrics</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc_metrics</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Try to allocate by <code class="param">action_hints</code> to <code class="param">group</code>. This function will add allocated field slices to <code class="param">allocated</code>. </p>
<p>we found one hint allocated, commit and break.</p>

</div>
</div>
<a id="a39381cf2e304bb5c2eab40bd8e8be7a5" name="a39381cf2e304bb5c2eab40bd8e8be7a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39381cf2e304bb5c2eab40bd8e8be7a5">&#9670;&#160;</a></span>try_sliced_super_cluster()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_p_h_v_1_1v2_1_1_alloc_result.html">AllocResult</a> PHV::v2::AllocatorBase::try_sliced_super_cluster </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1v2_1_1_score_context.html">ScoreContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *</td>          <td class="paramname"><span class="paramname"><em>sc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerGroupsBySize &amp;</td>          <td class="paramname"><span class="paramname"><em>groups</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p_h_v_1_1v2_1_1_allocator_metrics.html">AllocatorMetrics</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc_metrics</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ALLOCATION functions common to trivial and greedy allocation. </p>
<p>Try to allocate <code class="param">sc</code>, without further slicing, to <code class="param">groups</code>. Premise: (1) DO NOT pass fully clot-allocated clusters to this function. If does, fields will be double-allocated. (2) DO NOT pass deparser-zero-candidate cluster to this function, because they will not be allocated to zero containers, Unless the correctness of their allocation does not matter, e.g., in trivial allocator, as they are not referenced in MAU. </p>

</div>
</div>
<a id="aaed7d89a4550ed4684cc8d65e63f96cc" name="aaed7d89a4550ed4684cc8d65e63f96cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaed7d89a4550ed4684cc8d65e63f96cc">&#9670;&#160;</a></span>try_slices_adapter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_p_h_v_1_1v2_1_1_some_cont_scope_alloc_result.html">SomeContScopeAllocResult</a> PHV::v2::AllocatorBase::try_slices_adapter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1v2_1_1_score_context.html">ScoreContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1ordered__map.html">FieldSliceAllocStartMap</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>fs_starts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_container_group.html">ContainerGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="class_p_h_v_1_1_container.html">Container</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p_h_v_1_1v2_1_1_allocator_metrics.html">AllocatorMetrics</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc_metrics</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A helper function that will call try_slices_to_container if <code class="param">c</code> is specified (not std::nullopt). Otherwise, it will call try_slices_to_container_group with <code class="param">group</code>. </p>

</div>
</div>
<a id="aa33a6c927f57ff3a2757dc94d4e5491d" name="aa33a6c927f57ff3a2757dc94d4e5491d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa33a6c927f57ff3a2757dc94d4e5491d">&#9670;&#160;</a></span>try_slices_to_container()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_p_h_v_1_1v2_1_1_cont_scope_alloc_result.html">ContScopeAllocResult</a> PHV::v2::AllocatorBase::try_slices_to_container </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1v2_1_1_score_context.html">ScoreContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1ordered__map.html">FieldSliceAllocStartMap</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>fs_starts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_container.html">Container</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p_h_v_1_1v2_1_1_allocator_metrics.html">AllocatorMetrics</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc_metrics</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>skip_mau_checks</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Try to allocate fieldslices with starting positions defined in <code class="param">fs_starts</code> to container <code class="param">c</code>. Various container-level constraints will be checked. When <code class="param">skip_mau_checks</code> are true, mau-related checks will be skipped, e.g., verify_can_pack. It should only be true when allocator is trying to allocate stride clusters. Premises without BUG_CHECK: (1) <code class="param">fs_starts</code> contains all field slices that needs to be allocated to <code class="param">c</code>. They should never exceed the width of the container, i.e., max_i(start_i + size_i) &lt; c.width(). (2) allocating to <code class="param">c</code> will not violate pa_container_size pragma specified on field slices in <code class="param">fs_starts:</code> (3) if there were wide_arithmetic slices, if lo(hi), <code class="param">c</code> must have even(odd) index. Also caller needs to allocate them to adjacent even-odd pair containers. (4) if deparsed/exact_container, total number of bits must be equal to the width of <code class="param">c</code>. (5) field slices of an aligned cluster, including slices that have already been allocated in <code class="param">alloc</code>, and slices to be allcoated in <code class="param">fs_starts</code>, must have the same starting index in container. This function, and all the functions this function will invoke, will not check this constraint. Failed to respect this rule will get an action analysis error in later passes. </p><dl class="section return"><dt>Returns</dt><dd>error in AllocResult if (1) not enough space: &lt;1&gt; non-mutex bits occupied or has non-mutex solitary field. &lt;2&gt; uninitialized read + extracted. (2) cannot pack into container. (3) when container is mocha/dark/tphv, not all field slices are be valid to be allocated to the container type of <code class="param">c</code>. (4) violate pa_container_type. (5) container gress match (6) parserGroupGress match, all containers must have same write mode. (7) deparser group must be the same. (8) solitary fields are not packed with other fields except for paddings fields. (9) fields in <code class="param">fs_starts</code> will not violate parser extraction constraints. (5) field max container bytes constraints. NOTE: alloc slices of ignore_alloc field slices will not be generated. Possible ErrorCode: (1) NOT_ENOUGH_SPACE (2) ACTION_CANNOT_BE_SYNTHESIZED (3) *all kinds of container scope static error codes, e.g. gress, container type mismatch.. </dd></dl>

</div>
</div>
<a id="adf7ea3a442d4d717499e510b81fdc460" name="adf7ea3a442d4d717499e510b81fdc460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf7ea3a442d4d717499e510b81fdc460">&#9670;&#160;</a></span>try_slices_to_container_group()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_p_h_v_1_1v2_1_1_some_cont_scope_alloc_result.html">SomeContScopeAllocResult</a> PHV::v2::AllocatorBase::try_slices_to_container_group </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1v2_1_1_score_context.html">ScoreContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1ordered__map.html">FieldSliceAllocStartMap</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>fs_starts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_container_group.html">ContainerGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p_h_v_1_1v2_1_1_allocator_metrics.html">AllocatorMetrics</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc_metrics</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>try to find a valid container in <code class="param">group</code> for <code class="param">fs_starts</code> by calling try_slices_to_container on every container of <code class="param">group</code>. The returned result will be the container that has the highest score based on ctx.score()-&gt;make(). Premises without BUG_CHECK: (1) AllocSlices that will be generated based on <code class="param">fs_starts</code> will not exceed the size of width of <code class="param">group</code>. (2) <code class="param">ctx</code> score has been initialized. Possible ErrorCode: (1) NOT_ENOUGH_SPACE (2) ACTION_CANNOT_BE_SYNTHESIZED Pruning container group to improve speedup</p><ul>
<li>Skip containers of the same type (kind and size) if an empty container cannot be allocated</li>
<li>Skip containers of the same equivalence class which have been tried before NOTE: Above pruning improves phv compilation times by 10x in some cases </li>
</ul>
<p>pretty-print error messages that aggregates the same failures.</p>

</div>
</div>
<a id="a8fdb425138ff0ee6cfb28bfa83002661" name="a8fdb425138ff0ee6cfb28bfa83002661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fdb425138ff0ee6cfb28bfa83002661">&#9670;&#160;</a></span>try_super_cluster_to_container_group()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_p_h_v_1_1v2_1_1_alloc_result.html">AllocResult</a> PHV::v2::AllocatorBase::try_super_cluster_to_container_group </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1v2_1_1_score_context.html">ScoreContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *</td>          <td class="paramname"><span class="paramname"><em>sc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_container_group.html">ContainerGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p_h_v_1_1v2_1_1_allocator_metrics.html">AllocatorMetrics</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc_metrics</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>try to allocate <code class="param">sc</code> with <code class="param">alignment</code> to <code class="param">group</code>. premise: (1) alloc_alignment must have been populated in <code class="param">ctx</code>. </p>

</div>
</div>
<a id="ade4b2f42fd2c1837d5ed098a51b2520a" name="ade4b2f42fd2c1837d5ed098a51b2520a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade4b2f42fd2c1837d5ed098a51b2520a">&#9670;&#160;</a></span>try_wide_arith_slices_to_container_group()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_p_h_v_1_1v2_1_1_alloc_result.html">AllocResult</a> PHV::v2::AllocatorBase::try_wide_arith_slices_to_container_group </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1v2_1_1_score_context.html">ScoreContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_p_h_v_1_1v2_1_1_sc_alloc_alignment.html">ScAllocAlignment</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alignment</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SuperCluster::SliceList *</td>          <td class="paramname"><span class="paramname"><em>lo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SuperCluster::SliceList *</td>          <td class="paramname"><span class="paramname"><em>hi</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_container_group.html">ContainerGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p_h_v_1_1v2_1_1_allocator_metrics.html">AllocatorMetrics</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc_metrics</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>try to allocate a pair of wide_arith slice lists (<code class="param">lo</code>, <code class="param">hi</code>) to an even-odd pair of containers in <code class="param">group</code>. </p>

</div>
</div>
<a id="a453ba4a9aa4dca3f9ee6394697a0fc03" name="a453ba4a9aa4dca3f9ee6394697a0fc03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a453ba4a9aa4dca3f9ee6394697a0fc03">&#9670;&#160;</a></span>verify_can_pack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_p_h_v_1_1v2_1_1_alloc_error.html">AllocError</a> * PHV::v2::AllocatorBase::verify_can_pack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1v2_1_1_score_context.html">ScoreContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *</td>          <td class="paramname"><span class="paramname"><em>sc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>candidates</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_container.html">Container</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1ordered__map.html">ActionSourceCoPackMap</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>co_pack_hints</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>AllocError if can_pack verification failed. NOTE: when <code class="param">c</code> is an empty normal container, a special error with code ACTION_CANNOT_BE_SYNTHESIZED will be returned. It indicates that even if we are allocating candidates to an empty container (assume all other container-scope constraint checks have passed), we still cannot pack or allocate candidates, which usually means that we need to slice the original super cluster, which has the slice list of <code class="param">candidates</code>, differently, to avoid some packings. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_p_h_v.html">PHV</a></li><li class="navelem"><b>v2</b></li><li class="navelem"><a class="el" href="class_p_h_v_1_1v2_1_1_allocator_base.html">AllocatorBase</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
