<!-- HTML header for doxygen 1.13.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>P4 Compiler Documentation (P4C): P4::IR Namespace Reference</title>
<link rel="icon" href="p4-fav.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!--  Add link to paragraphs   -->
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
  DoxygenAwesomeParagraphLink.init()
</script>
<!-- Add copy button to code fragments  -->
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
  DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add dark mode toggle -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
  DoxygenAwesomeDarkModeToggle.init()
</script>
<!-- Add interactive TOC -->
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
  DoxygenAwesomeInteractiveToc.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-interactive-toc.js" rel="stylesheet" type="text/css"/>
<link href="cards.css" rel="stylesheet" type="text/css"/>
<link href="flow.css" rel="stylesheet" type="text/css"/>
<link href="p4c_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="p4-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">P4C
   </div>
   <div id="projectbrief">The P4 Compiler</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespace_p4_1_1_i_r.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">P4::IR Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p4_1_1_i_r_1_1has__static__type__name.html">has_static_type_name</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p4_1_1_i_r_1_1has__static__type__name_3_01_t_00_01std_1_1void__t_3_01decltype_07_t_1_1static__type__name_07_08_08_4_01_4.html">has_static_type_name&lt; T, std::void_t&lt; decltype(T::static_type_name())&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p4_1_1_i_r_1_1_i_d.html">ID</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4_1_1_i_r_1_1_i_declaration.html">IDeclaration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Declaration interface, representing objects with names.  <a href="class_p4_1_1_i_r_1_1_i_declaration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4_1_1_i_r_1_1_indexed_vector.html">IndexedVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4_1_1_i_r_1_1_i_node.html">INode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4_1_1_i_r_1_1_name_map.html">NameMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4_1_1_i_r_1_1_node.html">Node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4_1_1_i_r_1_1_node_map.html">NodeMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p4_1_1_i_r_1_1_state_variable_equal.html">StateVariableEqual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equals for StateVariable pointers. We only compare the label.  <a href="struct_p4_1_1_i_r_1_1_state_variable_equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p4_1_1_i_r_1_1_state_variable_less.html">StateVariableLess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less for StateVariable pointers. We only compare the label.  <a href="struct_p4_1_1_i_r_1_1_state_variable_less.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p4_1_1_i_r_1_1_symbolic_variable_equal.html">SymbolicVariableEqual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equals for SymbolicVariable pointers. We only compare the label.  <a href="struct_p4_1_1_i_r_1_1_symbolic_variable_equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p4_1_1_i_r_1_1_symbolic_variable_less.html">SymbolicVariableLess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less for SymbolicVariable pointers. We only compare the label.  <a href="struct_p4_1_1_i_r_1_1_symbolic_variable_less.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4_1_1_i_r_1_1_vector.html">Vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4_1_1_i_r_1_1_vector_base.html">VectorBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a947ee9cf3213ee0eed9843ac41ef6a3e" id="r_a947ee9cf3213ee0eed9843ac41ef6a3e"><td class="memItemLeft" align="right" valign="top">const IR::Constant *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a947ee9cf3213ee0eed9843ac41ef6a3e">convertBoolLiteral</a> (const IR::BoolLiteral *lit)</td></tr>
<tr class="separator:a947ee9cf3213ee0eed9843ac41ef6a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1915a6e63353b853ef4b8b6e3d0cd7c3" id="r_a1915a6e63353b853ef4b8b6e3d0cd7c3"><td class="memItemLeft" align="right" valign="top"><a id="a1915a6e63353b853ef4b8b6e3d0cd7c3" name="a1915a6e63353b853ef4b8b6e3d0cd7c3"></a>
<a class="el" href="class_p4_1_1cstring.html">cstring</a>&#160;</td><td class="memItemRight" valign="bottom"><b>dbp</b> (const <a class="el" href="class_p4_1_1_i_r_1_1_i_node.html">INode</a> *node)</td></tr>
<tr class="separator:a1915a6e63353b853ef4b8b6e3d0cd7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69fa876e44faac2d03898aed6ec763a" id="r_ae69fa876e44faac2d03898aed6ec763a"><td class="memItemLeft" align="right" valign="top"><a id="ae69fa876e44faac2d03898aed6ec763a" name="ae69fa876e44faac2d03898aed6ec763a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>equal</b> (const <a class="el" href="class_p4_1_1_i_r_1_1_i_node.html">INode</a> *a, const <a class="el" href="class_p4_1_1_i_r_1_1_i_node.html">INode</a> *b)</td></tr>
<tr class="separator:ae69fa876e44faac2d03898aed6ec763a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8a29219e34282b7d25c4ed20fb8d70" id="r_aca8a29219e34282b7d25c4ed20fb8d70"><td class="memItemLeft" align="right" valign="top"><a id="aca8a29219e34282b7d25c4ed20fb8d70" name="aca8a29219e34282b7d25c4ed20fb8d70"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>equal</b> (const <a class="el" href="class_p4_1_1_i_r_1_1_node.html">Node</a> *a, const <a class="el" href="class_p4_1_1_i_r_1_1_node.html">Node</a> *b)</td></tr>
<tr class="separator:aca8a29219e34282b7d25c4ed20fb8d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968723202a1ef720835783824af616a5" id="r_a968723202a1ef720835783824af616a5"><td class="memItemLeft" align="right" valign="top"><a id="a968723202a1ef720835783824af616a5" name="a968723202a1ef720835783824af616a5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>equiv</b> (const <a class="el" href="class_p4_1_1_i_r_1_1_i_node.html">INode</a> *a, const <a class="el" href="class_p4_1_1_i_r_1_1_i_node.html">INode</a> *b)</td></tr>
<tr class="separator:a968723202a1ef720835783824af616a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a3043a66da95cf6127908d836c5150" id="r_a94a3043a66da95cf6127908d836c5150"><td class="memItemLeft" align="right" valign="top"><a id="a94a3043a66da95cf6127908d836c5150" name="a94a3043a66da95cf6127908d836c5150"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>equiv</b> (const <a class="el" href="class_p4_1_1_i_r_1_1_node.html">Node</a> *a, const <a class="el" href="class_p4_1_1_i_r_1_1_node.html">Node</a> *b)</td></tr>
<tr class="separator:a94a3043a66da95cf6127908d836c5150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae911b23e4671c88cb06734298bb80d2d" id="r_ae911b23e4671c88cb06734298bb80d2d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; const Expression * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae911b23e4671c88cb06734298bb80d2d">flattenListExpression</a> (const BaseListExpression *listExpr)</td></tr>
<tr class="separator:ae911b23e4671c88cb06734298bb80d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092fe151b12ab7bff08b890b26bf278b" id="r_a092fe151b12ab7bff08b890b26bf278b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; const Expression * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a092fe151b12ab7bff08b890b26bf278b">flattenListOrStructExpression</a> (const Expression *listLikeExpr)</td></tr>
<tr class="separator:a092fe151b12ab7bff08b890b26bf278b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab358d2d531195268ccbee3ba33a35244" id="r_ab358d2d531195268ccbee3ba33a35244"><td class="memItemLeft" align="right" valign="top">std::vector&lt; const Expression * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab358d2d531195268ccbee3ba33a35244">flattenStructExpression</a> (const StructExpression *structExpr)</td></tr>
<tr class="separator:ab358d2d531195268ccbee3ba33a35244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6210dd9c22f00ae7ee114a078e5b170a" id="r_a6210dd9c22f00ae7ee114a078e5b170a"><td class="memTemplParams" colspan="2"><a id="a6210dd9c22f00ae7ee114a078e5b170a" name="a6210dd9c22f00ae7ee114a078e5b170a"></a>
template&lt;class T, class U&gt; </td></tr>
<tr class="memitem:a6210dd9c22f00ae7ee114a078e5b170a"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const <a class="el" href="class_p4_1_1_i_r_1_1_vector.html">IR::Vector</a>&lt; T &gt; &amp;vec, U name)</td></tr>
<tr class="separator:a6210dd9c22f00ae7ee114a078e5b170a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ea03cf6c2bbd3642645c7a05d18b56" id="r_aa2ea03cf6c2bbd3642645c7a05d18b56"><td class="memTemplParams" colspan="2"><a id="aa2ea03cf6c2bbd3642645c7a05d18b56" name="aa2ea03cf6c2bbd3642645c7a05d18b56"></a>
template&lt;class T, class U&gt; </td></tr>
<tr class="memitem:aa2ea03cf6c2bbd3642645c7a05d18b56"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const <a class="el" href="class_p4_1_1_i_r_1_1_vector.html">IR::Vector</a>&lt; T &gt; *vec, U name)</td></tr>
<tr class="separator:aa2ea03cf6c2bbd3642645c7a05d18b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa73b2ae9e69f36400517159e75c36e" id="r_acaa73b2ae9e69f36400517159e75c36e"><td class="memItemLeft" align="right" valign="top">big_int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acaa73b2ae9e69f36400517159e75c36e">getBigIntFromLiteral</a> (const Literal *l)</td></tr>
<tr class="separator:acaa73b2ae9e69f36400517159e75c36e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc00c575e059ebe6b62a37b3f3cd3e5" id="r_a7cc00c575e059ebe6b62a37b3f3cd3e5"><td class="memItemLeft" align="right" valign="top">const Type_Bits *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7cc00c575e059ebe6b62a37b3f3cd3e5">getBitTypeToFit</a> (int value)</td></tr>
<tr class="memdesc:a7cc00c575e059ebe6b62a37b3f3cd3e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility functions for generating IR nodes.  <br /></td></tr>
<tr class="separator:a7cc00c575e059ebe6b62a37b3f3cd3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74adee5a2ac967ecc41e3aa30d1c32c4" id="r_a74adee5a2ac967ecc41e3aa30d1c32c4"><td class="memItemLeft" align="right" valign="top"><a id="a74adee5a2ac967ecc41e3aa30d1c32c4" name="a74adee5a2ac967ecc41e3aa30d1c32c4"></a>
const IR::Expression *&#160;</td><td class="memItemRight" valign="bottom"><b>getDefaultValue</b> (const IR::Type *type, const <a class="el" href="class_p4_1_1_util_1_1_source_info.html">Util::SourceInfo</a> &amp;srcInfo, bool valueRequired)</td></tr>
<tr class="separator:a74adee5a2ac967ecc41e3aa30d1c32c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d17d0c42623218c9bcbbfb6cb4147ff" id="r_a4d17d0c42623218c9bcbbfb6cb4147ff"><td class="memItemLeft" align="right" valign="top">const IR::Expression *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d17d0c42623218c9bcbbfb6cb4147ff">getDefaultValue</a> (const Type *type, const <a class="el" href="class_p4_1_1_util_1_1_source_info.html">Util::SourceInfo</a> &amp;srcInfo={}, bool valueRequired=false)</td></tr>
<tr class="separator:a4d17d0c42623218c9bcbbfb6cb4147ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd26aec929b5889cbe7e1ee4aa93d35" id="r_a1fd26aec929b5889cbe7e1ee4aa93d35"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1fd26aec929b5889cbe7e1ee4aa93d35">getIntFromLiteral</a> (const Literal *l)</td></tr>
<tr class="separator:a1fd26aec929b5889cbe7e1ee4aa93d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50db24fa30117fb0132f0f1c80851a1a" id="r_a50db24fa30117fb0132f0f1c80851a1a"><td class="memItemLeft" align="right" valign="top">big_int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50db24fa30117fb0132f0f1c80851a1a">getMaxBvVal</a> (const Type *t)</td></tr>
<tr class="separator:a50db24fa30117fb0132f0f1c80851a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f932b8f1653613c56081d5efe8ef5f" id="r_ac7f932b8f1653613c56081d5efe8ef5f"><td class="memItemLeft" align="right" valign="top">big_int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7f932b8f1653613c56081d5efe8ef5f">getMaxBvVal</a> (int bitWidth)</td></tr>
<tr class="separator:ac7f932b8f1653613c56081d5efe8ef5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a952cf15c808257296af608b660fc7c" id="r_a0a952cf15c808257296af608b660fc7c"><td class="memItemLeft" align="right" valign="top">const IR::Constant *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a952cf15c808257296af608b660fc7c">getMaxValueConstant</a> (const Type *t, const <a class="el" href="class_p4_1_1_util_1_1_source_info.html">Util::SourceInfo</a> &amp;srcInfo)</td></tr>
<tr class="separator:a0a952cf15c808257296af608b660fc7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0e2e62536ffb21e085dfd3c3b7cf8f" id="r_a2e0e2e62536ffb21e085dfd3c3b7cf8f"><td class="memItemLeft" align="right" valign="top">big_int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e0e2e62536ffb21e085dfd3c3b7cf8f">getMinBvVal</a> (const Type *t)</td></tr>
<tr class="separator:a2e0e2e62536ffb21e085dfd3c3b7cf8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb89832001139a214ab65d8769388c7" id="r_aecb89832001139a214ab65d8769388c7"><td class="memItemLeft" align="right" valign="top"><a id="aecb89832001139a214ab65d8769388c7" name="aecb89832001139a214ab65d8769388c7"></a>
const <a class="el" href="class_p4_1_1_i_r_1_1_node.html">IR::Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>inlineBlock</b> (const <a class="el" href="class_p4_1_1_transform.html">Transform</a> &amp;t, const <a class="el" href="class_p4_1_1_i_r_1_1_indexed_vector.html">IR::IndexedVector</a>&lt; IR::StatOrDecl &gt; &amp;stmts)</td></tr>
<tr class="separator:aecb89832001139a214ab65d8769388c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dce8aeacbb8c5eaac964246f005dd75" id="r_a2dce8aeacbb8c5eaac964246f005dd75"><td class="memItemLeft" align="right" valign="top"><a id="a2dce8aeacbb8c5eaac964246f005dd75" name="a2dce8aeacbb8c5eaac964246f005dd75"></a>
const <a class="el" href="class_p4_1_1_i_r_1_1_node.html">IR::Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>inlineBlock</b> (const <a class="el" href="class_p4_1_1_transform.html">Transform</a> &amp;t, <a class="el" href="class_p4_1_1_i_r_1_1_indexed_vector.html">IR::IndexedVector</a>&lt; IR::StatOrDecl &gt; &amp;&amp;stmts)</td></tr>
<tr class="separator:a2dce8aeacbb8c5eaac964246f005dd75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dab6bd29ce84c5633b692f0c6d9be4d" id="r_a6dab6bd29ce84c5633b692f0c6d9be4d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_p4_1_1_i_r_1_1_node.html">IR::Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6dab6bd29ce84c5633b692f0c6d9be4d">inlineBlock</a> (const <a class="el" href="class_p4_1_1_transform.html">Transform</a> &amp;t, std::initializer_list&lt; const IR::StatOrDecl * &gt; stmts)</td></tr>
<tr class="separator:a6dab6bd29ce84c5633b692f0c6d9be4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70bbaf662c71a8517d0407570bb2bffc" id="r_a70bbaf662c71a8517d0407570bb2bffc"><td class="memTemplParams" colspan="2"><a id="a70bbaf662c71a8517d0407570bb2bffc" name="a70bbaf662c71a8517d0407570bb2bffc"></a>
template&lt;typename Stmts&gt; </td></tr>
<tr class="memitem:a70bbaf662c71a8517d0407570bb2bffc"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_p4_1_1_i_r_1_1_node.html">IR::Node</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inlineBlockImpl</b> (const <a class="el" href="class_p4_1_1_transform.html">Transform</a> &amp;t, Stmts &amp;&amp;stmts)</td></tr>
<tr class="separator:a70bbaf662c71a8517d0407570bb2bffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a9b804713872262d92b8864f3de92471a" id="r_a9b804713872262d92b8864f3de92471a"><td class="memTemplParams" colspan="2"><a id="a9b804713872262d92b8864f3de92471a" name="a9b804713872262d92b8864f3de92471a"></a>
template&lt;class T&gt; </td></tr>
<tr class="memitem:a9b804713872262d92b8864f3de92471a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>has_static_type_name_v</b> = <a class="el" href="struct_p4_1_1_i_r_1_1has__static__type__name.html">has_static_type_name</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a9b804713872262d92b8864f3de92471a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Copyright (C) 2024 Intel Corporation</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p>
<p><a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p>SPDX-License-Identifier: Apache-2.0 </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a947ee9cf3213ee0eed9843ac41ef6a3e" name="a947ee9cf3213ee0eed9843ac41ef6a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947ee9cf3213ee0eed9843ac41ef6a3e">&#9670;&#160;</a></span>convertBoolLiteral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const IR::Constant * P4::IR::convertBoolLiteral </td>
          <td>(</td>
          <td class="paramtype">const IR::BoolLiteral *</td>          <td class="paramname"><span class="paramname"><em>lit</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a bool literal into a constant of type Type_Bits and width 1. The value is 1, if the bool literal is true, 0 otherwise. </p>

</div>
</div>
<a id="ae911b23e4671c88cb06734298bb80d2d" name="ae911b23e4671c88cb06734298bb80d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae911b23e4671c88cb06734298bb80d2d">&#9670;&#160;</a></span>flattenListExpression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; const Expression * &gt; P4::IR::flattenListExpression </td>
          <td>(</td>
          <td class="paramtype">const BaseListExpression *</td>          <td class="paramname"><span class="paramname"><em>listExpr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given an BaseListExpression, returns a flat vector of the expressions contained in that list. </p>

</div>
</div>
<a id="a092fe151b12ab7bff08b890b26bf278b" name="a092fe151b12ab7bff08b890b26bf278b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a092fe151b12ab7bff08b890b26bf278b">&#9670;&#160;</a></span>flattenListOrStructExpression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; const Expression * &gt; P4::IR::flattenListOrStructExpression </td>
          <td>(</td>
          <td class="paramtype">const Expression *</td>          <td class="paramname"><span class="paramname"><em>listLikeExpr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a StructExpression or BaseListExpression, returns a flat vector of the expressions contained in that list. Note that this function will fail if the type of any input struct expression is not a Type_Name. </p>

</div>
</div>
<a id="ab358d2d531195268ccbee3ba33a35244" name="ab358d2d531195268ccbee3ba33a35244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab358d2d531195268ccbee3ba33a35244">&#9670;&#160;</a></span>flattenStructExpression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; const Expression * &gt; P4::IR::flattenStructExpression </td>
          <td>(</td>
          <td class="paramtype">const StructExpression *</td>          <td class="paramname"><span class="paramname"><em>structExpr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given an StructExpression, returns a flat vector of the expressions contained in that struct. Unfortunately, list and struct expressions are similar but have no common ancestors. This is why we require two separate methods. Note that this function will fail if the type of</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">structExpr</td><td>is not a Type_Name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acaa73b2ae9e69f36400517159e75c36e" name="acaa73b2ae9e69f36400517159e75c36e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaa73b2ae9e69f36400517159e75c36e">&#9670;&#160;</a></span>getBigIntFromLiteral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">big_int P4::IR::getBigIntFromLiteral </td>
          <td>(</td>
          <td class="paramtype">const Literal *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the big int value stored in a literal. </dd></dl>

</div>
</div>
<a id="a7cc00c575e059ebe6b62a37b3f3cd3e5" name="a7cc00c575e059ebe6b62a37b3f3cd3e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc00c575e059ebe6b62a37b3f3cd3e5">&#9670;&#160;</a></span>getBitTypeToFit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Type_Bits * P4::IR::getBitTypeToFit </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility functions for generating IR nodes. </p>
<dl class="section return"><dt>Returns</dt><dd>a representation of bit&lt;&gt; that is just wide enough to fit the given value. </dd></dl>

</div>
</div>
<a id="a4d17d0c42623218c9bcbbfb6cb4147ff" name="a4d17d0c42623218c9bcbbfb6cb4147ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d17d0c42623218c9bcbbfb6cb4147ff">&#9670;&#160;</a></span>getDefaultValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const IR::Expression * P4::IR::getDefaultValue </td>
          <td>(</td>
          <td class="paramtype">const Type *</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1_util_1_1_source_info.html">Util::SourceInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>srcInfo</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>valueRequired</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the "default" value for a given type. The resulting expression will have the specified srcInfo position. The current mapping as defined in the P4 specification is: Type_Bits 0 Type_Boolean false Type_InfInt 0 Type_Enum first member Type_SerEnum first member Type_Error NoError Type_String "" Type_Header InvalidHeader Type_HeaderUnion InvalidHeaderUnion Type_StructLike StructExpression (fields filled with getDefaultValue) Type_Fragment recurses into getDefaultValue Type_BaseList ListExpression (fields filled with getDefaultValue) Type_Array HeaderStackExpression (fields filled with getDefaultValue) Definition: <a href="https://p4.org/p4-spec/docs/P4-16-working-spec.html#sec-default-values">https://p4.org/p4-spec/docs/P4-16-working-spec.html#sec-default-values</a> </dd></dl>

</div>
</div>
<a id="a1fd26aec929b5889cbe7e1ee4aa93d35" name="a1fd26aec929b5889cbe7e1ee4aa93d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fd26aec929b5889cbe7e1ee4aa93d35">&#9670;&#160;</a></span>getIntFromLiteral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int P4::IR::getIntFromLiteral </td>
          <td>(</td>
          <td class="paramtype">const Literal *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the integer value stored in a literal. We use int here. </dd></dl>

</div>
</div>
<a id="a50db24fa30117fb0132f0f1c80851a1a" name="a50db24fa30117fb0132f0f1c80851a1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50db24fa30117fb0132f0f1c80851a1a">&#9670;&#160;</a></span>getMaxBvVal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">big_int P4::IR::getMaxBvVal </td>
          <td>(</td>
          <td class="paramtype">const Type *</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the maximum value that can fit into this type. This function assumes a big int value, meaning it only supports bit vectors and booleans. </dd></dl>

</div>
</div>
<a id="ac7f932b8f1653613c56081d5efe8ef5f" name="ac7f932b8f1653613c56081d5efe8ef5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f932b8f1653613c56081d5efe8ef5f">&#9670;&#160;</a></span>getMaxBvVal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">big_int P4::IR::getMaxBvVal </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>bitWidth</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the maximum big_int value that can fit into this bit width. </dd></dl>

</div>
</div>
<a id="a0a952cf15c808257296af608b660fc7c" name="a0a952cf15c808257296af608b660fc7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a952cf15c808257296af608b660fc7c">&#9670;&#160;</a></span>getMaxValueConstant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const IR::Constant * P4::IR::getMaxValueConstant </td>
          <td>(</td>
          <td class="paramtype">const Type *</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1_util_1_1_source_info.html">Util::SourceInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>srcInfo</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a constant with the maximum big_int value that can fit into this bit width. Implicitly converts boolean types to a bit vector of width one with value 1. </dd></dl>

</div>
</div>
<a id="a2e0e2e62536ffb21e085dfd3c3b7cf8f" name="a2e0e2e62536ffb21e085dfd3c3b7cf8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e0e2e62536ffb21e085dfd3c3b7cf8f">&#9670;&#160;</a></span>getMinBvVal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">big_int P4::IR::getMinBvVal </td>
          <td>(</td>
          <td class="paramtype">const Type *</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the minimum value that can fit into this type. </dd></dl>

</div>
</div>
<a id="a6dab6bd29ce84c5633b692f0c6d9be4d" name="a6dab6bd29ce84c5633b692f0c6d9be4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dab6bd29ce84c5633b692f0c6d9be4d">&#9670;&#160;</a></span>inlineBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_p4_1_1_i_r_1_1_node.html">IR::Node</a> * P4::IR::inlineBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1_transform.html">Transform</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; const IR::StatOrDecl * &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A helper useful when returning multiple statements out of a Transform's function that should return a statement. While an IR::BlockStatement can accept a vector of statements for each of its child statements, some other places (namely IR::IfStatmenent, IR::SwitchStatement / IR::SwitchCase) only accept a statement. In these case, the visitor will fail with a BUG if the returned value is not IR::StatOrDecl. Passing the arguments through this function (or one of its overloads) works around this by wrapping the statements into a BlockStatement if the parent node cannot accept them directly.</p>
<p>This would be usually used as follows const IR::Node *preorder(IR::SomeStatement *stmt) { ... return IR::inlineBlock(*this, {a, b, c}); }</p>
<dl class="section return"><dt>Returns</dt><dd>IR::IndexedVector&lt;IR::StatOrDecl&gt; * containing the values if the parent is IR::BlockStatement, and IR::BlockStatement * containing the values otherwise. As a special case, returns the sole statement if there is just one passed to the function. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_p4.html">P4</a></li><li class="navelem"><a class="el" href="namespace_p4_1_1_i_r.html">IR</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
