/* Automatically generated by p4c-ubpf from /home/mateusz/p4c/testdata/p4_16_samples/metadata_ubpf.p4 on Fri Jan 24 10:30:10 2020
 */
#include "metadata_ubpf.h"
#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>
#include "ubpf_common.h"

#define BPF_MASK(t, w) ((((t)(1)) << (w)) - (t)1)
#define BYTES(w) ((w) / 8)

void* memcpy(void* dest, const void* src, size_t num);

static void *(*ubpf_map_lookup)(const void *, const void *) = (void *)1;
static int (*ubpf_map_update)(void *, const void *, void *) = (void *)2;
static int (*ubpf_map_delete)(void *, const void *) = (void *)3;
static int (*ubpf_map_add)(void *, const void *) = (void *)4;
static uint64_t (*ubpf_time_get_ns)() = (void *)5;
static uint32_t (*ubpf_hash)(const void *, uint64_t) = (void *)6;
static void (*ubpf_printf)(const char *fmt, ...) = (void *)7;
static void *(*ubpf_packet_data)(const void *) = (void *)9;
static void *(*ubpf_adjust_head)(const void *, uint64_t) = (void *)8;


#define write_partial(a, w, s, v) do { *((uint8_t*)a) = ((*((uint8_t*)a)) & ~(BPF_MASK(uint8_t, w) << s)) | (v << s) ; } while (0)
#define write_byte(base, offset, v) do { *(uint8_t*)((base) + (offset)) = (v); } while (0)

static uint32_t
bpf_htonl(uint32_t val) {
    return htonl(val);
}
static uint16_t
bpf_htons(uint16_t val) {
    return htons(val);
}
static uint64_t
bpf_htonll(uint64_t val) {
    return htonll(val);
}

uint64_t entry(void *ctx, uint64_t pkt_len){
    void *pkt = ubpf_packet_data(ctx);
    struct Headers_t headers = {
        .ethernet = {
            .ebpf_valid = 0
        },
    };
    struct metadata meta = {
        .etherType = 0,
    };
    int packetOffsetInBits = 0;
    uint8_t pass = 1;
    unsigned char ebpf_byte;
    int head_len = 0;

    if (sizeof(struct Headers_t) < pkt_len) {
        return 0;
    }

    goto start;
    start: {
        /* extract(headers.ethernet)*/
        
        headers.ethernet.dstAddr = (uint64_t)((load_dword(pkt, BYTES(packetOffsetInBits)) >> 16) & BPF_MASK(uint64_t, 48));
        packetOffsetInBits += 48;

        headers.ethernet.srcAddr = (uint64_t)((load_dword(pkt, BYTES(packetOffsetInBits)) >> 16) & BPF_MASK(uint64_t, 48));
        packetOffsetInBits += 48;

        headers.ethernet.etherType = (uint16_t)((load_half(pkt, BYTES(packetOffsetInBits))));
        packetOffsetInBits += 16;

        headers.ethernet.ebpf_valid = 1;
        goto accept;
    }

    reject: { return 0; }

    accept:
    {
        {

            {
                /* construct key */
                struct pipe_tbl_key key = {};
                key.headers_ethernet_etherType = headers.ethernet.etherType;
                /* value */
                struct pipe_tbl_value *value = NULL;
                /* perform lookup */
                value = ubpf_map_lookup(&pipe_tbl, &key);

                if (value != NULL) {
                    /* run action */
                    switch (value->action) {
                        case pipe_fill_metadata: 
                        {
                            meta.etherType = headers.ethernet.etherType;
                        }
                        break;
                        case pipe_tbl_NoAction: 
                        {
                            
                        }
                        break;
                        default: return 0;
                    }
                }
                else return 0;
            }
;

            {
                /* construct key */
                struct pipe_meta_based_tbl_key key = {};
                key.meta_etherType = meta.etherType;
                /* value */
                struct pipe_meta_based_tbl_value *value = NULL;
                /* perform lookup */
                value = ubpf_map_lookup(&pipe_meta_based_tbl, &key);

                if (value != NULL) {
                    /* run action */
                    switch (value->action) {
                        case pipe_change_etherType: 
                        {
                            headers.ethernet.etherType = 0x86dd;
                        }
                        break;
                        case pipe_meta_based_tbl_NoAction: 
                        {
                            
                        }
                        break;
                        default: return 0;
                    }
                }
                else return 0;
            }
;

        }    }
    packetOffsetInBits = 0;
    pkt = ubpf_adjust_head(ctx, head_len);
    if (headers.ethernet.ebpf_valid) {
        headers.ethernet.dstAddr = htonll(headers.ethernet.dstAddr << 16);
        ebpf_byte = ((char*)(&headers.ethernet.dstAddr))[0];
        write_byte(pkt, BYTES(packetOffsetInBits) + 0, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.ethernet.dstAddr))[1];
        write_byte(pkt, BYTES(packetOffsetInBits) + 1, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.ethernet.dstAddr))[2];
        write_byte(pkt, BYTES(packetOffsetInBits) + 2, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.ethernet.dstAddr))[3];
        write_byte(pkt, BYTES(packetOffsetInBits) + 3, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.ethernet.dstAddr))[4];
        write_byte(pkt, BYTES(packetOffsetInBits) + 4, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.ethernet.dstAddr))[5];
        write_byte(pkt, BYTES(packetOffsetInBits) + 5, (ebpf_byte));
        packetOffsetInBits += 48;

        headers.ethernet.srcAddr = htonll(headers.ethernet.srcAddr << 16);
        ebpf_byte = ((char*)(&headers.ethernet.srcAddr))[0];
        write_byte(pkt, BYTES(packetOffsetInBits) + 0, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.ethernet.srcAddr))[1];
        write_byte(pkt, BYTES(packetOffsetInBits) + 1, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.ethernet.srcAddr))[2];
        write_byte(pkt, BYTES(packetOffsetInBits) + 2, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.ethernet.srcAddr))[3];
        write_byte(pkt, BYTES(packetOffsetInBits) + 3, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.ethernet.srcAddr))[4];
        write_byte(pkt, BYTES(packetOffsetInBits) + 4, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.ethernet.srcAddr))[5];
        write_byte(pkt, BYTES(packetOffsetInBits) + 5, (ebpf_byte));
        packetOffsetInBits += 48;

        headers.ethernet.etherType = bpf_htons(headers.ethernet.etherType);
        ebpf_byte = ((char*)(&headers.ethernet.etherType))[0];
        write_byte(pkt, BYTES(packetOffsetInBits) + 0, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.ethernet.etherType))[1];
        write_byte(pkt, BYTES(packetOffsetInBits) + 1, (ebpf_byte));
        packetOffsetInBits += 16;

    }
;    if (pass)
        return 1;
    else
        return 0;
}
