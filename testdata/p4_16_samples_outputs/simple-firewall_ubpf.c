/* Automatically generated by p4c-ubpf from /home/mateusz/p4c/testdata/p4_16_samples/simple-firewall_ubpf.p4 on Mon Jan 20 15:27:07 2020
 */
#include "simple-firewall_ubpf.h"
#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>
#include "ubpf_common.h"

#define BPF_MASK(t, w) ((((t)(1)) << (w)) - (t)1)
#define BYTES(w) ((w) / 8)

void* memcpy(void* dest, const void* src, size_t num);

static void *(*ubpf_map_lookup)(const void *, const void *) = (void *)1;
static int (*ubpf_map_update)(void *, const void *, void *) = (void *)2;
static int (*ubpf_map_delete)(void *, const void *) = (void *)3;
static int (*ubpf_map_add)(void *, const void *) = (void *)4;
static uint64_t (*ubpf_time_get_ns)() = (void *)5;
static uint32_t (*ubpf_hash)(const void *, uint64_t) = (void *)6;
static void (*ubpf_printf)(const char *fmt, ...) = (void *)7;
static void *(*ubpf_packet_data)(const void *) = (void *)9;
static void *(*ubpf_adjust_head)(const void *, uint64_t) = (void *)8;


#define write_partial(a, w, s, v) do { *((uint8_t*)a) = ((*((uint8_t*)a)) & ~(BPF_MASK(uint8_t, w) << s)) | (v << s) ; } while (0)
#define write_byte(base, offset, v) do { *(uint8_t*)((base) + (offset)) = (v); } while (0)

static uint32_t
bpf_htonl(uint32_t val) {
    return htonl(val);
}
static uint16_t
bpf_htons(uint16_t val) {
    return htons(val);
}
static uint64_t
bpf_htonll(uint64_t val) {
    return htonll(val);
}

uint64_t entry(void *ctx, uint64_t pkt_len){
    void *pkt = ubpf_packet_data(ctx);
    struct Headers_t headers = {
        .ethernet = {
            .ebpf_valid = 0
        },
        .ipv4 = {
            .ebpf_valid = 0
        },
        .tcp = {
            .ebpf_valid = 0
        },
    };
    struct metadata meta = {
        .connInfo = {
            .s = 0,
            .srv_addr = 0,
        },
        .conn_id = 0,
    };
    int packetOffsetInBits = 0;
    uint8_t pass = 1;
    unsigned char ebpf_byte;
    int head_len = 0;

    if (sizeof(struct Headers_t) < pkt_len) {
        return 0;
    }

    goto start;
    start: {
        /* extract(headers.ethernet)*/
        
        headers.ethernet.dstAddr = (uint64_t)((load_dword(pkt, BYTES(packetOffsetInBits)) >> 16) & BPF_MASK(uint64_t, 48));
        packetOffsetInBits += 48;

        headers.ethernet.srcAddr = (uint64_t)((load_dword(pkt, BYTES(packetOffsetInBits)) >> 16) & BPF_MASK(uint64_t, 48));
        packetOffsetInBits += 48;

        headers.ethernet.etherType = (uint16_t)((load_half(pkt, BYTES(packetOffsetInBits))));
        packetOffsetInBits += 16;

        headers.ethernet.ebpf_valid = 1;
        switch (headers.ethernet.etherType) {
            case 0x800: goto parse_ipv4;
            default: goto accept;
        }
    }
    parse_ipv4: {
        /* extract(headers.ipv4)*/
        
        headers.ipv4.version = (uint8_t)((load_byte(pkt, BYTES(packetOffsetInBits)) >> 4) & BPF_MASK(uint8_t, 4));
        packetOffsetInBits += 4;

        headers.ipv4.ihl = (uint8_t)((load_byte(pkt, BYTES(packetOffsetInBits))) & BPF_MASK(uint8_t, 4));
        packetOffsetInBits += 4;

        headers.ipv4.diffserv = (uint8_t)((load_byte(pkt, BYTES(packetOffsetInBits))));
        packetOffsetInBits += 8;

        headers.ipv4.totalLen = (uint16_t)((load_half(pkt, BYTES(packetOffsetInBits))));
        packetOffsetInBits += 16;

        headers.ipv4.identification = (uint16_t)((load_half(pkt, BYTES(packetOffsetInBits))));
        packetOffsetInBits += 16;

        headers.ipv4.flags = (uint8_t)((load_byte(pkt, BYTES(packetOffsetInBits)) >> 5) & BPF_MASK(uint8_t, 3));
        packetOffsetInBits += 3;

        headers.ipv4.fragOffset = (uint16_t)((load_half(pkt, BYTES(packetOffsetInBits))) & BPF_MASK(uint16_t, 13));
        packetOffsetInBits += 13;

        headers.ipv4.ttl = (uint8_t)((load_byte(pkt, BYTES(packetOffsetInBits))));
        packetOffsetInBits += 8;

        headers.ipv4.protocol = (uint8_t)((load_byte(pkt, BYTES(packetOffsetInBits))));
        packetOffsetInBits += 8;

        headers.ipv4.hdrChecksum = (uint16_t)((load_half(pkt, BYTES(packetOffsetInBits))));
        packetOffsetInBits += 16;

        headers.ipv4.srcAddr = (uint32_t)((load_word(pkt, BYTES(packetOffsetInBits))));
        packetOffsetInBits += 32;

        headers.ipv4.dstAddr = (uint32_t)((load_word(pkt, BYTES(packetOffsetInBits))));
        packetOffsetInBits += 32;

        headers.ipv4.ebpf_valid = 1;
        /* extract(headers.tcp)*/
        
        headers.tcp.srcPort = (uint16_t)((load_half(pkt, BYTES(packetOffsetInBits))));
        packetOffsetInBits += 16;

        headers.tcp.dstPort = (uint16_t)((load_half(pkt, BYTES(packetOffsetInBits))));
        packetOffsetInBits += 16;

        headers.tcp.seqNo = (uint32_t)((load_word(pkt, BYTES(packetOffsetInBits))));
        packetOffsetInBits += 32;

        headers.tcp.ackNo = (uint32_t)((load_word(pkt, BYTES(packetOffsetInBits))));
        packetOffsetInBits += 32;

        headers.tcp.dataOffset = (uint8_t)((load_byte(pkt, BYTES(packetOffsetInBits)) >> 4) & BPF_MASK(uint8_t, 4));
        packetOffsetInBits += 4;

        headers.tcp.res = (uint8_t)((load_byte(pkt, BYTES(packetOffsetInBits)) >> 1) & BPF_MASK(uint8_t, 3));
        packetOffsetInBits += 3;

        headers.tcp.ecn = (uint8_t)((load_half(pkt, BYTES(packetOffsetInBits)) >> 6) & BPF_MASK(uint8_t, 3));
        packetOffsetInBits += 3;

        headers.tcp.urgent = (uint8_t)((load_byte(pkt, BYTES(packetOffsetInBits)) >> 5) & BPF_MASK(uint8_t, 1));
        packetOffsetInBits += 1;

        headers.tcp.ack = (uint8_t)((load_byte(pkt, BYTES(packetOffsetInBits)) >> 4) & BPF_MASK(uint8_t, 1));
        packetOffsetInBits += 1;

        headers.tcp.psh = (uint8_t)((load_byte(pkt, BYTES(packetOffsetInBits)) >> 3) & BPF_MASK(uint8_t, 1));
        packetOffsetInBits += 1;

        headers.tcp.rst = (uint8_t)((load_byte(pkt, BYTES(packetOffsetInBits)) >> 2) & BPF_MASK(uint8_t, 1));
        packetOffsetInBits += 1;

        headers.tcp.syn = (uint8_t)((load_byte(pkt, BYTES(packetOffsetInBits)) >> 1) & BPF_MASK(uint8_t, 1));
        packetOffsetInBits += 1;

        headers.tcp.fin = (uint8_t)((load_byte(pkt, BYTES(packetOffsetInBits))) & BPF_MASK(uint8_t, 1));
        packetOffsetInBits += 1;

        headers.tcp.window = (uint16_t)((load_half(pkt, BYTES(packetOffsetInBits))));
        packetOffsetInBits += 16;

        headers.tcp.checksum = (uint16_t)((load_half(pkt, BYTES(packetOffsetInBits))));
        packetOffsetInBits += 16;

        headers.tcp.urgentPtr = (uint16_t)((load_half(pkt, BYTES(packetOffsetInBits))));
        packetOffsetInBits += 16;

        headers.tcp.ebpf_valid = 1;
        goto accept;
    }

    reject: { return 0; }

    accept:
    {
        uint32_t* tmp;
        uint32_t* tmp_0;
        {

            if (headers.tcp.ebpf_valid) {

                if ((headers.ipv4.srcAddr < headers.ipv4.dstAddr)) {
                    struct hash_key {
                        uint32_t headers_ipv4_srcAddr;
                        uint32_t headers_ipv4_dstAddr;
                    };
                    struct hash_key hash_key_instance = {
                        .headers_ipv4_srcAddr = headers.ipv4.srcAddr,
                        .headers_ipv4_dstAddr = headers.ipv4.dstAddr
                    };
                    meta.conn_id = ubpf_hash(&hash_key_instance, sizeof(hash_key_instance));
                } else {
                    struct hash_key_0 {
                        uint32_t headers_ipv4_dstAddr;
                        uint32_t headers_ipv4_srcAddr;
                    };
                    struct hash_key_0 hash_key_instance_0 = {
                        .headers_ipv4_dstAddr = headers.ipv4.dstAddr,
                        .headers_ipv4_srcAddr = headers.ipv4.srcAddr
                    };
                    meta.conn_id = ubpf_hash(&hash_key_instance_0, sizeof(hash_key_instance_0));
                }

                uint32_t key_local_var = meta.conn_id;
                tmp = ubpf_map_lookup(&conn_state_0, &key_local_var);
                if (tmp != NULL) {

                    meta.connInfo.s = *tmp;
                    uint32_t key_local_var_0 = meta.conn_id;
                    tmp_0 = ubpf_map_lookup(&conn_srv_addr_0, &key_local_var_0);
                    if (tmp_0 != NULL) {

                        meta.connInfo.srv_addr = *tmp_0;
                        if (((tmp == 0) || (tmp_0 == 0))) {
                            if (((headers.tcp.syn == 1) && (headers.tcp.ack == 0))) {
                                {

                                    uint32_t key_local_var_1 = meta.conn_id;
                                    uint32_t value_local_var = 1;
                                    ubpf_map_update(&conn_state_0, &key_local_var_1, &value_local_var);

                                    uint32_t key_local_var_2 = meta.conn_id;
                                    uint32_t value_local_var_0 = headers.ipv4.dstAddr;
                                    ubpf_map_update(&conn_srv_addr_0, &key_local_var_2, &value_local_var_0);

                                };
                            }
                        } else {
                            if ((tmp_0 == headers.ipv4.srcAddr)) {
                                if ((tmp == 1)) {
                                    if (((headers.tcp.syn == 1) && (headers.tcp.ack == 1))) {
                                        {

                                            uint32_t key_local_var_3 = meta.conn_id;
                                            uint32_t value_local_var_1 = 2;
                                            ubpf_map_update(&conn_state_0, &key_local_var_3, &value_local_var_1);

                                        };
                                    }
                                } else {
                                    if ((tmp == 2)) {
                                        {

                                            pass = false;

                                        };
                                    } else {
                                        if ((tmp == 3)) {
                                            if (((headers.tcp.fin == 1) && (headers.tcp.ack == 1))) {
                                                {

                                                    uint32_t key_local_var_4 = meta.conn_id;
                                                    uint32_t value_local_var_2 = 0;
                                                    ubpf_map_update(&conn_state_0, &key_local_var_4, &value_local_var_2);

                                                    uint32_t key_local_var_5 = meta.conn_id;
                                                    uint32_t value_local_var_3 = 0;
                                                    ubpf_map_update(&conn_srv_addr_0, &key_local_var_5, &value_local_var_3);

                                                };
                                            }
                                        }
                                    }
                                }
                            } else {
                                if ((tmp == 1)) {
                                    {

                                        pass = false;

                                    };
                                } else {
                                    if ((tmp == 2)) {
                                        if (((headers.tcp.syn == 0) && (headers.tcp.ack == 1))) {
                                            {

                                                uint32_t key_local_var_6 = meta.conn_id;
                                                uint32_t value_local_var_4 = 3;
                                                ubpf_map_update(&conn_state_0, &key_local_var_6, &value_local_var_4);

                                            };
                                        }
                                    } else {
                                        if ((tmp == 3)) {
                                            if (((headers.tcp.fin == 1) && (headers.tcp.ack == 1))) {
                                                {

                                                    uint32_t key_local_var_7 = meta.conn_id;
                                                    uint32_t value_local_var_5 = 0;
                                                    ubpf_map_update(&conn_state_0, &key_local_var_7, &value_local_var_5);

                                                    uint32_t key_local_var_8 = meta.conn_id;
                                                    uint32_t value_local_var_6 = 0;
                                                    ubpf_map_update(&conn_srv_addr_0, &key_local_var_8, &value_local_var_6);

                                                };
                                            }
                                        }
                                    }
                                }
                            }
                        }

                    }
                }
            }

        }
    }
    packetOffsetInBits = 0;
    pkt = ubpf_adjust_head(ctx, head_len);
    if (headers.ethernet.ebpf_valid) {
        headers.ethernet.dstAddr = htonll(headers.ethernet.dstAddr << 16);
        ebpf_byte = ((char*)(&headers.ethernet.dstAddr))[0];
        write_byte(pkt, BYTES(packetOffsetInBits) + 0, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.ethernet.dstAddr))[1];
        write_byte(pkt, BYTES(packetOffsetInBits) + 1, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.ethernet.dstAddr))[2];
        write_byte(pkt, BYTES(packetOffsetInBits) + 2, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.ethernet.dstAddr))[3];
        write_byte(pkt, BYTES(packetOffsetInBits) + 3, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.ethernet.dstAddr))[4];
        write_byte(pkt, BYTES(packetOffsetInBits) + 4, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.ethernet.dstAddr))[5];
        write_byte(pkt, BYTES(packetOffsetInBits) + 5, (ebpf_byte));
        packetOffsetInBits += 48;

        headers.ethernet.srcAddr = htonll(headers.ethernet.srcAddr << 16);
        ebpf_byte = ((char*)(&headers.ethernet.srcAddr))[0];
        write_byte(pkt, BYTES(packetOffsetInBits) + 0, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.ethernet.srcAddr))[1];
        write_byte(pkt, BYTES(packetOffsetInBits) + 1, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.ethernet.srcAddr))[2];
        write_byte(pkt, BYTES(packetOffsetInBits) + 2, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.ethernet.srcAddr))[3];
        write_byte(pkt, BYTES(packetOffsetInBits) + 3, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.ethernet.srcAddr))[4];
        write_byte(pkt, BYTES(packetOffsetInBits) + 4, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.ethernet.srcAddr))[5];
        write_byte(pkt, BYTES(packetOffsetInBits) + 5, (ebpf_byte));
        packetOffsetInBits += 48;

        headers.ethernet.etherType = bpf_htons(headers.ethernet.etherType);
        ebpf_byte = ((char*)(&headers.ethernet.etherType))[0];
        write_byte(pkt, BYTES(packetOffsetInBits) + 0, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.ethernet.etherType))[1];
        write_byte(pkt, BYTES(packetOffsetInBits) + 1, (ebpf_byte));
        packetOffsetInBits += 16;

    }
;    if (headers.ipv4.ebpf_valid) {
        ebpf_byte = ((char*)(&headers.ipv4.version))[0];
        write_partial(pkt + BYTES(packetOffsetInBits) + 0, 4, 4, (ebpf_byte >> 0));
        packetOffsetInBits += 4;

        ebpf_byte = ((char*)(&headers.ipv4.ihl))[0];
        write_partial(pkt + BYTES(packetOffsetInBits) + 0, 4, 0, (ebpf_byte >> 0));
        packetOffsetInBits += 4;

        ebpf_byte = ((char*)(&headers.ipv4.diffserv))[0];
        write_byte(pkt, BYTES(packetOffsetInBits) + 0, (ebpf_byte));
        packetOffsetInBits += 8;

        headers.ipv4.totalLen = bpf_htons(headers.ipv4.totalLen);
        ebpf_byte = ((char*)(&headers.ipv4.totalLen))[0];
        write_byte(pkt, BYTES(packetOffsetInBits) + 0, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.ipv4.totalLen))[1];
        write_byte(pkt, BYTES(packetOffsetInBits) + 1, (ebpf_byte));
        packetOffsetInBits += 16;

        headers.ipv4.identification = bpf_htons(headers.ipv4.identification);
        ebpf_byte = ((char*)(&headers.ipv4.identification))[0];
        write_byte(pkt, BYTES(packetOffsetInBits) + 0, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.ipv4.identification))[1];
        write_byte(pkt, BYTES(packetOffsetInBits) + 1, (ebpf_byte));
        packetOffsetInBits += 16;

        ebpf_byte = ((char*)(&headers.ipv4.flags))[0];
        write_partial(pkt + BYTES(packetOffsetInBits) + 0, 3, 5, (ebpf_byte >> 0));
        packetOffsetInBits += 3;

        headers.ipv4.fragOffset = bpf_htons(headers.ipv4.fragOffset << 3);
        ebpf_byte = ((char*)(&headers.ipv4.fragOffset))[0];
        write_partial(pkt + BYTES(packetOffsetInBits) + 0, 5, 0, (ebpf_byte >> 3));
        write_partial(pkt + BYTES(packetOffsetInBits) + 0 + 1, 3, 5, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.ipv4.fragOffset))[1];
        write_partial(pkt + BYTES(packetOffsetInBits) + 1, 5, 0, (ebpf_byte >> 3));
        packetOffsetInBits += 13;

        ebpf_byte = ((char*)(&headers.ipv4.ttl))[0];
        write_byte(pkt, BYTES(packetOffsetInBits) + 0, (ebpf_byte));
        packetOffsetInBits += 8;

        ebpf_byte = ((char*)(&headers.ipv4.protocol))[0];
        write_byte(pkt, BYTES(packetOffsetInBits) + 0, (ebpf_byte));
        packetOffsetInBits += 8;

        headers.ipv4.hdrChecksum = bpf_htons(headers.ipv4.hdrChecksum);
        ebpf_byte = ((char*)(&headers.ipv4.hdrChecksum))[0];
        write_byte(pkt, BYTES(packetOffsetInBits) + 0, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.ipv4.hdrChecksum))[1];
        write_byte(pkt, BYTES(packetOffsetInBits) + 1, (ebpf_byte));
        packetOffsetInBits += 16;

        headers.ipv4.srcAddr = htonl(headers.ipv4.srcAddr);
        ebpf_byte = ((char*)(&headers.ipv4.srcAddr))[0];
        write_byte(pkt, BYTES(packetOffsetInBits) + 0, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.ipv4.srcAddr))[1];
        write_byte(pkt, BYTES(packetOffsetInBits) + 1, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.ipv4.srcAddr))[2];
        write_byte(pkt, BYTES(packetOffsetInBits) + 2, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.ipv4.srcAddr))[3];
        write_byte(pkt, BYTES(packetOffsetInBits) + 3, (ebpf_byte));
        packetOffsetInBits += 32;

        headers.ipv4.dstAddr = htonl(headers.ipv4.dstAddr);
        ebpf_byte = ((char*)(&headers.ipv4.dstAddr))[0];
        write_byte(pkt, BYTES(packetOffsetInBits) + 0, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.ipv4.dstAddr))[1];
        write_byte(pkt, BYTES(packetOffsetInBits) + 1, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.ipv4.dstAddr))[2];
        write_byte(pkt, BYTES(packetOffsetInBits) + 2, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.ipv4.dstAddr))[3];
        write_byte(pkt, BYTES(packetOffsetInBits) + 3, (ebpf_byte));
        packetOffsetInBits += 32;

    }
;    if (headers.tcp.ebpf_valid) {
        headers.tcp.srcPort = bpf_htons(headers.tcp.srcPort);
        ebpf_byte = ((char*)(&headers.tcp.srcPort))[0];
        write_byte(pkt, BYTES(packetOffsetInBits) + 0, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.tcp.srcPort))[1];
        write_byte(pkt, BYTES(packetOffsetInBits) + 1, (ebpf_byte));
        packetOffsetInBits += 16;

        headers.tcp.dstPort = bpf_htons(headers.tcp.dstPort);
        ebpf_byte = ((char*)(&headers.tcp.dstPort))[0];
        write_byte(pkt, BYTES(packetOffsetInBits) + 0, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.tcp.dstPort))[1];
        write_byte(pkt, BYTES(packetOffsetInBits) + 1, (ebpf_byte));
        packetOffsetInBits += 16;

        headers.tcp.seqNo = htonl(headers.tcp.seqNo);
        ebpf_byte = ((char*)(&headers.tcp.seqNo))[0];
        write_byte(pkt, BYTES(packetOffsetInBits) + 0, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.tcp.seqNo))[1];
        write_byte(pkt, BYTES(packetOffsetInBits) + 1, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.tcp.seqNo))[2];
        write_byte(pkt, BYTES(packetOffsetInBits) + 2, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.tcp.seqNo))[3];
        write_byte(pkt, BYTES(packetOffsetInBits) + 3, (ebpf_byte));
        packetOffsetInBits += 32;

        headers.tcp.ackNo = htonl(headers.tcp.ackNo);
        ebpf_byte = ((char*)(&headers.tcp.ackNo))[0];
        write_byte(pkt, BYTES(packetOffsetInBits) + 0, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.tcp.ackNo))[1];
        write_byte(pkt, BYTES(packetOffsetInBits) + 1, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.tcp.ackNo))[2];
        write_byte(pkt, BYTES(packetOffsetInBits) + 2, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.tcp.ackNo))[3];
        write_byte(pkt, BYTES(packetOffsetInBits) + 3, (ebpf_byte));
        packetOffsetInBits += 32;

        ebpf_byte = ((char*)(&headers.tcp.dataOffset))[0];
        write_partial(pkt + BYTES(packetOffsetInBits) + 0, 4, 4, (ebpf_byte >> 0));
        packetOffsetInBits += 4;

        ebpf_byte = ((char*)(&headers.tcp.res))[0];
        write_partial(pkt + BYTES(packetOffsetInBits) + 0, 3, 1, (ebpf_byte >> 0));
        packetOffsetInBits += 3;

        ebpf_byte = ((char*)(&headers.tcp.ecn))[0];
        write_partial(pkt + BYTES(packetOffsetInBits) + 0, 1, 0, (ebpf_byte >> 7));
        write_partial(pkt + BYTES(packetOffsetInBits) + 0 + 1, 7, 1, (ebpf_byte));
        packetOffsetInBits += 3;

        ebpf_byte = ((char*)(&headers.tcp.urgent))[0];
        write_partial(pkt + BYTES(packetOffsetInBits) + 0, 1, 5, (ebpf_byte >> 0));
        packetOffsetInBits += 1;

        ebpf_byte = ((char*)(&headers.tcp.ack))[0];
        write_partial(pkt + BYTES(packetOffsetInBits) + 0, 1, 4, (ebpf_byte >> 0));
        packetOffsetInBits += 1;

        ebpf_byte = ((char*)(&headers.tcp.psh))[0];
        write_partial(pkt + BYTES(packetOffsetInBits) + 0, 1, 3, (ebpf_byte >> 0));
        packetOffsetInBits += 1;

        ebpf_byte = ((char*)(&headers.tcp.rst))[0];
        write_partial(pkt + BYTES(packetOffsetInBits) + 0, 1, 2, (ebpf_byte >> 0));
        packetOffsetInBits += 1;

        ebpf_byte = ((char*)(&headers.tcp.syn))[0];
        write_partial(pkt + BYTES(packetOffsetInBits) + 0, 1, 1, (ebpf_byte >> 0));
        packetOffsetInBits += 1;

        ebpf_byte = ((char*)(&headers.tcp.fin))[0];
        write_partial(pkt + BYTES(packetOffsetInBits) + 0, 1, 0, (ebpf_byte >> 0));
        packetOffsetInBits += 1;

        headers.tcp.window = bpf_htons(headers.tcp.window);
        ebpf_byte = ((char*)(&headers.tcp.window))[0];
        write_byte(pkt, BYTES(packetOffsetInBits) + 0, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.tcp.window))[1];
        write_byte(pkt, BYTES(packetOffsetInBits) + 1, (ebpf_byte));
        packetOffsetInBits += 16;

        headers.tcp.checksum = bpf_htons(headers.tcp.checksum);
        ebpf_byte = ((char*)(&headers.tcp.checksum))[0];
        write_byte(pkt, BYTES(packetOffsetInBits) + 0, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.tcp.checksum))[1];
        write_byte(pkt, BYTES(packetOffsetInBits) + 1, (ebpf_byte));
        packetOffsetInBits += 16;

        headers.tcp.urgentPtr = bpf_htons(headers.tcp.urgentPtr);
        ebpf_byte = ((char*)(&headers.tcp.urgentPtr))[0];
        write_byte(pkt, BYTES(packetOffsetInBits) + 0, (ebpf_byte));
        ebpf_byte = ((char*)(&headers.tcp.urgentPtr))[1];
        write_byte(pkt, BYTES(packetOffsetInBits) + 1, (ebpf_byte));
        packetOffsetInBits += 16;

    }
;    if (pass)
        return 1;
    else
        return 0;
}
