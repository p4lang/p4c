/* Automatically generated by p4c-pna-p4tc from ../testdata/p4tc_samples/simple_l3_varbits.p4 on Tue Jun  4 14:45:31 2024
 */
#include "simple_l3_varbits_parser.h"
struct p4tc_filter_fields p4tc_filter_fields;

struct internal_metadata {
    __u16 pkt_ether_type;
} __attribute__((aligned(4)));

struct __attribute__((__packed__)) ingress_nh_table_key {
    u32 keysz;
    u32 maskid;
    u32 field0; /* hdr.ipv4.dstAddr */
} __attribute__((aligned(8)));
#define INGRESS_NH_TABLE_ACT_INGRESS_SEND_NH 1
#define INGRESS_NH_TABLE_ACT_INGRESS_DROP 2
#define INGRESS_NH_TABLE_ACT_NOACTION 0
struct __attribute__((__packed__)) ingress_nh_table_value {
    unsigned int action;
    u32 hit:1,
    is_default_miss_act:1,
    is_default_hit_act:1;
    union {
        struct {
        } _NoAction;
        struct __attribute__((__packed__)) {
            u32 port;
            u64 srcMac;
            u64 dstMac;
        } ingress_send_nh;
        struct {
        } ingress_drop;
    } u;
};

static __always_inline int process(struct __sk_buff *skb, struct my_ingress_headers_t *hdr, struct pna_global_metadata *compiler_meta__)
{
    struct hdr_md *hdrMd;

    unsigned ebpf_packetOffsetInBits_save = 0;
    ParserError_t ebpf_errorCode = NoError;
    void* pkt = ((void*)(long)skb->data);
    u8* hdr_start = pkt;
    void* ebpf_packetEnd = ((void*)(long)skb->data_end);
    u32 ebpf_zero = 0;
    u32 ebpf_one = 1;
    unsigned char ebpf_byte;
    u32 pkt_len = skb->len;

    struct my_ingress_metadata_t *meta;
    hdrMd = BPF_MAP_LOOKUP_ELEM(hdr_md_cpumap, &ebpf_zero);
    if (!hdrMd)
        return TC_ACT_SHOT;
    unsigned ebpf_packetOffsetInBits = hdrMd->ebpf_packetOffsetInBits;
    hdr_start = pkt + BYTES(ebpf_packetOffsetInBits);
    hdr = &(hdrMd->cpumap_hdr);
    meta = &(hdrMd->cpumap_usermeta);
{
        u8 hit;
        {
if (/* hdr->ipv4.isValid() */
            hdr->ipv4.ebpf_valid && hdr->ipv4.protocol == 0x6) {
/* nh_table_0.apply() */
                {
                    /* construct key */
                    struct p4tc_table_entry_act_bpf_params__local params = {
                        .pipeid = p4tc_filter_fields.pipeid,
                        .tblid = 1
                    };
                    struct ingress_nh_table_key key;
                    // XXX eBPF gets upset at memset(); let's
                    // hope __builtin_memset() does what we want
                    __builtin_memset(&key, 0, sizeof(key));
                    key.keysz = 32;
                    key.field0 = bpf_htonl(hdr->ipv4.dstAddr);
                    struct p4tc_table_entry_act_bpf *act_bpf;
                    /* value */
                    struct ingress_nh_table_value *value = NULL;
                    /* perform lookup */
                    act_bpf = bpf_p4tc_tbl_read(skb, &params, sizeof(params), &key, sizeof(key));
                    value = (struct ingress_nh_table_value *)act_bpf;
                    if (value == NULL) {
                        /* miss; find default action */
                        hit = 0;
                    } else {
                        hit = value->hit;
                    }
                    if (value != NULL) {
                        /* run action */
                        switch (value->action) {
                            case INGRESS_NH_TABLE_ACT_INGRESS_SEND_NH: 
                                {
                                    hdr->ethernet.srcAddr = ntohll(value->u.ingress_send_nh.srcMac << 16);
                                                                        hdr->ethernet.dstAddr = ntohll(value->u.ingress_send_nh.dstMac << 16);
                                                                        hdr->ipv4.ttl = 31;
                                    /* send_to_port(value->u.ingress_send_nh.port) */
                                    compiler_meta__->drop = false;
                                    send_to_port(value->u.ingress_send_nh.port);
                                }
                                break;
                            case INGRESS_NH_TABLE_ACT_INGRESS_DROP: 
                                {
/* drop_packet() */
                                    drop_packet();
                                }
                                break;
                            case INGRESS_NH_TABLE_ACT_NOACTION: 
                                {
                                }
                                break;
                        }
                    } else {
                    }
                }
;            }

        }
    }
    {
{
;
            ;
            ;
        }

        if (compiler_meta__->drop) {
            return TC_ACT_SHOT;
        }
        int outHeaderLength = 0;
        if (hdr->ethernet.ebpf_valid) {
            outHeaderLength += 112;
        }
;        if (hdr->ipv4.ebpf_valid) {
            outHeaderLength += 160;
        }
;        if (hdr->opts.ebpf_valid) {
            outHeaderLength += 0;
        }
;
        int outHeaderOffset = BYTES(outHeaderLength) - (hdr_start - (u8*)pkt);
        if (outHeaderOffset != 0) {
            int returnCode = 0;
            returnCode = bpf_skb_adjust_room(skb, outHeaderOffset, 1, 0);
            if (returnCode) {
                return TC_ACT_SHOT;
            }
        }
        pkt = ((void*)(long)skb->data);
        ebpf_packetEnd = ((void*)(long)skb->data_end);
        ebpf_packetOffsetInBits = 0;
        if (hdr->ethernet.ebpf_valid) {
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 112)) {
                return TC_ACT_SHOT;
            }
            
            hdr->ethernet.dstAddr = htonll(hdr->ethernet.dstAddr << 16);
            ebpf_byte = ((char*)(&hdr->ethernet.dstAddr))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ethernet.dstAddr))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ethernet.dstAddr))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ethernet.dstAddr))[3];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ethernet.dstAddr))[4];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 4, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ethernet.dstAddr))[5];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 5, (ebpf_byte));
            ebpf_packetOffsetInBits += 48;

            hdr->ethernet.srcAddr = htonll(hdr->ethernet.srcAddr << 16);
            ebpf_byte = ((char*)(&hdr->ethernet.srcAddr))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ethernet.srcAddr))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ethernet.srcAddr))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ethernet.srcAddr))[3];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ethernet.srcAddr))[4];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 4, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ethernet.srcAddr))[5];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 5, (ebpf_byte));
            ebpf_packetOffsetInBits += 48;

            hdr->ethernet.etherType = bpf_htons(hdr->ethernet.etherType);
            ebpf_byte = ((char*)(&hdr->ethernet.etherType))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ethernet.etherType))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

        }
;        if (hdr->ipv4.ebpf_valid) {
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 160)) {
                return TC_ACT_SHOT;
            }
            
            ebpf_byte = ((char*)(&hdr->ipv4.version))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 4, 4, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 4;

            ebpf_byte = ((char*)(&hdr->ipv4.ihl))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 4, 0, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 4;

            ebpf_byte = ((char*)(&hdr->ipv4.diffserv))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_packetOffsetInBits += 8;

            hdr->ipv4.totalLen = bpf_htons(hdr->ipv4.totalLen);
            ebpf_byte = ((char*)(&hdr->ipv4.totalLen))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ipv4.totalLen))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

            hdr->ipv4.identification = bpf_htons(hdr->ipv4.identification);
            ebpf_byte = ((char*)(&hdr->ipv4.identification))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ipv4.identification))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

            ebpf_byte = ((char*)(&hdr->ipv4.flags))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 3, 5, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 3;

            hdr->ipv4.fragOffset = bpf_htons(hdr->ipv4.fragOffset << 3);
            ebpf_byte = ((char*)(&hdr->ipv4.fragOffset))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 5, 0, (ebpf_byte >> 3));
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0 + 1, 3, 5, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ipv4.fragOffset))[1];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 1, 5, 0, (ebpf_byte >> 3));
            ebpf_packetOffsetInBits += 13;

            ebpf_byte = ((char*)(&hdr->ipv4.ttl))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_packetOffsetInBits += 8;

            ebpf_byte = ((char*)(&hdr->ipv4.protocol))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_packetOffsetInBits += 8;

            hdr->ipv4.hdrChecksum = bpf_htons(hdr->ipv4.hdrChecksum);
            ebpf_byte = ((char*)(&hdr->ipv4.hdrChecksum))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ipv4.hdrChecksum))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

            hdr->ipv4.srcAddr = htonl(hdr->ipv4.srcAddr);
            ebpf_byte = ((char*)(&hdr->ipv4.srcAddr))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ipv4.srcAddr))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ipv4.srcAddr))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ipv4.srcAddr))[3];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_packetOffsetInBits += 32;

            hdr->ipv4.dstAddr = htonl(hdr->ipv4.dstAddr);
            ebpf_byte = ((char*)(&hdr->ipv4.dstAddr))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ipv4.dstAddr))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ipv4.dstAddr))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ipv4.dstAddr))[3];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_packetOffsetInBits += 32;

        }
;        if (hdr->opts.ebpf_valid) {
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 0)) {
                return TC_ACT_SHOT;
            }
            
            ebpf_byte = ((char*)(&hdr->opts.opts))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->opts.opts))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->opts.opts))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->opts.opts))[3];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->opts.opts))[4];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 4, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->opts.opts))[5];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 5, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->opts.opts))[6];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 6, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->opts.opts))[7];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 7, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->opts.opts))[8];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 8, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->opts.opts))[9];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 9, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->opts.opts))[10];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 10, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->opts.opts))[11];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 11, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->opts.opts))[12];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 12, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->opts.opts))[13];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 13, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->opts.opts))[14];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 14, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->opts.opts))[15];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 15, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->opts.opts))[16];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 16, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->opts.opts))[17];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 17, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->opts.opts))[18];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 18, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->opts.opts))[19];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 19, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->opts.opts))[20];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 20, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->opts.opts))[21];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 21, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->opts.opts))[22];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 22, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->opts.opts))[23];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 23, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->opts.opts))[24];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 24, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->opts.opts))[25];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 25, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->opts.opts))[26];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 26, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->opts.opts))[27];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 27, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->opts.opts))[28];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 28, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->opts.opts))[29];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 29, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->opts.opts))[30];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 30, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->opts.opts))[31];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 31, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->opts.opts))[32];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 32, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->opts.opts))[33];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 33, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->opts.opts))[34];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 34, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->opts.opts))[35];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 35, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->opts.opts))[36];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 36, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->opts.opts))[37];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 37, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->opts.opts))[38];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 38, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->opts.opts))[39];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 39, (ebpf_byte));
            ebpf_packetOffsetInBits += 320;

        }
;
    }
    return -1;
}
SEC("p4tc/main")
int tc_ingress_func(struct __sk_buff *skb) {
    struct pna_global_metadata *compiler_meta__ = (struct pna_global_metadata *) skb->cb;
    if (compiler_meta__->pass_to_kernel == true) return TC_ACT_OK;
    if (!compiler_meta__->recirculated) {
        compiler_meta__->mark = 153;
        struct internal_metadata *md = (struct internal_metadata *)(unsigned long)skb->data_meta;
        if ((void *) ((struct internal_metadata *) md + 1) <= (void *)(long)skb->data) {
            __u16 *ether_type = (__u16 *) ((void *) (long)skb->data + 12);
            if ((void *) ((__u16 *) ether_type + 1) > (void *) (long) skb->data_end) {
                return TC_ACT_SHOT;
            }
            *ether_type = md->pkt_ether_type;
        }
    }
    struct hdr_md *hdrMd;
    struct my_ingress_headers_t *hdr;
    int ret = -1;
    ret = process(skb, (struct my_ingress_headers_t *) hdr, compiler_meta__);
    if (ret != -1) {
        return ret;
    }
    if (!compiler_meta__->drop && compiler_meta__->egress_port == 0) {
        compiler_meta__->pass_to_kernel = true;
        return bpf_redirect(skb->ifindex, BPF_F_INGRESS);
    }
    return bpf_redirect(compiler_meta__->egress_port, 0);
}
char _license[] SEC("license") = "GPL";
