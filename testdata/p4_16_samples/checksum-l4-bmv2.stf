# The first packet was created with these Python statements:
# pkt1=Ether()/IP(dst='10.1.0.1')/TCP(sport=5793, dport=80)
#

# The packet in the first 'expect' line was created by running the P4
# program checksum1-bmv2.p4 using simple_switch  It was verified
# using Wireshark to verify that the TCP header checksum is correct.

# Any of these packets can be converted back into a Scapy packet
# object with Python statements like this:

# s1='525400123502080027018bbc0800 45000028000100003f0665bb0a00020f0a010005 16a20050000000000000000050022000278e0000'
# pkt1=Ether(hex_to_str(s1))

packet 0 525400123502080027018bbc08004500003000010000400664b70a00020f0a01000116a10050000000000000000050022000278e0000deadbeefdeadbeef
expect 0 525400123502080027018BBC080045000030000100003F0665B30A00020F0A01000516A2005000000000000000005002200027890000DEADBEEFDEADBEEF

# The second packet was created with these Python statements:
# pkt2=Ether() / IP(dst='10.2.3.4', options=IPOption('\x83\x03\x10')) / TCP(sport=5501, dport=80)
# str_to_hex(str(pkt2))

# This tests that the P4 code for calculating a fresh IPv4 header and TCP
# checksum also works with a varbit field 'options' in the ipv4_t
# header type.

packet 0 525400123502080027018bbc0800 4600002c000100004006cdb30a00020f0a02030483031000 157d005000000000000000005002200025b60000deadbeefdeadbeef
expect 0 525400123502080027018BBC08004600002C000100003F06CEAF0A00020F0A02030883031000157E005000000000000000005002200025B10000DEADBEEFDEADBEEF

# UDP pkt for UDP checksum test
#
packet 0 CA0107FC001C11111111111108004500002C00010000401166BA0A0100040A01000116A100500018B99B64656164626565666465616462656566
expect 0 CA0107FC001C11111111111108004500002C000100003F1167B60A0100040A01000516A200500018B98664656164626565666465616462656566
