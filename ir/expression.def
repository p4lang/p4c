/* -*-C++-*- */
/* This file contains the IR classes for all expressions.
   The base classes are in base.def */

abstract Operation_Unary : Operation {
    Expression expr;
    Operation_Unary {
        if (!srcInfo && expr) srcInfo = expr->srcInfo;
        if (type->is<Type::Unknown>() && expr) type = expr->type; }
    precedence = DBPrint::Prec_Prefix;
}

class Neg : Operation_Unary {
    stringOp = "-";
}

class Cmpl : Operation_Unary {
    stringOp = "~";
}

class LNot : Operation_Unary {
    stringOp = "!";
}

abstract Operation_Binary : Operation {
    Expression left;
    Expression right;
    Operation_Binary {
        if (!srcInfo && left && right) srcInfo = left->srcInfo + right->srcInfo;
        if (type->is<Type::Unknown>() && left && right && left->type == right->type)
            type = left->type; }
}

abstract Operation_Ternary : Operation {
    Expression e0;
    Expression e1;
    Expression e2;
    Operation_Ternary { if (!srcInfo && e0 && e2) srcInfo = e0->srcInfo + e2->srcInfo; }
}

abstract Operation_Relation : Operation_Binary {
    Operation_Relation { type = Type::Boolean::get(); }
}

class Mul : Operation_Binary {
    stringOp = "*";
    precedence = DBPrint::Prec_Mul;
}

class Div : Operation_Binary {
    stringOp = "/";
    precedence = DBPrint::Prec_Div;
}
class Mod : Operation_Binary {
    stringOp = "%";
    precedence = DBPrint::Prec_Mod;
}
class Add : Operation_Binary {
    stringOp = "+";
    precedence = DBPrint::Prec_Add;
}
class Sub : Operation_Binary {
    stringOp = "-";
    precedence = DBPrint::Prec_Sub;
}
class Shl : Operation_Binary {
    stringOp = "<<";
    precedence = DBPrint::Prec_Shl;
}
class Shr : Operation_Binary {
    stringOp = ">>";
    precedence = DBPrint::Prec_Shr;
}
class Equ : Operation_Relation {
    stringOp = "==";
    precedence = DBPrint::Prec_Equ;
}
class Neq : Operation_Relation {
    stringOp = "!=";
    precedence = DBPrint::Prec_Neq;
}
class Lss : Operation_Relation {
    stringOp = "<";
    precedence = DBPrint::Prec_Lss;
}
class Leq : Operation_Relation {
    stringOp = "<=";
    precedence = DBPrint::Prec_Leq;
}
class Grt : Operation_Relation {
    stringOp = ">";
    precedence = DBPrint::Prec_Grt;
}
class Geq : Operation_Relation {
    stringOp = ">=";
    precedence = DBPrint::Prec_Geq;
}
class BAnd : Operation_Binary {
    stringOp = "&";
    precedence = DBPrint::Prec_BAnd;
}
class BOr : Operation_Binary {
    stringOp = "|";
    precedence = DBPrint::Prec_BOr;
}
class BXor : Operation_Binary {
    stringOp = "^";
    precedence = DBPrint::Prec_BXor;
}
class LAnd : Operation_Binary {
    stringOp = "&&";
    precedence = DBPrint::Prec_LAnd;
}
class LOr : Operation_Binary {
    stringOp = "||";
    precedence = DBPrint::Prec_LOr;
}

abstract Literal : Expression, CompileTimeValue {
#nodbprint
}

// This is an integer literal on arbitrary-precision.
class Constant : Literal {
    mpz_class value;
    optional unsigned  base;  // base used when reading/writing
#noconstructor
    // if noWarning is true, no warning is emitted
    void handleOverflow(bool noWarning);
    Constant(intmax_t v, unsigned base = 10) :
            Literal(new Type_InfInt()), value(v), base(base) {}
    Constant(mpz_class v, unsigned base = 10) :
            Literal(new Type_InfInt()), value(v), base(base) {}
    Constant(Util::SourceInfo si, mpz_class v, unsigned base = 10) :
            Literal(si, new Type_InfInt()), value(v), base(base) {}
    Constant(const Type *t, mpz_class v, unsigned base = 10, bool noWarning = false) :
            Literal(t), value(v), base(base) { CHECK_NULL(t); handleOverflow(noWarning); }
    Constant(Util::SourceInfo si, const Type *t, mpz_class v,
             unsigned base = 10, bool noWarning = false) :
            Literal(si, t), value(v), base(base) { CHECK_NULL(t); handleOverflow(noWarning); }
#emit
    static Constant GetMask(unsigned width);
#end
    bool fitsInt() const { return value.fits_sint_p(); }
    bool fitsLong() const { return value.fits_slong_p(); }
    long asLong() const {
        if (!fitsLong())
            ::error("%1%: Value too large", this);
        return value.get_si(); }
    int asInt() const {
        if (!fitsInt())
            ::error("%1%: Value too large", this);
        return value.get_si(); }
    // The following operators are only used in special circumstances.
    // They do not look at the type when operating.  There are separate
    // implementations of these computations when doing proper constant folding.
#emit
    Constant operator<<(const unsigned &shift) const;
    Constant operator>>(const unsigned &shift) const;
    Constant operator&(const Constant &c) const;
    Constant operator-(const Constant &c) const;
    Constant operator-() const;
#end
    toString { return Util::toString(&value); }
    visit_children { v.visit(type, "type"); }
}

class BoolLiteral : Literal {
    bool value;
    toString{ return value ? "true" : "false"; }
}

class StringLiteral : Literal {
    cstring value;
    validate{ if (value.isNull()) BUG("null StringLiteral"); }
    toString{ return cstring("\"") + value + "\""; }
}

class PathExpression : Expression {
    Path path;
    PathExpression { if (!srcInfo && path) srcInfo = path->srcInfo; }
    PathExpression(IR::ID id) : Expression(id.srcInfo), path(new IR::Path(id)) {}
    toString{ return path->toString(); }
}

// enum X { a }
// X.a
// The 'X' portion is a TypeNameExpression
class TypeNameExpression : Expression {
    Type_Name typeName;
    TypeNameExpression { if (!srcInfo && typeName) srcInfo = typeName->srcInfo; }
    TypeNameExpression(ID id) : Expression(id.srcInfo),
                                typeName(new IR::Type_Name(new IR::Path(id))) {}
    dbprint{ Node::dbprint(out); out << typeName; }
    toString { return typeName->toString(); }
}

class Slice : Operation_Ternary {
    precedence = DBPrint::Prec_Postfix;
    stringOp = "[:]";
    toString{ return e0->toString() + "[" + e1->toString() + ":" + e2->toString() + "]"; }
    // After type checking e1 and e2 will be constants
    int getH() const { return e1->to<IR::Constant>()->asInt(); }
    int getL() const { return e2->to<IR::Constant>()->asInt(); }
    Slice(Expression a, int hi, int lo)
    : Operation_Ternary(a, new Constant(hi), new Constant(lo)) {}
    Slice(Util::SourceInfo si, Expression a, int hi, int lo)
    : Operation_Ternary(si, a, new Constant(hi), new Constant(lo)) {}
}

class Member : Operation_Unary {
    ID member;
    virtual int offset_bits() const;
    int lsb() const;
    int msb() const;
    stringOp = ".";
    toString{ return expr->toString() + "." + member; }
}

class Concat : Operation_Binary {
    stringOp = "++";
    precedence = DBPrint::Prec_Add;
}

class ArrayIndex : Operation_Binary {
    stringOp = "[]";
    precedence = DBPrint::Prec_Postfix;
}

class Range : Operation_Binary {
    stringOp = "..";
    precedence = DBPrint::Prec_Low;
}

class Mask : Operation_Binary {
    stringOp = "&&&";
    precedence = DBPrint::Prec_Low;
}

class Mux : Operation_Ternary {
    stringOp = "?:";
    precedence = DBPrint::Prec_Low;
    visit_children {
        v.visit(e0, "e0");
        auto &clone(v.flow_clone());
        v.visit(e1, "e1");
        clone.visit(e2, "e2");
        v.flow_merge(clone); }
}

class DefaultExpression : Expression {}

class This : Expression {}  // experimental

class Cast : Operation_Unary {
    Type destType = type;
    // These will generally always be the same, except when a cast to a type argument of
    // a generic occurs.  Then at some point, the 'destType' will be specialized to a concrete
    // type, and 'type' will only be updated later when type inferencing occurs
    precedence = DBPrint::Prec_Prefix;
    stringOp = "(cast)";
    toString{ return "cast"; }
    validate{ BUG_CHECK(!destType->is<Type_Unknown>(), "%1%: Cannot cast to unknown type", this); }
}

class SelectCase {
    Expression     keyset;
    PathExpression state;
#nodbprint
}

class SelectExpression : Expression {
    ListExpression            select;
    inline Vector<SelectCase> selectCases;
#nodbprint
    visit_children {
        v.visit(select, "select");
        selectCases.parallel_visit_children(v); }
}

class MethodCallExpression : Expression {
    Expression         method;
    Vector<Type>       typeArguments;
    Vector<Expression> arguments;
    toString{ return method->toString(); }
    validate{ typeArguments->check_null(); arguments->check_null(); }
}

class ConstructorCallExpression : Expression {
    Type               constructedType = type;  // Either a Type_Name or a Specialized_Type
    Vector<Expression> arguments;
    toString{ return constructedType->toString(); }
    validate{ BUG_CHECK(constructedType->is<Type_Name>() ||
                        constructedType->is<Type_Specialized>(),
                        "%1%: unexpected type", constructedType);
        arguments->check_null(); }
}

// Represents a list of expressions separated by commas
class ListExpression : Expression {
    Vector<Expression> components;
    validate {
        components->check_null();
    }
}
