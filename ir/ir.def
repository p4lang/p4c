/* -*-C++-*- */

/*
  P4 compiler IR definition file.
  To understand this you really have to understand the shape of the generated IR code.

  The IR builder "knows" the following methods for a class T:

  cstring toString() const override;
  void dbprint(std::ostream &out) const override;
  bool operator==(const T &a) const;
  void validate() const;
  const char *node_type_name() const;
  void visit_children(Visitor &v);
  void dump_fields(std::ostream& out) const;

  C comments are ignored.
  C++ line comments can appear in some places and are emitted in the output.

  #emit/#end   -> copy text literally to output
  #noXXX       -> do not emit the specified implementation for the XXX method
                  e.g., #noconstructor, #nodbprint, #novisit_children
  #apply       -> generate apply overload for visitors
  method{ ... } -> specifies an implementation for a default method
                   method can be 'operator=='

  Some assignments are turned into methods returning constant values:
  stringOp     -> cstring getStringOp() const
  precedence   -> int getPrecedence() const
 */

class SelectCase {
    Expression     keyset;
    PathExpression state;
#nodbprint
}

class ParserState : ISimpleNamespace, Declaration, IAnnotated {
    Annotations               annotations;
    IndexedVector<StatOrDecl> components;
    // selectExpression can be a SelectExpression, or a PathExpression representing a state
    NullOK Expression         selectExpression;
#emit
    const Annotations* getAnnotations() const override { return annotations; }
    Util::Enumerator<const IDeclaration*>* getDeclarations() const override
    { return components->getDeclarations(); }
    const IDeclaration* getDeclByName(cstring name) const override
    { return components->getDeclaration(name); }

    static const ID accept;
    static const ID reject;
    static const ID start;
    bool isBuiltin() const { return name == ParserState::accept || name == ParserState::reject; }
#end
#nodbprint
    validate{ components->check_null(); }
}

// A parser that contains all states (unlike the P4 v1.0 parser, which is really just a state)
class P4Parser : Type_Declaration, ISimpleNamespace, IApply, IContainer {
    Type_Parser          type;
    ParameterList        constructorParams;
    IndexedVector<Declaration>  stateful;
    IndexedVector<ParserState>  states;
#emit
    const TypeParameters* getTypeParameters() const override { return type->getTypeParameters(); }
    Util::Enumerator<const IDeclaration*>* getDeclarations() const override
    { return stateful->getDeclarations()->concat(states->getDeclarations()); }
    const IDeclaration* getDeclByName(cstring name) const override {
        auto decl = stateful->getDeclaration(name);
        if (decl != nullptr)
            return decl;
        return states->getDeclaration(name); }
    const Type_Method* getApplyMethodType() const override { return type->getApplyMethodType(); }
    const Type_Method* getConstructorMethodType() const override;
    const ParameterList* getConstructorParameters() const override { return constructorParams; }
    void checkDuplicates() const;
#end
#apply
#nodbprint
    validate {
        if (!(name == type->name))
            BUG("Name mismatch for %1%: %2% != %3%", this, name, type->name);
        stateful->check_null();
        states->check_null();
        checkDuplicates();
    }
    toString { return cstring("parser ") + externalName(); }
}

class P4Control : Type_Declaration, ISimpleNamespace, IApply, IContainer {
    Type_Control         type;
    ParameterList        constructorParams;
    IndexedVector<Declaration>  stateful;
    BlockStatement       body;
#emit
    const TypeParameters* getTypeParameters() const override { return type->getTypeParameters(); }
    Util::Enumerator<const IDeclaration*>* getDeclarations() const override
    { return stateful->getDeclarations(); }
    const Type_Method* getApplyMethodType() const override { return type->getApplyMethodType(); }
    const Type_Method* getConstructorMethodType() const override;
    const IDeclaration* getDeclByName(cstring name) const override
    { return stateful->getDeclaration(name); }
    const ParameterList* getConstructorParameters() const override { return constructorParams; }
#end
#apply
#nodbprint
    validate {
        if (!(name == type->name))
            BUG("Name mismatch for %1%: %2% != %3%", this, name, type->name);
        stateful->check_null();
    }
    toString { return cstring("control ") + externalName(); }
}

class P4Action : Declaration, ISimpleNamespace, IAnnotated {
    Annotations    annotations;
    ParameterList  parameters;
    BlockStatement body;
#emit
    Util::Enumerator<const IDeclaration*>* getDeclarations() const override;
    const IDeclaration* getDeclByName(cstring name) const override;
    const Annotations* getAnnotations() const override { return annotations; }
#end
}

// Not a subclass of IDeclaration
class Declaration_Errors : ISimpleNamespace {
    IndexedVector<Declaration_ID> members;
#emit
    Util::Enumerator<const IDeclaration*>* getDeclarations() const override
    { return members->getDeclarations(); }
    const IDeclaration* getDeclByName(cstring name) const override
    { return members->getDeclaration(name); }
#end
#nodbprint
    validate{ members->check_null(); }
}

// Not a subclass of IDeclaration
class Declaration_MatchKind : ISimpleNamespace {
    IndexedVector<Declaration_ID> members;
#emit
    Util::Enumerator<const IDeclaration*>* getDeclarations() const override
    { return members->getDeclarations(); }
    const IDeclaration* getDeclByName(cstring name) const override
    { return members->getDeclaration(name); }
#end
#nodbprint
    validate{ members->check_null(); }
}

// Table property value abstract base class
abstract PropertyValue {
#nodbprint
}

// A property whose value is an expression
class ExpressionValue : PropertyValue {
    Expression expression;
#nodbprint
}

// An element in a table actions list
class ActionListElement : IAnnotated, IDeclaration {
    Annotations annotations;
    Expression  expression;  // This can be a PathExpression or a MethodCallExpression
#nodbprint
#emit
    ID getName() const override { return getPath()->name; }
    const Path* getPath() const;
    const Annotations* getAnnotations() const override { return annotations; }
#end
    validate {
        BUG_CHECK(expression->is<IR::PathExpression>() ||
                  expression->is<IR::MethodCallExpression>(),
                "%1%: unexpected expression", expression);
    }
    toString{ return getName().toString(); }
}

// A list of actions (in a table)
class ActionList : PropertyValue {
    IndexedVector<ActionListElement> actionList;
#nodbprint
    validate{ actionList->check_null(); }
}

class KeyElement {
    Expression      expression;
    PathExpression  matchType;
#nodbprint
}

// Value of a table key property
class Key : PropertyValue {
    Vector<KeyElement> keyElements;
#nodbprint
    validate { keyElements->check_null(); }
}

class TableProperty : Declaration, IAnnotated {
    Annotations   annotations;
    PropertyValue value;
    bool          isConstant;
#emit
    const Annotations* getAnnotations() const override { return annotations; }
#end
#nodbprint
}

class TableProperties : ISimpleNamespace {
    IndexedVector<TableProperty> properties;
    toString{ return "TableProperties(" + Util::toString(properties->size()) + ")"; }
#emit
    TableProperties() { properties = new IndexedVector<TableProperty>(); }
    Util::Enumerator<const IDeclaration*>* getDeclarations() const override
    { return properties->getDeclarations(); }
    const TableProperty* getProperty(cstring name) const
    { return properties->getDeclaration<TableProperty>(name); }
    const IDeclaration* getDeclByName(cstring name) const override
    { return properties->getDeclaration(name); }

    static const cstring actionsPropertyName;
    static const cstring keyPropertyName;
    static const cstring defaultActionPropertyName;
#end
#nodbprint
    validate{ properties->check_null(); }
}

class P4Table : Declaration, IAnnotated, IApply {
    Annotations     annotations;
    ParameterList   parameters;
    TableProperties properties;
#emit
    const Annotations* getAnnotations() const override { return annotations; }
    const Type_Method* getApplyMethodType() const override;
    const ActionList* getActionList() const {
        auto ap = properties->getProperty(TableProperties::actionsPropertyName);
        if (ap == nullptr)
            return nullptr;
        if (!ap->value->is<IR::ActionList>()) {
            ::error("%1% must be an action list", ap);
            return nullptr;
        }
        return ap->value->to<IR::ActionList>();
    }
    const Key* getKey() const {
        auto kp = properties->getProperty(TableProperties::keyPropertyName);
        if (kp == nullptr)
            return nullptr;
        if (!kp->value->is<IR::Key>()) {
            ::error("%1% must be a key", kp);
            return nullptr;
        }
        return kp->value->to<IR::Key>();
    }
    const Expression* getDefaultAction() const {
        auto d = properties->getProperty(TableProperties::defaultActionPropertyName);
        if (d == nullptr)
            return nullptr;
        if (!d->value->is<IR::ExpressionValue>()) {
            ::error("%1% must be an expression", d);
            return nullptr;
        }
        return d->value->to<IR::ExpressionValue>()->expression;
    }
#end
#nodbprint
}

class Declaration_Variable : Declaration, IAnnotated {
    Annotations        annotations;
    Type               type;
    NullOK Expression  initializer;
#emit
    const Annotations* getAnnotations() const override { return annotations; }
#end
    dbprint { Declaration::dbprint(out);
        if (initializer) out << " = " << *initializer; }
}

class Declaration_Constant : Declaration, IAnnotated {
    Annotations        annotations;
    Type               type;
    Expression         initializer;
#emit
    const Annotations* getAnnotations() const override { return annotations; }
#end
#nodbprint
    toString { return Declaration::toString(); }
}

// Like a variable, but for a statically allocated instance.
// The syntax is Contructor(args) name = initializer;
class Declaration_Instance : Declaration, IAnnotated {
    Type                  type;
    Vector<Expression>    arguments;
    Annotations           annotations;
    NullOK BlockStatement initializer;  // experimental only; contains just declarations, no code
#emit
    const Annotations* getAnnotations() const override { return annotations; }
#end
#nodbprint
    validate{ arguments->check_null(); }
}

// Toplevel program representation
class P4Program : ISimpleNamespace {
    IndexedVector<Node> declarations;
#emit
    Util::Enumerator<const IDeclaration*>* getDeclarations() const override
    { return declarations->getDeclarations(); }
    const IDeclaration* getDeclByName(cstring name) const override
    { return declarations->getDeclaration(name); }
    static const cstring main;
#end
#apply
#nodbprint
}

///////////////////////////// Statements //////////////////////////

abstract Statement : StatOrDecl {
#nodbprint
}

class ExitStatement : Statement {
    toString{ return "exit"; }
#nodbprint
}

class ReturnStatement : Statement {
    NullOK Expression expression;
    toString{ return "return"; }
#nodbprint
}

class EmptyStatement : Statement {
#nodbprint
}

class AssignmentStatement : Statement {
    Expression left;
    Expression right;
    dbprint{ out << left << " = " << right; }
}

class IfStatement : Statement {
    Expression       condition;
    Statement        ifTrue;
    NullOK Statement ifFalse;
#nodbprint
    visit_children {
        v.visit(condition, "condition");
        auto &clone(v.flow_clone());
        v.visit(ifTrue, "ifTrue");
        clone.visit(ifFalse, "ifFalse");
        v.flow_merge(clone);
    }
}

class BlockStatement : Statement, ISimpleNamespace {
    IndexedVector<StatOrDecl> components;
#emit
    const IDeclaration* getDeclByName(cstring name) const override
    { return components->getDeclaration(name); }
    Util::Enumerator<const IDeclaration*>* getDeclarations() const override
    { return components->getDeclarations(); }
#end
}

class MethodCallStatement : Statement {
    MethodCallExpression methodCall;
}

class SwitchCase {
    Expression       label;  // Can be DefaultExpression or a PathExpression
    NullOK Statement statement;  // If missing then it's a fall-through
#nodbprint
}

// The type system will enforce the fact that
// expression is IR::Member(IR::MethodCallExpression(table_apply), Type_Table::action_run)
class SwitchStatement : Statement {
    Expression expression;
    Vector<SwitchCase> cases;
#nodbprint
}

class Function : Declaration {
    Type_Method    type;
    BlockStatement body;
#nodbprint
}

/////////////////////////////////////////////////////////////

// Block is the base class for IR nodes produced by the evaluator.
// A block represents a compile-time allocated resource.
// Blocks are not visited using visitors, so the visit_children()
// method is empty.  Users have to write custom visitors to
// traverse the constantValue map.
abstract Block : CompileTimeValue {
    Node node;  // Node that evaluates to this block.
    // It's either a Declaration_Instance or a ConstructorCallExpression.
#emit
    // One value for each Node inside that evaluates to a compile-time constant.
    // This includes all constructor parameters, and all inner nested blocks.
    ordered_map<const Node*, const CompileTimeValue*> constantValue;

    virtual void dbprint(std::ostream& out) const override;
    virtual void dbprint_recursive(std::ostream& out) const;
    void setValue(const Node* node, const CompileTimeValue* value) {
        CHECK_NULL(node); CHECK_NULL(value);
        auto it = constantValue.find(node);
        BUG_CHECK(it == constantValue.end(), "%1% already set", node);
        constantValue[node] = value;
    }
    const CompileTimeValue* getValue(const Node* node) const {
        CHECK_NULL(node);
        auto it = constantValue.find(node);
        if (it == constantValue.end())
            return nullptr;
        return it->second;
    }
#end
    visit_children { (void)v; }
}

class TableBlock : Block {
    P4Table container;
#nodbprint
}

// An object that has been instantiated
// The substitution holds the constructor arguments.
abstract InstantiatedBlock : Block {
    Type instanceType;  // May be a SpecializedType
#emit
    virtual const IR::ParameterList* getConstructorParameters() const = 0;
    void instantiate(std::vector<const IR::CompileTimeValue*> *args);
    const CompileTimeValue* getParameterValue(cstring paramName) const;
    virtual void dbprint(std::ostream& out) const override;
#end
}

class ParserBlock : InstantiatedBlock {
    P4Parser container;
#emit
    const IR::ParameterList* getConstructorParameters() const override
    { return container->constructorParams; }
#end
#nodbprint
}

class ControlBlock : InstantiatedBlock {
    P4Control container;
#emit
    const IR::ParameterList* getConstructorParameters() const override
    { return container->constructorParams; }
#end
#nodbprint
}

class PackageBlock : InstantiatedBlock {
    Type_Package type;
#emit
    const IR::ParameterList* getConstructorParameters() const override
    { return type->constructorParams; }
#end
#nodbprint
}

class ExternBlock : InstantiatedBlock {
    Type_Extern type;
    Method      constructor;  // used to instantiate this block
#emit
    const IR::ParameterList* getConstructorParameters() const override
    { return constructor->type->parameters; }
#end
#nodbprint
}

// Represents the program as a whole
class ToplevelBlock : Block {
#emit
    const P4Program* getProgram() const
    { return node->to<IR::P4Program>(); }
    const IR::PackageBlock* getMain() const;
#end
#nodbprint
    validate { BUG_CHECK(node->is<IR::P4Program>(), "%1%: expected a P4Program", node); }
}
