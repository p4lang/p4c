<!-- HTML header for doxygen 1.13.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>P4 Compiler Documentation (P4C): InferWriteMode Struct Reference</title>
<link rel="icon" href="p4-fav.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!--  Add link to paragraphs   -->
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
  DoxygenAwesomeParagraphLink.init()
</script>
<!-- Add copy button to code fragments  -->
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
  DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add dark mode toggle -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
  DoxygenAwesomeDarkModeToggle.init()
</script>
<!-- Add interactive TOC -->
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
  DoxygenAwesomeInteractiveToc.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-interactive-toc.js" rel="stylesheet" type="text/css"/>
<link href="cards.css" rel="stylesheet" type="text/css"/>
<link href="flow.css" rel="stylesheet" type="text/css"/>
<link href="p4c_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="p4-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">P4C
   </div>
   <div id="projectbrief">The P4 Compiler</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('struct_infer_write_mode.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="struct_infer_write_mode-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">InferWriteMode Struct Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for InferWriteMode:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="struct_infer_write_mode__inherit__graph.svg" width="138" height="183"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_infer_write_mode_1_1_counter_example.html">CounterExample</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad2fecde53eb14f07a9f80de387c12aa4" id="r_ad2fecde53eb14f07a9f80de387c12aa4"><td class="memItemLeft" align="right" valign="top"><a id="ad2fecde53eb14f07a9f80de387c12aa4" name="ad2fecde53eb14f07a9f80de387c12aa4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>InferWriteMode</b> (const <a class="el" href="class_phv_info.html">PhvInfo</a> &amp;ph, const <a class="el" href="group__parde.html">CollectParserInfo</a> &amp;pi, const <a class="el" href="class_map_field_to_parser_states.html">MapFieldToParserStates</a> &amp;fs)</td></tr>
<tr class="separator:ad2fecde53eb14f07a9f80de387c12aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454f014c1d6bbff655dc73d58c358cfe" id="r_a454f014c1d6bbff655dc73d58c358cfe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a454f014c1d6bbff655dc73d58c358cfe">can_absorb</a> (const IR::BFN::ParserPrimitive *prev_p, const IR::BFN::ParserPrimitive *curr_p)</td></tr>
<tr class="separator:a454f014c1d6bbff655dc73d58c358cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e03b8df1bafe9b0401560f234ea016" id="r_a24e03b8df1bafe9b0401560f234ea016"><td class="memItemLeft" align="right" valign="top"><a id="a24e03b8df1bafe9b0401560f234ea016" name="a24e03b8df1bafe9b0401560f234ea016"></a>
<a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const IR::BFN::ParserPrimitive * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>exclude_zero_inits</b> (const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const IR::BFN::ParserPrimitive * &gt; &amp;writes)</td></tr>
<tr class="separator:a24e03b8df1bafe9b0401560f234ea016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21b384a27bb9e43a3d567cabbf886a7" id="r_ae21b384a27bb9e43a3d567cabbf886a7"><td class="memItemLeft" align="right" valign="top"><a id="ae21b384a27bb9e43a3d567cabbf886a7" name="ae21b384a27bb9e43a3d567cabbf886a7"></a>
<a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const IR::BFN::ParserPrimitive * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>find_inits</b> (const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const IR::BFN::ParserPrimitive * &gt; &amp;writes)</td></tr>
<tr class="separator:ae21b384a27bb9e43a3d567cabbf886a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c1679a0a78e8941cba1895d79985cc7" id="r_a5c1679a0a78e8941cba1895d79985cc7"><td class="memItemLeft" align="right" valign="top"><a id="a5c1679a0a78e8941cba1895d79985cc7" name="a5c1679a0a78e8941cba1895d79985cc7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>infer_write_mode</b> (const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *dest, const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const IR::BFN::ParserPrimitive * &gt; &amp;prim_writes)</td></tr>
<tr class="separator:a5c1679a0a78e8941cba1895d79985cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21db207aa8a8302044d919470d21d308" id="r_a21db207aa8a8302044d919470d21d308"><td class="memItemLeft" align="right" valign="top"><a id="a21db207aa8a8302044d919470d21d308" name="a21db207aa8a8302044d919470d21d308"></a>
profile_t&#160;</td><td class="memItemRight" valign="bottom"><b>init_apply</b> (const IR::Node *root) override</td></tr>
<tr class="separator:a21db207aa8a8302044d919470d21d308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af66c5d2ef11e8c7653854ffac7af3758" id="r_af66c5d2ef11e8c7653854ffac7af3758"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_infer_write_mode_1_1_counter_example.html">CounterExample</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af66c5d2ef11e8c7653854ffac7af3758">is_bitwise_or</a> (const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *dest, const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const IR::BFN::ParserPrimitive * &gt; &amp;writes, bool strict=false)</td></tr>
<tr class="separator:af66c5d2ef11e8c7653854ffac7af3758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0358086eefbd14e919dae2f3b1f9a257" id="r_a0358086eefbd14e919dae2f3b1f9a257"><td class="memItemLeft" align="right" valign="top"><a id="a0358086eefbd14e919dae2f3b1f9a257" name="a0358086eefbd14e919dae2f3b1f9a257"></a>
<a class="el" href="struct_infer_write_mode_1_1_counter_example.html">CounterExample</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>is_clear_on_write</b> (const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const IR::BFN::ParserPrimitive * &gt; &amp;writes)</td></tr>
<tr class="separator:a0358086eefbd14e919dae2f3b1f9a257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b03a729e090e184de47d0e9a1f0323" id="r_ad7b03a729e090e184de47d0e9a1f0323"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7b03a729e090e184de47d0e9a1f0323">is_postdominated_by_extract</a> (const IR::BFN::ParserPrimitive *write, const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const IR::BFN::ParserPrimitive * &gt; &amp;writes)</td></tr>
<tr class="separator:ad7b03a729e090e184de47d0e9a1f0323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42eaf72a0f9ea3aa4a182a73d16ca467" id="r_a42eaf72a0f9ea3aa4a182a73d16ca467"><td class="memItemLeft" align="right" valign="top"><a id="a42eaf72a0f9ea3aa4a182a73d16ca467" name="a42eaf72a0f9ea3aa4a182a73d16ca467"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_zero_extract</b> (const IR::BFN::ParserPrimitive *p)</td></tr>
<tr class="separator:a42eaf72a0f9ea3aa4a182a73d16ca467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4c1614144c4ebd6912d81ebd834498" id="r_a1d4c1614144c4ebd6912d81ebd834498"><td class="memItemLeft" align="right" valign="top"><a id="a1d4c1614144c4ebd6912d81ebd834498" name="a1d4c1614144c4ebd6912d81ebd834498"></a>
<a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const IR::BFN::ParserPrimitive * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mark_and_exclude_dead_writes</b> (const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const IR::BFN::ParserPrimitive * &gt; &amp;writes)</td></tr>
<tr class="separator:a1d4c1614144c4ebd6912d81ebd834498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d90c5dbd7eeeb587b588bbbefb35365" id="r_a5d90c5dbd7eeeb587b588bbbefb35365"><td class="memItemLeft" align="right" valign="top"><a id="a5d90c5dbd7eeeb587b588bbbefb35365" name="a5d90c5dbd7eeeb587b588bbbefb35365"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mark_write_mode</b> (IR::BFN::ParserWriteMode mode, const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *dest, const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const IR::BFN::ParserPrimitive * &gt; &amp;writes)</td></tr>
<tr class="separator:a5d90c5dbd7eeeb587b588bbbefb35365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3358166f022672e25fdef3338487c148" id="r_a3358166f022672e25fdef3338487c148"><td class="memItemLeft" align="right" valign="top"><a id="a3358166f022672e25fdef3338487c148" name="a3358166f022672e25fdef3338487c148"></a>
IR::Node *&#160;</td><td class="memItemRight" valign="bottom"><b>preorder</b> (IR::BFN::Extract *extract) override</td></tr>
<tr class="separator:a3358166f022672e25fdef3338487c148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35cc775c395136dcbf260acd0cd27ef" id="r_ab35cc775c395136dcbf260acd0cd27ef"><td class="memItemLeft" align="right" valign="top"><a id="ab35cc775c395136dcbf260acd0cd27ef" name="ab35cc775c395136dcbf260acd0cd27ef"></a>
IR::Node *&#160;</td><td class="memItemRight" valign="bottom"><b>preorder</b> (IR::BFN::ParserChecksumWritePrimitive *checksum_write) override</td></tr>
<tr class="separator:ab35cc775c395136dcbf260acd0cd27ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a08a9ac64d0d71d5e8eb8edfdecf4f2" id="r_a8a08a9ac64d0d71d5e8eb8edfdecf4f2"><td class="memItemLeft" align="right" valign="top"><a id="a8a08a9ac64d0d71d5e8eb8edfdecf4f2" name="a8a08a9ac64d0d71d5e8eb8edfdecf4f2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>print</b> (<a class="el" href="struct_infer_write_mode_1_1_counter_example.html">CounterExample</a> *example)</td></tr>
<tr class="separator:a8a08a9ac64d0d71d5e8eb8edfdecf4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e0d39f00bdfcac0581c395051fb5a1" id="r_a82e0d39f00bdfcac0581c395051fb5a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82e0d39f00bdfcac0581c395051fb5a1">validate_checksum_residual_deposits</a> (const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *field, const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const IR::BFN::ParserPrimitive * &gt; &amp;writes)</td></tr>
<tr class="separator:a82e0d39f00bdfcac0581c395051fb5a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:adfdc20db6dbbf5591ddcec2e34ecbc89" id="r_adfdc20db6dbbf5591ddcec2e34ecbc89"><td class="memItemLeft" align="right" valign="top"><a id="adfdc20db6dbbf5591ddcec2e34ecbc89" name="adfdc20db6dbbf5591ddcec2e34ecbc89"></a>
<a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const IR::BFN::ParserPrimitive * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>dead_writes</b></td></tr>
<tr class="separator:adfdc20db6dbbf5591ddcec2e34ecbc89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10dd2cf34b81fd0c43416ae701a8d6cf" id="r_a10dd2cf34b81fd0c43416ae701a8d6cf"><td class="memItemLeft" align="right" valign="top"><a id="a10dd2cf34b81fd0c43416ae701a8d6cf" name="a10dd2cf34b81fd0c43416ae701a8d6cf"></a>
const <a class="el" href="class_map_field_to_parser_states.html">MapFieldToParserStates</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>field_to_states</b></td></tr>
<tr class="separator:a10dd2cf34b81fd0c43416ae701a8d6cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d80e79346ef5285e0e099b6a6409a9" id="r_ac0d80e79346ef5285e0e099b6a6409a9"><td class="memItemLeft" align="right" valign="top"><a id="ac0d80e79346ef5285e0e099b6a6409a9" name="ac0d80e79346ef5285e0e099b6a6409a9"></a>
const <a class="el" href="group__parde.html">CollectParserInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>parser_info</b></td></tr>
<tr class="separator:ac0d80e79346ef5285e0e099b6a6409a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3deebf171fc09b6418ab08e61966bc58" id="r_a3deebf171fc09b6418ab08e61966bc58"><td class="memItemLeft" align="right" valign="top"><a id="a3deebf171fc09b6418ab08e61966bc58" name="a3deebf171fc09b6418ab08e61966bc58"></a>
const <a class="el" href="class_phv_info.html">PhvInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>phv</b></td></tr>
<tr class="separator:a3deebf171fc09b6418ab08e61966bc58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3e254fe359e72966fef129cfe085bc" id="r_a0c3e254fe359e72966fef129cfe085bc"><td class="memItemLeft" align="right" valign="top"><a id="a0c3e254fe359e72966fef129cfe085bc" name="a0c3e254fe359e72966fef129cfe085bc"></a>
const <a class="el" href="struct_parser_query.html">ParserQuery</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pq</b></td></tr>
<tr class="separator:a0c3e254fe359e72966fef129cfe085bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d1d8c0f1555c675b294a6409d2c2e9" id="r_ae8d1d8c0f1555c675b294a6409d2c2e9"><td class="memItemLeft" align="right" valign="top"><a id="ae8d1d8c0f1555c675b294a6409d2c2e9" name="ae8d1d8c0f1555c675b294a6409d2c2e9"></a>
std::map&lt; const IR::BFN::ParserPrimitive *, IR::BFN::ParserWriteMode &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>write_to_write_mode</b></td></tr>
<tr class="separator:ae8d1d8c0f1555c675b294a6409d2c2e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe61cd34f8ea827fbef6514aefd38059" id="r_abe61cd34f8ea827fbef6514aefd38059"><td class="memItemLeft" align="right" valign="top"><a id="abe61cd34f8ea827fbef6514aefd38059" name="abe61cd34f8ea827fbef6514aefd38059"></a>
<a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const IR::BFN::ParserPrimitive * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>zero_inits</b></td></tr>
<tr class="separator:abe61cd34f8ea827fbef6514aefd38059"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a454f014c1d6bbff655dc73d58c358cfe" name="a454f014c1d6bbff655dc73d58c358cfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a454f014c1d6bbff655dc73d58c358cfe">&#9670;&#160;</a></span>can_absorb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool InferWriteMode::can_absorb </td>
          <td>(</td>
          <td class="paramtype">const IR::BFN::ParserPrimitive *</td>          <td class="paramname"><span class="paramname"><em>prev_p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IR::BFN::ParserPrimitive *</td>          <td class="paramname"><span class="paramname"><em>curr_p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the current write <code class="param">curr_p</code> is safe to be applied BITWISE_OR on the <code class="param">prev_p</code> write. This can be done if we can guarantee that no bit will need to be set to 0.</p><ul>
<li>if both <code class="param">prev_p</code> and <code class="param">curr_p</code> are constants and their bitwise or is same as <code class="param">curr_p</code> </li>
<li>if <code class="param">curr_p</code> is a constant and sets all bits in the left-hand-side of the assignment to 1</li>
<li>if <code class="param">prev_p</code> is constant 0 </li>
</ul>

</div>
</div>
<a id="af66c5d2ef11e8c7653854ffac7af3758" name="af66c5d2ef11e8c7653854ffac7af3758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af66c5d2ef11e8c7653854ffac7af3758">&#9670;&#160;</a></span>is_bitwise_or()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_infer_write_mode_1_1_counter_example.html">CounterExample</a> * InferWriteMode::is_bitwise_or </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const IR::BFN::ParserPrimitive * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>writes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>strict</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><code class="param">strict</code> indicates that all ovewrites should be treated as "always overwrites". This specifically means that they will always cause error even on Tofino 1. </p>

</div>
</div>
<a id="ad7b03a729e090e184de47d0e9a1f0323" name="ad7b03a729e090e184de47d0e9a1f0323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7b03a729e090e184de47d0e9a1f0323">&#9670;&#160;</a></span>is_postdominated_by_extract()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool InferWriteMode::is_postdominated_by_extract </td>
          <td>(</td>
          <td class="paramtype">const IR::BFN::ParserPrimitive *</td>          <td class="paramname"><span class="paramname"><em>write</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const IR::BFN::ParserPrimitive * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>writes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determines whether extract <code class="param">write</code> is postdominated by extract of the same field (from <code class="param">writes</code>). Essentially we want to check 2 separate things:</p><ol type="1">
<li>A state/extract is postdominated by extracts of a same field as is (without loopbacks) Example: A-&gt;B -&gt;C if A, B, C extract the same field x then is_postdominated_by_extract = true if A, B extract the same field x, but C does not then is_postdominated_by_extract = false</li>
<li>There is a loopback in which the same field is always extracted (loop start is postdominate by extracts within that loop). In this case we also have to take into account the fact that the "loop from" state needs to be dominated by the set, otherwise the loop might make sense when we reach this state without extracting the field and then take the loopback once. Example: A-&gt;B-&gt;D-&gt;A (loopback from D to A) -&gt;C-&gt; if B, C extract the same field x then is_postdominated_by_extract = true if A or D extract the field x then is_postdominated_by_extract = true if A, D does not extract x and only one of B, C extract the field x then is_postdominated_by_extract = false</li>
</ol>
<p>This is mainly used to detect the cases where we allow unsafe rewrites on Tofino 1 </p>

</div>
</div>
<a id="a82e0d39f00bdfcac0581c395051fb5a1" name="a82e0d39f00bdfcac0581c395051fb5a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82e0d39f00bdfcac0581c395051fb5a1">&#9670;&#160;</a></span>validate_checksum_residual_deposits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void InferWriteMode::validate_checksum_residual_deposits </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *</td>          <td class="paramname"><span class="paramname"><em>field</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const IR::BFN::ParserPrimitive * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>writes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check for all pairs of checksum residual deposits that can conflict with each other. This can be a problem as these instructions have affect at the end of the parser, after they were called in some previous state. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="struct_infer_write_mode.html">InferWriteMode</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
