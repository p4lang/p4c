<!-- HTML header for doxygen 1.12.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>P4 Compiler Documentation (P4C): Parde::Lowered Namespace Reference</title>
<link rel="icon" href="p4-fav.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!--  Add link to paragraphs   -->
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
  DoxygenAwesomeParagraphLink.init()
</script>
<!-- Add copy button to code fragments  -->
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
  DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add dark mode toggle -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
  DoxygenAwesomeDarkModeToggle.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="cards.css" rel="stylesheet" type="text/css"/>
<link href="flow.css" rel="stylesheet" type="text/css"/>
<link href="p4c_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="p4-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">P4C
   </div>
   <div id="projectbrief">The P4 Compiler</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespace_parde_1_1_lowered.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Parde::Lowered Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_parde_1_1_lowered_1_1_clear_lowered_parser_match.html">ClearLoweredParserMatch</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_parde_1_1_lowered_1_1_compute_buffer_requirements" id="r_class_parde_1_1_lowered_1_1_compute_buffer_requirements"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___lower_parser.html#class_parde_1_1_lowered_1_1_compute_buffer_requirements">ComputeBufferRequirements</a></td></tr>
<tr class="memdesc:class_parde_1_1_lowered_1_1_compute_buffer_requirements"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the number of bytes which must be available for each parser match to avoid a stall.  <a href="group___lower_parser.html#class_parde_1_1_lowered_1_1_compute_buffer_requirements">More...</a><br /></td></tr>
<tr class="separator:class_parde_1_1_lowered_1_1_compute_buffer_requirements"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_parde_1_1_lowered_1_1_compute_init_zero_containers" id="r_class_parde_1_1_lowered_1_1_compute_init_zero_containers"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___lower_parser.html#class_parde_1_1_lowered_1_1_compute_init_zero_containers">ComputeInitZeroContainers</a></td></tr>
<tr class="memdesc:class_parde_1_1_lowered_1_1_compute_init_zero_containers"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes containers that have fields relying on parser zero initialization.  <a href="group___lower_parser.html#class_parde_1_1_lowered_1_1_compute_init_zero_containers">More...</a><br /></td></tr>
<tr class="separator:class_parde_1_1_lowered_1_1_compute_init_zero_containers"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_parde_1_1_lowered_1_1_compute_lowered_deparser_i_r" id="r_struct_parde_1_1_lowered_1_1_compute_lowered_deparser_i_r"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___lower_deparser_i_r.html#struct_parde_1_1_lowered_1_1_compute_lowered_deparser_i_r">ComputeLoweredDeparserIR</a></td></tr>
<tr class="memdesc:struct_parde_1_1_lowered_1_1_compute_lowered_deparser_i_r"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates lowered deparser IR with container references.  <a href="group___lower_deparser_i_r.html#struct_parde_1_1_lowered_1_1_compute_lowered_deparser_i_r">More...</a><br /></td></tr>
<tr class="separator:struct_parde_1_1_lowered_1_1_compute_lowered_deparser_i_r"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_parde_1_1_lowered_1_1_compute_lowered_parser_i_r" id="r_struct_parde_1_1_lowered_1_1_compute_lowered_parser_i_r"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___lower_parser_i_r.html#struct_parde_1_1_lowered_1_1_compute_lowered_parser_i_r">ComputeLoweredParserIR</a></td></tr>
<tr class="memdesc:struct_parde_1_1_lowered_1_1_compute_lowered_parser_i_r"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines the high-level parser IR and the results of PHV allocation to produce a low-level, target-specific representation of the parser program.  <a href="group___lower_parser_i_r.html#struct_parde_1_1_lowered_1_1_compute_lowered_parser_i_r">More...</a><br /></td></tr>
<tr class="separator:struct_parde_1_1_lowered_1_1_compute_lowered_parser_i_r"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_parde_1_1_lowered_1_1_compute_multi_write_containers" id="r_class_parde_1_1_lowered_1_1_compute_multi_write_containers"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___lower_parser.html#class_parde_1_1_lowered_1_1_compute_multi_write_containers">ComputeMultiWriteContainers</a></td></tr>
<tr class="memdesc:class_parde_1_1_lowered_1_1_compute_multi_write_containers"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects all containers that are written more than once by the parser.  <a href="group___lower_parser.html#class_parde_1_1_lowered_1_1_compute_multi_write_containers">More...</a><br /></td></tr>
<tr class="separator:class_parde_1_1_lowered_1_1_compute_multi_write_containers"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_parde_1_1_lowered_1_1_eliminate_empty_states" id="r_struct_parde_1_1_lowered_1_1_eliminate_empty_states"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___lower_parser_i_r.html#struct_parde_1_1_lowered_1_1_eliminate_empty_states">EliminateEmptyStates</a></td></tr>
<tr class="memdesc:struct_parde_1_1_lowered_1_1_eliminate_empty_states"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminates empty states.  <a href="group___lower_parser_i_r.html#struct_parde_1_1_lowered_1_1_eliminate_empty_states">More...</a><br /></td></tr>
<tr class="separator:struct_parde_1_1_lowered_1_1_eliminate_empty_states"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_parde_1_1_lowered_1_1_extract_simplifier" id="r_struct_parde_1_1_lowered_1_1_extract_simplifier"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___lower_parser_i_r.html#struct_parde_1_1_lowered_1_1_extract_simplifier">ExtractSimplifier</a></td></tr>
<tr class="memdesc:struct_parde_1_1_lowered_1_1_extract_simplifier"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class that splits extract operations into multiple smaller extracts, such that each extract writes to exactly one PHV container.  <a href="group___lower_parser_i_r.html#struct_parde_1_1_lowered_1_1_extract_simplifier">More...</a><br /></td></tr>
<tr class="separator:struct_parde_1_1_lowered_1_1_extract_simplifier"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_parde_1_1_lowered_1_1_find_negative_deposits" id="r_struct_parde_1_1_lowered_1_1_find_negative_deposits"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___lower_parser_i_r.html#struct_parde_1_1_lowered_1_1_find_negative_deposits">FindNegativeDeposits</a></td></tr>
<tr class="memdesc:struct_parde_1_1_lowered_1_1_find_negative_deposits"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all of the states that do a checksum deposit but also do not extract/shift before doing it (= the end_pos is negative) and also all of the states from which we can get via 0 shift to a state that does this negative checksum deposit.  <a href="group___lower_parser_i_r.html#struct_parde_1_1_lowered_1_1_find_negative_deposits">More...</a><br /></td></tr>
<tr class="separator:struct_parde_1_1_lowered_1_1_find_negative_deposits"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_parde_1_1_lowered_1_1_hoist_common_match_operations" id="r_class_parde_1_1_lowered_1_1_hoist_common_match_operations"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___lower_parser_i_r.html#class_parde_1_1_lowered_1_1_hoist_common_match_operations">HoistCommonMatchOperations</a></td></tr>
<tr class="memdesc:class_parde_1_1_lowered_1_1_hoist_common_match_operations"><td class="mdescLeft">&#160;</td><td class="mdescRight">After parser lowering, we have converted the parser IR from P4 semantic (action-&gt;match) to hardware semantic (match-&gt;action), there may still be opportunities where we can merge matches where we could not before lowering (without breaking the P4 semantic).  <a href="group___lower_parser_i_r.html#class_parde_1_1_lowered_1_1_hoist_common_match_operations">More...</a><br /></td></tr>
<tr class="separator:class_parde_1_1_lowered_1_1_hoist_common_match_operations"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_parde_1_1_lowered_1_1_lower_deparser_i_r.html">LowerDeparserIR</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_parde_1_1_lowered_1_1_lower_parser_i_r.html">LowerParserIR</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_parde_1_1_lowered_1_1_merge_lowered_parser_states" id="r_struct_parde_1_1_lowered_1_1_merge_lowered_parser_states"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___lower_parser_i_r.html#struct_parde_1_1_lowered_1_1_merge_lowered_parser_states">MergeLoweredParserStates</a></td></tr>
<tr class="memdesc:struct_parde_1_1_lowered_1_1_merge_lowered_parser_states"><td class="mdescLeft">&#160;</td><td class="mdescRight">After parser lowering, we have converted the parser IR from P4 semantic (action-&gt;match) to HW semantic (match-&gt;action), there may still be opportunities where we can merge states where we couldn't before lowering (without breaking the P4 semantic).  <a href="group___lower_parser_i_r.html#struct_parde_1_1_lowered_1_1_merge_lowered_parser_states">More...</a><br /></td></tr>
<tr class="separator:struct_parde_1_1_lowered_1_1_merge_lowered_parser_states"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_parde_1_1_lowered_1_1_remove_negative_deposits" id="r_struct_parde_1_1_lowered_1_1_remove_negative_deposits"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___lower_parser_i_r.html#struct_parde_1_1_lowered_1_1_remove_negative_deposits">RemoveNegativeDeposits</a></td></tr>
<tr class="memdesc:struct_parde_1_1_lowered_1_1_remove_negative_deposits"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the IR so that every checksum deposit can also shift by at least one.  <a href="group___lower_parser_i_r.html#struct_parde_1_1_lowered_1_1_remove_negative_deposits">More...</a><br /></td></tr>
<tr class="separator:struct_parde_1_1_lowered_1_1_remove_negative_deposits"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_parde_1_1_lowered_1_1_replace_deparser_i_r" id="r_struct_parde_1_1_lowered_1_1_replace_deparser_i_r"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___lower_deparser_i_r.html#struct_parde_1_1_lowered_1_1_replace_deparser_i_r">ReplaceDeparserIR</a></td></tr>
<tr class="memdesc:struct_parde_1_1_lowered_1_1_replace_deparser_i_r"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace deparser IR with lowered version.  <a href="group___lower_deparser_i_r.html#struct_parde_1_1_lowered_1_1_replace_deparser_i_r">More...</a><br /></td></tr>
<tr class="separator:struct_parde_1_1_lowered_1_1_replace_deparser_i_r"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_parde_1_1_lowered_1_1_replace_parser_i_r" id="r_struct_parde_1_1_lowered_1_1_replace_parser_i_r"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___lower_parser_i_r.html#struct_parde_1_1_lowered_1_1_replace_parser_i_r">ReplaceParserIR</a></td></tr>
<tr class="memdesc:struct_parde_1_1_lowered_1_1_replace_parser_i_r"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pass that replaces an IR::BRN::Parser node with an IR::BFN::LoweredParser node.  <a href="group___lower_parser_i_r.html#struct_parde_1_1_lowered_1_1_replace_parser_i_r">More...</a><br /></td></tr>
<tr class="separator:struct_parde_1_1_lowered_1_1_replace_parser_i_r"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_parde_1_1_lowered_1_1_resolve_parser_constants" id="r_class_parde_1_1_lowered_1_1_resolve_parser_constants"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___lower_parser_i_r.html#class_parde_1_1_lowered_1_1_resolve_parser_constants">ResolveParserConstants</a></td></tr>
<tr class="memdesc:class_parde_1_1_lowered_1_1_resolve_parser_constants"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolves constants in parser.  <a href="group___lower_parser_i_r.html#class_parde_1_1_lowered_1_1_resolve_parser_constants">More...</a><br /></td></tr>
<tr class="separator:class_parde_1_1_lowered_1_1_resolve_parser_constants"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_parde_1_1_lowered_1_1_rewrite_emit_clot" id="r_struct_parde_1_1_lowered_1_1_rewrite_emit_clot"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___lower_deparser_i_r.html#struct_parde_1_1_lowered_1_1_rewrite_emit_clot">RewriteEmitClot</a></td></tr>
<tr class="memdesc:struct_parde_1_1_lowered_1_1_rewrite_emit_clot"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace Emits covered in a CLOT with EmitClot.  <a href="group___lower_deparser_i_r.html#struct_parde_1_1_lowered_1_1_rewrite_emit_clot">More...</a><br /></td></tr>
<tr class="separator:struct_parde_1_1_lowered_1_1_rewrite_emit_clot"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_parde_1_1_lowered_1_1_right_shift_csum_mask.html">RightShiftCsumMask</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_parde_1_1_lowered_1_1_right_shift_packet_r_val.html">RightShiftPacketRVal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_parde_1_1_lowered_1_1_split_greedy_parser_states" id="r_struct_parde_1_1_lowered_1_1_split_greedy_parser_states"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___lower_parser_i_r.html#struct_parde_1_1_lowered_1_1_split_greedy_parser_states">SplitGreedyParserStates</a></td></tr>
<tr class="memdesc:struct_parde_1_1_lowered_1_1_split_greedy_parser_states"><td class="mdescLeft">&#160;</td><td class="mdescRight">This pass is used to ensure that there will be no conflicting partial_hdr_err_proc at the time the LoweredParserMatch is created.  <a href="group___lower_parser_i_r.html#struct_parde_1_1_lowered_1_1_split_greedy_parser_states">More...</a><br /></td></tr>
<tr class="separator:struct_parde_1_1_lowered_1_1_split_greedy_parser_states"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_parde_1_1_lowered_1_1_warn_ternary_match_fields" id="r_class_parde_1_1_lowered_1_1_warn_ternary_match_fields"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___lower_parser.html#class_parde_1_1_lowered_1_1_warn_ternary_match_fields">WarnTernaryMatchFields</a></td></tr>
<tr class="memdesc:class_parde_1_1_lowered_1_1_warn_ternary_match_fields"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues warning for invalid container participating in ternary match.  <a href="group___lower_parser.html#class_parde_1_1_lowered_1_1_warn_ternary_match_fields">More...</a><br /></td></tr>
<tr class="separator:class_parde_1_1_lowered_1_1_warn_ternary_match_fields"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a942487bad638187d4868dc0608ee9873" id="r_a942487bad638187d4868dc0608ee9873"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_p4_1_1safe__vector.html">safe_vector</a>&lt; IR::BFN::DigestField &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a942487bad638187d4868dc0608ee9873">computeControlPlaneFormat</a> (const <a class="el" href="class_phv_info.html">PhvInfo</a> &amp;phv, const <a class="el" href="class_p4_1_1_i_r_1_1_vector.html">IR::Vector</a>&lt; IR::BFN::FieldLVal &gt; &amp;fields)</td></tr>
<tr class="separator:a942487bad638187d4868dc0608ee9873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2520765cb7308f732451e0889cfc060d" id="r_a2520765cb7308f732451e0889cfc060d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p4_1_1cstring.html">cstring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2520765cb7308f732451e0889cfc060d">debugInfoFor</a> (const <a class="el" href="class_p4_1_1cstring.html">cstring</a> fieldName, const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;slice, bool includeContainerInfo)</td></tr>
<tr class="separator:a2520765cb7308f732451e0889cfc060d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c98080e4d5bac7a4cc24c1dc9647a86" id="r_a8c98080e4d5bac7a4cc24c1dc9647a86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p4_1_1cstring.html">cstring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c98080e4d5bac7a4cc24c1dc9647a86">debugInfoFor</a> (const IR::BFN::Extract *extract, const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;slice, const <a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> &amp;pov_range, const <a class="el" href="class_p4_1_1cstring.html">cstring</a> pov_type_string)</td></tr>
<tr class="separator:a8c98080e4d5bac7a4cc24c1dc9647a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01d97125d9914eb5137afd76522911c" id="r_ab01d97125d9914eb5137afd76522911c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p4_1_1cstring.html">cstring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab01d97125d9914eb5137afd76522911c">debugInfoFor</a> (const IR::BFN::Extract *extract, const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;slice, const <a class="el" href="namespace_p4.html#a19f5abed1a21ad7a5703944aa5099da7">nw_bitrange</a> &amp;bufferRange, bool includeRangeInfo)</td></tr>
<tr class="separator:ab01d97125d9914eb5137afd76522911c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc76f7ac3fcb67bd18f6b39f1b475bcf" id="r_adc76f7ac3fcb67bd18f6b39f1b475bcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p4_1_1cstring.html">cstring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc76f7ac3fcb67bd18f6b39f1b475bcf">debugInfoFor</a> (const IR::BFN::ParserLVal *lval, const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;slice, bool includeContainerInfo)</td></tr>
<tr class="separator:adc76f7ac3fcb67bd18f6b39f1b475bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e1550d93697987bc7dd3ae94a0b850" id="r_a82e1550d93697987bc7dd3ae94a0b850"><td class="memItemLeft" align="right" valign="top"><a id="a82e1550d93697987bc7dd3ae94a0b850" name="a82e1550d93697987bc7dd3ae94a0b850"></a>
std::map&lt; <a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a>, unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getChecksumPhvSwap</b> (const <a class="el" href="class_phv_info.html">PhvInfo</a> &amp;phv, const IR::BFN::EmitChecksum *emitChecksum)</td></tr>
<tr class="separator:a82e1550d93697987bc7dd3ae94a0b850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1de6dc38ee3657d050a73b94539575" id="r_a3e1de6dc38ee3657d050a73b94539575"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="class_p4_1_1_i_r_1_1_vector.html">IR::Vector</a>&lt; IR::BFN::ContainerRef &gt;, std::vector&lt; <a class="el" href="class_clot.html">Clot</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e1de6dc38ee3657d050a73b94539575">lowerFields</a> (const <a class="el" href="class_phv_info.html">PhvInfo</a> &amp;phv, const <a class="el" href="class_clot_info.html">ClotInfo</a> &amp;clotInfo, const <a class="el" href="class_p4_1_1_i_r_1_1_vector.html">IR::Vector</a>&lt; IR::BFN::FieldLVal &gt; &amp;fields, bool is_checksum)</td></tr>
<tr class="separator:a3e1de6dc38ee3657d050a73b94539575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e2d9e1282d8cdf3592a2a6b49f0029" id="r_a82e2d9e1282d8cdf3592a2a6b49f0029"><td class="memItemLeft" align="right" valign="top">const IR::BFN::ContainerBitRef *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82e2d9e1282d8cdf3592a2a6b49f0029">lowerSingleBit</a> (const <a class="el" href="class_phv_info.html">PhvInfo</a> &amp;phv, const IR::BFN::FieldLVal *fieldRef, const <a class="el" href="class_p_h_v_1_1_alloc_context.html">PHV::AllocContext</a> *ctxt)</td></tr>
<tr class="separator:a82e2d9e1282d8cdf3592a2a6b49f0029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d20dbd355611cd1437c19a908fd8fcc" id="r_a5d20dbd355611cd1437c19a908fd8fcc"><td class="memItemLeft" align="right" valign="top">const IR::BFN::ContainerRef *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d20dbd355611cd1437c19a908fd8fcc">lowerUnsplittableField</a> (const <a class="el" href="class_phv_info.html">PhvInfo</a> &amp;phv, const <a class="el" href="class_clot_info.html">ClotInfo</a> &amp;clotInfo, const IR::BFN::FieldLVal *fieldRef, const char *unsplittableReason)</td></tr>
<tr class="separator:a5d20dbd355611cd1437c19a908fd8fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0693fb2acbd0c87eccb6adcf7344a0" id="r_a2c0693fb2acbd0c87eccb6adcf7344a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p4_1_1cstring.html">cstring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c0693fb2acbd0c87eccb6adcf7344a0">sanitizeName</a> (<a class="el" href="struct_p4_1_1_string_ref.html">StringRef</a> name)</td></tr>
<tr class="separator:a2c0693fb2acbd0c87eccb6adcf7344a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Copyright (C) 2024 Intel Corporation</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p>
<p><a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p>SPDX-License-Identifier: Apache-2.0 </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a942487bad638187d4868dc0608ee9873" name="a942487bad638187d4868dc0608ee9873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a942487bad638187d4868dc0608ee9873">&#9670;&#160;</a></span>computeControlPlaneFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_p4_1_1safe__vector.html">safe_vector</a>&lt; IR::BFN::DigestField &gt; * Parde::Lowered::computeControlPlaneFormat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_phv_info.html">PhvInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>phv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1_i_r_1_1_vector.html">IR::Vector</a>&lt; IR::BFN::FieldLVal &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fields</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a sequence of fields, construct a packing format describing how the fields will be laid out once they're lowered to containers. </p>
<p>The container into which the last field was placed.</p>
<p>The number of unused bits which remain on the LSB side of the container after the last field was placed.</p>

</div>
</div>
<a id="a2520765cb7308f732451e0889cfc060d" name="a2520765cb7308f732451e0889cfc060d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2520765cb7308f732451e0889cfc060d">&#9670;&#160;</a></span>debugInfoFor() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p4_1_1cstring.html">cstring</a> Parde::Lowered::debugInfoFor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1cstring.html">cstring</a></td>          <td class="paramname"><span class="paramname"><em>fieldName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slice</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>includeContainerInfo</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct debugging information describing a slice of a field.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>Field name. </td></tr>
    <tr><td class="paramname">slice</td><td>An <code>alloc_slice</code> mapping a range of bits in the field to a range of bits in a container. </td></tr>
    <tr><td class="paramname">includeContainerInfo</td><td>If true, the result will include information about which bits in the container the field slice was mapped to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string describing which bits in the field are included in the slice, and describing the corresponding bits in the container. </dd></dl>

</div>
</div>
<a id="a8c98080e4d5bac7a4cc24c1dc9647a86" name="a8c98080e4d5bac7a4cc24c1dc9647a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c98080e4d5bac7a4cc24c1dc9647a86">&#9670;&#160;</a></span>debugInfoFor() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p4_1_1cstring.html">cstring</a> Parde::Lowered::debugInfoFor </td>
          <td>(</td>
          <td class="paramtype">const IR::BFN::Extract *</td>          <td class="paramname"><span class="paramname"><em>extract</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slice</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pov_range</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1cstring.html">cstring</a></td>          <td class="paramname"><span class="paramname"><em>pov_type_string</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a string describing how an <code>Extract</code> primitive was mapped to a hardware extract operation (in case of extract from POV (state/flags) bits).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extract</td><td>The original <code>Extract</code> primitive, with a field as the destination. </td></tr>
    <tr><td class="paramname">slice</td><td>An <code>alloc_slice</code> mapping a range of bits in the field to a range of bits in a container. </td></tr>
    <tr><td class="paramname">pov_range</td><td>The range corresponding to the bits from POV state/flags bits. </td></tr>
    <tr><td class="paramname">pov_type_string</td><td>Optional string with info about type of POV (state/flags). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string containing debugging info describing the mapping between the field, the container, and POV state/flags bits read by the <code>Extract</code>. </dd></dl>
<p>Describe the value that's being written into the destination container.</p>
<p>Describe the field slice that we're writing to.</p>

</div>
</div>
<a id="ab01d97125d9914eb5137afd76522911c" name="ab01d97125d9914eb5137afd76522911c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab01d97125d9914eb5137afd76522911c">&#9670;&#160;</a></span>debugInfoFor() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p4_1_1cstring.html">cstring</a> Parde::Lowered::debugInfoFor </td>
          <td>(</td>
          <td class="paramtype">const IR::BFN::Extract *</td>          <td class="paramname"><span class="paramname"><em>extract</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slice</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_p4.html#a19f5abed1a21ad7a5703944aa5099da7">nw_bitrange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bufferRange</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>includeRangeInfo</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a string describing how an <code>Extract</code> primitive was mapped to a hardware extract operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extract</td><td>The original <code>Extract</code> primitive, with a field as the destination. </td></tr>
    <tr><td class="paramname">slice</td><td>An <code>alloc_slice</code> mapping a range of bits in the field to a range of bits in a container. </td></tr>
    <tr><td class="paramname">bufferRange</td><td>For extracts that read from the input buffer, an input buffer range corresponding to the range of bits in the <code>alloc_slice</code>. </td></tr>
    <tr><td class="paramname">includeRangeInfo</td><td>If true, the range of bits being extracted into the destination container is printed even if it matches the size of the container exactly. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string containing debugging info describing the mapping between the field, the container, and the constant or input buffer region read by the <code>Extract</code>. </dd></dl>

</div>
</div>
<a id="adc76f7ac3fcb67bd18f6b39f1b475bcf" name="adc76f7ac3fcb67bd18f6b39f1b475bcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc76f7ac3fcb67bd18f6b39f1b475bcf">&#9670;&#160;</a></span>debugInfoFor() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p4_1_1cstring.html">cstring</a> Parde::Lowered::debugInfoFor </td>
          <td>(</td>
          <td class="paramtype">const IR::BFN::ParserLVal *</td>          <td class="paramname"><span class="paramname"><em>lval</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slice</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>includeContainerInfo</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct debugging information describing a slice of a field.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lval</td><td>A reference to a field. </td></tr>
    <tr><td class="paramname">slice</td><td>An <code>alloc_slice</code> mapping a range of bits in the field to a range of bits in a container. </td></tr>
    <tr><td class="paramname">includeContainerInfo</td><td>If true, the result will include information about which bits in the container the field slice was mapped to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string describing which bits in the field are included in the slice, and describing the corresponding bits in the container. </dd></dl>

</div>
</div>
<a id="a3e1de6dc38ee3657d050a73b94539575" name="a3e1de6dc38ee3657d050a73b94539575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e1de6dc38ee3657d050a73b94539575">&#9670;&#160;</a></span>lowerFields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="class_p4_1_1_i_r_1_1_vector.html">IR::Vector</a>&lt; IR::BFN::ContainerRef &gt;, std::vector&lt; <a class="el" href="class_clot.html">Clot</a> * &gt; &gt; Parde::Lowered::lowerFields </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_phv_info.html">PhvInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>phv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_clot_info.html">ClotInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>clotInfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1_i_r_1_1_vector.html">IR::Vector</a>&lt; IR::BFN::FieldLVal &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fields</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_checksum</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maps a sequence of fields to a sequence of PHV containers. The sequence of fields is treated as ordered and non-overlapping; the resulting container sequence is the shortest one which maintains these properties. </p>

</div>
</div>
<a id="a82e2d9e1282d8cdf3592a2a6b49f0029" name="a82e2d9e1282d8cdf3592a2a6b49f0029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82e2d9e1282d8cdf3592a2a6b49f0029">&#9670;&#160;</a></span>lowerSingleBit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const IR::BFN::ContainerBitRef * Parde::Lowered::lowerSingleBit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_phv_info.html">PhvInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>phv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IR::BFN::FieldLVal *</td>          <td class="paramname"><span class="paramname"><em>fieldRef</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_alloc_context.html">PHV::AllocContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctxt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maps a POV bit field to a single bit within a container, represented as a ContainerBitRef. Checks that the allocation for the POV bit field is sane. </p>

</div>
</div>
<a id="a5d20dbd355611cd1437c19a908fd8fcc" name="a5d20dbd355611cd1437c19a908fd8fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d20dbd355611cd1437c19a908fd8fcc">&#9670;&#160;</a></span>lowerUnsplittableField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const IR::BFN::ContainerRef * Parde::Lowered::lowerUnsplittableField </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_phv_info.html">PhvInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>phv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_clot_info.html">ClotInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>clotInfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IR::BFN::FieldLVal *</td>          <td class="paramname"><span class="paramname"><em>fieldRef</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>unsplittableReason</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maps a field which cannot be split between multiple containers to a single container, represented as a ContainerRef. Checks that the allocation for the field is sane. </p>

</div>
</div>
<a id="a2c0693fb2acbd0c87eccb6adcf7344a0" name="a2c0693fb2acbd0c87eccb6adcf7344a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c0693fb2acbd0c87eccb6adcf7344a0">&#9670;&#160;</a></span>sanitizeName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p4_1_1cstring.html">cstring</a> Parde::Lowered::sanitizeName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p4_1_1_string_ref.html">StringRef</a></td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a version of the provided state name which is safe to use in the generated assembly. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.12.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>Parde</b></li><li class="navelem"><a class="el" href="namespace_parde_1_1_lowered.html">Lowered</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
