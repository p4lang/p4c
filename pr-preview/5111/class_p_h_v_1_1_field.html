<!-- HTML header for doxygen 1.13.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>P4 Compiler Documentation (P4C): PHV::Field Class Reference</title>
<link rel="icon" href="p4-fav.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!--  Add link to paragraphs   -->
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
  DoxygenAwesomeParagraphLink.init()
</script>
<!-- Add copy button to code fragments  -->
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
  DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add dark mode toggle -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
  DoxygenAwesomeDarkModeToggle.init()
</script>
<!-- Add interactive TOC -->
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
  DoxygenAwesomeInteractiveToc.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-interactive-toc.js" rel="stylesheet" type="text/css"/>
<link href="cards.css" rel="stylesheet" type="text/css"/>
<link href="flow.css" rel="stylesheet" type="text/css"/>
<link href="p4c_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="p4-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">P4C
   </div>
   <div id="projectbrief">The P4 Compiler</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_p_h_v_1_1_field.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_p_h_v_1_1_field-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">PHV::Field Class Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for PHV::Field:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_p_h_v_1_1_field__inherit__graph.svg" width="143" height="110"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_h_v_1_1_field_1_1mirror__field__list__t.html">mirror_field_list_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mirror field points to its field list (one of eight)  <a href="struct_p_h_v_1_1_field_1_1mirror__field__list__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0b6077d2acc27b1a05d475689c0c4b0f" id="r_a0b6077d2acc27b1a05d475689c0c4b0f"><td class="memItemLeft" align="right" valign="top"><a id="a0b6077d2acc27b1a05d475689c0c4b0f" name="a0b6077d2acc27b1a05d475689c0c4b0f"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>alloc_code_t</b> { <br />
&#160;&#160;<b>EMPTY</b> = 0
, <b>REFERENCED</b> = 1 &lt;&lt; 0
, <b>HAS_PHV_ALLOCATION</b> = 1 &lt;&lt; 1
, <b>FULLY_PHV_ALLOCATED</b> = 1 &lt;&lt; 2
, <br />
&#160;&#160;<b>HAS_CLOT_ALLOCATION</b> = 1 &lt;&lt; 3
<br />
 }</td></tr>
<tr class="separator:a0b6077d2acc27b1a05d475689c0c4b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c85cca7846064bea98be74b3e8216c" id="r_a13c85cca7846064bea98be74b3e8216c"><td class="memItemLeft" align="right" valign="top"><a id="a13c85cca7846064bea98be74b3e8216c" name="a13c85cca7846064bea98be74b3e8216c"></a>
typedef unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>AllocState</b></td></tr>
<tr class="separator:a13c85cca7846064bea98be74b3e8216c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a99c815eb77c6bb38584ba2582c58fa60" id="r_a99c815eb77c6bb38584ba2582c58fa60"><td class="memItemLeft" align="right" valign="top"><a id="a99c815eb77c6bb38584ba2582c58fa60" name="a99c815eb77c6bb38584ba2582c58fa60"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>add_alloc</b> (const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;alloc)</td></tr>
<tr class="memdesc:a99c815eb77c6bb38584ba2582c58fa60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a slice of this field. <br /></td></tr>
<tr class="separator:a99c815eb77c6bb38584ba2582c58fa60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ef687175ecc392a4c2bc1fc17c9234" id="r_a79ef687175ecc392a4c2bc1fc17c9234"><td class="memItemLeft" align="right" valign="top"><a id="a79ef687175ecc392a4c2bc1fc17c9234" name="a79ef687175ecc392a4c2bc1fc17c9234"></a>
<a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>add_and_return_alloc</b> (const <a class="el" href="class_p_h_v_1_1_field.html">Field</a> *f, <a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a> c, int fb, int cb, int w, const <a class="el" href="class_p4_1_1ordered__set.html">ActionSet</a> &amp;a)</td></tr>
<tr class="separator:a79ef687175ecc392a4c2bc1fc17c9234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a549b8bb2a3681c1dcb28ad2658727005" id="r_a549b8bb2a3681c1dcb28ad2658727005"><td class="memItemLeft" align="right" valign="top"><a id="a549b8bb2a3681c1dcb28ad2658727005" name="a549b8bb2a3681c1dcb28ad2658727005"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>add_wide_arith_start_bit</b> (int start_bit)</td></tr>
<tr class="separator:a549b8bb2a3681c1dcb28ad2658727005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a080e2f543188692029705871c9d70803" id="r_a080e2f543188692029705871c9d70803"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a080e2f543188692029705871c9d70803">alloc_size</a> () const</td></tr>
<tr class="separator:a080e2f543188692029705871c9d70803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280692ca16acbdbaa36b6a0e1b447c98" id="r_a280692ca16acbdbaa36b6a0e1b447c98"><td class="memItemLeft" align="right" valign="top"><a id="a280692ca16acbdbaa36b6a0e1b447c98" name="a280692ca16acbdbaa36b6a0e1b447c98"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>bit_is_wide_arith_lo</b> (int slice_bit) const</td></tr>
<tr class="separator:a280692ca16acbdbaa36b6a0e1b447c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8893c30da16f0da54acb68ff7fc036b" id="r_aa8893c30da16f0da54acb68ff7fc036b"><td class="memItemLeft" align="right" valign="top"><a id="aa8893c30da16f0da54acb68ff7fc036b" name="aa8893c30da16f0da54acb68ff7fc036b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>bit_used_in_wide_arith</b> (int slice_bit) const</td></tr>
<tr class="separator:aa8893c30da16f0da54acb68ff7fc036b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619905bddda92e02d9bb54565b1a3a87" id="r_a619905bddda92e02d9bb54565b1a3a87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a619905bddda92e02d9bb54565b1a3a87">byteAlignedRangeInBits</a> () const</td></tr>
<tr class="separator:a619905bddda92e02d9bb54565b1a3a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2de2df68b196307135eab89cb7b2ce" id="r_add2de2df68b196307135eab89cb7b2ce"><td class="memItemLeft" align="right" valign="top"><a id="add2de2df68b196307135eab89cb7b2ce" name="add2de2df68b196307135eab89cb7b2ce"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear_alloc</b> ()</td></tr>
<tr class="memdesc:add2de2df68b196307135eab89cb7b2ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear any PHV allocation for this field. <br /></td></tr>
<tr class="separator:add2de2df68b196307135eab89cb7b2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4eb6d2cc03fc0d22b4dd52d6e1388a" id="r_afc4eb6d2cc03fc0d22b4dd52d6e1388a"><td class="memItemLeft" align="right" valign="top"><a id="afc4eb6d2cc03fc0d22b4dd52d6e1388a" name="afc4eb6d2cc03fc0d22b4dd52d6e1388a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearExternalName</b> ()</td></tr>
<tr class="memdesc:afc4eb6d2cc03fc0d22b4dd52d6e1388a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the external name, if any has been set. <br /></td></tr>
<tr class="separator:afc4eb6d2cc03fc0d22b4dd52d6e1388a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80de3f3191e532be5fadb526f5eb744" id="r_ab80de3f3191e532be5fadb526f5eb744"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab80de3f3191e532be5fadb526f5eb744">container_bytes</a> (std::optional&lt; <a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> &gt; bits=std::nullopt) const</td></tr>
<tr class="separator:ab80de3f3191e532be5fadb526f5eb744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ad303d4472f88019892e412296aa63" id="r_a57ad303d4472f88019892e412296aa63"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57ad303d4472f88019892e412296aa63">deparsed</a> () const</td></tr>
<tr class="separator:a57ad303d4472f88019892e412296aa63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0a42ecf785b5b204e697bccbd22c86" id="r_a6a0a42ecf785b5b204e697bccbd22c86"><td class="memItemLeft" align="right" valign="top"><a id="a6a0a42ecf785b5b204e697bccbd22c86" name="a6a0a42ecf785b5b204e697bccbd22c86"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>deparsed_bottom_bits</b> () const</td></tr>
<tr class="separator:a6a0a42ecf785b5b204e697bccbd22c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f44193356e555b22b3da10a4cb0999" id="r_a57f44193356e555b22b3da10a4cb0999"><td class="memItemLeft" align="right" valign="top"><a id="a57f44193356e555b22b3da10a4cb0999" name="a57f44193356e555b22b3da10a4cb0999"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>deparsed_to_tm</b> () const</td></tr>
<tr class="separator:a57f44193356e555b22b3da10a4cb0999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68cfb6819cb7031af435e12175c756d3" id="r_a68cfb6819cb7031af435e12175c756d3"><td class="memItemLeft" align="right" valign="top"><a id="a68cfb6819cb7031af435e12175c756d3" name="a68cfb6819cb7031af435e12175c756d3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>deparsed_top_bits</b> () const</td></tr>
<tr class="separator:a68cfb6819cb7031af435e12175c756d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557950c5b1c7c36a5d49a1f29a8d09fe" id="r_a557950c5b1c7c36a5d49a1f29a8d09fe"><td class="memItemLeft" align="right" valign="top"><a id="a557950c5b1c7c36a5d49a1f29a8d09fe" name="a557950c5b1c7c36a5d49a1f29a8d09fe"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>emitted</b> () const</td></tr>
<tr class="separator:a557950c5b1c7c36a5d49a1f29a8d09fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4f964856ec6728f477b1e41e0b1cbc2" id="r_aa4f964856ec6728f477b1e41e0b1cbc2"><td class="memItemLeft" align="right" valign="top"><a id="aa4f964856ec6728f477b1e41e0b1cbc2" name="aa4f964856ec6728f477b1e41e0b1cbc2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>erase_alignment</b> ()</td></tr>
<tr class="separator:aa4f964856ec6728f477b1e41e0b1cbc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03010531b8f29ba2c5ca6348736bdeed" id="r_a03010531b8f29ba2c5ca6348736bdeed"><td class="memItemLeft" align="right" valign="top"><a id="a03010531b8f29ba2c5ca6348736bdeed" name="a03010531b8f29ba2c5ca6348736bdeed"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>eraseAlignment</b> ()</td></tr>
<tr class="memdesc:a03010531b8f29ba2c5ca6348736bdeed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the alignment requirement for this field. <br /></td></tr>
<tr class="separator:a03010531b8f29ba2c5ca6348736bdeed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365e21aceabe91d6b5e83d3df06f52ab" id="r_a365e21aceabe91d6b5e83d3df06f52ab"><td class="memItemLeft" align="right" valign="top"><a id="a365e21aceabe91d6b5e83d3df06f52ab" name="a365e21aceabe91d6b5e83d3df06f52ab"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>exact_containers</b> () const</td></tr>
<tr class="separator:a365e21aceabe91d6b5e83d3df06f52ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645488aa0046cbf0084c9d3497b2ebc3" id="r_a645488aa0046cbf0084c9d3497b2ebc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p4_1_1cstring.html">cstring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a645488aa0046cbf0084c9d3497b2ebc3">externalName</a> () const</td></tr>
<tr class="separator:a645488aa0046cbf0084c9d3497b2ebc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07440949e4fae928574c2d0ed26c52ea" id="r_a07440949e4fae928574c2d0ed26c52ea"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07440949e4fae928574c2d0ed26c52ea">for_bit</a> (int bit) const</td></tr>
<tr class="separator:a07440949e4fae928574c2d0ed26c52ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50c188b2516687521d149ccbfa8f9e7" id="r_ac50c188b2516687521d149ccbfa8f9e7"><td class="memItemLeft" align="right" valign="top"><a id="ac50c188b2516687521d149ccbfa8f9e7" name="ac50c188b2516687521d149ccbfa8f9e7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>foreach_alloc</b> (const IR::MAU::Table *ctxt, const <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> *use, std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;)&gt; fn, SliceMatch useTblRefs=SliceMatch::DFLT) const</td></tr>
<tr class="separator:ac50c188b2516687521d149ccbfa8f9e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4832adfece75380b23fce3a41b0aa889" id="r_a4832adfece75380b23fce3a41b0aa889"><td class="memItemLeft" align="right" valign="top"><a id="a4832adfece75380b23fce3a41b0aa889" name="a4832adfece75380b23fce3a41b0aa889"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>foreach_alloc</b> (const <a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> *r, const IR::MAU::Table *ctxt, const <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> *use, std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;)&gt; fn, SliceMatch useTblRefs=SliceMatch::DFLT) const</td></tr>
<tr class="separator:a4832adfece75380b23fce3a41b0aa889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1d944fe8d84f67d98ba20261b760a0" id="r_a1d1d944fe8d84f67d98ba20261b760a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d1d944fe8d84f67d98ba20261b760a0">foreach_alloc</a> (const <a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> *r, const <a class="el" href="class_p_h_v_1_1_alloc_context.html">PHV::AllocContext</a> *ctxt, const <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> *use, std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;)&gt; fn, SliceMatch useTblRefs=SliceMatch::DFLT) const</td></tr>
<tr class="separator:a1d1d944fe8d84f67d98ba20261b760a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa728164df95cd98f9d943e69a6675a3b" id="r_aa728164df95cd98f9d943e69a6675a3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa728164df95cd98f9d943e69a6675a3b">foreach_alloc</a> (const <a class="el" href="class_p_h_v_1_1_alloc_context.html">PHV::AllocContext</a> *ctxt, const <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> *use, std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;)&gt; fn, SliceMatch useTblRefs=SliceMatch::DFLT) const</td></tr>
<tr class="separator:aa728164df95cd98f9d943e69a6675a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef6c79a3f3a4ab119dc93594e3d0aff" id="r_afef6c79a3f3a4ab119dc93594e3d0aff"><td class="memItemLeft" align="right" valign="top"><a id="afef6c79a3f3a4ab119dc93594e3d0aff" name="afef6c79a3f3a4ab119dc93594e3d0aff"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>foreach_alloc</b> (<a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> r, const IR::MAU::Table *ctxt, const <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> *use, std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;)&gt; fn, SliceMatch useTblRefs=SliceMatch::DFLT) const</td></tr>
<tr class="separator:afef6c79a3f3a4ab119dc93594e3d0aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa850790d78f97f6b7aa3ca8de1d4e44" id="r_afa850790d78f97f6b7aa3ca8de1d4e44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa850790d78f97f6b7aa3ca8de1d4e44">foreach_alloc</a> (<a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> r, const <a class="el" href="class_p_h_v_1_1_alloc_context.html">PHV::AllocContext</a> *ctxt, const <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> *use, std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;)&gt; fn, SliceMatch useTblRefs=SliceMatch::DFLT) const</td></tr>
<tr class="separator:afa850790d78f97f6b7aa3ca8de1d4e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f22f23b07dfca7f88825109997a8de" id="r_a27f22f23b07dfca7f88825109997a8de"><td class="memItemLeft" align="right" valign="top"><a id="a27f22f23b07dfca7f88825109997a8de" name="a27f22f23b07dfca7f88825109997a8de"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>foreach_alloc</b> (<a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> r, std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;)&gt; fn, SliceMatch useTblRefs=SliceMatch::DFLT) const</td></tr>
<tr class="separator:a27f22f23b07dfca7f88825109997a8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7237c602ea66018ac5ac271b85b478ba" id="r_a7237c602ea66018ac5ac271b85b478ba"><td class="memItemLeft" align="right" valign="top"><a id="a7237c602ea66018ac5ac271b85b478ba" name="a7237c602ea66018ac5ac271b85b478ba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>foreach_alloc</b> (std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;)&gt; fn, SliceMatch useTblRefs=SliceMatch::DFLT) const</td></tr>
<tr class="separator:a7237c602ea66018ac5ac271b85b478ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00be6f0735f48e1fca31613ee2b2782a" id="r_a00be6f0735f48e1fca31613ee2b2782a"><td class="memItemLeft" align="right" valign="top"><a id="a00be6f0735f48e1fca31613ee2b2782a" name="a00be6f0735f48e1fca31613ee2b2782a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>foreach_byte</b> (const IR::MAU::Table *ctxt, const <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> *use, std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;)&gt; fn, SliceMatch useTblRefs=SliceMatch::DFLT) const</td></tr>
<tr class="separator:a00be6f0735f48e1fca31613ee2b2782a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d68cfce1d0f13a104ccdcca8f75003" id="r_a10d68cfce1d0f13a104ccdcca8f75003"><td class="memItemLeft" align="right" valign="top"><a id="a10d68cfce1d0f13a104ccdcca8f75003" name="a10d68cfce1d0f13a104ccdcca8f75003"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>foreach_byte</b> (const <a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> *r, const IR::MAU::Table *ctxt, const <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> *use, std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;)&gt; fn, SliceMatch useTblRefs=SliceMatch::DFLT) const</td></tr>
<tr class="separator:a10d68cfce1d0f13a104ccdcca8f75003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef007f89d88ad70e582927c9519c0b4d" id="r_aef007f89d88ad70e582927c9519c0b4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef007f89d88ad70e582927c9519c0b4d">foreach_byte</a> (const <a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> *r, const <a class="el" href="class_p_h_v_1_1_alloc_context.html">PHV::AllocContext</a> *ctxt, const <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> *use, std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;)&gt; fn, SliceMatch useTblRefs=SliceMatch::DFLT) const</td></tr>
<tr class="separator:aef007f89d88ad70e582927c9519c0b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab723e4c848c9833c764f59ebc5912300" id="r_ab723e4c848c9833c764f59ebc5912300"><td class="memItemLeft" align="right" valign="top"><a id="ab723e4c848c9833c764f59ebc5912300" name="ab723e4c848c9833c764f59ebc5912300"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>foreach_byte</b> (const <a class="el" href="class_p_h_v_1_1_alloc_context.html">PHV::AllocContext</a> *ctxt, const <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> *use, std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;)&gt; fn, SliceMatch useTblRefs=SliceMatch::DFLT) const</td></tr>
<tr class="separator:ab723e4c848c9833c764f59ebc5912300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9862cfd6292ee875091528c163044a" id="r_a6e9862cfd6292ee875091528c163044a"><td class="memItemLeft" align="right" valign="top"><a id="a6e9862cfd6292ee875091528c163044a" name="a6e9862cfd6292ee875091528c163044a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>foreach_byte</b> (<a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> r, const IR::MAU::Table *ctxt, const <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> *use, std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;)&gt; fn, SliceMatch useTblRefs=SliceMatch::DFLT) const</td></tr>
<tr class="separator:a6e9862cfd6292ee875091528c163044a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d1afd09e3442906797d5af349508b2" id="r_af4d1afd09e3442906797d5af349508b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4d1afd09e3442906797d5af349508b2">foreach_byte</a> (<a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> r, const <a class="el" href="class_p_h_v_1_1_alloc_context.html">PHV::AllocContext</a> *ctxt, const <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> *use, std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;)&gt; fn, SliceMatch useTblRefs=SliceMatch::DFLT) const</td></tr>
<tr class="separator:af4d1afd09e3442906797d5af349508b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2cde564a21cf02a7110ec7166fc5c4f" id="r_aa2cde564a21cf02a7110ec7166fc5c4f"><td class="memItemLeft" align="right" valign="top"><a id="aa2cde564a21cf02a7110ec7166fc5c4f" name="aa2cde564a21cf02a7110ec7166fc5c4f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>fullyPhvAllocated</b> (AllocState s) const</td></tr>
<tr class="separator:aa2cde564a21cf02a7110ec7166fc5c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100f3923c18d5c3c23e5859d84e09023" id="r_a100f3923c18d5c3c23e5859d84e09023"><td class="memItemLeft" align="right" valign="top"><a id="a100f3923c18d5c3c23e5859d84e09023" name="a100f3923c18d5c3c23e5859d84e09023"></a>
<a class="el" href="class_p4_1_1safe__vector.html">safe_vector</a>&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_alloc</b> ()</td></tr>
<tr class="separator:a100f3923c18d5c3c23e5859d84e09023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05070321f34c626e18accc2b4b18229c" id="r_a05070321f34c626e18accc2b4b18229c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_p4_1_1safe__vector.html">safe_vector</a>&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05070321f34c626e18accc2b4b18229c">get_alloc</a> () const</td></tr>
<tr class="separator:a05070321f34c626e18accc2b4b18229c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5109d5b3aefc31cd3a504f2f0191a273" id="r_a5109d5b3aefc31cd3a504f2f0191a273"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5109d5b3aefc31cd3a504f2f0191a273">get_combined_alloc_bytes</a> (const <a class="el" href="class_p_h_v_1_1_alloc_context.html">PHV::AllocContext</a> *ctxt, const <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> *use, SliceMatch useTblRefs=SliceMatch::DFLT) const</td></tr>
<tr class="separator:a5109d5b3aefc31cd3a504f2f0191a273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab81afbdc01e19643677d9c58a45302a0" id="r_ab81afbdc01e19643677d9c58a45302a0"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab81afbdc01e19643677d9c58a45302a0">get_combined_alloc_slices</a> (<a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> bits, const <a class="el" href="class_p_h_v_1_1_alloc_context.html">PHV::AllocContext</a> *ctxt, const <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> *use) const</td></tr>
<tr class="separator:ab81afbdc01e19643677d9c58a45302a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22fdb432d64a5eeb01046cb948a83fdb" id="r_a22fdb432d64a5eeb01046cb948a83fdb"><td class="memItemLeft" align="right" valign="top"><a id="a22fdb432d64a5eeb01046cb948a83fdb" name="a22fdb432d64a5eeb01046cb948a83fdb"></a>
const <a class="el" href="class_constraints_1_1_alignment_constraint.html">Constraints::AlignmentConstraint</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getAlignmentConstraint</b> () const</td></tr>
<tr class="separator:a22fdb432d64a5eeb01046cb948a83fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae76ca1781374ed9ed2beb4852a0af2c" id="r_aae76ca1781374ed9ed2beb4852a0af2c"><td class="memItemLeft" align="right" valign="top"><a id="aae76ca1781374ed9ed2beb4852a0af2c" name="aae76ca1781374ed9ed2beb4852a0af2c"></a>
const <a class="el" href="class_constraints_1_1_digest_constraint.html">Constraints::DigestConstraint</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getDigestConstraint</b> () const</td></tr>
<tr class="separator:aae76ca1781374ed9ed2beb4852a0af2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35009966d2d1e175873c80c78a6a2f83" id="r_a35009966d2d1e175873c80c78a6a2f83"><td class="memItemLeft" align="right" valign="top"><a id="a35009966d2d1e175873c80c78a6a2f83" name="a35009966d2d1e175873c80c78a6a2f83"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getMaxContainerBytes</b> () const</td></tr>
<tr class="separator:a35009966d2d1e175873c80c78a6a2f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0991cbd6ae8a046412733c506226da9d" id="r_a0991cbd6ae8a046412733c506226da9d"><td class="memItemLeft" align="right" valign="top"><a id="a0991cbd6ae8a046412733c506226da9d" name="a0991cbd6ae8a046412733c506226da9d"></a>
const <a class="el" href="class_constraints_1_1_solitary_constraint.html">Constraints::SolitaryConstraint</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getSolitaryConstraint</b> () const</td></tr>
<tr class="separator:a0991cbd6ae8a046412733c506226da9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4ca9afe978f5cb14e7860b6f87acfc" id="r_a4c4ca9afe978f5cb14e7860b6f87acfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p4_1_1bitvec.html">bitvec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c4ca9afe978f5cb14e7860b6f87acfc">getStartBits</a> (<a class="el" href="namespace_p_h_v.html#a3ff115c4ef9dcfb7a3565ddc263f0ece">PHV::Size</a> <a class="el" href="#a10a198e7adff85104913040f88af6081">size</a>) const</td></tr>
<tr class="separator:a4c4ca9afe978f5cb14e7860b6f87acfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e9e56274e757145ddc213465a68b3c" id="r_ad2e9e56274e757145ddc213465a68b3c"><td class="memItemLeft" align="right" valign="top"><a id="ad2e9e56274e757145ddc213465a68b3c" name="ad2e9e56274e757145ddc213465a68b3c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_no_split_at_pos</b> () const</td></tr>
<tr class="separator:ad2e9e56274e757145ddc213465a68b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa5fe7bba632323082f79140b7fd0c1" id="r_abaa5fe7bba632323082f79140b7fd0c1"><td class="memItemLeft" align="right" valign="top"><a id="abaa5fe7bba632323082f79140b7fd0c1" name="abaa5fe7bba632323082f79140b7fd0c1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasAllocation</b> (AllocState s) const</td></tr>
<tr class="memdesc:abaa5fe7bba632323082f79140b7fd0c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether <code class="param">s</code> has a PHV allocation or a CLOT allocation. <br /></td></tr>
<tr class="separator:abaa5fe7bba632323082f79140b7fd0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2293bc71c5537205e674a380c1929ea1" id="r_a2293bc71c5537205e674a380c1929ea1"><td class="memItemLeft" align="right" valign="top"><a id="a2293bc71c5537205e674a380c1929ea1" name="a2293bc71c5537205e674a380c1929ea1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasClotAllocation</b> (AllocState s) const</td></tr>
<tr class="separator:a2293bc71c5537205e674a380c1929ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad456ed5385ab9c7b5e0489da225d5e4b" id="r_ad456ed5385ab9c7b5e0489da225d5e4b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad456ed5385ab9c7b5e0489da225d5e4b">hasExternalName</a> () const</td></tr>
<tr class="separator:ad456ed5385ab9c7b5e0489da225d5e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde837817f1dc0208f6dfb05a8d72d44" id="r_adde837817f1dc0208f6dfb05a8d72d44"><td class="memItemLeft" align="right" valign="top"><a id="adde837817f1dc0208f6dfb05a8d72d44" name="adde837817f1dc0208f6dfb05a8d72d44"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasMaxContainerBytesConstraint</b> () const</td></tr>
<tr class="separator:adde837817f1dc0208f6dfb05a8d72d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7508f3101a56779adcda30c2ae086a" id="r_a1f7508f3101a56779adcda30c2ae086a"><td class="memItemLeft" align="right" valign="top"><a id="a1f7508f3101a56779adcda30c2ae086a" name="a1f7508f3101a56779adcda30c2ae086a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasPhvAllocation</b> (AllocState s) const</td></tr>
<tr class="memdesc:a1f7508f3101a56779adcda30c2ae086a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility functions to get field allocation status. <br /></td></tr>
<tr class="separator:a1f7508f3101a56779adcda30c2ae086a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a6d6b14acb95881dd97317b20d17a1" id="r_aa2a6d6b14acb95881dd97317b20d17a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p4_1_1cstring.html">cstring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2a6d6b14acb95881dd97317b20d17a1">header</a> () const</td></tr>
<tr class="separator:aa2a6d6b14acb95881dd97317b20d17a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd93e383eee3de2c21b5e07813aa6b9" id="r_acfd93e383eee3de2c21b5e07813aa6b9"><td class="memItemLeft" align="right" valign="top"><a id="acfd93e383eee3de2c21b5e07813aa6b9" name="acfd93e383eee3de2c21b5e07813aa6b9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_avoid_alloc</b> () const</td></tr>
<tr class="separator:acfd93e383eee3de2c21b5e07813aa6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade69f0d6a4cbf08525ae2b4d186fe575" id="r_ade69f0d6a4cbf08525ae2b4d186fe575"><td class="memItemLeft" align="right" valign="top"><a id="ade69f0d6a4cbf08525ae2b4d186fe575" name="ade69f0d6a4cbf08525ae2b4d186fe575"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_checksummed</b> () const</td></tr>
<tr class="separator:ade69f0d6a4cbf08525ae2b4d186fe575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de31832f6229a32b0d3451ec987888b" id="r_a1de31832f6229a32b0d3451ec987888b"><td class="memItemLeft" align="right" valign="top"><a id="a1de31832f6229a32b0d3451ec987888b" name="a1de31832f6229a32b0d3451ec987888b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_dark_candidate</b> () const</td></tr>
<tr class="separator:a1de31832f6229a32b0d3451ec987888b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32789b31800d9064a9b4739d338a0684" id="r_a32789b31800d9064a9b4739d338a0684"><td class="memItemLeft" align="right" valign="top"><a id="a32789b31800d9064a9b4739d338a0684" name="a32789b31800d9064a9b4739d338a0684"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_deparser_zero_candidate</b> () const</td></tr>
<tr class="separator:a32789b31800d9064a9b4739d338a0684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3414effd7e21dfd8f57134de5cace108" id="r_a3414effd7e21dfd8f57134de5cace108"><td class="memItemLeft" align="right" valign="top"><a id="a3414effd7e21dfd8f57134de5cace108" name="a3414effd7e21dfd8f57134de5cace108"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_digest</b> () const</td></tr>
<tr class="separator:a3414effd7e21dfd8f57134de5cace108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa42fd32fc626411d7a07aa9189c785" id="r_a9fa42fd32fc626411d7a07aa9189c785"><td class="memItemLeft" align="right" valign="top"><a id="a9fa42fd32fc626411d7a07aa9189c785" name="a9fa42fd32fc626411d7a07aa9189c785"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_fixed_size_header</b> () const</td></tr>
<tr class="separator:a9fa42fd32fc626411d7a07aa9189c785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a980ac202069c814a9ad84a7939e1d9" id="r_a6a980ac202069c814a9ad84a7939e1d9"><td class="memItemLeft" align="right" valign="top"><a id="a6a980ac202069c814a9ad84a7939e1d9" name="a6a980ac202069c814a9ad84a7939e1d9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_flexible</b> () const</td></tr>
<tr class="separator:a6a980ac202069c814a9ad84a7939e1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59804dc2a9266aa66faa300a4e9d749a" id="r_a59804dc2a9266aa66faa300a4e9d749a"><td class="memItemLeft" align="right" valign="top"><a id="a59804dc2a9266aa66faa300a4e9d749a" name="a59804dc2a9266aa66faa300a4e9d749a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_ignore_alloc</b> () const</td></tr>
<tr class="separator:a59804dc2a9266aa66faa300a4e9d749a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1df4382325de22e2bd704d036d52155" id="r_aa1df4382325de22e2bd704d036d52155"><td class="memItemLeft" align="right" valign="top"><a id="aa1df4382325de22e2bd704d036d52155" name="aa1df4382325de22e2bd704d036d52155"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_intrinsic</b> () const</td></tr>
<tr class="separator:aa1df4382325de22e2bd704d036d52155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f20f38439ed21ae5618fd5c8da8315" id="r_a92f20f38439ed21ae5618fd5c8da8315"><td class="memItemLeft" align="right" valign="top"><a id="a92f20f38439ed21ae5618fd5c8da8315" name="a92f20f38439ed21ae5618fd5c8da8315"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_invalidate_from_arch</b> () const</td></tr>
<tr class="separator:a92f20f38439ed21ae5618fd5c8da8315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb8debdb2fcea8a073cd5e1fff6f8d3" id="r_a9bb8debdb2fcea8a073cd5e1fff6f8d3"><td class="memItemLeft" align="right" valign="top"><a id="a9bb8debdb2fcea8a073cd5e1fff6f8d3" name="a9bb8debdb2fcea8a073cd5e1fff6f8d3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_marshaled</b> () const</td></tr>
<tr class="separator:a9bb8debdb2fcea8a073cd5e1fff6f8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8e7645b36dea94db0c993760da4870" id="r_a1d8e7645b36dea94db0c993760da4870"><td class="memItemLeft" align="right" valign="top"><a id="a1d8e7645b36dea94db0c993760da4870" name="a1d8e7645b36dea94db0c993760da4870"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_mocha_candidate</b> () const</td></tr>
<tr class="separator:a1d8e7645b36dea94db0c993760da4870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476f63b2953ebb19bfc11ea4ae4c4281" id="r_a476f63b2953ebb19bfc11ea4ae4c4281"><td class="memItemLeft" align="right" valign="top"><a id="a476f63b2953ebb19bfc11ea4ae4c4281" name="a476f63b2953ebb19bfc11ea4ae4c4281"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_overlayable</b> () const</td></tr>
<tr class="separator:a476f63b2953ebb19bfc11ea4ae4c4281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ec39824d9c31a6c63e3876d669ec31" id="r_a24ec39824d9c31a6c63e3876d669ec31"><td class="memItemLeft" align="right" valign="top"><a id="a24ec39824d9c31a6c63e3876d669ec31" name="a24ec39824d9c31a6c63e3876d669ec31"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_padding</b> () const</td></tr>
<tr class="separator:a24ec39824d9c31a6c63e3876d669ec31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9c28af451d98350d127e95fa9fefed" id="r_aee9c28af451d98350d127e95fa9fefed"><td class="memItemLeft" align="right" valign="top"><a id="aee9c28af451d98350d127e95fa9fefed" name="aee9c28af451d98350d127e95fa9fefed"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_solitary</b> () const</td></tr>
<tr class="separator:aee9c28af451d98350d127e95fa9fefed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad1d2ab2a098e6d3c281bbf1615be09" id="r_aaad1d2ab2a098e6d3c281bbf1615be09"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaad1d2ab2a098e6d3c281bbf1615be09">is_tphv_candidate</a> (const <a class="el" href="class_phv_use.html">PhvUse</a> &amp;uses) const</td></tr>
<tr class="separator:aaad1d2ab2a098e6d3c281bbf1615be09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba26e64059e50345fe648aa6d6661de" id="r_acba26e64059e50345fe648aa6d6661de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acba26e64059e50345fe648aa6d6661de">is_unallocated</a> () const</td></tr>
<tr class="separator:acba26e64059e50345fe648aa6d6661de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a456ac026abe222254627d9b55976e" id="r_a83a456ac026abe222254627d9b55976e"><td class="memItemLeft" align="right" valign="top"><a id="a83a456ac026abe222254627d9b55976e" name="a83a456ac026abe222254627d9b55976e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_upcasted</b> () const</td></tr>
<tr class="separator:a83a456ac026abe222254627d9b55976e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16320c02eef51398a1897f3745ce5be1" id="r_a16320c02eef51398a1897f3745ce5be1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16320c02eef51398a1897f3745ce5be1">isCompilerGeneratedPaddingField</a> () const</td></tr>
<tr class="separator:a16320c02eef51398a1897f3745ce5be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93ede68cb6db7baeec0e32680d166b2" id="r_ad93ede68cb6db7baeec0e32680d166b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad93ede68cb6db7baeec0e32680d166b2">isGhostField</a> () const</td></tr>
<tr class="separator:ad93ede68cb6db7baeec0e32680d166b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30be98d708c3b0d88fc582c4da0e81d" id="r_aa30be98d708c3b0d88fc582c4da0e81d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa30be98d708c3b0d88fc582c4da0e81d">isPacketField</a> () const</td></tr>
<tr class="separator:aa30be98d708c3b0d88fc582c4da0e81d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3a09255b7f4fb4e8f1aab191b8d88c" id="r_a9f3a09255b7f4fb4e8f1aab191b8d88c"><td class="memItemLeft" align="right" valign="top"><a id="a9f3a09255b7f4fb4e8f1aab191b8d88c" name="a9f3a09255b7f4fb4e8f1aab191b8d88c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isReferenced</b> (AllocState s) const</td></tr>
<tr class="separator:a9f3a09255b7f4fb4e8f1aab191b8d88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9cce1f926ec5607ceedc7ade903d03c" id="r_af9cce1f926ec5607ceedc7ade903d03c"><td class="memItemLeft" align="right" valign="top"><a id="af9cce1f926ec5607ceedc7ade903d03c" name="af9cce1f926ec5607ceedc7ade903d03c"></a>
const std::optional&lt; <a class="el" href="class_p4_1_1bitvec.html">bitvec</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>limited_container_ids</b> () const</td></tr>
<tr class="separator:af9cce1f926ec5607ceedc7ade903d03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc66934d503168f44fe303f8f7b61164" id="r_acc66934d503168f44fe303f8f7b61164"><td class="memItemLeft" align="right" valign="top"><a id="acc66934d503168f44fe303f8f7b61164" name="acc66934d503168f44fe303f8f7b61164"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>no_holes</b> () const</td></tr>
<tr class="separator:acc66934d503168f44fe303f8f7b61164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369947c6ceb5d1436d9e98cb96254c0c" id="r_a369947c6ceb5d1436d9e98cb96254c0c"><td class="memItemLeft" align="right" valign="top"><a id="a369947c6ceb5d1436d9e98cb96254c0c" name="a369947c6ceb5d1436d9e98cb96254c0c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>no_split</b> () const</td></tr>
<tr class="separator:a369947c6ceb5d1436d9e98cb96254c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac613a0c7e8e70bdc35dc71b329ac1bab" id="r_ac613a0c7e8e70bdc35dc71b329ac1bab"><td class="memItemLeft" align="right" valign="top"><a id="ac613a0c7e8e70bdc35dc71b329ac1bab" name="ac613a0c7e8e70bdc35dc71b329ac1bab"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>no_split_at</b> (int pos) const</td></tr>
<tr class="separator:ac613a0c7e8e70bdc35dc71b329ac1bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4cec3fbd123b35ccdc1192cf8bc3d1" id="r_a4c4cec3fbd123b35ccdc1192cf8bc3d1"><td class="memItemLeft" align="right" valign="top"><a id="a4c4cec3fbd123b35ccdc1192cf8bc3d1" name="a4c4cec3fbd123b35ccdc1192cf8bc3d1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>no_split_container_size</b> () const</td></tr>
<tr class="separator:a4c4cec3fbd123b35ccdc1192cf8bc3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef758dcc55875b983026b0c9ac00b4c" id="r_a7ef758dcc55875b983026b0c9ac00b4c"><td class="memItemLeft" align="right" valign="top"><a id="a7ef758dcc55875b983026b0c9ac00b4c" name="a7ef758dcc55875b983026b0c9ac00b4c"></a>
std::vector&lt; <a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>no_split_ranges</b> () const</td></tr>
<tr class="separator:a7ef758dcc55875b983026b0c9ac00b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b5064af7a5838d23e20302404a984f" id="r_aa8b5064af7a5838d23e20302404a984f"><td class="memItemLeft" align="right" valign="top"><a id="aa8b5064af7a5838d23e20302404a984f" name="aa8b5064af7a5838d23e20302404a984f"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>num_pack_conflicts</b> () const</td></tr>
<tr class="separator:aa8b5064af7a5838d23e20302404a984f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44a7ec07d7afa6927bed54018d38a70b" id="r_a44a7ec07d7afa6927bed54018d38a70b"><td class="memItemLeft" align="right" valign="top"><a id="a44a7ec07d7afa6927bed54018d38a70b" name="a44a7ec07d7afa6927bed54018d38a70b"></a>
<a class="el" href="class_p4_1_1safe__vector.html">safe_vector</a>&lt; <a class="el" href="struct_p_h_v_1_1_field_operation.html">FieldOperation</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operations</b> ()</td></tr>
<tr class="separator:a44a7ec07d7afa6927bed54018d38a70b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c9f868cb598b6deddadd5088950633c" id="r_a4c9f868cb598b6deddadd5088950633c"><td class="memItemLeft" align="right" valign="top"><a id="a4c9f868cb598b6deddadd5088950633c" name="a4c9f868cb598b6deddadd5088950633c"></a>
const <a class="el" href="class_p4_1_1safe__vector.html">safe_vector</a>&lt; <a class="el" href="struct_p_h_v_1_1_field_operation.html">FieldOperation</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operations</b> () const</td></tr>
<tr class="separator:a4c9f868cb598b6deddadd5088950633c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb2842c76b9bc66e829b74cc5206988" id="r_a5bb2842c76b9bc66e829b74cc5206988"><td class="memItemLeft" align="right" valign="top"><a id="a5bb2842c76b9bc66e829b74cc5206988" name="a5bb2842c76b9bc66e829b74cc5206988"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="class_p_h_v_1_1_field.html">Field</a> &amp;other) const</td></tr>
<tr class="memdesc:a5bb2842c76b9bc66e829b74cc5206988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orders by name. <br /></td></tr>
<tr class="separator:a5bb2842c76b9bc66e829b74cc5206988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c177aec194cf8edaa86de820c59afee" id="r_a9c177aec194cf8edaa86de820c59afee"><td class="memItemLeft" align="right" valign="top"><a id="a9c177aec194cf8edaa86de820c59afee" name="a9c177aec194cf8edaa86de820c59afee"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>parsed</b> () const</td></tr>
<tr class="separator:a9c177aec194cf8edaa86de820c59afee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f9271b0f3614bd30ddd59f7b925966" id="r_a68f9271b0f3614bd30ddd59f7b925966"><td class="memItemLeft" align="right" valign="top"><a id="a68f9271b0f3614bd30ddd59f7b925966" name="a68f9271b0f3614bd30ddd59f7b925966"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>partiallyPhvAllocated</b> (AllocState s) const</td></tr>
<tr class="separator:a68f9271b0f3614bd30ddd59f7b925966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af471fe5ddf96f4c3dd52714facf5426b" id="r_af471fe5ddf96f4c3dd52714facf5426b"><td class="memItemLeft" align="right" valign="top"><a id="af471fe5ddf96f4c3dd52714facf5426b" name="af471fe5ddf96f4c3dd52714facf5426b"></a>
<a class="el" href="namespace_p_h_v.html#a3ff115c4ef9dcfb7a3565ddc263f0ece">PHV::Size</a>&#160;</td><td class="memItemRight" valign="bottom"><b>prefer_container_size</b> () const</td></tr>
<tr class="separator:af471fe5ddf96f4c3dd52714facf5426b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f3fd127b3c3aa5f35d31166fe1c3761" id="r_a2f3fd127b3c3aa5f35d31166fe1c3761"><td class="memItemLeft" align="right" valign="top"><a id="a2f3fd127b3c3aa5f35d31166fe1c3761" name="a2f3fd127b3c3aa5f35d31166fe1c3761"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>same_container_group</b> () const</td></tr>
<tr class="separator:a2f3fd127b3c3aa5f35d31166fe1c3761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41326436d4beb35e040bb4220f991ea0" id="r_a41326436d4beb35e040bb4220f991ea0"><td class="memItemLeft" align="right" valign="top"><a id="a41326436d4beb35e040bb4220f991ea0" name="a41326436d4beb35e040bb4220f991ea0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_alignment</b> (<a class="el" href="class_constraints_1_1_alignment_constraint.html">Constraints::AlignmentConstraint</a> &amp;c)</td></tr>
<tr class="separator:a41326436d4beb35e040bb4220f991ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e855d0ed4f673a764ef9fbcc8992a1" id="r_a57e855d0ed4f673a764ef9fbcc8992a1"><td class="memItemLeft" align="right" valign="top"><a id="a57e855d0ed4f673a764ef9fbcc8992a1" name="a57e855d0ed4f673a764ef9fbcc8992a1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_alignment</b> (unsigned r, unsigned v)</td></tr>
<tr class="separator:a57e855d0ed4f673a764ef9fbcc8992a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707ec20fab2aa314f0873586243fc459" id="r_a707ec20fab2aa314f0873586243fc459"><td class="memItemLeft" align="right" valign="top"><a id="a707ec20fab2aa314f0873586243fc459" name="a707ec20fab2aa314f0873586243fc459"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_alloc</b> (const <a class="el" href="class_p4_1_1safe__vector.html">safe_vector</a>&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;alloc)</td></tr>
<tr class="memdesc:a707ec20fab2aa314f0873586243fc459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all allocated slices of this field. <br /></td></tr>
<tr class="separator:a707ec20fab2aa314f0873586243fc459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c553e63280171c8fecd367dcf89db88" id="r_a8c553e63280171c8fecd367dcf89db88"><td class="memItemLeft" align="right" valign="top"><a id="a8c553e63280171c8fecd367dcf89db88" name="a8c553e63280171c8fecd367dcf89db88"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_avoid_alloc</b> (bool a)</td></tr>
<tr class="separator:a8c553e63280171c8fecd367dcf89db88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e3f9d34d4fb46a6e468499b030dcd4" id="r_a61e3f9d34d4fb46a6e468499b030dcd4"><td class="memItemLeft" align="right" valign="top"><a id="a61e3f9d34d4fb46a6e468499b030dcd4" name="a61e3f9d34d4fb46a6e468499b030dcd4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_dark_candidate</b> (bool c)</td></tr>
<tr class="separator:a61e3f9d34d4fb46a6e468499b030dcd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5859b9600768fc5cc6f3b5902431fe4" id="r_ae5859b9600768fc5cc6f3b5902431fe4"><td class="memItemLeft" align="right" valign="top"><a id="ae5859b9600768fc5cc6f3b5902431fe4" name="ae5859b9600768fc5cc6f3b5902431fe4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_deparsed</b> (bool b)</td></tr>
<tr class="separator:ae5859b9600768fc5cc6f3b5902431fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e689b5053d9e49d8cbe2ddca4d4dd1" id="r_af6e689b5053d9e49d8cbe2ddca4d4dd1"><td class="memItemLeft" align="right" valign="top"><a id="af6e689b5053d9e49d8cbe2ddca4d4dd1" name="af6e689b5053d9e49d8cbe2ddca4d4dd1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_deparsed_bottom_bits</b> (bool b)</td></tr>
<tr class="separator:af6e689b5053d9e49d8cbe2ddca4d4dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd1abdb7d0cd993c270898a583261207" id="r_afd1abdb7d0cd993c270898a583261207"><td class="memItemLeft" align="right" valign="top"><a id="afd1abdb7d0cd993c270898a583261207" name="afd1abdb7d0cd993c270898a583261207"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_deparsed_to_tm</b> (bool b)</td></tr>
<tr class="separator:afd1abdb7d0cd993c270898a583261207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3c2c29d7c36b659ce930dcd0834727" id="r_a8c3c2c29d7c36b659ce930dcd0834727"><td class="memItemLeft" align="right" valign="top"><a id="a8c3c2c29d7c36b659ce930dcd0834727" name="a8c3c2c29d7c36b659ce930dcd0834727"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_deparsed_top_bits</b> (bool b)</td></tr>
<tr class="separator:a8c3c2c29d7c36b659ce930dcd0834727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833229d7c62e46c143e05c1c31cb9716" id="r_a833229d7c62e46c143e05c1c31cb9716"><td class="memItemLeft" align="right" valign="top"><a id="a833229d7c62e46c143e05c1c31cb9716" name="a833229d7c62e46c143e05c1c31cb9716"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_deparser_zero_candidate</b> (bool c)</td></tr>
<tr class="separator:a833229d7c62e46c143e05c1c31cb9716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe6ea14bcddd9f00ba29fc1df343351" id="r_a3fe6ea14bcddd9f00ba29fc1df343351"><td class="memItemLeft" align="right" valign="top"><a id="a3fe6ea14bcddd9f00ba29fc1df343351" name="a3fe6ea14bcddd9f00ba29fc1df343351"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_digest</b> (uint32_t source)</td></tr>
<tr class="separator:a3fe6ea14bcddd9f00ba29fc1df343351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955ae1dcb59a00bcdbf43c3b210fd562" id="r_a955ae1dcb59a00bcdbf43c3b210fd562"><td class="memItemLeft" align="right" valign="top"><a id="a955ae1dcb59a00bcdbf43c3b210fd562" name="a955ae1dcb59a00bcdbf43c3b210fd562"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_emitted</b> (bool b)</td></tr>
<tr class="separator:a955ae1dcb59a00bcdbf43c3b210fd562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0abeabf6fa694b4d7794378e9bd60fa" id="r_ac0abeabf6fa694b4d7794378e9bd60fa"><td class="memItemLeft" align="right" valign="top"><a id="ac0abeabf6fa694b4d7794378e9bd60fa" name="ac0abeabf6fa694b4d7794378e9bd60fa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_exact_containers</b> (bool b)</td></tr>
<tr class="separator:ac0abeabf6fa694b4d7794378e9bd60fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b0705524d311f2baf381961340b2c4" id="r_ad5b0705524d311f2baf381961340b2c4"><td class="memItemLeft" align="right" valign="top"><a id="ad5b0705524d311f2baf381961340b2c4" name="ad5b0705524d311f2baf381961340b2c4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_fixed_size_header</b> (bool f)</td></tr>
<tr class="separator:ad5b0705524d311f2baf381961340b2c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8444f8f1603370d4e04b6f80f44c65b" id="r_ae8444f8f1603370d4e04b6f80f44c65b"><td class="memItemLeft" align="right" valign="top"><a id="ae8444f8f1603370d4e04b6f80f44c65b" name="ae8444f8f1603370d4e04b6f80f44c65b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_flexible</b> (bool b)</td></tr>
<tr class="separator:ae8444f8f1603370d4e04b6f80f44c65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d5f7d05ef9e00b4c09ed9a1919b901" id="r_a79d5f7d05ef9e00b4c09ed9a1919b901"><td class="memItemLeft" align="right" valign="top"><a id="a79d5f7d05ef9e00b4c09ed9a1919b901" name="a79d5f7d05ef9e00b4c09ed9a1919b901"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_ignore_alloc</b> (bool b)</td></tr>
<tr class="separator:a79d5f7d05ef9e00b4c09ed9a1919b901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac47a47afe8c7a7071a6a1d255bb635c" id="r_aac47a47afe8c7a7071a6a1d255bb635c"><td class="memItemLeft" align="right" valign="top"><a id="aac47a47afe8c7a7071a6a1d255bb635c" name="aac47a47afe8c7a7071a6a1d255bb635c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_intrinsic</b> (bool b)</td></tr>
<tr class="separator:aac47a47afe8c7a7071a6a1d255bb635c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbcd766689f4534e698a76bcf832ea94" id="r_adbcd766689f4534e698a76bcf832ea94"><td class="memItemLeft" align="right" valign="top"><a id="adbcd766689f4534e698a76bcf832ea94" name="adbcd766689f4534e698a76bcf832ea94"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_invalidate_from_arch</b> (bool b)</td></tr>
<tr class="separator:adbcd766689f4534e698a76bcf832ea94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8605c32598834da105aef5ed2ac80b" id="r_aea8605c32598834da105aef5ed2ac80b"><td class="memItemLeft" align="right" valign="top"><a id="aea8605c32598834da105aef5ed2ac80b" name="aea8605c32598834da105aef5ed2ac80b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_is_checksummed</b> (bool b)</td></tr>
<tr class="separator:aea8605c32598834da105aef5ed2ac80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259edb0fb9e95db20704cb39ac5baefb" id="r_a259edb0fb9e95db20704cb39ac5baefb"><td class="memItemLeft" align="right" valign="top"><a id="a259edb0fb9e95db20704cb39ac5baefb" name="a259edb0fb9e95db20704cb39ac5baefb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_is_marshaled</b> (bool b)</td></tr>
<tr class="separator:a259edb0fb9e95db20704cb39ac5baefb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab050adac3d71ba78c174b6abe1dcbb88" id="r_ab050adac3d71ba78c174b6abe1dcbb88"><td class="memItemLeft" align="right" valign="top"><a id="ab050adac3d71ba78c174b6abe1dcbb88" name="ab050adac3d71ba78c174b6abe1dcbb88"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_limited_container_ids</b> (const std::optional&lt; <a class="el" href="class_p4_1_1bitvec.html">bitvec</a> &gt; &amp;ids)</td></tr>
<tr class="separator:ab050adac3d71ba78c174b6abe1dcbb88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0f0c52980e06aee67782190386dffd" id="r_a3d0f0c52980e06aee67782190386dffd"><td class="memItemLeft" align="right" valign="top"><a id="a3d0f0c52980e06aee67782190386dffd" name="a3d0f0c52980e06aee67782190386dffd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_mocha_candidate</b> (bool c)</td></tr>
<tr class="separator:a3d0f0c52980e06aee67782190386dffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9afc36f12e0685a6bb3b8331656ac2f" id="r_af9afc36f12e0685a6bb3b8331656ac2f"><td class="memItemLeft" align="right" valign="top"><a id="af9afc36f12e0685a6bb3b8331656ac2f" name="af9afc36f12e0685a6bb3b8331656ac2f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_no_holes</b> (bool b)</td></tr>
<tr class="separator:af9afc36f12e0685a6bb3b8331656ac2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451ae604a4c2bce8b8ca84b8429d3f39" id="r_a451ae604a4c2bce8b8ca84b8429d3f39"><td class="memItemLeft" align="right" valign="top"><a id="a451ae604a4c2bce8b8ca84b8429d3f39" name="a451ae604a4c2bce8b8ca84b8429d3f39"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_no_split</b> (bool b)</td></tr>
<tr class="separator:a451ae604a4c2bce8b8ca84b8429d3f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87fef10f941abb2dce543c018c0e220b" id="r_a87fef10f941abb2dce543c018c0e220b"><td class="memItemLeft" align="right" valign="top"><a id="a87fef10f941abb2dce543c018c0e220b" name="a87fef10f941abb2dce543c018c0e220b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_no_split_at</b> (<a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> range)</td></tr>
<tr class="separator:a87fef10f941abb2dce543c018c0e220b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17eb0f0a570052091d98e47c649cfac6" id="r_a17eb0f0a570052091d98e47c649cfac6"><td class="memItemLeft" align="right" valign="top"><a id="a17eb0f0a570052091d98e47c649cfac6" name="a17eb0f0a570052091d98e47c649cfac6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_no_split_container_size</b> (int <a class="el" href="#a10a198e7adff85104913040f88af6081">size</a>)</td></tr>
<tr class="separator:a17eb0f0a570052091d98e47c649cfac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7a9bee9c8cd03843085d66fb5466f0" id="r_a0b7a9bee9c8cd03843085d66fb5466f0"><td class="memItemLeft" align="right" valign="top"><a id="a0b7a9bee9c8cd03843085d66fb5466f0" name="a0b7a9bee9c8cd03843085d66fb5466f0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_num_pack_conflicts</b> (size_t no)</td></tr>
<tr class="separator:a0b7a9bee9c8cd03843085d66fb5466f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333f57caa991d65a568fa996af6052af" id="r_a333f57caa991d65a568fa996af6052af"><td class="memItemLeft" align="right" valign="top"><a id="a333f57caa991d65a568fa996af6052af" name="a333f57caa991d65a568fa996af6052af"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_overlayable</b> (bool p)</td></tr>
<tr class="separator:a333f57caa991d65a568fa996af6052af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5295b562401c5e09d002bed0a9d900d" id="r_ae5295b562401c5e09d002bed0a9d900d"><td class="memItemLeft" align="right" valign="top"><a id="ae5295b562401c5e09d002bed0a9d900d" name="ae5295b562401c5e09d002bed0a9d900d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_padding</b> (bool p)</td></tr>
<tr class="separator:ae5295b562401c5e09d002bed0a9d900d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a549708e3da389040a7d3380acb196e5c" id="r_a549708e3da389040a7d3380acb196e5c"><td class="memItemLeft" align="right" valign="top"><a id="a549708e3da389040a7d3380acb196e5c" name="a549708e3da389040a7d3380acb196e5c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_parsed</b> (bool b)</td></tr>
<tr class="separator:a549708e3da389040a7d3380acb196e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa58aef4de913db7a31c75ab37d2f0716" id="r_aa58aef4de913db7a31c75ab37d2f0716"><td class="memItemLeft" align="right" valign="top"><a id="aa58aef4de913db7a31c75ab37d2f0716" name="aa58aef4de913db7a31c75ab37d2f0716"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_prefer_container_size</b> (<a class="el" href="namespace_p_h_v.html#a3ff115c4ef9dcfb7a3565ddc263f0ece">PHV::Size</a> cnt_size)</td></tr>
<tr class="separator:aa58aef4de913db7a31c75ab37d2f0716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00d252e492b61cdd108c6a8d8ea4af3" id="r_ae00d252e492b61cdd108c6a8d8ea4af3"><td class="memItemLeft" align="right" valign="top"><a id="ae00d252e492b61cdd108c6a8d8ea4af3" name="ae00d252e492b61cdd108c6a8d8ea4af3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_same_container_group</b> (bool b)</td></tr>
<tr class="separator:ae00d252e492b61cdd108c6a8d8ea4af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e42b790348dd83ec18a26543b491e5" id="r_a03e42b790348dd83ec18a26543b491e5"><td class="memItemLeft" align="right" valign="top"><a id="a03e42b790348dd83ec18a26543b491e5" name="a03e42b790348dd83ec18a26543b491e5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_solitary</b> (uint32_t reason)</td></tr>
<tr class="separator:a03e42b790348dd83ec18a26543b491e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe7e37b88704c115afa98de13de4521" id="r_abbe7e37b88704c115afa98de13de4521"><td class="memItemLeft" align="right" valign="top"><a id="abbe7e37b88704c115afa98de13de4521" name="abbe7e37b88704c115afa98de13de4521"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_upcasted</b> (bool c)</td></tr>
<tr class="separator:abbe7e37b88704c115afa98de13de4521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be62317512899a871fa90a07a6cf087" id="r_a9be62317512899a871fa90a07a6cf087"><td class="memItemLeft" align="right" valign="top"><a id="a9be62317512899a871fa90a07a6cf087" name="a9be62317512899a871fa90a07a6cf087"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_written_in_force_immediate</b> (bool b)</td></tr>
<tr class="separator:a9be62317512899a871fa90a07a6cf087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163eb297d6f56ad9e6212cf6a7ce1845" id="r_a163eb297d6f56ad9e6212cf6a7ce1845"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a163eb297d6f56ad9e6212cf6a7ce1845">setExternalName</a> (<a class="el" href="class_p4_1_1cstring.html">cstring</a> <a class="el" href="#a6dc1459985650d5003fe4638787556c8">name</a>)</td></tr>
<tr class="separator:a163eb297d6f56ad9e6212cf6a7ce1845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5468a845f98f079ae7bef10c4a35c77" id="r_ac5468a845f98f079ae7bef10c4a35c77"><td class="memItemLeft" align="right" valign="top"><a id="ac5468a845f98f079ae7bef10c4a35c77" name="ac5468a845f98f079ae7bef10c4a35c77"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setMaxContainerBytes</b> (int <a class="el" href="#a10a198e7adff85104913040f88af6081">size</a>)</td></tr>
<tr class="separator:ac5468a845f98f079ae7bef10c4a35c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82512864023bb78386efe053ae8f07c2" id="r_a82512864023bb78386efe053ae8f07c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82512864023bb78386efe053ae8f07c2">setStartBits</a> (<a class="el" href="namespace_p_h_v.html#a3ff115c4ef9dcfb7a3565ddc263f0ece">PHV::Size</a> <a class="el" href="#a10a198e7adff85104913040f88af6081">size</a>, <a class="el" href="class_p4_1_1bitvec.html">bitvec</a> startPositions)</td></tr>
<tr class="separator:a82512864023bb78386efe053ae8f07c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d2f455b34713d10ecb41dc5f91b8b0" id="r_ae6d2f455b34713d10ecb41dc5f91b8b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6d2f455b34713d10ecb41dc5f91b8b0">setStartBitsToLowerBitsOfBottomByte</a> ()</td></tr>
<tr class="separator:ae6d2f455b34713d10ecb41dc5f91b8b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9e51f4d992dcdf9d55f7826428ffc5" id="r_a3d9e51f4d992dcdf9d55f7826428ffc5"><td class="memItemLeft" align="right" valign="top"><a id="a3d9e51f4d992dcdf9d55f7826428ffc5" name="a3d9e51f4d992dcdf9d55f7826428ffc5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sort_alloc</b> ()</td></tr>
<tr class="memdesc:a3d9e51f4d992dcdf9d55f7826428ffc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort by field MSB. <br /></td></tr>
<tr class="separator:a3d9e51f4d992dcdf9d55f7826428ffc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7bb5db7971bcbe3b337b76583a5130e" id="r_ae7bb5db7971bcbe3b337b76583a5130e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7bb5db7971bcbe3b337b76583a5130e">updateAlignment</a> (PHV::AlignmentReason, const <a class="el" href="struct_field_alignment.html">FieldAlignment</a> &amp;newAlignment, const <a class="el" href="class_p4_1_1_util_1_1_source_info.html">Util::SourceInfo</a> &amp;newAlignmentSource)</td></tr>
<tr class="separator:ae7bb5db7971bcbe3b337b76583a5130e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a39a8e5fb79e8b4989634dbc2396a21" id="r_a0a39a8e5fb79e8b4989634dbc2396a21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a39a8e5fb79e8b4989634dbc2396a21">updateValidContainerRange</a> (<a class="el" href="namespace_p4.html#a19f5abed1a21ad7a5703944aa5099da7">nw_bitrange</a> newValidRange)</td></tr>
<tr class="separator:a0a39a8e5fb79e8b4989634dbc2396a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a937edfff1d88dad9358a6e58176e5760" id="r_a937edfff1d88dad9358a6e58176e5760"><td class="memItemLeft" align="right" valign="top"><a id="a937edfff1d88dad9358a6e58176e5760" name="a937edfff1d88dad9358a6e58176e5760"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>used_in_wide_arith</b> () const</td></tr>
<tr class="separator:a937edfff1d88dad9358a6e58176e5760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e0e91bc716c5af1c7c0c042478e535" id="r_af1e0e91bc716c5af1c7c0c042478e535"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_p4.html#a19f5abed1a21ad7a5703944aa5099da7">nw_bitrange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1e0e91bc716c5af1c7c0c042478e535">validContainerRange</a> () const</td></tr>
<tr class="separator:af1e0e91bc716c5af1c7c0c042478e535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e8fde333378ea3e772226da070cd38" id="r_a00e8fde333378ea3e772226da070cd38"><td class="memItemLeft" align="right" valign="top"><a id="a00e8fde333378ea3e772226da070cd38" name="a00e8fde333378ea3e772226da070cd38"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>written_in_force_immediate_table</b> () const</td></tr>
<tr class="separator:a00e8fde333378ea3e772226da070cd38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_lift_less"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_class_lift_less')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_lift_less.html">LiftLess&lt; Field &gt;</a></td></tr>
<tr class="memitem:ac9d1be93a9a9238205edbe6d884fa2e9 inherit pub_methods_class_lift_less" id="r_ac9d1be93a9a9238205edbe6d884fa2e9"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR</b> (equal, Equal)</td></tr>
<tr class="separator:ac9d1be93a9a9238205edbe6d884fa2e9 inherit pub_methods_class_lift_less"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a22ca4e6fd2ebe84d954d07160307eb inherit pub_methods_class_lift_less" id="r_a4a22ca4e6fd2ebe84d954d07160307eb"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR</b> (greater, Greater)</td></tr>
<tr class="separator:a4a22ca4e6fd2ebe84d954d07160307eb inherit pub_methods_class_lift_less"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7d21bbd0fc325488393aeb9b8062ff inherit pub_methods_class_lift_less" id="r_a6f7d21bbd0fc325488393aeb9b8062ff"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR</b> (greater_equal, GreaterEqual)</td></tr>
<tr class="separator:a6f7d21bbd0fc325488393aeb9b8062ff inherit pub_methods_class_lift_less"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6504181e2a46fa71670e44f9db60e9 inherit pub_methods_class_lift_less" id="r_a0f6504181e2a46fa71670e44f9db60e9"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR</b> (less, Less)</td></tr>
<tr class="separator:a0f6504181e2a46fa71670e44f9db60e9 inherit pub_methods_class_lift_less"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d058359e7920d2ae77200def30694d4 inherit pub_methods_class_lift_less" id="r_a7d058359e7920d2ae77200def30694d4"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR</b> (less_equal, LessEqual)</td></tr>
<tr class="separator:a7d058359e7920d2ae77200def30694d4 inherit pub_methods_class_lift_less"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7530753bb8a8ba5a58353a1dee0daed inherit pub_methods_class_lift_less" id="r_ac7530753bb8a8ba5a58353a1dee0daed"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR</b> (not_equal, NotEqual)</td></tr>
<tr class="separator:ac7530753bb8a8ba5a58353a1dee0daed inherit pub_methods_class_lift_less"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e3e1a23762704ba9b499994bc05393 inherit pub_methods_class_lift_less" id="r_ab9e3e1a23762704ba9b499994bc05393"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const Field &amp;other) const</td></tr>
<tr class="separator:ab9e3e1a23762704ba9b499994bc05393 inherit pub_methods_class_lift_less"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302351e829dc1c3583ab45bafa63891b inherit pub_methods_class_lift_less" id="r_a302351e829dc1c3583ab45bafa63891b"><td class="memItemLeft" align="right" valign="top">
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const Field &amp;) const=0</td></tr>
<tr class="separator:a302351e829dc1c3583ab45bafa63891b inherit pub_methods_class_lift_less"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb4e5cdc6dacc195fdab82e7d1cb5cd inherit pub_methods_class_lift_less" id="r_a0bb4e5cdc6dacc195fdab82e7d1cb5cd"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;=</b> (const Field &amp;other) const</td></tr>
<tr class="separator:a0bb4e5cdc6dacc195fdab82e7d1cb5cd inherit pub_methods_class_lift_less"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79c61d1f3e398cafb2a69098bb6835b inherit pub_methods_class_lift_less" id="r_ac79c61d1f3e398cafb2a69098bb6835b"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const Field &amp;other) const</td></tr>
<tr class="separator:ac79c61d1f3e398cafb2a69098bb6835b inherit pub_methods_class_lift_less"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f51e2f23e6e5ef8a00af96840dbc20 inherit pub_methods_class_lift_less" id="r_af1f51e2f23e6e5ef8a00af96840dbc20"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;</b> (const Field &amp;other) const</td></tr>
<tr class="separator:af1f51e2f23e6e5ef8a00af96840dbc20 inherit pub_methods_class_lift_less"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5600d14ca6d499ed0931b1d537f3c646 inherit pub_methods_class_lift_less" id="r_a5600d14ca6d499ed0931b1d537f3c646"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;=</b> (const Field &amp;other) const</td></tr>
<tr class="separator:a5600d14ca6d499ed0931b1d537f3c646 inherit pub_methods_class_lift_less"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ab3cc4195b4753cdfd96d7304f634168c" id="r_ab3cc4195b4753cdfd96d7304f634168c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3cc4195b4753cdfd96d7304f634168c">aliasSource</a> = nullptr</td></tr>
<tr class="separator:ab3cc4195b4753cdfd96d7304f634168c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086243ace1d14197dac4311827936006" id="r_a086243ace1d14197dac4311827936006"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="struct_field_alignment.html">FieldAlignment</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a086243ace1d14197dac4311827936006">alignment</a></td></tr>
<tr class="separator:a086243ace1d14197dac4311827936006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af124e1a34342828c2e3614fe57fa5c02" id="r_af124e1a34342828c2e3614fe57fa5c02"><td class="memItemLeft" align="right" valign="top"><a id="af124e1a34342828c2e3614fe57fa5c02" name="af124e1a34342828c2e3614fe57fa5c02"></a>
std::list&lt; std::pair&lt; <a class="el" href="struct_field_alignment.html">FieldAlignment</a>, <a class="el" href="class_p4_1_1_util_1_1_source_info.html">Util::SourceInfo</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>alignmentSources</b></td></tr>
<tr class="memdesc:af124e1a34342828c2e3614fe57fa5c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of alignment sources for this field (mainly for error printing) <br /></td></tr>
<tr class="separator:af124e1a34342828c2e3614fe57fa5c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8621a5edf58e28fde136f3a0e59c187" id="r_aa8621a5edf58e28fde136f3a0e59c187"><td class="memItemLeft" align="right" valign="top"><a id="aa8621a5edf58e28fde136f3a0e59c187" name="aa8621a5edf58e28fde136f3a0e59c187"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>bridged</b> = false</td></tr>
<tr class="memdesc:aa8621a5edf58e28fde136f3a0e59c187"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this Field is metadata bridged from ingress to egress. <br /></td></tr>
<tr class="separator:aa8621a5edf58e28fde136f3a0e59c187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2400d1b9099379cb7a497ac267b507" id="r_afd2400d1b9099379cb7a497ac267b507"><td class="memItemLeft" align="right" valign="top"><a id="afd2400d1b9099379cb7a497ac267b507" name="afd2400d1b9099379cb7a497ac267b507"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>emitted_i</b> = false</td></tr>
<tr class="memdesc:afd2400d1b9099379cb7a497ac267b507"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this field is emitted by the deparser onto the wire. <br /></td></tr>
<tr class="separator:afd2400d1b9099379cb7a497ac267b507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6262d2f5baa4d007b672a90432d91c6" id="r_af6262d2f5baa4d007b672a90432d91c6"><td class="memItemLeft" align="right" valign="top"><a id="af6262d2f5baa4d007b672a90432d91c6" name="af6262d2f5baa4d007b672a90432d91c6"></a>
gress_t&#160;</td><td class="memItemRight" valign="bottom"><b>gress</b> = INGRESS</td></tr>
<tr class="memdesc:af6262d2f5baa4d007b672a90432d91c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the Field is ingress or egress. <br /></td></tr>
<tr class="separator:af6262d2f5baa4d007b672a90432d91c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116fa1a523b6f5d9136355f7d3c46cc8" id="r_a116fa1a523b6f5d9136355f7d3c46cc8"><td class="memItemLeft" align="right" valign="top"><a id="a116fa1a523b6f5d9136355f7d3c46cc8" name="a116fa1a523b6f5d9136355f7d3c46cc8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>id</b> = 0</td></tr>
<tr class="memdesc:a116fa1a523b6f5d9136355f7d3c46cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unique field ID. <br /></td></tr>
<tr class="separator:a116fa1a523b6f5d9136355f7d3c46cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e974d4d0f9ae2d59744ea6058350f9" id="r_a91e974d4d0f9ae2d59744ea6058350f9"><td class="memItemLeft" align="right" valign="top"><a id="a91e974d4d0f9ae2d59744ea6058350f9" name="a91e974d4d0f9ae2d59744ea6058350f9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>intrinsic_i</b> = false</td></tr>
<tr class="memdesc:a91e974d4d0f9ae2d59744ea6058350f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this Field is intrinsic. <br /></td></tr>
<tr class="separator:a91e974d4d0f9ae2d59744ea6058350f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c9d3ef11d7a6187281901a38f54972c" id="r_a4c9d3ef11d7a6187281901a38f54972c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c9d3ef11d7a6187281901a38f54972c">invalidate_from_arch_i</a> = false</td></tr>
<tr class="separator:a4c9d3ef11d7a6187281901a38f54972c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc4b0042d28ceca7add4ea73f9b4a25" id="r_afbc4b0042d28ceca7add4ea73f9b4a25"><td class="memItemLeft" align="right" valign="top"><a id="afbc4b0042d28ceca7add4ea73f9b4a25" name="afbc4b0042d28ceca7add4ea73f9b4a25"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>metadata</b> = false</td></tr>
<tr class="memdesc:afbc4b0042d28ceca7add4ea73f9b4a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this Field is metadata. <br /></td></tr>
<tr class="separator:afbc4b0042d28ceca7add4ea73f9b4a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb209509b8480564f60f5071bb9a82c" id="r_a6eb209509b8480564f60f5071bb9a82c"><td class="memItemLeft" align="right" valign="top"><a id="a6eb209509b8480564f60f5071bb9a82c" name="a6eb209509b8480564f60f5071bb9a82c"></a>
struct <a class="el" href="struct_p_h_v_1_1_field_1_1mirror__field__list__t.html">PHV::Field::mirror_field_list_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mirror_field_list</b> = {nullptr, -1}</td></tr>
<tr class="separator:a6eb209509b8480564f60f5071bb9a82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc1459985650d5003fe4638787556c8" id="r_a6dc1459985650d5003fe4638787556c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p4_1_1cstring.html">cstring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6dc1459985650d5003fe4638787556c8">name</a></td></tr>
<tr class="separator:a6dc1459985650d5003fe4638787556c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb0f973812431ea37b65f7b76797c8b" id="r_a3cb0f973812431ea37b65f7b76797c8b"><td class="memItemLeft" align="right" valign="top"><a id="a3cb0f973812431ea37b65f7b76797c8b" name="a3cb0f973812431ea37b65f7b76797c8b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>offset</b> = 0</td></tr>
<tr class="memdesc:a3cb0f973812431ea37b65f7b76797c8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset of lsb from lsb (last) bit of containing header. <br /></td></tr>
<tr class="separator:a3cb0f973812431ea37b65f7b76797c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a126872581bb3cff5a10369cfe932351c" id="r_a126872581bb3cff5a10369cfe932351c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a126872581bb3cff5a10369cfe932351c">overlayable</a> = false</td></tr>
<tr class="separator:a126872581bb3cff5a10369cfe932351c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f34f8b751c2fb7ce38154ad13971fe3" id="r_a3f34f8b751c2fb7ce38154ad13971fe3"><td class="memItemLeft" align="right" valign="top"><a id="a3f34f8b751c2fb7ce38154ad13971fe3" name="a3f34f8b751c2fb7ce38154ad13971fe3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>padding</b> = false</td></tr>
<tr class="memdesc:a3f34f8b751c2fb7ce38154ad13971fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this Field is a padding field. <br /></td></tr>
<tr class="separator:a3f34f8b751c2fb7ce38154ad13971fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa088557d6ac28ad96694360685396466" id="r_aa088557d6ac28ad96694360685396466"><td class="memItemLeft" align="right" valign="top"><a id="aa088557d6ac28ad96694360685396466" name="aa088557d6ac28ad96694360685396466"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>pov</b> = false</td></tr>
<tr class="memdesc:aa088557d6ac28ad96694360685396466"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this Field is a validity bit. <br /></td></tr>
<tr class="separator:aa088557d6ac28ad96694360685396466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a198e7adff85104913040f88af6081" id="r_a10a198e7adff85104913040f88af6081"><td class="memItemLeft" align="right" valign="top"><a id="a10a198e7adff85104913040f88af6081" name="a10a198e7adff85104913040f88af6081"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> = 0</td></tr>
<tr class="memdesc:a10a198e7adff85104913040f88af6081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total size of Field in bits. <br /></td></tr>
<tr class="separator:a10a198e7adff85104913040f88af6081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8631797d1714eb0b9b2e9e23dba82fd3" id="r_a8631797d1714eb0b9b2e9e23dba82fd3"><td class="memItemLeft" align="right" valign="top"><a id="a8631797d1714eb0b9b2e9e23dba82fd3" name="a8631797d1714eb0b9b2e9e23dba82fd3"></a>
std::optional&lt; <a class="el" href="class_p4_1_1_util_1_1_source_info.html">Util::SourceInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>srcInfo</b></td></tr>
<tr class="memdesc:a8631797d1714eb0b9b2e9e23dba82fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate source info to each field. <br /></td></tr>
<tr class="separator:a8631797d1714eb0b9b2e9e23dba82fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0311021b775df3f9a3c5cc1f458d7eb4" id="r_a0311021b775df3f9a3c5cc1f458d7eb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_p4.html#a19f5abed1a21ad7a5703944aa5099da7">nw_bitrange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0311021b775df3f9a3c5cc1f458d7eb4">validContainerRange_i</a> = <a class="el" href="struct_p4_1_1_bit_range_1_1_zero_to_max.html">ZeroToMax</a>()</td></tr>
<tr class="separator:a0311021b775df3f9a3c5cc1f458d7eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ab84dc20e1b7f9045cb03a401bfc6fcec" id="r_ab84dc20e1b7f9045cb03a401bfc6fcec"><td class="memItemLeft" align="right" valign="top"><a id="ab84dc20e1b7f9045cb03a401bfc6fcec" name="ab84dc20e1b7f9045cb03a401bfc6fcec"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const <a class="el" href="class_p_h_v_1_1_field.html">Field</a> &amp;field)</td></tr>
<tr class="separator:ab84dc20e1b7f9045cb03a401bfc6fcec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a080e2f543188692029705871c9d70803" name="a080e2f543188692029705871c9d70803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a080e2f543188692029705871c9d70803">&#9670;&#160;</a></span>alloc_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t PHV::Field::alloc_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of allocated slices of this field. </dd></dl>

</div>
</div>
<a id="a619905bddda92e02d9bb54565b1a3a87" name="a619905bddda92e02d9bb54565b1a3a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619905bddda92e02d9bb54565b1a3a87">&#9670;&#160;</a></span>byteAlignedRangeInBits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> PHV::Field::byteAlignedRangeInBits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a range of bits in the header that captures the byte aligned offset of this field within its header. </p>

</div>
</div>
<a id="ab80de3f3191e532be5fadb526f5eb744" name="ab80de3f3191e532be5fadb526f5eb744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab80de3f3191e532be5fadb526f5eb744">&#9670;&#160;</a></span>container_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHV::Field::container_bytes </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; <a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>bits</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of distinct container bytes that contain slices of the <code class="param">bits</code> of this field. </dd></dl>

</div>
</div>
<a id="a57ad303d4472f88019892e412296aa63" name="a57ad303d4472f88019892e412296aa63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57ad303d4472f88019892e412296aa63">&#9670;&#160;</a></span>deparsed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PHV::Field::deparsed </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>NB: Fields satisfying the deparsed constraint are not necessarily emitted. To determine whether a field is emitted by the deparser onto the wire, see <em class="arg">emitted_i</em>. </p>

</div>
</div>
<a id="a645488aa0046cbf0084c9d3497b2ebc3" name="a645488aa0046cbf0084c9d3497b2ebc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a645488aa0046cbf0084c9d3497b2ebc3">&#9670;&#160;</a></span>externalName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p4_1_1cstring.html">cstring</a> PHV::Field::externalName </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the external name of this field. If PHV::Field::externalName is not std::nullopt, use that; otherwise, use PHV::Field::name. </p>

</div>
</div>
<a id="a07440949e4fae928574c2d0ed26c52ea" name="a07440949e4fae928574c2d0ed26c52ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07440949e4fae928574c2d0ed26c52ea">&#9670;&#160;</a></span>for_bit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp; PHV::Field::for_bit </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>bit</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the PHV::AllocSlice in which field <code class="param">bit</code> is allocated. Fails catastrophically if <code class="param">bit</code> is not allocated or not within the range of this field's size. FIXME &ndash; should take an AllocContext and FieldUse like foreach_byte below? </dd></dl>

</div>
</div>
<a id="a1d1d944fe8d84f67d98ba20261b760a0" name="a1d1d944fe8d84f67d98ba20261b760a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d1d944fe8d84f67d98ba20261b760a0">&#9670;&#160;</a></span>foreach_alloc() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PHV::Field::foreach_alloc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> *</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_alloc_context.html">PHV::AllocContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctxt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> *</td>          <td class="paramname"><span class="paramname"><em>use</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;)&gt;</td>          <td class="paramname"><span class="paramname"><em>fn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SliceMatch</td>          <td class="paramname"><span class="paramname"><em>useTblRefs</em></span><span class="paramdefsep"> = </span><span class="paramdefval">SliceMatch::DFLT</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Equivalent to <code>foreach_alloc(StartLen(0, this-&gt;size), ctxt, use, fn)</code>, or to <code>foreach_alloc(ctxt, fn)</code> when <code class="param">r</code> is null.</p>
<dl class="section see"><dt>See also</dt><dd>foreach_alloc(le_bitrange, const IR::BFN::Unit *,
                   std::function&lt;void(const PHV::AllocSlice&amp;)&gt;). </dd></dl>

</div>
</div>
<a id="aa728164df95cd98f9d943e69a6675a3b" name="aa728164df95cd98f9d943e69a6675a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa728164df95cd98f9d943e69a6675a3b">&#9670;&#160;</a></span>foreach_alloc() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PHV::Field::foreach_alloc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_alloc_context.html">PHV::AllocContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctxt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> *</td>          <td class="paramname"><span class="paramname"><em>use</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;)&gt;</td>          <td class="paramname"><span class="paramname"><em>fn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SliceMatch</td>          <td class="paramname"><span class="paramname"><em>useTblRefs</em></span><span class="paramdefsep"> = </span><span class="paramdefval">SliceMatch::DFLT</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Equivalent to <code>foreach_alloc(StartLen(0, this-&gt;size), ctxt, fn)</code>.</p>
<dl class="section see"><dt>See also</dt><dd>foreach_alloc(le_bitrange, const IR::BFN::Unit *, const PHV::FieldUse&amp;,
                   std::function&lt;void(const PHV::AllocSlice&amp;)&gt;). </dd></dl>

</div>
</div>
<a id="afa850790d78f97f6b7aa3ca8de1d4e44" name="afa850790d78f97f6b7aa3ca8de1d4e44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa850790d78f97f6b7aa3ca8de1d4e44">&#9670;&#160;</a></span>foreach_alloc() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PHV::Field::foreach_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_alloc_context.html">PHV::AllocContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctxt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> *</td>          <td class="paramname"><span class="paramname"><em>use</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;)&gt;</td>          <td class="paramname"><span class="paramname"><em>fn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SliceMatch</td>          <td class="paramname"><span class="paramname"><em>useTblRefs</em></span><span class="paramdefsep"> = </span><span class="paramdefval">SliceMatch::DFLT</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply <code class="param">fn</code> to each PHV::AllocSlice within the specified <code class="param">ctxt</code> to which this has been allocated (if any). <code class="param">ctxt</code> can be one of ParserState, Table, Deparser, or null for no filter. <code class="param">use</code> can be READ or WRITE. For now, the context is the entire pipeline, as PHV allocation is global. </p>

</div>
</div>
<a id="aef007f89d88ad70e582927c9519c0b4d" name="aef007f89d88ad70e582927c9519c0b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef007f89d88ad70e582927c9519c0b4d">&#9670;&#160;</a></span>foreach_byte() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PHV::Field::foreach_byte </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> *</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_alloc_context.html">PHV::AllocContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctxt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> *</td>          <td class="paramname"><span class="paramname"><em>use</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;)&gt;</td>          <td class="paramname"><span class="paramname"><em>fn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SliceMatch</td>          <td class="paramname"><span class="paramname"><em>useTblRefs</em></span><span class="paramdefsep"> = </span><span class="paramdefval">SliceMatch::DFLT</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Equivalent to <code>foreach_byte(*r, fn)</code>, or <code>foreach_byte(StartLen(0, this-&gt;size), fn)</code> when <code class="param">r</code> is null.</p>
<dl class="section see"><dt>See also</dt><dd>foreach_byte(le_bitrange, std::function&lt;void(const PHV::AllocSlice&amp;)&gt;). </dd></dl>

</div>
</div>
<a id="af4d1afd09e3442906797d5af349508b2" name="af4d1afd09e3442906797d5af349508b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d1afd09e3442906797d5af349508b2">&#9670;&#160;</a></span>foreach_byte() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PHV::Field::foreach_byte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_alloc_context.html">PHV::AllocContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctxt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> *</td>          <td class="paramname"><span class="paramname"><em>use</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;)&gt;</td>          <td class="paramname"><span class="paramname"><em>fn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PHV::SliceMatch</td>          <td class="paramname"><span class="paramname"><em>useTblRefs</em></span><span class="paramdefsep"> = </span><span class="paramdefval">SliceMatch::DFLT</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For each byte-aligned container byte of each allocated slice of this field, construct an alloc_slice representing that allocated byte (or fraction thereof) and apply <code class="param">fn</code> to it, BUT ONLY if the container is NOT a TPHV container.</p>
<p>For example, suppose a 16b field (f) is allocated as follows:</p>
<p>C8 [4:0] &lt; f [15:11] C8 [7:7] &lt; f [10:10] C16 [9:0] &lt; f [9:0]</p>
<p>Where C8 is an 8b container and C16 is a 16b container.</p>
<p>Invoking `f-&gt;foreach_byte(1, 14, fn)` should invoke fn on the following alloc_slices (in this order):</p>
<p>C16 [7:1] &lt; f [7:1] C16 [9:8] &lt; f [9:8] C8 [7:7] &lt; f [10:10] C8 [3:0] &lt; f [14:11] </p>

</div>
</div>
<a id="a05070321f34c626e18accc2b4b18229c" name="a05070321f34c626e18accc2b4b18229c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05070321f34c626e18accc2b4b18229c">&#9670;&#160;</a></span>get_alloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_p4_1_1safe__vector.html">safe_vector</a>&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp; PHV::Field::get_alloc </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the PHV allocation for this field, if any. </dd></dl>

</div>
</div>
<a id="a5109d5b3aefc31cd3a504f2f0191a273" name="a5109d5b3aefc31cd3a504f2f0191a273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5109d5b3aefc31cd3a504f2f0191a273">&#9670;&#160;</a></span>get_combined_alloc_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; PHV::Field::get_combined_alloc_bytes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_alloc_context.html">PHV::AllocContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctxt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> *</td>          <td class="paramname"><span class="paramname"><em>use</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SliceMatch</td>          <td class="paramname"><span class="paramname"><em>useTblRefs</em></span><span class="paramdefsep"> = </span><span class="paramdefval">SliceMatch::DFLT</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a vector of PHV::AllocSlice, such that multiple PHV::AllocSlice within the same byte of the same container are combined into the same new PHV::AllocSlice. This is necessary because input crossbar allocation combines multiple slices of the same field in the same container into a single Use object. </dd></dl>

</div>
</div>
<a id="ab81afbdc01e19643677d9c58a45302a0" name="ab81afbdc01e19643677d9c58a45302a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab81afbdc01e19643677d9c58a45302a0">&#9670;&#160;</a></span>get_combined_alloc_slices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; PHV::Field::get_combined_alloc_slices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a></td>          <td class="paramname"><span class="paramname"><em>bits</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_alloc_context.html">PHV::AllocContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctxt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> *</td>          <td class="paramname"><span class="paramname"><em>use</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a vector of PHV::AllocSlice, such that multiple PHV::AllocSlice within the same container are combined into the same new PHV::AllocSlice, if the ranges of the two PHV::AllocSlice are contiguous. This is necessary because parser validation checks has this invariant. </dd></dl>

</div>
</div>
<a id="a4c4ca9afe978f5cb14e7860b6f87acfc" name="a4c4ca9afe978f5cb14e7860b6f87acfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c4ca9afe978f5cb14e7860b6f87acfc">&#9670;&#160;</a></span>getStartBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p4_1_1bitvec.html">bitvec</a> PHV::Field::getStartBits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_p_h_v.html#a3ff115c4ef9dcfb7a3565ddc263f0ece">PHV::Size</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the bit positions (little Endian) at which the least significant bit of this field may be placed. </dd></dl>

</div>
</div>
<a id="ad456ed5385ab9c7b5e0489da225d5e4b" name="ad456ed5385ab9c7b5e0489da225d5e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad456ed5385ab9c7b5e0489da225d5e4b">&#9670;&#160;</a></span>hasExternalName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PHV::Field::hasExternalName </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if this field as an external name set independently of its name. </dd></dl>

</div>
</div>
<a id="aa2a6d6b14acb95881dd97317b20d17a1" name="aa2a6d6b14acb95881dd97317b20d17a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2a6d6b14acb95881dd97317b20d17a1">&#9670;&#160;</a></span>header()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p4_1_1cstring.html">cstring</a> PHV::Field::header </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the header to which this field belongs. </dd></dl>

</div>
</div>
<a id="aaad1d2ab2a098e6d3c281bbf1615be09" name="aaad1d2ab2a098e6d3c281bbf1615be09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad1d2ab2a098e6d3c281bbf1615be09">&#9670;&#160;</a></span>is_tphv_candidate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PHV::Field::is_tphv_candidate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_phv_use.html">PhvUse</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>uses</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if this field can be placed in TPHV containers. </dd></dl>

</div>
</div>
<a id="acba26e64059e50345fe648aa6d6661de" name="acba26e64059e50345fe648aa6d6661de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba26e64059e50345fe648aa6d6661de">&#9670;&#160;</a></span>is_unallocated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PHV::Field::is_unallocated </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if there are no allocated slices of this field. </dd></dl>

</div>
</div>
<a id="a16320c02eef51398a1897f3745ce5be1" name="a16320c02eef51398a1897f3745ce5be1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16320c02eef51398a1897f3745ce5be1">&#9670;&#160;</a></span>isCompilerGeneratedPaddingField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PHV::Field::isCompilerGeneratedPaddingField </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the field has been generated by the compiler for padding marshalled fields. </dd></dl>

</div>
</div>
<a id="ad93ede68cb6db7baeec0e32680d166b2" name="ad93ede68cb6db7baeec0e32680d166b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad93ede68cb6db7baeec0e32680d166b2">&#9670;&#160;</a></span>isGhostField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PHV::Field::isGhostField </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the Field is a ghost field. TODO: Right now, ghost fields are marked as ingress fields, so we use string comparison for this method. Ideally, we should use the gress member directly and not have a separate ghost field. </dd></dl>

</div>
</div>
<a id="aa30be98d708c3b0d88fc582c4da0e81d" name="aa30be98d708c3b0d88fc582c4da0e81d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa30be98d708c3b0d88fc582c4da0e81d">&#9670;&#160;</a></span>isPacketField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PHV::Field::isPacketField </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if this field is a packet field. </dd></dl>

</div>
</div>
<a id="a163eb297d6f56ad9e6212cf6a7ce1845" name="a163eb297d6f56ad9e6212cf6a7ce1845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a163eb297d6f56ad9e6212cf6a7ce1845">&#9670;&#160;</a></span>setExternalName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PHV::Field::setExternalName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p4_1_1cstring.html">cstring</a></td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the external name of this field, which will be used in place of PHV::Field::name when generating assembly. </p>

</div>
</div>
<a id="a82512864023bb78386efe053ae8f07c2" name="a82512864023bb78386efe053ae8f07c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82512864023bb78386efe053ae8f07c2">&#9670;&#160;</a></span>setStartBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PHV::Field::setStartBits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_p_h_v.html#a3ff115c4ef9dcfb7a3565ddc263f0ece">PHV::Size</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1bitvec.html">bitvec</a></td>          <td class="paramname"><span class="paramname"><em>startPositions</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the valid starting bit positions (little Endian) for this field. For example, setStartBits(PHV::Size::b8, bitvec(0,1)) means that the least significant bit of this field must start at bit 0 in 8b containers. </p>

</div>
</div>
<a id="ae6d2f455b34713d10ecb41dc5f91b8b0" name="ae6d2f455b34713d10ecb41dc5f91b8b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d2f455b34713d10ecb41dc5f91b8b0">&#9670;&#160;</a></span>setStartBitsToLowerBitsOfBottomByte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PHV::Field::setStartBitsToLowerBitsOfBottomByte </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>setStartBitsToLowerBitsOfBottomByte will set the start bit of this field to be limited to the [0..x]-th (little endian) bit of any-sized containers, where x equals to (1) for field.size &lt;= 8-bit, x = 8 - size; (2) for 8 &lt; field.size &lt;= 16, x = 16 - size; (3) for 16 &lt; field.size, x = 7. </p>

</div>
</div>
<a id="ae7bb5db7971bcbe3b337b76583a5130e" name="ae7bb5db7971bcbe3b337b76583a5130e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7bb5db7971bcbe3b337b76583a5130e">&#9670;&#160;</a></span>updateAlignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PHV::Field::updateAlignment </td>
          <td>(</td>
          <td class="paramtype">PHV::AlignmentReason</td>          <td class="paramname"><span class="paramname"><em>reason</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_field_alignment.html">FieldAlignment</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>newAlignment</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1_util_1_1_source_info.html">Util::SourceInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>newAlignmentSource</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the alignment requirement for this field. Reports an error if conflicting requirements render the alignment unsatisfiable. </p>

</div>
</div>
<a id="a0a39a8e5fb79e8b4989634dbc2396a21" name="a0a39a8e5fb79e8b4989634dbc2396a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a39a8e5fb79e8b4989634dbc2396a21">&#9670;&#160;</a></span>updateValidContainerRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PHV::Field::updateValidContainerRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_p4.html#a19f5abed1a21ad7a5703944aa5099da7">nw_bitrange</a></td>          <td class="paramname"><span class="paramname"><em>newValidRange</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the valid range of container positions for this field. Reports an error if conflicting requirements render the constraint unsatisfiable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newValidRange</td><td>A new valid range constraint. This is intersected with any existing valid range constraint to produce a new overall valid container range for this field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1e0e91bc716c5af1c7c0c042478e535" name="af1e0e91bc716c5af1c7c0c042478e535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1e0e91bc716c5af1c7c0c042478e535">&#9670;&#160;</a></span>validContainerRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_p4.html#a19f5abed1a21ad7a5703944aa5099da7">nw_bitrange</a> PHV::Field::validContainerRange </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The range of possible bit positions at which this field can be placed in a container, in network order. For example, suppose we have an 8-bit field with <code>validContainerRange = [0, 11]</code> and a 16-bit container. </p><pre class="fragment"> 0              15  (network order)
</pre><p> | -------------&mdash; | container ^ ^ X Y</p>
<p>The entire field must be placed between X and Y (inclusive).</p>
<p>Note that field--&gt;container assignment is usually in <em>little Endian</em>. From that perspective the picture looks like: </p><pre class="fragment"> 15             0   (little Endian order)
</pre><p> | -------------&mdash; | container ^ ^ X Y</p>
<p>And so the field must be placed in what are considered the "upper" bits of the container.</p>
<p>TODO: This range always starts at 0, which is an invariant that other parts of the compiler rely on. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ab3cc4195b4753cdfd96d7304f634168c" name="ab3cc4195b4753cdfd96d7304f634168c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3cc4195b4753cdfd96d7304f634168c">&#9670;&#160;</a></span>aliasSource</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a>* PHV::Field::aliasSource = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If this field is an alias destination, then maintain a pointer to the alias source. Alias destinations are the canonical representation for alias sources.</p>
<p>For example, if we have </p><div class="fragment"><div class="line">@pa_alias(<span class="stringliteral">&quot;ingress&quot;</span>, <span class="stringliteral">&quot;h.f&quot;</span>, <span class="stringliteral">&quot;h.f1&quot;</span>)</div>
<div class="line">@pa_alias(<span class="stringliteral">&quot;ingress&quot;</span>, <span class="stringliteral">&quot;h.f&quot;</span>, <span class="stringliteral">&quot;h.f2&quot;</span>)</div>
</div><!-- fragment --><p>then h.f (the first field mentioned in each annotation) is an alias destination for h.f1 and h.f2, which are sources (the second field in each annotation). The ReplaceAllAliases pass replaces references to h.f1 with an h.f reference that has h.f1 as its alias source, and similarly for references to h.f2. </p>

</div>
</div>
<a id="a086243ace1d14197dac4311827936006" name="a086243ace1d14197dac4311827936006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a086243ace1d14197dac4311827936006">&#9670;&#160;</a></span>alignment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;<a class="el" href="struct_field_alignment.html">FieldAlignment</a>&gt; PHV::Field::alignment</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The alignment requirement of this field. If std::nullopt, there is no particular alignment requirement. </p>

</div>
</div>
<a id="a4c9d3ef11d7a6187281901a38f54972c" name="a4c9d3ef11d7a6187281901a38f54972c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c9d3ef11d7a6187281901a38f54972c">&#9670;&#160;</a></span>invalidate_from_arch_i</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PHV::Field::invalidate_from_arch_i = false</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>True if this field needs to invalid when reaching the deparser and is not written by the user (on Tofino). </p>

</div>
</div>
<a id="a6dc1459985650d5003fe4638787556c8" name="a6dc1459985650d5003fe4638787556c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dc1459985650d5003fe4638787556c8">&#9670;&#160;</a></span>name</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p4_1_1cstring.html">cstring</a> PHV::Field::name</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Field name, following this scheme:</p><ul>
<li>"gress::header.field"</li>
<li>"gress::header.field[i]" where "i" is a positive integer</li>
<li>"gress::header.$valid" </li>
</ul>

</div>
</div>
<a id="a126872581bb3cff5a10369cfe932351c" name="a126872581bb3cff5a10369cfe932351c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a126872581bb3cff5a10369cfe932351c">&#9670;&#160;</a></span>overlayable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PHV::Field::overlayable = false</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>True if this Field can always be overlayable with other fields. Used for padding fields for bridged metadata. </p>

</div>
</div>
<a id="a0311021b775df3f9a3c5cc1f458d7eb4" name="a0311021b775df3f9a3c5cc1f458d7eb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0311021b775df3f9a3c5cc1f458d7eb4">&#9670;&#160;</a></span>validContainerRange_i</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_p4.html#a19f5abed1a21ad7a5703944aa5099da7">nw_bitrange</a> PHV::Field::validContainerRange_i = <a class="el" href="struct_p4_1_1_bit_range_1_1_zero_to_max.html">ZeroToMax</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>Field::validContainerRange(). </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_p_h_v.html">PHV</a></li><li class="navelem"><a class="el" href="class_p_h_v_1_1_field.html">Field</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
