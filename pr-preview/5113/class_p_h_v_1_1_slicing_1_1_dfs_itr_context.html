<!-- HTML header for doxygen 1.13.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>P4 Compiler Documentation (P4C): PHV::Slicing::DfsItrContext Class Reference</title>
<link rel="icon" href="p4-fav.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!--  Add link to paragraphs   -->
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
  DoxygenAwesomeParagraphLink.init()
</script>
<!-- Add copy button to code fragments  -->
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
  DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add dark mode toggle -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
  DoxygenAwesomeDarkModeToggle.init()
</script>
<!-- Add interactive TOC -->
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
  DoxygenAwesomeInteractiveToc.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-interactive-toc.js" rel="stylesheet" type="text/css"/>
<link href="cards.css" rel="stylesheet" type="text/css"/>
<link href="flow.css" rel="stylesheet" type="text/css"/>
<link href="p4c_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="p4-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">P4C
   </div>
   <div id="projectbrief">The P4 Compiler</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_p_h_v_1_1_slicing_1_1_dfs_itr_context.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="class_p_h_v_1_1_slicing_1_1_dfs_itr_context-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">PHV::Slicing::DfsItrContext Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="phv__slicing__dfs__iterator_8h_source.html">phv_slicing_dfs_iterator.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PHV::Slicing::DfsItrContext:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_p_h_v_1_1_slicing_1_1_dfs_itr_context__inherit__graph.svg" width="224" height="110"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa238bda51dd4caa6eb647e986b7c4dbe" id="r_aa238bda51dd4caa6eb647e986b7c4dbe"><td class="memItemLeft" align="right" valign="top"><a id="aa238bda51dd4caa6eb647e986b7c4dbe" name="aa238bda51dd4caa6eb647e986b7c4dbe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DfsItrContext</b> (const <a class="el" href="class_phv_info.html">PhvInfo</a> &amp;phv, const <a class="el" href="class_map_field_to_parser_states.html">MapFieldToParserStates</a> &amp;field_to_states, const <a class="el" href="group__parde.html">CollectParserInfo</a> &amp;parser_info, const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *sc, const <a class="el" href="class_p4_1_1ordered__map.html">PHVContainerSizeLayout</a> &amp;pa, const <a class="el" href="class_p_h_v_1_1_action_packing_validator_interface.html">ActionPackingValidatorInterface</a> &amp;action_packing_validator, const <a class="el" href="class_p_h_v_1_1_parser_packing_validator_interface.html">ParserPackingValidatorInterface</a> &amp;parser_packing_validator, const PackConflictChecker &amp;pack_conflict, const IsReferencedChecker is_used)</td></tr>
<tr class="separator:aa238bda51dd4caa6eb647e986b7c4dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1559d3f074de251a997230dcade715b" id="r_ad1559d3f074de251a997230dcade715b"><td class="memItemLeft" align="right" valign="top"><a id="ad1559d3f074de251a997230dcade715b" name="ad1559d3f074de251a997230dcade715b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>check_duplicate_slicing_plan</b> (const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> * &gt;)</td></tr>
<tr class="separator:ad1559d3f074de251a997230dcade715b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41627cce81c43fda9116574f908cc5d" id="r_ab41627cce81c43fda9116574f908cc5d"><td class="memItemLeft" align="right" valign="top"><a id="ab41627cce81c43fda9116574f908cc5d" name="ab41627cce81c43fda9116574f908cc5d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>check_pack_conflict</b> (const SuperCluster::SliceList *sl) const</td></tr>
<tr class="memdesc:ab41627cce81c43fda9116574f908cc5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">return true if there are pack_conflicts in <code class="param">sl</code>. <br /></td></tr>
<tr class="separator:ab41627cce81c43fda9116574f908cc5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ecac4674c8871ada91ab91eab84624b" id="r_a8ecac4674c8871ada91ab91eab84624b"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="class_p4_1_1ordered__map.html">SplitDecision</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ecac4674c8871ada91ab91eab84624b">collect_aftersplit_constraints</a> (const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *sc) const</td></tr>
<tr class="separator:a8ecac4674c8871ada91ab91eab84624b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5d2cc420574cfb47f21246c437f324" id="r_aaf5d2cc420574cfb47f21246c437f324"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf5d2cc420574cfb47f21246c437f324">collect_implicit_container_sz_constraint</a> (<a class="el" href="class_p4_1_1ordered__map.html">SplitDecision</a> *decided_sz, const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *sc) const</td></tr>
<tr class="separator:aaf5d2cc420574cfb47f21246c437f324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89805465f6db6bf358839991257e11d1" id="r_a89805465f6db6bf358839991257e11d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89805465f6db6bf358839991257e11d1">dfs</a> (const IterateCb &amp;yield, const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> * &gt; &amp;unchecked)</td></tr>
<tr class="separator:a89805465f6db6bf358839991257e11d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c0f28d6cac77c3cf15bd269f9c2d6de" id="r_a8c0f28d6cac77c3cf15bd269f9c2d6de"><td class="memItemLeft" align="right" valign="top">std::optional&lt; SliceListLoc &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c0f28d6cac77c3cf15bd269f9c2d6de">dfs_pick_next</a> () const</td></tr>
<tr class="separator:a8c0f28d6cac77c3cf15bd269f9c2d6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45777503ff86a4253d808351ae0cbc0" id="r_ad45777503ff86a4253d808351ae0cbc0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad45777503ff86a4253d808351ae0cbc0">dfs_prune</a> (const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> * &gt; &amp;unchecked)</td></tr>
<tr class="separator:ad45777503ff86a4253d808351ae0cbc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9f1ad4e92cbd49a7d6aec2303a14f1" id="r_acf9f1ad4e92cbd49a7d6aec2303a14f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf9f1ad4e92cbd49a7d6aec2303a14f1">dfs_prune_invalid_packing</a> (const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *sc)</td></tr>
<tr class="separator:acf9f1ad4e92cbd49a7d6aec2303a14f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950601557c105a752c206db072251ab3" id="r_a950601557c105a752c206db072251ab3"><td class="memItemLeft" align="right" valign="top"><a id="a950601557c105a752c206db072251ab3" name="a950601557c105a752c206db072251ab3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>dfs_prune_invalid_parser_packing</b> (const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *sc) const</td></tr>
<tr class="separator:a950601557c105a752c206db072251ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ab43c146785d672b2250ddc402011d" id="r_a61ab43c146785d672b2250ddc402011d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61ab43c146785d672b2250ddc402011d">dfs_prune_unsat_exact_list_size_mismatch</a> (const <a class="el" href="class_p4_1_1ordered__map.html">SplitDecision</a> &amp;decided_sz, const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *sc) const</td></tr>
<tr class="separator:a61ab43c146785d672b2250ddc402011d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ee851ac5a50c6baaa7f10b6a9092fb" id="r_a66ee851ac5a50c6baaa7f10b6a9092fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66ee851ac5a50c6baaa7f10b6a9092fb">dfs_prune_unsat_slicelist_constraints</a> (const <a class="el" href="class_p4_1_1ordered__map.html">SplitDecision</a> &amp;constraints, const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *sc) const</td></tr>
<tr class="separator:a66ee851ac5a50c6baaa7f10b6a9092fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d30d96f078f3f05b358b94bbb15544" id="r_a17d30d96f078f3f05b358b94bbb15544"><td class="memItemLeft" align="right" valign="top"><a id="a17d30d96f078f3f05b358b94bbb15544" name="a17d30d96f078f3f05b358b94bbb15544"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>dfs_prune_unsat_slicelist_max_size</b> (const <a class="el" href="class_p4_1_1ordered__map.html">SplitDecision</a> &amp;constraints, const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *sc) const</td></tr>
<tr class="memdesc:a17d30d96f078f3f05b358b94bbb15544"><td class="mdescLeft">&#160;</td><td class="mdescRight">return true if exists constraint unsat due to the limit of slice list size. <br /></td></tr>
<tr class="separator:a17d30d96f078f3f05b358b94bbb15544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad42a1c1f353813e10d379106d5f46825" id="r_ad42a1c1f353813e10d379106d5f46825"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad42a1c1f353813e10d379106d5f46825">dfs_prune_unwell_formed</a> (const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *sc) const</td></tr>
<tr class="separator:ad42a1c1f353813e10d379106d5f46825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e9e5f566dc7d749d05589c39a4c46d" id="r_ac2e9e5f566dc7d749d05589c39a4c46d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2e9e5f566dc7d749d05589c39a4c46d">get_well_formed_no_more_split</a> () const</td></tr>
<tr class="separator:ac2e9e5f566dc7d749d05589c39a4c46d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f787949b1cdcff13440d4d05bee4d31" id="r_a1f787949b1cdcff13440d4d05bee4d31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f787949b1cdcff13440d4d05bee4d31">invalidate</a> (const SuperCluster::SliceList *sl) override</td></tr>
<tr class="separator:a1f787949b1cdcff13440d4d05bee4d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b14d44527ff91d55e303589d45ed54b" id="r_a0b14d44527ff91d55e303589d45ed54b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b14d44527ff91d55e303589d45ed54b">iterate</a> (const IterateCb &amp;cb) override</td></tr>
<tr class="memdesc:a0b14d44527ff91d55e303589d45ed54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterate will pass valid slicing results to cb. Stop when cb returns false.  <br /></td></tr>
<tr class="separator:a0b14d44527ff91d55e303589d45ed54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b2f01abca38bd51aa7416c2619b91a" id="r_a21b2f01abca38bd51aa7416c2619b91a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; SplitChoice &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21b2f01abca38bd51aa7416c2619b91a">make_choices</a> (const SliceListLoc &amp;target) const</td></tr>
<tr class="separator:a21b2f01abca38bd51aa7416c2619b91a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6308eb392cd1ca97ade76510ae4443fc" id="r_a6308eb392cd1ca97ade76510ae4443fc"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::pair&lt; <a class="el" href="class_p4_1_1ordered__map.html">SplitSchema</a>, <a class="el" href="class_p4_1_1ordered__map.html">SplitDecision</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6308eb392cd1ca97ade76510ae4443fc">make_split_meta</a> (<a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *sc, SuperCluster::SliceList *sl, int first_n_bits) const</td></tr>
<tr class="separator:a6308eb392cd1ca97ade76510ae4443fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d965bf98c72016c6c6c14711efc5b1d" id="r_a6d965bf98c72016c6c6c14711efc5b1d"><td class="memItemLeft" align="right" valign="top"><a id="a6d965bf98c72016c6c6c14711efc5b1d" name="a6d965bf98c72016c6c6c14711efc5b1d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>need_further_split</b> (const SuperCluster::SliceList *sl) const</td></tr>
<tr class="memdesc:a6d965bf98c72016c6c6c14711efc5b1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">return true if the slicelist needs to be further split. <br /></td></tr>
<tr class="separator:a6d965bf98c72016c6c6c14711efc5b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746a59bc716622b79fbaf9f90c594a94" id="r_a746a59bc716622b79fbaf9f90c594a94"><td class="memItemLeft" align="right" valign="top"><a id="a746a59bc716622b79fbaf9f90c594a94" name="a746a59bc716622b79fbaf9f90c594a94"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>need_to_check_duplicate</b> ()</td></tr>
<tr class="separator:a746a59bc716622b79fbaf9f90c594a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d0f113fce9d41fb25d9de4e704a62f" id="r_a06d0f113fce9d41fb25d9de4e704a62f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06d0f113fce9d41fb25d9de4e704a62f">propagate_8bit_exact_container_split</a> (<a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *sc, SuperCluster::SliceList *target, <a class="el" href="class_p4_1_1ordered__map.html">SplitSchema</a> *schema, <a class="el" href="class_p4_1_1ordered__map.html">SplitDecision</a> *decisions) const</td></tr>
<tr class="separator:a06d0f113fce9d41fb25d9de4e704a62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ac432dfc05f0c106db4e22099c2ea8" id="r_a84ac432dfc05f0c106db4e22099c2ea8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84ac432dfc05f0c106db4e22099c2ea8">propagate_tail_split</a> (<a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *sc, const <a class="el" href="class_p4_1_1ordered__map.html">SplitDecision</a> &amp;constraints, const <a class="el" href="class_p4_1_1ordered__map.html">SplitDecision</a> *decisions, const SuperCluster::SliceList *just_split_target, const int n_just_split_bits, <a class="el" href="class_p4_1_1ordered__map.html">SplitSchema</a> *schema) const</td></tr>
<tr class="separator:a84ac432dfc05f0c106db4e22099c2ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ab8a3ad1ff84047c2f3be1cbef44a7" id="r_ab4ab8a3ad1ff84047c2f3be1cbef44a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4ab8a3ad1ff84047c2f3be1cbef44a7">set_config</a> (const <a class="el" href="struct_p_h_v_1_1_slicing_1_1_iterator_config.html">IteratorConfig</a> &amp;cfg) override</td></tr>
<tr class="memdesc:ab4ab8a3ad1ff84047c2f3be1cbef44a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">set configs.  <br /></td></tr>
<tr class="separator:ab4ab8a3ad1ff84047c2f3be1cbef44a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f118e03da4bdacd709b951cdc9ebc4" id="r_a87f118e03da4bdacd709b951cdc9ebc4"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::list&lt; <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87f118e03da4bdacd709b951cdc9ebc4">split_by_adjacent_deparsed_and_non_deparsed</a> (<a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *sc) const</td></tr>
<tr class="separator:a87f118e03da4bdacd709b951cdc9ebc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9bee7fc4668caf3c77b2546cee8e881" id="r_ab9bee7fc4668caf3c77b2546cee8e881"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::list&lt; <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9bee7fc4668caf3c77b2546cee8e881">split_by_adjacent_no_pack</a> (<a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *sc) const</td></tr>
<tr class="separator:ab9bee7fc4668caf3c77b2546cee8e881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e0d0163bf07b975084e64cc67cad1a" id="r_a33e0d0163bf07b975084e64cc67cad1a"><td class="memItemLeft" align="right" valign="top"><a id="a33e0d0163bf07b975084e64cc67cad1a" name="a33e0d0163bf07b975084e64cc67cad1a"></a>
std::optional&lt; std::list&lt; <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>split_by_deparsed_bottom_bits</b> (<a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *sc) const</td></tr>
<tr class="memdesc:a33e0d0163bf07b975084e64cc67cad1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">split_by_deparsed_bottom_bits will split at the beginning of deparsed_bottom_bits field. <br /></td></tr>
<tr class="separator:a33e0d0163bf07b975084e64cc67cad1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80acfa386f9930e63e1ee25992685aa1" id="r_a80acfa386f9930e63e1ee25992685aa1"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::list&lt; <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80acfa386f9930e63e1ee25992685aa1">split_by_long_fieldslices</a> (<a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *sc) const</td></tr>
<tr class="separator:a80acfa386f9930e63e1ee25992685aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626198dd52de343caae5a662ad155672" id="r_a626198dd52de343caae5a662ad155672"><td class="memItemLeft" align="right" valign="top"><a id="a626198dd52de343caae5a662ad155672" name="a626198dd52de343caae5a662ad155672"></a>
std::optional&lt; std::list&lt; <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>split_by_pa_container_size</b> (const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *sc, const <a class="el" href="class_p4_1_1ordered__map.html">PHVContainerSizeLayout</a> &amp;pa)</td></tr>
<tr class="memdesc:a626198dd52de343caae5a662ad155672"><td class="mdescLeft">&#160;</td><td class="mdescRight">split_by_pa_container_size will split <code class="param">sc</code> by <code class="param">pa</code> container size. <br /></td></tr>
<tr class="separator:a626198dd52de343caae5a662ad155672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3184998e8badb0cbec60d6aaa8078d" id="r_afd3184998e8badb0cbec60d6aaa8078d"><td class="memItemLeft" align="right" valign="top"><a id="afd3184998e8badb0cbec60d6aaa8078d" name="afd3184998e8badb0cbec60d6aaa8078d"></a>
std::optional&lt; std::list&lt; <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>split_by_parser_write_mode</b> (<a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *sc)</td></tr>
<tr class="memdesc:afd3184998e8badb0cbec60d6aaa8078d"><td class="mdescLeft">&#160;</td><td class="mdescRight">split_by_parser_write_mode will split based on incompatible parser write modes <br /></td></tr>
<tr class="separator:afd3184998e8badb0cbec60d6aaa8078d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68bf14e98ee4ccb6a8199149b2026f73" id="r_a68bf14e98ee4ccb6a8199149b2026f73"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::list&lt; <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68bf14e98ee4ccb6a8199149b2026f73">split_by_valid_container_range</a> (<a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *sc) const</td></tr>
<tr class="separator:a68bf14e98ee4ccb6a8199149b2026f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:abab153da852e3be1de4b15d17e787d85" id="r_abab153da852e3be1de4b15d17e787d85"><td class="memItemLeft" align="right" valign="top"><a id="abab153da852e3be1de4b15d17e787d85" name="abab153da852e3be1de4b15d17e787d85"></a>
const <a class="el" href="class_p_h_v_1_1_action_packing_validator_interface.html">ActionPackingValidatorInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>action_packing_validator_i</b></td></tr>
<tr class="separator:abab153da852e3be1de4b15d17e787d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd8b6441722b153a1ff443cdee99f8f" id="r_a9dd8b6441722b153a1ff443cdee99f8f"><td class="memItemLeft" align="right" valign="top"><a id="a9dd8b6441722b153a1ff443cdee99f8f" name="a9dd8b6441722b153a1ff443cdee99f8f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>check_duplicate</b> = -1</td></tr>
<tr class="separator:a9dd8b6441722b153a1ff443cdee99f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49aab5acf2e937aca2afdf2898b2956b" id="r_a49aab5acf2e937aca2afdf2898b2956b"><td class="memItemLeft" align="right" valign="top"><a id="a49aab5acf2e937aca2afdf2898b2956b" name="a49aab5acf2e937aca2afdf2898b2956b"></a>
<a class="el" href="struct_check_write_mode_consistency.html">CheckWriteModeConsistency</a>&#160;</td><td class="memItemRight" valign="bottom"><b>check_write_mode_consistency_i</b></td></tr>
<tr class="separator:a49aab5acf2e937aca2afdf2898b2956b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc4a022a5605ad9fbb25fec4160f4c4" id="r_a2dc4a022a5605ad9fbb25fec4160f4c4"><td class="memItemLeft" align="right" valign="top"><a id="a2dc4a022a5605ad9fbb25fec4160f4c4" name="a2dc4a022a5605ad9fbb25fec4160f4c4"></a>
<a class="el" href="struct_p_h_v_1_1_slicing_1_1_iterator_config.html">IteratorConfig</a>&#160;</td><td class="memItemRight" valign="bottom"><b>config_i</b></td></tr>
<tr class="separator:a2dc4a022a5605ad9fbb25fec4160f4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f0c9874b1a058a1bd7ea0a91c56af3" id="r_aa6f0c9874b1a058a1bd7ea0a91c56af3"><td class="memItemLeft" align="right" valign="top"><a id="aa6f0c9874b1a058a1bd7ea0a91c56af3" name="aa6f0c9874b1a058a1bd7ea0a91c56af3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>dfs_depth_i</b> = 0</td></tr>
<tr class="separator:aa6f0c9874b1a058a1bd7ea0a91c56af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d5a91542cf6cb8f21a9021834b9c6e3" id="r_a6d5a91542cf6cb8f21a9021834b9c6e3"><td class="memItemLeft" align="right" valign="top"><a id="a6d5a91542cf6cb8f21a9021834b9c6e3" name="a6d5a91542cf6cb8f21a9021834b9c6e3"></a>
<a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>done_i</b></td></tr>
<tr class="separator:a6d5a91542cf6cb8f21a9021834b9c6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f89ccf4fd6d02f4f42c1347fa2531f" id="r_af8f89ccf4fd6d02f4f42c1347fa2531f"><td class="memItemLeft" align="right" valign="top"><a id="af8f89ccf4fd6d02f4f42c1347fa2531f" name="af8f89ccf4fd6d02f4f42c1347fa2531f"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>duplicate_check_supercluster_size</b> = 5</td></tr>
<tr class="separator:af8f89ccf4fd6d02f4f42c1347fa2531f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ca6b88beb31be777cf6d736fb77fc4" id="r_a92ca6b88beb31be777cf6d736fb77fc4"><td class="memItemLeft" align="right" valign="top"><a id="a92ca6b88beb31be777cf6d736fb77fc4" name="a92ca6b88beb31be777cf6d736fb77fc4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_itr_i</b> = false</td></tr>
<tr class="separator:a92ca6b88beb31be777cf6d736fb77fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e64c433d0281cc67df3be183707888b" id="r_a6e64c433d0281cc67df3be183707888b"><td class="memItemLeft" align="right" valign="top"><a id="a6e64c433d0281cc67df3be183707888b" name="a6e64c433d0281cc67df3be183707888b"></a>
const PackConflictChecker&#160;</td><td class="memItemRight" valign="bottom"><b>has_pack_conflict_i</b></td></tr>
<tr class="separator:a6e64c433d0281cc67df3be183707888b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabfc956a351676b8a31d549d2cd95bed" id="r_aabfc956a351676b8a31d549d2cd95bed"><td class="memItemLeft" align="right" valign="top"><a id="aabfc956a351676b8a31d549d2cd95bed" name="aabfc956a351676b8a31d549d2cd95bed"></a>
const IsReferencedChecker&#160;</td><td class="memItemRight" valign="bottom"><b>is_used_i</b></td></tr>
<tr class="separator:aabfc956a351676b8a31d549d2cd95bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7779e28e4cc376b17b69c971575731" id="r_aca7779e28e4cc376b17b69c971575731"><td class="memItemLeft" align="right" valign="top"><a id="aca7779e28e4cc376b17b69c971575731" name="aca7779e28e4cc376b17b69c971575731"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>n_steps_i</b> = 0</td></tr>
<tr class="separator:aca7779e28e4cc376b17b69c971575731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff89ded6ddd646a4fca3c057e4d10b9" id="r_acff89ded6ddd646a4fca3c057e4d10b9"><td class="memItemLeft" align="right" valign="top"><a id="acff89ded6ddd646a4fca3c057e4d10b9" name="acff89ded6ddd646a4fca3c057e4d10b9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>n_steps_since_last_solution</b> = 0</td></tr>
<tr class="separator:acff89ded6ddd646a4fca3c057e4d10b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7514b596ec58170b42b2afc67638eadf" id="r_a7514b596ec58170b42b2afc67638eadf"><td class="memItemLeft" align="right" valign="top"><a id="a7514b596ec58170b42b2afc67638eadf" name="a7514b596ec58170b42b2afc67638eadf"></a>
<a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt; const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *, std::pair&lt; <a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a>, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pa_container_size_upcastings_i</b></td></tr>
<tr class="separator:a7514b596ec58170b42b2afc67638eadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e0dad026b9d5758049191d4d3e54b0" id="r_ab0e0dad026b9d5758049191d4d3e54b0"><td class="memItemLeft" align="right" valign="top"><a id="ab0e0dad026b9d5758049191d4d3e54b0" name="ab0e0dad026b9d5758049191d4d3e54b0"></a>
const <a class="el" href="class_p4_1_1ordered__map.html">PHVContainerSizeLayout</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pa_i</b></td></tr>
<tr class="separator:ab0e0dad026b9d5758049191d4d3e54b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2079b29d3ecb4cc843baf552bfbc99" id="r_a9c2079b29d3ecb4cc843baf552bfbc99"><td class="memItemLeft" align="right" valign="top"><a id="a9c2079b29d3ecb4cc843baf552bfbc99" name="a9c2079b29d3ecb4cc843baf552bfbc99"></a>
const <a class="el" href="class_p_h_v_1_1_parser_packing_validator_interface.html">ParserPackingValidatorInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>parser_packing_validator_i</b></td></tr>
<tr class="separator:a9c2079b29d3ecb4cc843baf552bfbc99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46326e397b902237e31ab336cf56f1c0" id="r_a46326e397b902237e31ab336cf56f1c0"><td class="memItemLeft" align="right" valign="top"><a id="a46326e397b902237e31ab336cf56f1c0" name="a46326e397b902237e31ab336cf56f1c0"></a>
const <a class="el" href="class_phv_info.html">PhvInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>phv_i</b></td></tr>
<tr class="separator:a46326e397b902237e31ab336cf56f1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787a6c67da03612fa7f1c236dfcc3ef2" id="r_a787a6c67da03612fa7f1c236dfcc3ef2"><td class="memItemLeft" align="right" valign="top"><a id="a787a6c67da03612fa7f1c236dfcc3ef2" name="a787a6c67da03612fa7f1c236dfcc3ef2"></a>
std::set&lt; SplitChoice &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>reject_sizes</b></td></tr>
<tr class="separator:a787a6c67da03612fa7f1c236dfcc3ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5755ccd13c40082aa5ddb2c761898f" id="r_afb5755ccd13c40082aa5ddb2c761898f"><td class="memItemLeft" align="right" valign="top"><a id="afb5755ccd13c40082aa5ddb2c761898f" name="afb5755ccd13c40082aa5ddb2c761898f"></a>
const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>sc_i</b></td></tr>
<tr class="separator:afb5755ccd13c40082aa5ddb2c761898f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0015ee44024f3c9f9b0681161af15348" id="r_a0015ee44024f3c9f9b0681161af15348"><td class="memItemLeft" align="right" valign="top"><a id="a0015ee44024f3c9f9b0681161af15348" name="a0015ee44024f3c9f9b0681161af15348"></a>
std::vector&lt; const SuperCluster::SliceList * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>slicelist_on_stack_i</b></td></tr>
<tr class="separator:a0015ee44024f3c9f9b0681161af15348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3ccea152fd85563b6b978d3396d0bd" id="r_a0f3ccea152fd85563b6b978d3396d0bd"><td class="memItemLeft" align="right" valign="top"><a id="a0f3ccea152fd85563b6b978d3396d0bd" name="a0f3ccea152fd85563b6b978d3396d0bd"></a>
<a class="el" href="classassoc_1_1hash__map.html">assoc::hash_map</a>&lt; <a class="el" href="class_p_h_v_1_1_field_slice.html">FieldSlice</a>, <a class="el" href="struct_p_h_v_1_1_slicing_1_1_after_split_constraint.html">AfterSplitConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>split_decisions_i</b></td></tr>
<tr class="separator:a0f3ccea152fd85563b6b978d3396d0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac77316328fe74b58effcfbba37b6064" id="r_aac77316328fe74b58effcfbba37b6064"><td class="memItemLeft" align="right" valign="top"><a id="aac77316328fe74b58effcfbba37b6064" name="aac77316328fe74b58effcfbba37b6064"></a>
<a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>to_be_split_i</b></td></tr>
<tr class="separator:aac77316328fe74b58effcfbba37b6064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62700cd851165f6cf5533c23c5f5903d" id="r_a62700cd851165f6cf5533c23c5f5903d"><td class="memItemLeft" align="right" valign="top"><a id="a62700cd851165f6cf5533c23c5f5903d" name="a62700cd851165f6cf5533c23c5f5903d"></a>
const SuperCluster::SliceList *&#160;</td><td class="memItemRight" valign="bottom"><b>to_invalidate</b> = nullptr</td></tr>
<tr class="separator:a62700cd851165f6cf5533c23c5f5903d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9360012a77a59baa6496c1db873ce748" id="r_a9360012a77a59baa6496c1db873ce748"><td class="memItemLeft" align="right" valign="top"><a id="a9360012a77a59baa6496c1db873ce748" name="a9360012a77a59baa6496c1db873ce748"></a>
<a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt; const SuperCluster::SliceList *, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>to_invalidate_sl_counter</b></td></tr>
<tr class="separator:a9360012a77a59baa6496c1db873ce748"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a016a0281dfa1cd5ca560577b4d1883a2" id="r_a016a0281dfa1cd5ca560577b4d1883a2"><td class="memItemLeft" align="right" valign="top"><a id="a016a0281dfa1cd5ca560577b4d1883a2" name="a016a0281dfa1cd5ca560577b4d1883a2"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>to_invalidate_max_ignore</b> = 8</td></tr>
<tr class="separator:a016a0281dfa1cd5ca560577b4d1883a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>DfsItrContext implements the Slicing Iterator using DFS. Because caller won't be using DfsItrContext directly(protected by pImpl), to make white-box testing possible, all functions are public. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a8ecac4674c8871ada91ab91eab84624b" name="a8ecac4674c8871ada91ab91eab84624b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ecac4674c8871ada91ab91eab84624b">&#9670;&#160;</a></span>collect_aftersplit_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="class_p4_1_1ordered__map.html">SplitDecision</a> &gt; PHV::Slicing::DfsItrContext::collect_aftersplit_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *</td>          <td class="paramname"><span class="paramname"><em>sc</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>collect_aftersplit_constraints returns AfterSplitConstraints on the fieldslice of <code class="param">sc</code> based on split_decisions_i and pa_container_size_upcastings_i. </p>

</div>
</div>
<a id="aaf5d2cc420574cfb47f21246c437f324" name="aaf5d2cc420574cfb47f21246c437f324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf5d2cc420574cfb47f21246c437f324">&#9670;&#160;</a></span>collect_implicit_container_sz_constraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PHV::Slicing::DfsItrContext::collect_implicit_container_sz_constraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p4_1_1ordered__map.html">SplitDecision</a> *</td>          <td class="paramname"><span class="paramname"><em>decided_sz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *</td>          <td class="paramname"><span class="paramname"><em>sc</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>collect additional implicit container size constraint and save them to <code class="param">decided_sz</code>, if it can be expressed. Otherwise, if will only check whether the implicit container size constraint can be satisfied. TODO: this function is created initially for the most common case of egress::eg_intr_md.egress_port that has (1) ^bit[0..15]; (2) no_split; (3) deparsed_bottom_bits because of these three constraints, this field can only be allocated to 16-bit container. There can be more special cases for these implicit (hard to be generalized). </p>

</div>
</div>
<a id="a89805465f6db6bf358839991257e11d1" name="a89805465f6db6bf358839991257e11d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89805465f6db6bf358839991257e11d1">&#9670;&#160;</a></span>dfs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PHV::Slicing::DfsItrContext::dfs </td>
          <td>(</td>
          <td class="paramtype">const IterateCb &amp;</td>          <td class="paramname"><span class="paramname"><em>yield</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>unchecked</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>dfs search valid slicing. <code class="param">unchecked</code> are superclusters that needs to be checked for pruning. </p>

</div>
</div>
<a id="a8c0f28d6cac77c3cf15bd269f9c2d6de" name="a8c0f28d6cac77c3cf15bd269f9c2d6de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c0f28d6cac77c3cf15bd269f9c2d6de">&#9670;&#160;</a></span>dfs_pick_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; SliceListLoc &gt; PHV::Slicing::DfsItrContext::dfs_pick_next </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>dfs_pick_next return the next slice list to be split. There are some heuristics for returning the slicelist that has most constraints. </p>

</div>
</div>
<a id="ad45777503ff86a4253d808351ae0cbc0" name="ad45777503ff86a4253d808351ae0cbc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad45777503ff86a4253d808351ae0cbc0">&#9670;&#160;</a></span>dfs_prune()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PHV::Slicing::DfsItrContext::dfs_prune </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>unchecked</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>pruning strategies return true if found any unsatisfactory case. This function will return true if any of the following pruning strategies returns true. TODO: non-const because it may call invalidate(); </p>

</div>
</div>
<a id="acf9f1ad4e92cbd49a7d6aec2303a14f1" name="acf9f1ad4e92cbd49a7d6aec2303a14f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf9f1ad4e92cbd49a7d6aec2303a14f1">&#9670;&#160;</a></span>dfs_prune_invalid_packing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PHV::Slicing::DfsItrContext::dfs_prune_invalid_packing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *</td>          <td class="paramname"><span class="paramname"><em>sc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>return true if there exists packing that make it impossible to to synthesize actions. TODO: non-const because it may call invalidate(); </p>

</div>
</div>
<a id="a61ab43c146785d672b2250ddc402011d" name="a61ab43c146785d672b2250ddc402011d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61ab43c146785d672b2250ddc402011d">&#9670;&#160;</a></span>dfs_prune_unsat_exact_list_size_mismatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PHV::Slicing::DfsItrContext::dfs_prune_unsat_exact_list_size_mismatch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1ordered__map.html">SplitDecision</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>decided_sz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *</td>          <td class="paramname"><span class="paramname"><em>sc</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>return true if exists a metadata list that will join two exact_containers lists of different sizes. For example:; sl_1: [f1&lt;16&gt;, f2&lt;8&gt;, f3&lt;8&gt;[0:1], f3&lt;8&gt;[2:7]], total 32, exact. sl_2: [f2'&lt;8&gt;, f4&lt;8&gt;[0:3], f4&lt;8&gt;[4:7]], total 16, exact. sl_3: [md1&lt;2&gt;, pad&lt;2&gt;, md2&lt;4&gt;] rotational clusters: {f3[0:1], md1}, {f4&lt;8&gt;[0:3], md2} sl_3 will join sl_1 and sl_2 into one super cluster, and we can infer that this cluster is invalid because exact slice list sizes are not the same. </p>

</div>
</div>
<a id="a66ee851ac5a50c6baaa7f10b6a9092fb" name="a66ee851ac5a50c6baaa7f10b6a9092fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66ee851ac5a50c6baaa7f10b6a9092fb">&#9670;&#160;</a></span>dfs_prune_unsat_slicelist_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PHV::Slicing::DfsItrContext::dfs_prune_unsat_slicelist_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1ordered__map.html">SplitDecision</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>constraints</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *</td>          <td class="paramname"><span class="paramname"><em>sc</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>return true if constraints for a slice list cannot be <em>all</em> satisfied. Check for cases like: 32 xxx 16 [fs1&lt;8&gt;, fs2&lt;8&gt;, fs3&lt;16&gt;] it's unsat because fs1 was decided to be allocated into 32-bit container while for fs3 it's 16-bit container. However, in the above layout it's impossible. We run a greedy algorithm looking for cases but may have false negatives. </p>

</div>
</div>
<a id="ad42a1c1f353813e10d379106d5f46825" name="ad42a1c1f353813e10d379106d5f46825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad42a1c1f353813e10d379106d5f46825">&#9670;&#160;</a></span>dfs_prune_unwell_formed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PHV::Slicing::DfsItrContext::dfs_prune_unwell_formed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *</td>          <td class="paramname"><span class="paramname"><em>sc</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>dfs_prune_unwell_formed: return true if (1) <code class="param">sc</code> cannot be split further and is not well_formed. (2) a slicelist in <code class="param">sc</code> that cannot be split further has pack conflicts. </p>

</div>
</div>
<a id="ac2e9e5f566dc7d749d05589c39a4c46d" name="ac2e9e5f566dc7d749d05589c39a4c46d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e9e5f566dc7d749d05589c39a4c46d">&#9670;&#160;</a></span>get_well_formed_no_more_split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> * &gt; PHV::Slicing::DfsItrContext::get_well_formed_no_more_split </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>get_well_formed_no_more_split returns super clusters that all the slice lists does not need_further_split, and the cluster is well_formed. </p>

</div>
</div>
<a id="a1f787949b1cdcff13440d4d05bee4d31" name="a1f787949b1cdcff13440d4d05bee4d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f787949b1cdcff13440d4d05bee4d31">&#9670;&#160;</a></span>invalidate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PHV::Slicing::DfsItrContext::invalidate </td>
          <td>(</td>
          <td class="paramtype">const SuperCluster::SliceList *</td>          <td class="paramname"><span class="paramname"><em>sl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>invalidate is the feedback mechanism for allocation algorithm to ask iterator not to produce slicing result contains <code class="param">sl</code>. Caller can This DFS iterator will respect the list of top-most stack frame, i.e., the most recent decision made by DFS. </p>

<p>Implements <a class="el" href="class_p_h_v_1_1_slicing_1_1_iterator_interface.html#a98a0452a35509b8448413f66203041c2">PHV::Slicing::IteratorInterface</a>.</p>

</div>
</div>
<a id="a0b14d44527ff91d55e303589d45ed54b" name="a0b14d44527ff91d55e303589d45ed54b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b14d44527ff91d55e303589d45ed54b">&#9670;&#160;</a></span>iterate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PHV::Slicing::DfsItrContext::iterate </td>
          <td>(</td>
          <td class="paramtype">const IterateCb &amp;</td>          <td class="paramname"><span class="paramname"><em>cb</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>iterate will pass valid slicing results to cb. Stop when cb returns false. </p>

<p>Implements <a class="el" href="class_p_h_v_1_1_slicing_1_1_iterator_interface.html#aaeb868863c2ed6e2a1603d83543820f7">PHV::Slicing::IteratorInterface</a>.</p>

</div>
</div>
<a id="a21b2f01abca38bd51aa7416c2619b91a" name="a21b2f01abca38bd51aa7416c2619b91a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21b2f01abca38bd51aa7416c2619b91a">&#9670;&#160;</a></span>make_choices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; SplitChoice &gt; PHV::Slicing::DfsItrContext::make_choices </td>
          <td>(</td>
          <td class="paramtype">const SliceListLoc &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>return possible SplitChoice on <code class="param">target</code>. When minimal_packing_mode is false, results are sorted with a set of heuristics that choices with more packing opportunities (generally larger container-sized chunks), ,split at field boundaries, and better chances to split between ref/unref fields, are placed at lower indexes. See implementation for more details on heuristics. If minimal_packing_mode is true, then we will prefer to split with less packing of fieldslices. </p>

</div>
</div>
<a id="a6308eb392cd1ca97ade76510ae4443fc" name="a6308eb392cd1ca97ade76510ae4443fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6308eb392cd1ca97ade76510ae4443fc">&#9670;&#160;</a></span>make_split_meta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; std::pair&lt; <a class="el" href="class_p4_1_1ordered__map.html">SplitSchema</a>, <a class="el" href="class_p4_1_1ordered__map.html">SplitDecision</a> &gt; &gt; PHV::Slicing::DfsItrContext::make_split_meta </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *</td>          <td class="paramname"><span class="paramname"><em>sc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SuperCluster::SliceList *</td>          <td class="paramname"><span class="paramname"><em>sl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>first_n_bits</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>make_split_meta will generate schema and decision to split out first <code class="param">first_n_bits</code> of <code class="param">sl</code> under <code class="param">sc.When</code> a conflicting split decision is found, </p><dl class="section return"><dt>Returns</dt><dd>std::nullopt. </dd></dl>

</div>
</div>
<a id="a06d0f113fce9d41fb25d9de4e704a62f" name="a06d0f113fce9d41fb25d9de4e704a62f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06d0f113fce9d41fb25d9de4e704a62f">&#9670;&#160;</a></span>propagate_8bit_exact_container_split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PHV::Slicing::DfsItrContext::propagate_8bit_exact_container_split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *</td>          <td class="paramname"><span class="paramname"><em>sc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SuperCluster::SliceList *</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1ordered__map.html">SplitSchema</a> *</td>          <td class="paramname"><span class="paramname"><em>schema</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1ordered__map.html">SplitDecision</a> *</td>          <td class="paramname"><span class="paramname"><em>decisions</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>propagate_8bit_exact_container_split propagates the 8bit split decision on <code class="param">target</code> to other slice lists in <code class="param">sc</code>, as long as there is one exact_containers field slices in rotational clusters of splitted slices of list. If we are splitting out an 8-bit slice list with exact_containers constraint, then we can infer that all other slices in the the same rotational cluster with slices that were just split out, need to be split by the bytes (counting from the beginning of lists) that contains them. </p>

</div>
</div>
<a id="a84ac432dfc05f0c106db4e22099c2ea8" name="a84ac432dfc05f0c106db4e22099c2ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84ac432dfc05f0c106db4e22099c2ea8">&#9670;&#160;</a></span>propagate_tail_split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PHV::Slicing::DfsItrContext::propagate_tail_split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *</td>          <td class="paramname"><span class="paramname"><em>sc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1ordered__map.html">SplitDecision</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>constraints</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1ordered__map.html">SplitDecision</a> *</td>          <td class="paramname"><span class="paramname"><em>decisions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SuperCluster::SliceList *</td>          <td class="paramname"><span class="paramname"><em>just_split_target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>n_just_split_bits</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1ordered__map.html">SplitSchema</a> *</td>          <td class="paramname"><span class="paramname"><em>schema</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If we found that any field slice in the last byte of a slice list has a decided size, then we can split the <em>tail</em> out so that the packing is materialized as early as possible. </p>
<p>returns decision of <code class="param">fs</code> made by this round and all previous rounds.</p>
<p>Do not split cross the bytes that we just split out. If incorrect, it will fail very soon later.</p>

</div>
</div>
<a id="ab4ab8a3ad1ff84047c2f3be1cbef44a7" name="ab4ab8a3ad1ff84047c2f3be1cbef44a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4ab8a3ad1ff84047c2f3be1cbef44a7">&#9670;&#160;</a></span>set_config()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PHV::Slicing::DfsItrContext::set_config </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_h_v_1_1_slicing_1_1_iterator_config.html">IteratorConfig</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cfg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set configs. </p>

<p>Implements <a class="el" href="class_p_h_v_1_1_slicing_1_1_iterator_interface.html#a876bb267eea2ce3fcdcb2c8e10ecc1d2">PHV::Slicing::IteratorInterface</a>.</p>

</div>
</div>
<a id="a87f118e03da4bdacd709b951cdc9ebc4" name="a87f118e03da4bdacd709b951cdc9ebc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f118e03da4bdacd709b951cdc9ebc4">&#9670;&#160;</a></span>split_by_adjacent_deparsed_and_non_deparsed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; std::list&lt; <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> * &gt; &gt; PHV::Slicing::DfsItrContext::split_by_adjacent_deparsed_and_non_deparsed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *</td>          <td class="paramname"><span class="paramname"><em>sc</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>split_by_adjacent_deparsed_and_non_deparsed will split <code class="param">sc</code> between deparsed and non-deparsed field. </p>

</div>
</div>
<a id="ab9bee7fc4668caf3c77b2546cee8e881" name="ab9bee7fc4668caf3c77b2546cee8e881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9bee7fc4668caf3c77b2546cee8e881">&#9670;&#160;</a></span>split_by_adjacent_no_pack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; std::list&lt; <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> * &gt; &gt; PHV::Slicing::DfsItrContext::split_by_adjacent_no_pack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *</td>          <td class="paramname"><span class="paramname"><em>sc</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>split_by_adjacent_no_pack will split <code class="param">sc</code> at byte boundary if two adjacent fields cannot be packed into one container. </p>

</div>
</div>
<a id="a80acfa386f9930e63e1ee25992685aa1" name="a80acfa386f9930e63e1ee25992685aa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80acfa386f9930e63e1ee25992685aa1">&#9670;&#160;</a></span>split_by_long_fieldslices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; std::list&lt; <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> * &gt; &gt; PHV::Slicing::DfsItrContext::split_by_long_fieldslices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *</td>          <td class="paramname"><span class="paramname"><em>sc</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>split_by_long_fieldslices will split fieldslices that its length is greater or equal to 64 bits, using 32-bit container if possible. </p>

</div>
</div>
<a id="a68bf14e98ee4ccb6a8199149b2026f73" name="a68bf14e98ee4ccb6a8199149b2026f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68bf14e98ee4ccb6a8199149b2026f73">&#9670;&#160;</a></span>split_by_valid_container_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; std::list&lt; <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> * &gt; &gt; PHV::Slicing::DfsItrContext::split_by_valid_container_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *</td>          <td class="paramname"><span class="paramname"><em>sc</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>split_by_valid_container_range will split based on valid container range constraint that a field cannot be packed fields after it, when its valid container range is equal to the size of the field. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_p_h_v.html">PHV</a></li><li class="navelem"><b>Slicing</b></li><li class="navelem"><a class="el" href="class_p_h_v_1_1_slicing_1_1_dfs_itr_context.html">DfsItrContext</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
