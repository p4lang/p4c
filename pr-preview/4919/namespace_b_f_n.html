<!-- HTML header for doxygen 1.12.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>P4 Compiler Documentation (P4C): BFN Namespace Reference</title>
<link rel="icon" href="p4-fav.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!--  Add link to paragraphs   -->
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
  DoxygenAwesomeParagraphLink.init()
</script>
<!-- Add copy button to code fragments  -->
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
  DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add dark mode toggle -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
  DoxygenAwesomeDarkModeToggle.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="cards.css" rel="stylesheet" type="text/css"/>
<link href="flow.css" rel="stylesheet" type="text/css"/>
<link href="p4c_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="p4-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">P4C
   </div>
   <div id="projectbrief">The P4 Compiler</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespace_b_f_n.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">BFN Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The namespace encapsulating Barefoot/Intel-specific stuff.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_action_arg_setup.html">ActionArgSetup</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_action_body_setup.html">ActionBodySetup</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_action_function_setup.html">ActionFunctionSetup</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_action_profile.html">ActionProfile</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_action_selector.html">ActionSelector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_action_synthesis_policy.html">ActionSynthesisPolicy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_add_adjust_byte_count" id="r_class_b_f_n_1_1_add_adjust_byte_count"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___simple_switch_translation.html#class_b_f_n_1_1_add_adjust_byte_count">AddAdjustByteCount</a></td></tr>
<tr class="separator:class_b_f_n_1_1_add_adjust_byte_count"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_add_hardware_constrained_fields.html">AddHardwareConstrainedFields</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_add_intrinsic_metadata.html">AddIntrinsicMetadata</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_add_metadata_fields.html">AddMetadataFields</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_add_metadata_parser_states.html">AddMetadataParserStates</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_add_padding_fields.html">AddPaddingFields</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_add_parser_pad.html">AddParserPad</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add "padding" (additional states/extract fields) to parsers to meet minimum parse depth requirements.  <a href="class_b_f_n_1_1_add_parser_pad.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_add_psa_bridge_metadata.html">AddPsaBridgeMetadata</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_add_t2na_meta.html">AddT2naMeta</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_add_tna_bridge_metadata.html">AddTnaBridgeMetadata</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_adjust_byte_count_setup.html">AdjustByteCountSetup</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_alloc1_d.html">Alloc1D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_alloc1_dbase.html">Alloc1Dbase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_alloc2_d.html">Alloc2D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_alloc2_dbase.html">Alloc2Dbase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_alloc3_d.html">Alloc3D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_alloc3_dbase.html">Alloc3Dbase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_alpm_implementation" id="r_class_b_f_n_1_1_alpm_implementation"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alpm.html#class_b_f_n_1_1_alpm_implementation">AlpmImplementation</a></td></tr>
<tr class="memdesc:class_b_f_n_1_1_alpm_implementation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Top level PassManager that governs the ALPM implementation.  <a href="group__alpm.html#class_b_f_n_1_1_alpm_implementation">More...</a><br /></td></tr>
<tr class="separator:class_b_f_n_1_1_alpm_implementation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_ancestor_states.html">AncestorStates</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_annotate_varbit_extract_states" id="r_class_b_f_n_1_1_annotate_varbit_extract_states"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___desugar_varbit_extract.html#class_b_f_n_1_1_annotate_varbit_extract_states">AnnotateVarbitExtractStates</a></td></tr>
<tr class="separator:class_b_f_n_1_1_annotate_varbit_extract_states"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_annotate_with_in_hash" id="r_class_b_f_n_1_1_annotate_with_in_hash"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___annotate_with_in_hash.html#class_b_f_n_1_1_annotate_with_in_hash">AnnotateWithInHash</a></td></tr>
<tr class="memdesc:class_b_f_n_1_1_annotate_with_in_hash"><td class="mdescLeft">&#160;</td><td class="mdescRight">Top level PassManager that governs annotation of specific assignment statements with the @in_hash annotation.  <a href="group___annotate_with_in_hash.html#class_b_f_n_1_1_annotate_with_in_hash">More...</a><br /></td></tr>
<tr class="separator:class_b_f_n_1_1_annotate_with_in_hash"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_apply_evaluator" id="r_class_b_f_n_1_1_apply_evaluator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___arch_translation.html#class_b_f_n_1_1_apply_evaluator">ApplyEvaluator</a></td></tr>
<tr class="separator:class_b_f_n_1_1_apply_evaluator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_architecture.html">Architecture</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_arch_translation" id="r_class_b_f_n_1_1_arch_translation"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___arch_translation.html#class_b_f_n_1_1_arch_translation">ArchTranslation</a></td></tr>
<tr class="memdesc:class_b_f_n_1_1_arch_translation"><td class="mdescLeft">&#160;</td><td class="mdescRight">PassManager that governs the normalization of variations in the architectures.  <a href="group___arch_translation.html#class_b_f_n_1_1_arch_translation">More...</a><br /></td></tr>
<tr class="separator:class_b_f_n_1_1_arch_translation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_asm_output" id="r_class_b_f_n_1_1_asm_output"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___asm_output.html#class_b_f_n_1_1_asm_output">AsmOutput</a></td></tr>
<tr class="memdesc:class_b_f_n_1_1_asm_output"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate assembly output.  <a href="group___asm_output.html#class_b_f_n_1_1_asm_output">More...</a><br /></td></tr>
<tr class="separator:class_b_f_n_1_1_asm_output"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_assignment_stmt_error_check.html">AssignmentStmtErrorCheck</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_assign_or.html">AssignOr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_attach_tables.html">AttachTables</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_backend.html">Backend</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_backend_constant_folding.html">BackendConstantFolding</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_backend_converter.html">BackendConverter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_backend_strength_reduction.html">BackendStrengthReduction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_b_f_runtime_arch_handler_common.html">BFRuntimeArchHandlerCommon</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_b_f_runtime_arch_handler_p_s_a.html">BFRuntimeArchHandlerPSA</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_b_f_runtime_arch_handler_tofino.html">BFRuntimeArchHandlerTofino</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_b_f_n_1_1_block_info" id="r_struct_b_f_n_1_1_block_info"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___arch_translation.html#struct_b_f_n_1_1_block_info">BlockInfo</a></td></tr>
<tr class="separator:struct_b_f_n_1_1_block_info"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_b_f_n_1_1_bridged_field_info" id="r_struct_b_f_n_1_1_bridged_field_info"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#struct_b_f_n_1_1_bridged_field_info">BridgedFieldInfo</a></td></tr>
<tr class="separator:struct_b_f_n_1_1_bridged_field_info"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_check_design_pattern" id="r_class_b_f_n_1_1_check_design_pattern"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___check_design_pattern.html#class_b_f_n_1_1_check_design_pattern">CheckDesignPattern</a></td></tr>
<tr class="memdesc:class_b_f_n_1_1_check_design_pattern"><td class="mdescLeft">&#160;</td><td class="mdescRight">Top level PassManager that governs checking for design patterns.  <a href="group___check_design_pattern.html#class_b_f_n_1_1_check_design_pattern">More...</a><br /></td></tr>
<tr class="separator:class_b_f_n_1_1_check_design_pattern"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_check_direct_externs_on_tables" id="r_class_b_f_n_1_1_check_direct_externs_on_tables"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___check_design_pattern.html#class_b_f_n_1_1_check_direct_externs_on_tables">CheckDirectExternsOnTables</a></td></tr>
<tr class="separator:class_b_f_n_1_1_check_direct_externs_on_tables"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_check_direct_resource_invocation" id="r_class_b_f_n_1_1_check_direct_resource_invocation"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___check_design_pattern.html#class_b_f_n_1_1_check_direct_resource_invocation">CheckDirectResourceInvocation</a></td></tr>
<tr class="separator:class_b_f_n_1_1_check_direct_resource_invocation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_check_extern_invocation_common.html">CheckExternInvocationCommon</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_check_extern_validity" id="r_class_b_f_n_1_1_check_extern_validity"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___check_design_pattern.html#class_b_f_n_1_1_check_extern_validity">CheckExternValidity</a></td></tr>
<tr class="memdesc:class_b_f_n_1_1_check_extern_validity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the emit function call is valid with the TNA constraints.  <a href="group___check_design_pattern.html#class_b_f_n_1_1_check_extern_validity">More...</a><br /></td></tr>
<tr class="separator:class_b_f_n_1_1_check_extern_validity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_check_header_alignment.html">CheckHeaderAlignment</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_check_pad_assignment.html">CheckPadAssignment</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_check_phase_zero_extern.html">CheckPhaseZeroExtern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_check_register_actions" id="r_class_b_f_n_1_1_check_register_actions"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__midend.html#class_b_f_n_1_1_check_register_actions">CheckRegisterActions</a></td></tr>
<tr class="memdesc:class_b_f_n_1_1_check_register_actions"><td class="mdescLeft">&#160;</td><td class="mdescRight">PassManager that checks if the RegisterActions work on proper Registers.  <a href="group__midend.html#class_b_f_n_1_1_check_register_actions">More...</a><br /></td></tr>
<tr class="separator:class_b_f_n_1_1_check_register_actions"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_check_reserved_names.html">CheckReservedNames</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_check_t2_n_a_extern_invocation.html">CheckT2NAExternInvocation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_check_table_const_entries.html">CheckTableConstEntries</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_check_t_n_a_extern_invocation.html">CheckTNAExternInvocation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_check_unimplemented_features.html">CheckUnimplementedFeatures</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_check_unsupported" id="r_class_b_f_n_1_1_check_unsupported"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__midend.html#class_b_f_n_1_1_check_unsupported">CheckUnsupported</a></td></tr>
<tr class="memdesc:class_b_f_n_1_1_check_unsupported"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for unsupported features in the backend compiler.  <a href="group__midend.html#class_b_f_n_1_1_check_unsupported">More...</a><br /></td></tr>
<tr class="separator:class_b_f_n_1_1_check_unsupported"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_check_varbit_access" id="r_class_b_f_n_1_1_check_varbit_access"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___desugar_varbit_extract.html#class_b_f_n_1_1_check_varbit_access">CheckVarbitAccess</a></td></tr>
<tr class="memdesc:class_b_f_n_1_1_check_varbit_access"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that varbit accesses in pipeline are valid.  <a href="group___desugar_varbit_extract.html#class_b_f_n_1_1_check_varbit_access">More...</a><br /></td></tr>
<tr class="separator:class_b_f_n_1_1_check_varbit_access"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_clone_constants.html">CloneConstants</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_clot_resources_logging.html">ClotResourcesLogging</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_collect_alpm_info" id="r_class_b_f_n_1_1_collect_alpm_info"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alpm.html#class_b_f_n_1_1_collect_alpm_info">CollectAlpmInfo</a></td></tr>
<tr class="separator:class_b_f_n_1_1_collect_alpm_info"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_collect_bridged_fields.html">CollectBridgedFields</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_collect_hardware_constrained_fields.html">CollectHardwareConstrainedFields</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_collect_i_x_bar_info.html">CollectIXBarInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_collect_phase0_annotation.html">CollectPhase0Annotation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_collect_pipelines" id="r_class_b_f_n_1_1_collect_pipelines"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__midend.html#class_b_f_n_1_1_collect_pipelines">CollectPipelines</a></td></tr>
<tr class="memdesc:class_b_f_n_1_1_collect_pipelines"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inspector pass that collects information about all pipelines declared in the Switch. For given pipeline (given by its numeric id), it is possible to extract the pipeline components (e.g. parsers, deparsers and gress control for all gresses and possible ghost gress).  <a href="group__midend.html#class_b_f_n_1_1_collect_pipelines">More...</a><br /></td></tr>
<tr class="separator:class_b_f_n_1_1_collect_pipelines"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_collect_varbit_extract" id="r_class_b_f_n_1_1_collect_varbit_extract"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___desugar_varbit_extract.html#class_b_f_n_1_1_collect_varbit_extract">CollectVarbitExtract</a></td></tr>
<tr class="separator:class_b_f_n_1_1_collect_varbit_extract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_collect_variables.html">CollectVariables</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_compile_time_operations" id="r_class_b_f_n_1_1_compile_time_operations"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__midend.html#class_b_f_n_1_1_compile_time_operations">CompileTimeOperations</a></td></tr>
<tr class="memdesc:class_b_f_n_1_1_compile_time_operations"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass that checks for operations that are defined at compile time (Div, Mod).  <a href="group__midend.html#class_b_f_n_1_1_compile_time_operations">More...</a><br /></td></tr>
<tr class="separator:class_b_f_n_1_1_compile_time_operations"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_control_flow_visitor.html">ControlFlowVisitor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_convert_method_calls.html">ConvertMethodCalls</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_convert_phase0.html">ConvertPhase0</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_convert_phase0_assign_to_extract.html">ConvertPhase0AssignToExtract</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_convert_size_of_to_constant.html">ConvertSizeOfToConstant</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_copy_headers.html">CopyHeaders</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_b_f_n_1_1_counter_extern" id="r_struct_b_f_n_1_1_counter_extern"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#struct_b_f_n_1_1_counter_extern">CounterExtern</a></td></tr>
<tr class="separator:struct_b_f_n_1_1_counter_extern"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_debug_info.html">DebugInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_desugar_varbit_extract" id="r_class_b_f_n_1_1_desugar_varbit_extract"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___desugar_varbit_extract.html#class_b_f_n_1_1_desugar_varbit_extract">DesugarVarbitExtract</a></td></tr>
<tr class="memdesc:class_b_f_n_1_1_desugar_varbit_extract"><td class="mdescLeft">&#160;</td><td class="mdescRight">Top level PassManager that governs the rewrite of varbit usage.  <a href="group___desugar_varbit_extract.html#class_b_f_n_1_1_desugar_varbit_extract">More...</a><br /></td></tr>
<tr class="separator:class_b_f_n_1_1_desugar_varbit_extract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_detect_multiple_pipelines.html">DetectMultiplePipelines</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_b_f_n_1_1_digest" id="r_struct_b_f_n_1_1_digest"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#struct_b_f_n_1_1_digest">Digest</a></td></tr>
<tr class="memdesc:struct_b_f_n_1_1_digest"><td class="mdescLeft">&#160;</td><td class="mdescRight">The information about a digest instance which is needed to serialize it.  <a href="#struct_b_f_n_1_1_digest">More...</a><br /></td></tr>
<tr class="separator:struct_b_f_n_1_1_digest"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_do_annotate_with_in_hash" id="r_class_b_f_n_1_1_do_annotate_with_in_hash"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___annotate_with_in_hash.html#class_b_f_n_1_1_do_annotate_with_in_hash">DoAnnotateWithInHash</a></td></tr>
<tr class="separator:class_b_f_n_1_1_do_annotate_with_in_hash"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_do_initialize_mirror_i_o_select.html">DoInitializeMirrorIOSelect</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_do_remove_action_parameters_tofino" id="r_class_b_f_n_1_1_do_remove_action_parameters_tofino"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___remove_action_parameters.html#class_b_f_n_1_1_do_remove_action_parameters_tofino">DoRemoveActionParametersTofino</a></td></tr>
<tr class="separator:class_b_f_n_1_1_do_remove_action_parameters_tofino"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_b_f_n_1_1_do_rewrite_control_and_parser_blocks" id="r_struct_b_f_n_1_1_do_rewrite_control_and_parser_blocks"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___arch_translation.html#struct_b_f_n_1_1_do_rewrite_control_and_parser_blocks">DoRewriteControlAndParserBlocks</a></td></tr>
<tr class="separator:struct_b_f_n_1_1_do_rewrite_control_and_parser_blocks"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_drop_packet_with_mirror_engine.html">DropPacketWithMirrorEngine</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_drop_packet_with_mirror_engine__.html">DropPacketWithMirrorEngine_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_dynamic_hash_json.html">DynamicHashJson</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_b_f_n_1_1_dyn_hash" id="r_struct_b_f_n_1_1_dyn_hash"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#struct_b_f_n_1_1_dyn_hash">DynHash</a></td></tr>
<tr class="memdesc:struct_b_f_n_1_1_dyn_hash"><td class="mdescLeft">&#160;</td><td class="mdescRight">The information about a hash instance which is needed to serialize it.  <a href="#struct_b_f_n_1_1_dyn_hash">More...</a><br /></td></tr>
<tr class="separator:struct_b_f_n_1_1_dyn_hash"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_elim_casts" id="r_class_b_f_n_1_1_elim_casts"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___elim_casts.html#class_b_f_n_1_1_elim_casts">ElimCasts</a></td></tr>
<tr class="memdesc:class_b_f_n_1_1_elim_casts"><td class="mdescLeft">&#160;</td><td class="mdescRight">Top level PassManager that simplifies complex expression with multiple casts into simpler expression with at most one cast.  <a href="group___elim_casts.html#class_b_f_n_1_1_elim_casts">More...</a><br /></td></tr>
<tr class="separator:class_b_f_n_1_1_elim_casts"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_eliminate_headers" id="r_class_b_f_n_1_1_eliminate_headers"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___simplify_emit_args.html#class_b_f_n_1_1_eliminate_headers">EliminateHeaders</a></td></tr>
<tr class="separator:class_b_f_n_1_1_eliminate_headers"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_eliminate_tuples.html">EliminateTuples</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_eliminate_width_casts" id="r_class_b_f_n_1_1_eliminate_width_casts"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___elim_casts.html#class_b_f_n_1_1_eliminate_width_casts">EliminateWidthCasts</a></td></tr>
<tr class="separator:class_b_f_n_1_1_eliminate_width_casts"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_elim_parser_valid_zero_writes.html">ElimParserValidZeroWrites</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminate unnecessary parser zero-writes to validity bits.  <a href="class_b_f_n_1_1_elim_parser_valid_zero_writes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_elim_unused_metadata_states.html">ElimUnusedMetadataStates</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_enum_on32_bits" id="r_class_b_f_n_1_1_enum_on32_bits"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__midend.html#class_b_f_n_1_1_enum_on32_bits">EnumOn32Bits</a></td></tr>
<tr class="memdesc:class_b_f_n_1_1_enum_on32_bits"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that implements a policy suitable for the ConvertEnums pass.  <a href="group__midend.html#class_b_f_n_1_1_enum_on32_bits">More...</a><br /></td></tr>
<tr class="separator:class_b_f_n_1_1_enum_on32_bits"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_error_on_unsupported_varbit_use.html">ErrorOnUnsupportedVarbitUse</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_error_type.html">ErrorType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Barefoot specific error and warning types.  <a href="class_b_f_n_1_1_error_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_evaluate_for_var.html">EvaluateForVar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_evaluator_pass" id="r_class_b_f_n_1_1_evaluator_pass"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__midend.html#class_b_f_n_1_1_evaluator_pass">EvaluatorPass</a></td></tr>
<tr class="memdesc:class_b_f_n_1_1_evaluator_pass"><td class="mdescLeft">&#160;</td><td class="mdescRight">A modified version of P4::EvaluatorPass that uses BFN::TypeChecking.  <a href="group__midend.html#class_b_f_n_1_1_evaluator_pass">More...</a><br /></td></tr>
<tr class="separator:class_b_f_n_1_1_evaluator_pass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_b_f_n_1_1_extract_checksum" id="r_struct_b_f_n_1_1_extract_checksum"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___extract_checksum.html#struct_b_f_n_1_1_extract_checksum">ExtractChecksum</a></td></tr>
<tr class="memdesc:struct_b_f_n_1_1_extract_checksum"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass that extracts checksums from deparser.  <a href="group___extract_checksum.html#struct_b_f_n_1_1_extract_checksum">More...</a><br /></td></tr>
<tr class="separator:struct_b_f_n_1_1_extract_checksum"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_extract_deparser" id="r_class_b_f_n_1_1_extract_deparser"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parde.html#class_b_f_n_1_1_extract_deparser">ExtractDeparser</a></td></tr>
<tr class="memdesc:class_b_f_n_1_1_extract_deparser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms midend deparser IR::BFN::TnaDeparser into backend deparser IR::BFN::Deparser.  <a href="group__parde.html#class_b_f_n_1_1_extract_deparser">More...</a><br /></td></tr>
<tr class="separator:class_b_f_n_1_1_extract_deparser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_extract_metadata.html">ExtractMetadata</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_extract_parser" id="r_class_b_f_n_1_1_extract_parser"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parde.html#class_b_f_n_1_1_extract_parser">ExtractParser</a></td></tr>
<tr class="memdesc:class_b_f_n_1_1_extract_parser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms midend parser IR::BFN::TnaParser into backend parser IR::BFN::Parser.  <a href="group__parde.html#class_b_f_n_1_1_extract_parser">More...</a><br /></td></tr>
<tr class="separator:class_b_f_n_1_1_extract_parser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_field_packing.html">FieldPacking</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_find_architecture.html">FindArchitecture</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_find_bridge_metadata_assignment.html">FindBridgeMetadataAssignment</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_find_direct_externs" id="r_class_b_f_n_1_1_find_direct_externs"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___check_design_pattern.html#class_b_f_n_1_1_find_direct_externs">FindDirectExterns</a></td></tr>
<tr class="separator:class_b_f_n_1_1_find_direct_externs"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_find_padding_candidate.html">FindPaddingCandidate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_fix_p4_table.html">FixP4Table</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_fixup_mirror_metadata.html">FixupMirrorMetadata</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_fixup_resubmit_metadata.html">FixupResubmitMetadata</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_flatten_header" id="r_class_b_f_n_1_1_flatten_header"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___simplify_emit_args.html#class_b_f_n_1_1_flatten_header">FlattenHeader</a></td></tr>
<tr class="memdesc:class_b_f_n_1_1_flatten_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass that flattened nested struct within a struct.  <a href="group___simplify_emit_args.html#class_b_f_n_1_1_flatten_header">More...</a><br /></td></tr>
<tr class="separator:class_b_f_n_1_1_flatten_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_fold_constant_hashes" id="r_class_b_f_n_1_1_fold_constant_hashes"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__midend.html#class_b_f_n_1_1_fold_constant_hashes">FoldConstantHashes</a></td></tr>
<tr class="memdesc:class_b_f_n_1_1_fold_constant_hashes"><td class="mdescLeft">&#160;</td><td class="mdescRight">PassManager that substitutes the calls of the get methods of the Hash externs whose inputs are constants with the resulting hash value.  <a href="group__midend.html#class_b_f_n_1_1_fold_constant_hashes">More...</a><br /></td></tr>
<tr class="separator:class_b_f_n_1_1_fold_constant_hashes"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_front_end_policy.html">FrontEndPolicy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_gateway_control_flow.html">GatewayControlFlow</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_generate_dynamic_hash_json.html">GenerateDynamicHashJson</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_generate_tofino_program" id="r_class_b_f_n_1_1_generate_tofino_program"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___arch_translation.html#class_b_f_n_1_1_generate_tofino_program">GenerateTofinoProgram</a></td></tr>
<tr class="separator:class_b_f_n_1_1_generate_tofino_program"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_get_backend_parser.html">GetBackendParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts frontend parser IR into backend IR.  <a href="class_b_f_n_1_1_get_backend_parser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_get_backend_tables.html">GetBackendTables</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_get_header_stack_index.html">GetHeaderStackIndex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_has_table_apply" id="r_class_b_f_n_1_1_has_table_apply"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alpm.html#class_b_f_n_1_1_has_table_apply">HasTableApply</a></td></tr>
<tr class="separator:class_b_f_n_1_1_has_table_apply"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_header_stack_info.html">HeaderStackInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metadata about how header stacks are used in the program.  <a href="struct_b_f_n_1_1_header_stack_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_identify_pad_requirements.html">IdentifyPadRequirements</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify parse depth requirements and identify any "pad" required.  <a href="class_b_f_n_1_1_identify_pad_requirements.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_identify_pov_merge_targets.html">IdentifyPovMergeTargets</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify POV bits that can be merged.  <a href="class_b_f_n_1_1_identify_pov_merge_targets.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_ignore_key_element_transform" id="r_class_b_f_n_1_1_ignore_key_element_transform"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___elim_casts.html#class_b_f_n_1_1_ignore_key_element_transform">IgnoreKeyElementTransform</a></td></tr>
<tr class="memdesc:class_b_f_n_1_1_ignore_key_element_transform"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary transformer to avoid processing IR::KeyElement nodes.  <a href="group___elim_casts.html#class_b_f_n_1_1_ignore_key_element_transform">More...</a><br /></td></tr>
<tr class="separator:class_b_f_n_1_1_ignore_key_element_transform"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_initialize_mirror_i_o_select" id="r_class_b_f_n_1_1_initialize_mirror_i_o_select"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__midend.html#class_b_f_n_1_1_initialize_mirror_i_o_select">InitializeMirrorIOSelect</a></td></tr>
<tr class="memdesc:class_b_f_n_1_1_initialize_mirror_i_o_select"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes eg_intr_md_for_dprsr.mirror_io_select on devices except Tofino1.  <a href="group__midend.html#class_b_f_n_1_1_initialize_mirror_i_o_select">More...</a><br /></td></tr>
<tr class="separator:class_b_f_n_1_1_initialize_mirror_i_o_select"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_b_f_n_1_1_inject_tmp_var" id="r_struct_b_f_n_1_1_inject_tmp_var"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___simplify_emit_args.html#struct_b_f_n_1_1_inject_tmp_var">InjectTmpVar</a></td></tr>
<tr class="memdesc:struct_b_f_n_1_1_inject_tmp_var"><td class="mdescLeft">&#160;</td><td class="mdescRight">PassManager which controls injecting of temporary variables to be used instead of nested structures which need to be flattened by FlattenHeader pass.  <a href="group___simplify_emit_args.html#struct_b_f_n_1_1_inject_tmp_var">More...</a><br /></td></tr>
<tr class="separator:struct_b_f_n_1_1_inject_tmp_var"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_insert_hash_struct_expression.html">InsertHashStructExpression</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_is_phase0.html">IsPhase0</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_is_slice.html">IsSlice</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_is_slice_mask.html">IsSliceMask</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_key_is_simple.html">KeyIsSimple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_linear_path.html">LinearPath</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_lowering_type" id="r_class_b_f_n_1_1_lowering_type"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___arch_translation.html#class_b_f_n_1_1_lowering_type">LoweringType</a></td></tr>
<tr class="separator:class_b_f_n_1_1_lowering_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_lpf.html">Lpf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The information about a LPF instance which is needed to serialize it.  <a href="struct_b_f_n_1_1_lpf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_b_f_n_1_1_match" id="r_struct_b_f_n_1_1_match"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#struct_b_f_n_1_1_match">Match</a></td></tr>
<tr class="separator:struct_b_f_n_1_1_match"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_merge_pov_bits.html">MergePovBits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge POV bits where a single POV bit could be shared between multiple headers.  <a href="class_b_f_n_1_1_merge_pov_bits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_metadata_field.html">MetadataField</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper struct used to construct the metadata remapping tables.  <a href="struct_b_f_n_1_1_metadata_field.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_b_f_n_1_1_meter_extern" id="r_struct_b_f_n_1_1_meter_extern"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#struct_b_f_n_1_1_meter_extern">MeterExtern</a></td></tr>
<tr class="separator:struct_b_f_n_1_1_meter_extern"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_mid_end.html">MidEnd</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_mid_end_last" id="r_class_b_f_n_1_1_mid_end_last"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__midend.html#class_b_f_n_1_1_mid_end_last">MidEndLast</a></td></tr>
<tr class="memdesc:class_b_f_n_1_1_mid_end_last"><td class="mdescLeft">&#160;</td><td class="mdescRight">Final midend pass.  <a href="group__midend.html#class_b_f_n_1_1_mid_end_last">More...</a><br /></td></tr>
<tr class="separator:class_b_f_n_1_1_mid_end_last"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_move_bridge_metadata_assignment.html">MoveBridgeMetadataAssignment</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_b_f_n_1_1_normalize_native_program" id="r_struct_b_f_n_1_1_normalize_native_program"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tna_arch_translation.html#struct_b_f_n_1_1_normalize_native_program">NormalizeNativeProgram</a></td></tr>
<tr class="separator:struct_b_f_n_1_1_normalize_native_program"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_optional_to_ternary_match_type_converter" id="r_class_b_f_n_1_1_optional_to_ternary_match_type_converter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__midend.html#class_b_f_n_1_1_optional_to_ternary_match_type_converter">OptionalToTernaryMatchTypeConverter</a></td></tr>
<tr class="memdesc:class_b_f_n_1_1_optional_to_ternary_match_type_converter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass that converts optional match type to ternary.  <a href="group__midend.html#class_b_f_n_1_1_optional_to_ternary_match_type_converter">More...</a><br /></td></tr>
<tr class="separator:class_b_f_n_1_1_optional_to_ternary_match_type_converter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_p4_runtime_std_converter.html">P4RuntimeStdConverter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_pad_flexible_field.html">PadFlexibleField</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_parse_annotations.html">ParseAnnotations</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_parser_enforce_depth_req" id="r_class_b_f_n_1_1_parser_enforce_depth_req"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__midend.html#class_b_f_n_1_1_parser_enforce_depth_req">ParserEnforceDepthReq</a></td></tr>
<tr class="memdesc:class_b_f_n_1_1_parser_enforce_depth_req"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enforce parser min/max depth requirements.  <a href="group__midend.html#class_b_f_n_1_1_parser_enforce_depth_req">More...</a><br /></td></tr>
<tr class="separator:class_b_f_n_1_1_parser_enforce_depth_req"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_parser_loops_info.html">ParserLoopsInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_parser_pragmas.html">ParserPragmas</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_parser_resources_logging.html">ParserResourcesLogging</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for generating JSON info with parser resources usage for visualization in P4I.  <a href="class_b_f_n_1_1_parser_resources_logging.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_parse_tna" id="r_class_b_f_n_1_1_parse_tna"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___arch_translation.html#class_b_f_n_1_1_parse_tna">ParseTna</a></td></tr>
<tr class="separator:class_b_f_n_1_1_parse_tna"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_path_linearizer.html">PathLinearizer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_ping_pong_generation" id="r_class_b_f_n_1_1_ping_pong_generation"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__midend.html#class_b_f_n_1_1_ping_pong_generation">PingPongGeneration</a></td></tr>
<tr class="memdesc:class_b_f_n_1_1_ping_pong_generation"><td class="mdescLeft">&#160;</td><td class="mdescRight">PassManager that adds the ping pong mechanism for ghost thread.  <a href="group__midend.html#class_b_f_n_1_1_ping_pong_generation">More...</a><br /></td></tr>
<tr class="separator:class_b_f_n_1_1_ping_pong_generation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_pipeline.html">Pipeline</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_portable_switch_translation" id="r_class_b_f_n_1_1_portable_switch_translation"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___portable_switch_translation.html#class_b_f_n_1_1_portable_switch_translation">PortableSwitchTranslation</a></td></tr>
<tr class="memdesc:class_b_f_n_1_1_portable_switch_translation"><td class="mdescLeft">&#160;</td><td class="mdescRight">PassManager that governs normalization of PSA architecture.  <a href="group___portable_switch_translation.html#class_b_f_n_1_1_portable_switch_translation">More...</a><br /></td></tr>
<tr class="separator:class_b_f_n_1_1_portable_switch_translation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_port_metadata.html">PortMetadata</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_pragma.html">Pragma</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_process_backend_pipe.html">ProcessBackendPipe</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">must be applied to IR::BFN::Pipe  <a href="class_b_f_n_1_1_process_backend_pipe.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_process_parde.html">ProcessParde</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_program_pipelines.html">ProgramPipelines</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_program_structure.html">ProgramStructure</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_p_s_a_arch_handler_builder.html">PSAArchHandlerBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The architecture handler builder implementation for PSA.  <a href="struct_b_f_n_1_1_p_s_a_arch_handler_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_psa_bridge_ingress_to_egress.html">PsaBridgeIngressToEgress</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_register.html">Register</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The information about a register instance which is needed to serialize it.  <a href="struct_b_f_n_1_1_register.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_register_param.html">RegisterParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The information about a register parameter instance which is needed to serialize it.  <a href="struct_b_f_n_1_1_register_param.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_register_read_write" id="r_class_b_f_n_1_1_register_read_write"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stateful__alu.html#class_b_f_n_1_1_register_read_write">RegisterReadWrite</a></td></tr>
<tr class="memdesc:class_b_f_n_1_1_register_read_write"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pass replaces the Register.read/write() calls with register actions.  <a href="group__stateful__alu.html#class_b_f_n_1_1_register_read_write">More...</a><br /></td></tr>
<tr class="separator:class_b_f_n_1_1_register_read_write"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_remove_action_parameters" id="r_class_b_f_n_1_1_remove_action_parameters"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___remove_action_parameters.html#class_b_f_n_1_1_remove_action_parameters">RemoveActionParameters</a></td></tr>
<tr class="memdesc:class_b_f_n_1_1_remove_action_parameters"><td class="mdescLeft">&#160;</td><td class="mdescRight">Top level PassManager that governs moving of action parameters out of the actions (specialized for BFN).  <a href="group___remove_action_parameters.html#class_b_f_n_1_1_remove_action_parameters">More...</a><br /></td></tr>
<tr class="separator:class_b_f_n_1_1_remove_action_parameters"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_b_f_n_1_1_remove_extern_method_calls_excluded_by_annotation" id="r_struct_b_f_n_1_1_remove_extern_method_calls_excluded_by_annotation"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___arch_translation.html#struct_b_f_n_1_1_remove_extern_method_calls_excluded_by_annotation">RemoveExternMethodCallsExcludedByAnnotation</a></td></tr>
<tr class="separator:struct_b_f_n_1_1_remove_extern_method_calls_excluded_by_annotation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_remove_select_booleans.html">RemoveSelectBooleans</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_remove_set_metadata.html">RemoveSetMetadata</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_b_f_n_1_1_remove_zero_varbit_extract" id="r_struct_b_f_n_1_1_remove_zero_varbit_extract"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___desugar_varbit_extract.html#struct_b_f_n_1_1_remove_zero_varbit_extract">RemoveZeroVarbitExtract</a></td></tr>
<tr class="separator:struct_b_f_n_1_1_remove_zero_varbit_extract"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_rename_p4_start_state.html">RenameP4StartState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_reset_header_stack_index.html">ResetHeaderStackIndex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_resolve_header_stack_index.html">ResolveHeaderStackIndex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_resolve_size_of_operator.html">ResolveSizeOfOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_resources_logging.html">ResourcesLogging</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for generating resources.json logfile.  <a href="class_b_f_n_1_1_resources_logging.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_b_f_n_1_1_restore_params" id="r_struct_b_f_n_1_1_restore_params"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___arch_translation.html#struct_b_f_n_1_1_restore_params">RestoreParams</a></td></tr>
<tr class="separator:struct_b_f_n_1_1_restore_params"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_rewrite_action_names.html">RewriteActionNames</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_rewrite_action_selector.html">RewriteActionSelector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_rewrite_cast_to_reinterpret_cast" id="r_class_b_f_n_1_1_rewrite_cast_to_reinterpret_cast"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___elim_casts.html#class_b_f_n_1_1_rewrite_cast_to_reinterpret_cast">RewriteCastToReinterpretCast</a></td></tr>
<tr class="memdesc:class_b_f_n_1_1_rewrite_cast_to_reinterpret_cast"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass that converts some of the IR::Casts to ReinterpretCasts.  <a href="group___elim_casts.html#class_b_f_n_1_1_rewrite_cast_to_reinterpret_cast">More...</a><br /></td></tr>
<tr class="separator:class_b_f_n_1_1_rewrite_cast_to_reinterpret_cast"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_rewrite_concat_to_slices" id="r_class_b_f_n_1_1_rewrite_concat_to_slices"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___elim_casts.html#class_b_f_n_1_1_rewrite_concat_to_slices">RewriteConcatToSlices</a></td></tr>
<tr class="memdesc:class_b_f_n_1_1_rewrite_concat_to_slices"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass that replaces concat ++ operations with multiple operations on slices in the contexts.  <a href="group___elim_casts.html#class_b_f_n_1_1_rewrite_concat_to_slices">More...</a><br /></td></tr>
<tr class="separator:class_b_f_n_1_1_rewrite_concat_to_slices"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_b_f_n_1_1_rewrite_control_and_parser_blocks" id="r_struct_b_f_n_1_1_rewrite_control_and_parser_blocks"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___arch_translation.html#struct_b_f_n_1_1_rewrite_control_and_parser_blocks">RewriteControlAndParserBlocks</a></td></tr>
<tr class="separator:struct_b_f_n_1_1_rewrite_control_and_parser_blocks"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_rewrite_egress_intrinsic_metadata_header" id="r_class_b_f_n_1_1_rewrite_egress_intrinsic_metadata_header"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__midend.html#class_b_f_n_1_1_rewrite_egress_intrinsic_metadata_header">RewriteEgressIntrinsicMetadataHeader</a></td></tr>
<tr class="memdesc:class_b_f_n_1_1_rewrite_egress_intrinsic_metadata_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass that updates egress intrinsic metadata.  <a href="group__midend.html#class_b_f_n_1_1_rewrite_egress_intrinsic_metadata_header">More...</a><br /></td></tr>
<tr class="separator:class_b_f_n_1_1_rewrite_egress_intrinsic_metadata_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_rewrite_flexible_struct" id="r_class_b_f_n_1_1_rewrite_flexible_struct"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___rewrite_flexible_struct.html#class_b_f_n_1_1_rewrite_flexible_struct">RewriteFlexibleStruct</a></td></tr>
<tr class="memdesc:class_b_f_n_1_1_rewrite_flexible_struct"><td class="mdescLeft">&#160;</td><td class="mdescRight">Top level PassManager that governs moving of flexible annotation from structure to its fields.  <a href="group___rewrite_flexible_struct.html#class_b_f_n_1_1_rewrite_flexible_struct">More...</a><br /></td></tr>
<tr class="separator:class_b_f_n_1_1_rewrite_flexible_struct"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_b_f_n_1_1_rewrite_header" id="r_struct_b_f_n_1_1_rewrite_header"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___rewrite_flexible_struct.html#struct_b_f_n_1_1_rewrite_header">RewriteHeader</a></td></tr>
<tr class="separator:struct_b_f_n_1_1_rewrite_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_rewrite_parser_checksums.html">RewriteParserChecksums</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_rewrite_parser_statements.html">RewriteParserStatements</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrites frontend parser IR statements to the backend ones.  <a href="struct_b_f_n_1_1_rewrite_parser_statements.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_rewrite_parser_verify" id="r_class_b_f_n_1_1_rewrite_parser_verify"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___desugar_varbit_extract.html#class_b_f_n_1_1_rewrite_parser_verify">RewriteParserVerify</a></td></tr>
<tr class="separator:class_b_f_n_1_1_rewrite_parser_verify"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_rewrite_path_to_start_state.html">RewritePathToStartState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_rewrite_type_arguments" id="r_class_b_f_n_1_1_rewrite_type_arguments"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___simplify_emit_args.html#class_b_f_n_1_1_rewrite_type_arguments">RewriteTypeArguments</a></td></tr>
<tr class="separator:class_b_f_n_1_1_rewrite_type_arguments"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_rewrite_varbit_types" id="r_class_b_f_n_1_1_rewrite_varbit_types"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___desugar_varbit_extract.html#class_b_f_n_1_1_rewrite_varbit_types">RewriteVarbitTypes</a></td></tr>
<tr class="separator:class_b_f_n_1_1_rewrite_varbit_types"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_rewrite_varbit_uses" id="r_class_b_f_n_1_1_rewrite_varbit_uses"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___desugar_varbit_extract.html#class_b_f_n_1_1_rewrite_varbit_uses">RewriteVarbitUses</a></td></tr>
<tr class="separator:class_b_f_n_1_1_rewrite_varbit_uses"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_save_hash_list_expression.html">SaveHashListExpression</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_search_and_replace_expr.html">SearchAndReplaceExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_set_default_size" id="r_class_b_f_n_1_1_set_default_size"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__midend.html#class_b_f_n_1_1_set_default_size">SetDefaultSize</a></td></tr>
<tr class="memdesc:class_b_f_n_1_1_set_default_size"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass that sets default table size to 512 entries.  <a href="group__midend.html#class_b_f_n_1_1_set_default_size">More...</a><br /></td></tr>
<tr class="separator:class_b_f_n_1_1_set_default_size"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_setup_action_properties.html">SetupActionProperties</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_simple_switch_translation" id="r_class_b_f_n_1_1_simple_switch_translation"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___simple_switch_translation.html#class_b_f_n_1_1_simple_switch_translation">SimpleSwitchTranslation</a></td></tr>
<tr class="memdesc:class_b_f_n_1_1_simple_switch_translation"><td class="mdescLeft">&#160;</td><td class="mdescRight">PassManager that governs normalization of v1model architecture.  <a href="group___simple_switch_translation.html#class_b_f_n_1_1_simple_switch_translation">More...</a><br /></td></tr>
<tr class="separator:class_b_f_n_1_1_simple_switch_translation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_simplify_emit_args" id="r_class_b_f_n_1_1_simplify_emit_args"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___simplify_emit_args.html#class_b_f_n_1_1_simplify_emit_args">SimplifyEmitArgs</a></td></tr>
<tr class="memdesc:class_b_f_n_1_1_simplify_emit_args"><td class="mdescLeft">&#160;</td><td class="mdescRight">Top level PassManager that governs simplification of headers and emits.  <a href="group___simplify_emit_args.html#class_b_f_n_1_1_simplify_emit_args">More...</a><br /></td></tr>
<tr class="separator:class_b_f_n_1_1_simplify_emit_args"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_simplify_nested_casts" id="r_class_b_f_n_1_1_simplify_nested_casts"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___elim_casts.html#class_b_f_n_1_1_simplify_nested_casts">SimplifyNestedCasts</a></td></tr>
<tr class="memdesc:class_b_f_n_1_1_simplify_nested_casts"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass that removes nested casts when applicable.  <a href="group___elim_casts.html#class_b_f_n_1_1_simplify_nested_casts">More...</a><br /></td></tr>
<tr class="separator:class_b_f_n_1_1_simplify_nested_casts"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_simplify_operation_binary" id="r_class_b_f_n_1_1_simplify_operation_binary"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___elim_casts.html#class_b_f_n_1_1_simplify_operation_binary">SimplifyOperationBinary</a></td></tr>
<tr class="memdesc:class_b_f_n_1_1_simplify_operation_binary"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass that moves the cast on binary operation to each operand.  <a href="group___elim_casts.html#class_b_f_n_1_1_simplify_operation_binary">More...</a><br /></td></tr>
<tr class="separator:class_b_f_n_1_1_simplify_operation_binary"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_simplify_redundant_casts" id="r_class_b_f_n_1_1_simplify_redundant_casts"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___elim_casts.html#class_b_f_n_1_1_simplify_redundant_casts">SimplifyRedundantCasts</a></td></tr>
<tr class="memdesc:class_b_f_n_1_1_simplify_redundant_casts"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass that removes some of the redundant casts.  <a href="group___elim_casts.html#class_b_f_n_1_1_simplify_redundant_casts">More...</a><br /></td></tr>
<tr class="separator:class_b_f_n_1_1_simplify_redundant_casts"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_snapshot_field_finder.html">SnapshotFieldFinder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_snapshot_field_id_table.html">SnapshotFieldIdTable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_snapshot_field_info.html">SnapshotFieldInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_split_alpm" id="r_class_b_f_n_1_1_split_alpm"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alpm.html#class_b_f_n_1_1_split_alpm">SplitAlpm</a></td></tr>
<tr class="memdesc:class_b_f_n_1_1_split_alpm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass that splits ALPM table into pre-classifier TCAM and TCAM.  <a href="group__alpm.html#class_b_f_n_1_1_split_alpm">More...</a><br /></td></tr>
<tr class="separator:class_b_f_n_1_1_split_alpm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_strength_reduction" id="r_class_b_f_n_1_1_strength_reduction"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___elim_casts.html#class_b_f_n_1_1_strength_reduction">StrengthReduction</a></td></tr>
<tr class="separator:class_b_f_n_1_1_strength_reduction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_symbol_type.html">SymbolType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends P4RuntimeSymbolType for the Tofino extern types.  <a href="class_b_f_n_1_1_symbol_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_t2na_arch_translation.html">T2naArchTranslation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">PassManager that governs normalization of T2NA architecture.  <a href="struct_b_f_n_1_1_t2na_arch_translation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_tna_arch_translation.html">TnaArchTranslation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">PassManager that governs normalization of TNA architecture.  <a href="struct_b_f_n_1_1_tna_arch_translation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_tofino_arch_handler_builder.html">TofinoArchHandlerBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The architecture handler builder implementation for Tofino.  <a href="struct_b_f_n_1_1_tofino_arch_handler_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_transform_resubmit_headers.html">TransformResubmitHeaders</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_translate_phase0.html">TranslatePhase0</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_translation_first" id="r_class_b_f_n_1_1_translation_first"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___arch_translation.html#class_b_f_n_1_1_translation_first">TranslationFirst</a></td></tr>
<tr class="separator:class_b_f_n_1_1_translation_first"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_translation_last" id="r_class_b_f_n_1_1_translation_last"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___arch_translation.html#class_b_f_n_1_1_translation_last">TranslationLast</a></td></tr>
<tr class="separator:class_b_f_n_1_1_translation_last"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_type_checking" id="r_class_b_f_n_1_1_type_checking"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__midend.html#class_b_f_n_1_1_type_checking">TypeChecking</a></td></tr>
<tr class="memdesc:class_b_f_n_1_1_type_checking"><td class="mdescLeft">&#160;</td><td class="mdescRight">A TypeChecking pass in BFN namespace that uses the extended TypeInference pass. This should be used in our midend.  <a href="group__midend.html#class_b_f_n_1_1_type_checking">More...</a><br /></td></tr>
<tr class="separator:class_b_f_n_1_1_type_checking"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:class_b_f_n_1_1_type_inference" id="r_class_b_f_n_1_1_type_inference"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__midend.html#class_b_f_n_1_1_type_inference">TypeInference</a></td></tr>
<tr class="memdesc:class_b_f_n_1_1_type_inference"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended type inference pass from p4c used in barefoot's midend.  <a href="group__midend.html#class_b_f_n_1_1_type_inference">More...</a><br /></td></tr>
<tr class="separator:class_b_f_n_1_1_type_inference"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_update_phase0_header.html">UpdatePhase0Header</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_update_phase0_node_in_parser.html">UpdatePhase0NodeInParser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_n_1_1_update_pov_bits.html">UpdatePovBits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge POV bits.  <a href="class_b_f_n_1_1_update_pov_bits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_value_set.html">ValueSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The information about a value set instance which is needed to serialize it.  <a href="struct_b_f_n_1_1_value_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_n_1_1_wred.html">Wred</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The information about a Wred instance which is needed to serialize it.  <a href="struct_b_f_n_1_1_wred.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga3016456fa0dd09f76d71e5d5d6848b2d" id="r_ga3016456fa0dd09f76d71e5d5d6848b2d"><td class="memItemLeft" align="right" valign="top">
typedef std::map&lt; const IR::P4Action *, std::vector&lt; const <a class="el" href="class_p4_1_1_extern_method.html">P4::ExternMethod</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ActionExterns</b></td></tr>
<tr class="separator:ga3016456fa0dd09f76d71e5d5d6848b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7daca1e16a461f5a41d497316fcde55e" id="r_a7daca1e16a461f5a41d497316fcde55e"><td class="memItemLeft" align="right" valign="top"><a id="a7daca1e16a461f5a41d497316fcde55e" name="a7daca1e16a461f5a41d497316fcde55e"></a>
typedef std::unordered_map&lt; const IR::Declaration *, std::unordered_set&lt; const IR::Declaration * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ActionsByRegister</b></td></tr>
<tr class="separator:a7daca1e16a461f5a41d497316fcde55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a427eaa8f0f961693665e90f8d5ec4b06" id="r_a427eaa8f0f961693665e90f8d5ec4b06"><td class="memItemLeft" align="right" valign="top"><a id="a427eaa8f0f961693665e90f8d5ec4b06" name="a427eaa8f0f961693665e90f8d5ec4b06"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>BitOffsetMap</b> = std::unordered_map&lt;const IR::MethodCallExpression *, unsigned&gt;</td></tr>
<tr class="separator:a427eaa8f0f961693665e90f8d5ec4b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga321e9d2a6f62cd5a3f27a2c52e64efa5" id="r_ga321e9d2a6f62cd5a3f27a2c52e64efa5"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>BlockInfoMapping</b> = std::multimap&lt;const <a class="el" href="class_p4_1_1_i_r_1_1_node.html">IR::Node</a> *, <a class="el" href="group___arch_translation.html#struct_b_f_n_1_1_block_info">BlockInfo</a>&gt;</td></tr>
<tr class="separator:ga321e9d2a6f62cd5a3f27a2c52e64efa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d44a60720e829b04f646fbe8f73332" id="r_a91d44a60720e829b04f646fbe8f73332"><td class="memItemLeft" align="right" valign="top"><a id="a91d44a60720e829b04f646fbe8f73332" name="a91d44a60720e829b04f646fbe8f73332"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ChecksumInstrMap</b> = std::unordered_map&lt;<a class="el" href="class_p4_1_1cstring.html">cstring</a>, const IR::MethodCallExpression *&gt;</td></tr>
<tr class="separator:a91d44a60720e829b04f646fbe8f73332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31e7f512496d822da3ea85ad4e1ff98" id="r_ae31e7f512496d822da3ea85ad4e1ff98"><td class="memItemLeft" align="right" valign="top"><a id="ae31e7f512496d822da3ea85ad4e1ff98" name="ae31e7f512496d822da3ea85ad4e1ff98"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ChecksumOffsetMap</b> = std::unordered_map&lt;<a class="el" href="class_p4_1_1cstring.html">cstring</a>, std::unordered_map&lt;<a class="el" href="class_p4_1_1cstring.html">cstring</a>, int&gt;&gt;</td></tr>
<tr class="separator:ae31e7f512496d822da3ea85ad4e1ff98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3052bb250ac730f4b44716545f359a31" id="r_a3052bb250ac730f4b44716545f359a31"><td class="memItemLeft" align="right" valign="top"><a id="a3052bb250ac730f4b44716545f359a31" name="a3052bb250ac730f4b44716545f359a31"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ChecksumSourceMap</b> = <a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt;const IR::Member *, const IR::MethodCallExpression *&gt;</td></tr>
<tr class="separator:a3052bb250ac730f4b44716545f359a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e21fe022c26ebc180922ecc2602c9c" id="r_a80e21fe022c26ebc180922ecc2602c9c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classassoc_1_1map.html">assoc::map</a>&lt; const IR::Declaration_Instance *, const IR::MAU::AttachedMemory * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80e21fe022c26ebc180922ecc2602c9c">DeclarationConversions</a></td></tr>
<tr class="separator:a80e21fe022c26ebc180922ecc2602c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga240bb4eefac4ef167f13fdf3d982e42d" id="r_ga240bb4eefac4ef167f13fdf3d982e42d"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>DefaultPortMap</b> = std::map&lt;int, std::vector&lt;int&gt;&gt;</td></tr>
<tr class="separator:ga240bb4eefac4ef167f13fdf3d982e42d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fec0f1d9a4d18e511682adc0926ebde" id="r_a6fec0f1d9a4d18e511682adc0926ebde"><td class="memItemLeft" align="right" valign="top"><a id="a6fec0f1d9a4d18e511682adc0926ebde" name="a6fec0f1d9a4d18e511682adc0926ebde"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ExtractedFieldsMap</b> = <a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt;const IR::Member *, const IR::BFN::PacketRVal *&gt;</td></tr>
<tr class="separator:a6fec0f1d9a4d18e511682adc0926ebde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5092bb738b83dcbce7af53149ff16223" id="r_a5092bb738b83dcbce7af53149ff16223"><td class="memItemLeft" align="right" valign="top"><a id="a5092bb738b83dcbce7af53149ff16223" name="a5092bb738b83dcbce7af53149ff16223"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>FieldListId</b> = std::tuple&lt;gress_t, unsigned, <a class="el" href="class_p4_1_1cstring.html">cstring</a>&gt;</td></tr>
<tr class="separator:a5092bb738b83dcbce7af53149ff16223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2fa2541548b08dce5bbeb9026b0ca65" id="r_ab2fa2541548b08dce5bbeb9026b0ca65"><td class="memItemLeft" align="right" valign="top"><a id="ab2fa2541548b08dce5bbeb9026b0ca65" name="ab2fa2541548b08dce5bbeb9026b0ca65"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>FieldRef</b> = std::pair&lt;<a class="el" href="class_p4_1_1cstring.html">cstring</a>, <a class="el" href="class_p4_1_1cstring.html">cstring</a>&gt;</td></tr>
<tr class="separator:ab2fa2541548b08dce5bbeb9026b0ca65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe58b4cf81dff2d7ac8dc99fbefd97ec" id="r_abe58b4cf81dff2d7ac8dc99fbefd97ec"><td class="memItemLeft" align="right" valign="top"><a id="abe58b4cf81dff2d7ac8dc99fbefd97ec" name="abe58b4cf81dff2d7ac8dc99fbefd97ec"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>HeaderToPad</b> = std::unordered_set&lt;<a class="el" href="class_p4_1_1cstring.html">cstring</a>&gt;</td></tr>
<tr class="separator:abe58b4cf81dff2d7ac8dc99fbefd97ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab478e885d3e8950d882c1c8f186cfc7" id="r_aab478e885d3e8950d882c1c8f186cfc7"><td class="memItemLeft" align="right" valign="top"><a id="aab478e885d3e8950d882c1c8f186cfc7" name="aab478e885d3e8950d882c1c8f186cfc7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>HeaderTypeMap</b> = <a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt;<a class="el" href="class_p4_1_1cstring.html">cstring</a>, const IR::Type_Header *&gt;</td></tr>
<tr class="separator:aab478e885d3e8950d882c1c8f186cfc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a3d3968554d6ee963c30ff64773bca" id="r_a46a3d3968554d6ee963c30ff64773bca"><td class="memItemLeft" align="right" valign="top"><a id="a46a3d3968554d6ee963c30ff64773bca" name="a46a3d3968554d6ee963c30ff64773bca"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MetadataMap</b> = <a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt;<a class="el" href="class_p4_1_1cstring.html">cstring</a>, IR::MetadataInfo *&gt;</td></tr>
<tr class="separator:a46a3d3968554d6ee963c30ff64773bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3792f786df33f96907755dc870f2781d" id="r_a3792f786df33f96907755dc870f2781d"><td class="memItemLeft" align="right" valign="top"><a id="a3792f786df33f96907755dc870f2781d" name="a3792f786df33f96907755dc870f2781d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MirroredFieldList</b> = <a class="el" href="class_p4_1_1_i_r_1_1_vector.html">IR::Vector</a>&lt;IR::Expression&gt;</td></tr>
<tr class="separator:a3792f786df33f96907755dc870f2781d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0145ab61c30437b69512bbf6ee6e7c25" id="r_a0145ab61c30437b69512bbf6ee6e7c25"><td class="memItemLeft" align="right" valign="top"><a id="a0145ab61c30437b69512bbf6ee6e7c25" name="a0145ab61c30437b69512bbf6ee6e7c25"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MirroredFieldLists</b> = std::map&lt;FieldListId, const <a class="el" href="class_p4_1_1_i_r_1_1_vector.html">MirroredFieldList</a> *&gt;</td></tr>
<tr class="separator:a0145ab61c30437b69512bbf6ee6e7c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae513b5b05621d231d713315254062fc" id="r_aae513b5b05621d231d713315254062fc"><td class="memItemLeft" align="right" valign="top"><a id="aae513b5b05621d231d713315254062fc" name="aae513b5b05621d231d713315254062fc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>NodeNameMap</b> = <a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt;const <a class="el" href="class_p4_1_1_i_r_1_1_node.html">IR::Node</a> *, <a class="el" href="class_p4_1_1cstring.html">cstring</a>&gt;</td></tr>
<tr class="separator:aae513b5b05621d231d713315254062fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168c3a10da27797642958fe98d2a1023" id="r_a168c3a10da27797642958fe98d2a1023"><td class="memItemLeft" align="right" valign="top"><a id="a168c3a10da27797642958fe98d2a1023" name="a168c3a10da27797642958fe98d2a1023"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Phase0AnnotMap</b> = std::map&lt;<a class="el" href="class_p4_1_1cstring.html">cstring</a>, <a class="el" href="class_p4_1_1cstring.html">cstring</a>&gt;</td></tr>
<tr class="separator:a168c3a10da27797642958fe98d2a1023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d150c57fc6972e8e2d6b297b4e4582a" id="r_a7d150c57fc6972e8e2d6b297b4e4582a"><td class="memItemLeft" align="right" valign="top"><a id="a7d150c57fc6972e8e2d6b297b4e4582a" name="a7d150c57fc6972e8e2d6b297b4e4582a"></a>
typedef std::map&lt; const IR::BFN::TnaParser *, const IR::Type_StructLike * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Phase0CallMap</b></td></tr>
<tr class="separator:a7d150c57fc6972e8e2d6b297b4e4582a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a766124ebb46189d90c06058574a9b706" id="r_a766124ebb46189d90c06058574a9b706"><td class="memItemLeft" align="right" valign="top"><a id="a766124ebb46189d90c06058574a9b706" name="a766124ebb46189d90c06058574a9b706"></a>
typedef std::unordered_map&lt; const IR::P4Control *, <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; IR::Declaration_Instance * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RegisterActionsByControl</b></td></tr>
<tr class="separator:a766124ebb46189d90c06058574a9b706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f67e9ef30a634c33df550153e3e688" id="r_a02f67e9ef30a634c33df550153e3e688"><td class="memItemLeft" align="right" valign="top"><a id="a02f67e9ef30a634c33df550153e3e688" name="a02f67e9ef30a634c33df550153e3e688"></a>
typedef std::unordered_map&lt; const IR::Declaration *, std::unordered_map&lt; const IR::Declaration_Instance *, <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const IR::Statement * &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RegisterCallsByAction</b></td></tr>
<tr class="separator:a02f67e9ef30a634c33df550153e3e688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309e3a86d5919a4a3be5c6b5841a999b" id="r_a309e3a86d5919a4a3be5c6b5841a999b"><td class="memItemLeft" align="right" valign="top"><a id="a309e3a86d5919a4a3be5c6b5841a999b" name="a309e3a86d5919a4a3be5c6b5841a999b"></a>
typedef std::unordered_map&lt; const IR::Declaration *, std::unordered_map&lt; const IR::Declaration_Instance *, IR::MethodCallExpression * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RegisterExecuteCallByAction</b></td></tr>
<tr class="separator:a309e3a86d5919a4a3be5c6b5841a999b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e41128ffe63d066075688928aea4b69" id="r_a8e41128ffe63d066075688928aea4b69"><td class="memItemLeft" align="right" valign="top"><a id="a8e41128ffe63d066075688928aea4b69" name="a8e41128ffe63d066075688928aea4b69"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ResubmitExtracts</b> = std::map&lt;unsigned, std::pair&lt;<a class="el" href="class_p4_1_1cstring.html">cstring</a>, const <a class="el" href="class_p4_1_1_i_r_1_1_vector.html">ResubmitSources</a> *&gt;&gt;</td></tr>
<tr class="separator:a8e41128ffe63d066075688928aea4b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe2b8bdae2116cb325f173296dd36790" id="r_abe2b8bdae2116cb325f173296dd36790"><td class="memItemLeft" align="right" valign="top"><a id="abe2b8bdae2116cb325f173296dd36790" name="abe2b8bdae2116cb325f173296dd36790"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ResubmitHeaders</b> = std::unordered_set&lt;<a class="el" href="class_p4_1_1cstring.html">cstring</a>&gt;</td></tr>
<tr class="separator:abe2b8bdae2116cb325f173296dd36790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe5ad8ba4bd22d00e8a08ba9c6cadff1" id="r_afe5ad8ba4bd22d00e8a08ba9c6cadff1"><td class="memItemLeft" align="right" valign="top"><a id="afe5ad8ba4bd22d00e8a08ba9c6cadff1" name="afe5ad8ba4bd22d00e8a08ba9c6cadff1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ResubmitSources</b> = <a class="el" href="class_p4_1_1_i_r_1_1_vector.html">IR::Vector</a>&lt;IR::Expression&gt;</td></tr>
<tr class="separator:afe5ad8ba4bd22d00e8a08ba9c6cadff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf358c740bf0848dfb75c7524c7b2d2" id="r_a9cf358c740bf0848dfb75c7524c7b2d2"><td class="memItemLeft" align="right" valign="top"><a id="a9cf358c740bf0848dfb75c7524c7b2d2" name="a9cf358c740bf0848dfb75c7524c7b2d2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SimpleNameMap</b> = std::map&lt;<a class="el" href="class_p4_1_1cstring.html">cstring</a>, <a class="el" href="class_p4_1_1cstring.html">cstring</a>&gt;</td></tr>
<tr class="separator:a9cf358c740bf0848dfb75c7524c7b2d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403bb793b604abb6a77df47cb252b83d" id="r_a403bb793b604abb6a77df47cb252b83d"><td class="memItemLeft" align="right" valign="top"><a id="a403bb793b604abb6a77df47cb252b83d" name="a403bb793b604abb6a77df47cb252b83d"></a>
typedef <a class="el" href="classassoc_1_1map.html">assoc::map</a>&lt; const IR::Declaration_Instance *, const IR::MAU::Selector * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>StatefulSelectors</b></td></tr>
<tr class="separator:a403bb793b604abb6a77df47cb252b83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260c5b3636f6723fe48182abb385b355" id="r_a260c5b3636f6723fe48182abb385b355"><td class="memItemLeft" align="right" valign="top"><a id="a260c5b3636f6723fe48182abb385b355" name="a260c5b3636f6723fe48182abb385b355"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>TranslationMap</b> = <a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt;const <a class="el" href="class_p4_1_1_i_r_1_1_node.html">IR::Node</a> *, const <a class="el" href="class_p4_1_1_i_r_1_1_node.html">IR::Node</a> *&gt;</td></tr>
<tr class="separator:a260c5b3636f6723fe48182abb385b355"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:adefa12a856e855c837cd1769284d8d3c" id="r_adefa12a856e855c837cd1769284d8d3c"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adefa12a856e855c837cd1769284d8d3c">Arch</a> { <b>TNA</b>
, <b>PSA</b>
 }</td></tr>
<tr class="separator:adefa12a856e855c837cd1769284d8d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca2d8c21eebbc7d2fb385a34a754dd69" id="r_gaca2d8c21eebbc7d2fb385a34a754dd69"><td class="memItemLeft" align="right" valign="top"><a id="gaca2d8c21eebbc7d2fb385a34a754dd69" name="gaca2d8c21eebbc7d2fb385a34a754dd69"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ArchBlock_t</b> { <b>PARSER</b> = 0
, <b>MAU</b>
, <b>DEPARSER</b>
, <b>BLOCK_TYPE</b>
 }</td></tr>
<tr class="separator:gaca2d8c21eebbc7d2fb385a34a754dd69"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab79e18acb36657afb741a1001722b424" id="r_ab79e18acb36657afb741a1001722b424"><td class="memItemLeft" align="right" valign="top"><a id="ab79e18acb36657afb741a1001722b424" name="ab79e18acb36657afb741a1001722b424"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>add_param</b> (<a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt; <a class="el" href="class_p4_1_1cstring.html">cstring</a>, <a class="el" href="class_p4_1_1cstring.html">cstring</a> &gt; &amp;tnaParams, const IR::ParameterList *params, IR::ParameterList *newParams, <a class="el" href="class_p4_1_1cstring.html">cstring</a> hdr, size_t index, <a class="el" href="class_p4_1_1cstring.html">cstring</a> hdr_type=&quot;&quot;_cs, IR::Direction dir=IR::Direction::None)</td></tr>
<tr class="separator:ab79e18acb36657afb741a1001722b424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cab46dbcd73702fd89dec81cbca6fb0" id="r_a7cab46dbcd73702fd89dec81cbca6fb0"><td class="memItemLeft" align="right" valign="top"><a id="a7cab46dbcd73702fd89dec81cbca6fb0" name="a7cab46dbcd73702fd89dec81cbca6fb0"></a>
const IR::ParserState *&#160;</td><td class="memItemRight" valign="bottom"><b>addNewStartState</b> (<a class="el" href="class_p4_1_1cstring.html">cstring</a> name, <a class="el" href="class_p4_1_1cstring.html">cstring</a> nextState)</td></tr>
<tr class="separator:a7cab46dbcd73702fd89dec81cbca6fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03bff8dcfd894c02dfe89e179982d7a1" id="r_a03bff8dcfd894c02dfe89e179982d7a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03bff8dcfd894c02dfe89e179982d7a1">addNewStartState</a> (IR::P4Parser *parser, <a class="el" href="class_p4_1_1cstring.html">cstring</a> name, <a class="el" href="class_p4_1_1cstring.html">cstring</a> nextState)</td></tr>
<tr class="separator:a03bff8dcfd894c02dfe89e179982d7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1287a4ded581997515aa84e5178e61ec" id="r_a1287a4ded581997515aa84e5178e61ec"><td class="memItemLeft" align="right" valign="top"><a id="a1287a4ded581997515aa84e5178e61ec" name="a1287a4ded581997515aa84e5178e61ec"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>check_compile_time_constant</b> (const IR::Constant *c, const IR::MethodCallExpression *call, int varbit_field_size, bool zero_ok=false)</td></tr>
<tr class="separator:a1287a4ded581997515aa84e5178e61ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af802b41a57f832e74d0d80b286d51e02" id="r_af802b41a57f832e74d0d80b286d51e02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af802b41a57f832e74d0d80b286d51e02">collect_diagnostic_checks</a> (<a class="el" href="class_bf_error_reporter.html">BfErrorReporter</a> &amp;reporter, <a class="el" href="class_b_f_n___options.html">BFN_Options</a> &amp;options)</td></tr>
<tr class="memdesc:af802b41a57f832e74d0d80b286d51e02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects error/warning checks from the program.  <br /></td></tr>
<tr class="separator:af802b41a57f832e74d0d80b286d51e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3b074da63cf2630ff2aa8175d41ec4" id="r_a5b3b074da63cf2630ff2aa8175d41ec4"><td class="memItemLeft" align="right" valign="top"><a id="a5b3b074da63cf2630ff2aa8175d41ec4" name="a5b3b074da63cf2630ff2aa8175d41ec4"></a>
std::vector&lt; const IR::Expression * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>convertConcatToList</b> (const IR::Concat *expr)</td></tr>
<tr class="separator:a5b3b074da63cf2630ff2aa8175d41ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef607ae3e273fa2f1ebae0c3b1726c3" id="r_aaef607ae3e273fa2f1ebae0c3b1726c3"><td class="memItemLeft" align="right" valign="top"><a id="aaef607ae3e273fa2f1ebae0c3b1726c3" name="aaef607ae3e273fa2f1ebae0c3b1726c3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>convertConcatToList</b> (std::vector&lt; const IR::Expression * &gt; &amp;slices, const IR::Concat *expr)</td></tr>
<tr class="separator:aaef607ae3e273fa2f1ebae0c3b1726c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8525677601be8990b77cb9db82a5926" id="r_ac8525677601be8990b77cb9db82a5926"><td class="memItemLeft" align="right" valign="top"><a id="ac8525677601be8990b77cb9db82a5926" name="ac8525677601be8990b77cb9db82a5926"></a>
const IR::ParserState *&#160;</td><td class="memItemRight" valign="bottom"><b>convertStartStateToNormalState</b> (const IR::ParserState *state, <a class="el" href="class_p4_1_1cstring.html">cstring</a> newName)</td></tr>
<tr class="separator:ac8525677601be8990b77cb9db82a5926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab751c2e755f97c9d6d0b2431daa97ca2" id="r_ab751c2e755f97c9d6d0b2431daa97ca2"><td class="memItemLeft" align="right" valign="top">const IR::ParserState *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab751c2e755f97c9d6d0b2431daa97ca2">convertStartStateToNormalState</a> (IR::P4Parser *parser, <a class="el" href="class_p4_1_1cstring.html">cstring</a> newName)</td></tr>
<tr class="separator:ab751c2e755f97c9d6d0b2431daa97ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b18ec73c14a19d79e6585a1e31bce0" id="r_a95b18ec73c14a19d79e6585a1e31bce0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_p4_1_1_p4_runtime_a_p_i.html">P4::P4RuntimeAPI</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95b18ec73c14a19d79e6585a1e31bce0">convertToStdP4Runtime</a> (const <a class="el" href="struct_p4_1_1_p4_runtime_a_p_i.html">P4::P4RuntimeAPI</a> &amp;p4RuntimeIn)</td></tr>
<tr class="separator:a95b18ec73c14a19d79e6585a1e31bce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74bbdf90789a337ba3bb86ff72300d63" id="r_a74bbdf90789a337ba3bb86ff72300d63"><td class="memItemLeft" align="right" valign="top"><a id="a74bbdf90789a337ba3bb86ff72300d63" name="a74bbdf90789a337ba3bb86ff72300d63"></a>
IR::Member *&#160;</td><td class="memItemRight" valign="bottom"><b>create_member</b> (<a class="el" href="class_p4_1_1cstring.html">cstring</a> hdr, <a class="el" href="class_p4_1_1cstring.html">cstring</a> member)</td></tr>
<tr class="separator:a74bbdf90789a337ba3bb86ff72300d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0c064903f8b1fb0693e690c309006c" id="r_aed0c064903f8b1fb0693e690c309006c"><td class="memItemLeft" align="right" valign="top"><a id="aed0c064903f8b1fb0693e690c309006c" name="aed0c064903f8b1fb0693e690c309006c"></a>
IR::AssignmentStatement *&#160;</td><td class="memItemRight" valign="bottom"><b>create_valid_statement</b> (const IR::Type_Header *hdr, const IR::Expression *path, bool value)</td></tr>
<tr class="separator:aed0c064903f8b1fb0693e690c309006c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a216d4b4f00693bffd96016848a77a7" id="r_a9a216d4b4f00693bffd96016848a77a7"><td class="memItemLeft" align="right" valign="top">const IR::Statement *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a216d4b4f00693bffd96016848a77a7">createAdvanceCall</a> (<a class="el" href="class_p4_1_1cstring.html">cstring</a> pkt, int bits)</td></tr>
<tr class="separator:a9a216d4b4f00693bffd96016848a77a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85964266e506da1f55b19926c650f33c" id="r_a85964266e506da1f55b19926c650f33c"><td class="memItemLeft" align="right" valign="top">const IR::Statement *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85964266e506da1f55b19926c650f33c">createExtractCall</a> (<a class="el" href="class_p4_1_1cstring.html">cstring</a> pkt, <a class="el" href="class_p4_1_1cstring.html">cstring</a> type, <a class="el" href="class_p4_1_1cstring.html">cstring</a> hdr)</td></tr>
<tr class="separator:a85964266e506da1f55b19926c650f33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c2b31b0466af93899a969b328935c0" id="r_ab0c2b31b0466af93899a969b328935c0"><td class="memItemLeft" align="right" valign="top">const IR::Statement *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0c2b31b0466af93899a969b328935c0">createExtractCall</a> (<a class="el" href="class_p4_1_1cstring.html">cstring</a> pkt, <a class="el" href="class_p4_1_1cstring.html">cstring</a> typeName, IR::Expression *member)</td></tr>
<tr class="separator:ab0c2b31b0466af93899a969b328935c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cdfdafb642e08d9a0be216dd7a749f0" id="r_a9cdfdafb642e08d9a0be216dd7a749f0"><td class="memItemLeft" align="right" valign="top">const IR::Statement *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cdfdafb642e08d9a0be216dd7a749f0">createExtractCall</a> (<a class="el" href="class_p4_1_1cstring.html">cstring</a> pkt, IR::Expression *member)</td></tr>
<tr class="separator:a9cdfdafb642e08d9a0be216dd7a749f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f27a4285bd491c9dbb4e376b5d6fd6" id="r_a95f27a4285bd491c9dbb4e376b5d6fd6"><td class="memItemLeft" align="right" valign="top">const IR::ParserState *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95f27a4285bd491c9dbb4e376b5d6fd6">createGeneratedParserState</a> (<a class="el" href="class_p4_1_1cstring.html">cstring</a> name, <a class="el" href="class_p4_1_1_i_r_1_1_indexed_vector.html">IR::IndexedVector</a>&lt; IR::StatOrDecl &gt; &amp;&amp;statements, const IR::Expression *selectExpression)</td></tr>
<tr class="separator:a95f27a4285bd491c9dbb4e376b5d6fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f948b785e835fc37a66b3f1b32b0b1" id="r_a92f948b785e835fc37a66b3f1b32b0b1"><td class="memItemLeft" align="right" valign="top"><a id="a92f948b785e835fc37a66b3f1b32b0b1" name="a92f948b785e835fc37a66b3f1b32b0b1"></a>
const IR::ParserState *&#160;</td><td class="memItemRight" valign="bottom"><b>createGeneratedParserState</b> (<a class="el" href="class_p4_1_1cstring.html">cstring</a> name, <a class="el" href="class_p4_1_1_i_r_1_1_indexed_vector.html">IR::IndexedVector</a>&lt; IR::StatOrDecl &gt; &amp;&amp;statements, <a class="el" href="class_p4_1_1cstring.html">cstring</a> nextState)</td></tr>
<tr class="separator:a92f948b785e835fc37a66b3f1b32b0b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1dca5f5e9a7aff278a30cc47c9a5c23" id="r_ab1dca5f5e9a7aff278a30cc47c9a5c23"><td class="memItemLeft" align="right" valign="top">const IR::Expression *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1dca5f5e9a7aff278a30cc47c9a5c23">createLookaheadExpr</a> (<a class="el" href="class_p4_1_1cstring.html">cstring</a> pkt, int bits)</td></tr>
<tr class="separator:ab1dca5f5e9a7aff278a30cc47c9a5c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8eaf6a1775a2c6469ac19be22b47e57" id="r_ae8eaf6a1775a2c6469ac19be22b47e57"><td class="memItemLeft" align="right" valign="top">const IR::SelectCase *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8eaf6a1775a2c6469ac19be22b47e57">createSelectCase</a> (unsigned bitWidth, unsigned value, unsigned mask, const IR::ParserState *nextState)</td></tr>
<tr class="separator:ae8eaf6a1775a2c6469ac19be22b47e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5558dde70033a8dbac375467b6d209" id="r_aef5558dde70033a8dbac375467b6d209"><td class="memItemLeft" align="right" valign="top">const IR::Statement *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef5558dde70033a8dbac375467b6d209">createSetMetadata</a> (const IR::Expression *dest, <a class="el" href="class_p4_1_1cstring.html">cstring</a> header, <a class="el" href="class_p4_1_1cstring.html">cstring</a> field)</td></tr>
<tr class="separator:aef5558dde70033a8dbac375467b6d209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee0b62b38d5a626cf1295a924673879" id="r_a4ee0b62b38d5a626cf1295a924673879"><td class="memItemLeft" align="right" valign="top">const IR::Statement *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ee0b62b38d5a626cf1295a924673879">createSetMetadata</a> (<a class="el" href="class_p4_1_1cstring.html">cstring</a> header, <a class="el" href="class_p4_1_1cstring.html">cstring</a> field, int bitWidth, int constant)</td></tr>
<tr class="separator:a4ee0b62b38d5a626cf1295a924673879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbeb50bd2f0b8627287acd80c25f4441" id="r_acbeb50bd2f0b8627287acd80c25f4441"><td class="memItemLeft" align="right" valign="top">const IR::Statement *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acbeb50bd2f0b8627287acd80c25f4441">createSetMetadata</a> (<a class="el" href="class_p4_1_1cstring.html">cstring</a> param, <a class="el" href="class_p4_1_1cstring.html">cstring</a> header, <a class="el" href="class_p4_1_1cstring.html">cstring</a> field, int bitWidth, int constant)</td></tr>
<tr class="separator:acbeb50bd2f0b8627287acd80c25f4441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0ce5293fcf25cf6dfc136281963b9b" id="r_ace0ce5293fcf25cf6dfc136281963b9b"><td class="memItemLeft" align="right" valign="top">const IR::Statement *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace0ce5293fcf25cf6dfc136281963b9b">createSetValid</a> (const <a class="el" href="class_p4_1_1_util_1_1_source_info.html">Util::SourceInfo</a> &amp;si, <a class="el" href="class_p4_1_1cstring.html">cstring</a> header, <a class="el" href="class_p4_1_1cstring.html">cstring</a> field)</td></tr>
<tr class="separator:ace0ce5293fcf25cf6dfc136281963b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac97c8f7e7a5315d790e95f37b1540d1b" id="r_ac97c8f7e7a5315d790e95f37b1540d1b"><td class="memItemLeft" align="right" valign="top"><a id="ac97c8f7e7a5315d790e95f37b1540d1b" name="ac97c8f7e7a5315d790e95f37b1540d1b"></a>
const IR::BFN::Pipe *&#160;</td><td class="memItemRight" valign="bottom"><b>extract_maupipe</b> (const IR::P4Program *, <a class="el" href="class_b_f_n___options.html">BFN_Options</a> &amp;options)</td></tr>
<tr class="separator:ac97c8f7e7a5315d790e95f37b1540d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e547bdecf6ca866ce12868444dcedda" id="r_ga2e547bdecf6ca866ce12868444dcedda"><td class="memItemLeft" align="right" valign="top">IR::BFN::Pipe *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___extract_checksum.html#ga2e547bdecf6ca866ce12868444dcedda">extractChecksumFromDeparser</a> (const IR::BFN::TnaDeparser *deparser, IR::BFN::Pipe *pipe)</td></tr>
<tr class="separator:ga2e547bdecf6ca866ce12868444dcedda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5519749268c3acb04a84b3c326bc7541" id="r_ga5519749268c3acb04a84b3c326bc7541"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga5519749268c3acb04a84b3c326bc7541"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__midend.html#ga5519749268c3acb04a84b3c326bc7541">findContext</a> (const <a class="el" href="struct_p4_1_1_visitor___context.html">Visitor::Context</a> *c)</td></tr>
<tr class="separator:ga5519749268c3acb04a84b3c326bc7541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4e408ecbbded318ff9889ad8e2b725" id="r_a3b4e408ecbbded318ff9889ad8e2b725"><td class="memItemLeft" align="right" valign="top"><a id="a3b4e408ecbbded318ff9889ad8e2b725" name="a3b4e408ecbbded318ff9889ad8e2b725"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>force_link_dump</b> (const <a class="el" href="class_p4_1_1_i_r_1_1_node.html">IR::Node</a> *n)</td></tr>
<tr class="separator:a3b4e408ecbbded318ff9889ad8e2b725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b5a7ecfb4259bd22073bffadf25e73" id="r_a98b5a7ecfb4259bd22073bffadf25e73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98b5a7ecfb4259bd22073bffadf25e73">generateRuntime</a> (const IR::P4Program *program, const <a class="el" href="class_b_f_n___options.html">BFN_Options</a> &amp;options)</td></tr>
<tr class="separator:a98b5a7ecfb4259bd22073bffadf25e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae322f1df544aa58f28606e7bf7a642" id="r_a4ae322f1df544aa58f28606e7bf7a642"><td class="memItemLeft" align="right" valign="top"><a id="a4ae322f1df544aa58f28606e7bf7a642" name="a4ae322f1df544aa58f28606e7bf7a642"></a>
const IR::StructField *&#160;</td><td class="memItemRight" valign="bottom"><b>get_varbit_structfield</b> (const IR::Member *member)</td></tr>
<tr class="separator:a4ae322f1df544aa58f28606e7bf7a642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfe8d98b79697401bdf910b2320d3fa" id="r_aecfe8d98b79697401bdf910b2320d3fa"><td class="memItemLeft" align="right" valign="top"><a id="aecfe8d98b79697401bdf910b2320d3fa" name="aecfe8d98b79697401bdf910b2320d3fa"></a>
<a class="el" href="struct_b_f_n_1_1_assign_or.html">AssignOr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getAssignOr</b> (const IR::Expression *lhs, const IR::Expression *rhs)</td></tr>
<tr class="separator:aecfe8d98b79697401bdf910b2320d3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86acc323ca0348db2e1b440ff8062d3d" id="r_a86acc323ca0348db2e1b440ff8062d3d"><td class="memItemLeft" align="right" valign="top"><a id="a86acc323ca0348db2e1b440ff8062d3d" name="a86acc323ca0348db2e1b440ff8062d3d"></a>
const IR::Type *&#160;</td><td class="memItemRight" valign="bottom"><b>getBaseType</b> (const IR::Type *type)</td></tr>
<tr class="separator:a86acc323ca0348db2e1b440ff8062d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3231829d4f7298eff9cb8e8aaf5dbb0f" id="r_a3231829d4f7298eff9cb8e8aaf5dbb0f"><td class="memItemLeft" align="right" valign="top">const IR::Parameter *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3231829d4f7298eff9cb8e8aaf5dbb0f">getContainingParameter</a> (const <a class="el" href="struct_b_f_n_1_1_linear_path.html">LinearPath</a> &amp;path, <a class="el" href="class_p4_1_1_reference_map.html">P4::ReferenceMap</a> *refMap)</td></tr>
<tr class="separator:a3231829d4f7298eff9cb8e8aaf5dbb0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b0490ce79fac2d6af8c8489f60ded3" id="r_a47b0490ce79fac2d6af8c8489f60ded3"><td class="memItemLeft" align="right" valign="top">const IR::Declaration_Instance *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47b0490ce79fac2d6af8c8489f60ded3">getDeclInst</a> (const <a class="el" href="class_p4_1_1_reference_map.html">P4::ReferenceMap</a> *refMap, const IR::PathExpression *path)</td></tr>
<tr class="separator:a47b0490ce79fac2d6af8c8489f60ded3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfdf1b89de5d2d32f8b5faf952c035ed" id="r_abfdf1b89de5d2d32f8b5faf952c035ed"><td class="memItemLeft" align="right" valign="top"><a id="abfdf1b89de5d2d32f8b5faf952c035ed" name="abfdf1b89de5d2d32f8b5faf952c035ed"></a>
<a class="el" href="class_p4_1_1cstring.html">cstring</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getDefaultPhase0TableKeyName</b> ()</td></tr>
<tr class="separator:abfdf1b89de5d2d32f8b5faf952c035ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4096ee5571d8958b96e157527897ff64" id="r_a4096ee5571d8958b96e157527897ff64"><td class="memItemLeft" align="right" valign="top"><a id="a4096ee5571d8958b96e157527897ff64" name="a4096ee5571d8958b96e157527897ff64"></a>
std::optional&lt; const IR::ExpressionValue * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getExpressionFromProperty</b> (const IR::P4Table *table, const <a class="el" href="class_p4_1_1cstring.html">cstring</a> &amp;propertyName)</td></tr>
<tr class="separator:a4096ee5571d8958b96e157527897ff64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0fdb14b1be228b601b48e3aff79c76" id="r_ace0fdb14b1be228b601b48e3aff79c76"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="struct_p4_1_1_extern_instance.html">P4::ExternInstance</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace0fdb14b1be228b601b48e3aff79c76">getExternInstanceFromProperty</a> (const IR::P4Table *table, <a class="el" href="class_p4_1_1cstring.html">cstring</a> propertyName, <a class="el" href="class_p4_1_1_reference_map.html">P4::ReferenceMap</a> *refMap, <a class="el" href="class_p4_1_1_type_map.html">P4::TypeMap</a> *typeMap)</td></tr>
<tr class="separator:ace0fdb14b1be228b601b48e3aff79c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318b7dc7ae0b060a7746e786df0936f3" id="r_a318b7dc7ae0b060a7746e786df0936f3"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="struct_p4_1_1_extern_instance.html">P4::ExternInstance</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a318b7dc7ae0b060a7746e786df0936f3">getExternInstanceFromPropertyByTypeName</a> (const IR::P4Table *table, <a class="el" href="class_p4_1_1cstring.html">cstring</a> propertyName, <a class="el" href="class_p4_1_1cstring.html">cstring</a> externTypeName, <a class="el" href="class_p4_1_1_reference_map.html">P4::ReferenceMap</a> *refMap, <a class="el" href="class_p4_1_1_type_map.html">P4::TypeMap</a> *typeMap, bool *isConstructedInPlace)</td></tr>
<tr class="separator:a318b7dc7ae0b060a7746e786df0936f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dbda403b220d4839db4dbed1543b85b" id="r_a5dbda403b220d4839db4dbed1543b85b"><td class="memItemLeft" align="right" valign="top"><a id="a5dbda403b220d4839db4dbed1543b85b" name="a5dbda403b220d4839db4dbed1543b85b"></a>
std::optional&lt; <a class="el" href="class_p4_1_1cstring.html">cstring</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getExternTypeName</b> (const <a class="el" href="class_p4_1_1_extern_method.html">P4::ExternMethod</a> *extMethod)</td></tr>
<tr class="separator:a5dbda403b220d4839db4dbed1543b85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86909ded5f68cfc8991a4b4b536d7677" id="r_a86909ded5f68cfc8991a4b4b536d7677"><td class="memItemLeft" align="right" valign="top"><a id="a86909ded5f68cfc8991a4b4b536d7677" name="a86909ded5f68cfc8991a4b4b536d7677"></a>
<a class="el" href="class_p4_1_1cstring.html">cstring</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getTypeName</b> (const IR::Type *type)</td></tr>
<tr class="separator:a86909ded5f68cfc8991a4b4b536d7677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6400180812639d2c7184f1a865946bcb" id="r_a6400180812639d2c7184f1a865946bcb"><td class="memItemLeft" align="right" valign="top"><a id="a6400180812639d2c7184f1a865946bcb" name="a6400180812639d2c7184f1a865946bcb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasAtcamPragma</b> (const IR::P4Table *const table_ptr)</td></tr>
<tr class="separator:a6400180812639d2c7184f1a865946bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae781b876fd3ce31697113381fab01f12" id="r_ae781b876fd3ce31697113381fab01f12"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae781b876fd3ce31697113381fab01f12">isCompilerGeneratedType</a> (const IR::Type *type)</td></tr>
<tr class="separator:ae781b876fd3ce31697113381fab01f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1eccf62db8ae2460d43638b7b513145" id="r_ae1eccf62db8ae2460d43638b7b513145"><td class="memItemLeft" align="right" valign="top"><a id="ae1eccf62db8ae2460d43638b7b513145" name="ae1eccf62db8ae2460d43638b7b513145"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isEgressIntrinsicHeader</b> (const IR::Type *type)</td></tr>
<tr class="separator:ae1eccf62db8ae2460d43638b7b513145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a515805e7049521198847a3df49573a59" id="r_a515805e7049521198847a3df49573a59"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a515805e7049521198847a3df49573a59">isHeaderReference</a> (const <a class="el" href="struct_b_f_n_1_1_linear_path.html">LinearPath</a> &amp;path, <a class="el" href="class_p4_1_1_type_map.html">P4::TypeMap</a> *typeMap)</td></tr>
<tr class="separator:a515805e7049521198847a3df49573a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade18b77ae21f74ae8816b7027d6de63e" id="r_ade18b77ae21f74ae8816b7027d6de63e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade18b77ae21f74ae8816b7027d6de63e">isHeaderType</a> (const IR::Type *type)</td></tr>
<tr class="separator:ade18b77ae21f74ae8816b7027d6de63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97be3b73e982d19a91f32ea77086e0b6" id="r_a97be3b73e982d19a91f32ea77086e0b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97be3b73e982d19a91f32ea77086e0b6">isIntrinsicMetadataType</a> (const IR::Type *type)</td></tr>
<tr class="separator:a97be3b73e982d19a91f32ea77086e0b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d55ffb757ace701b91df7aaab55aee" id="r_a71d55ffb757ace701b91df7aaab55aee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71d55ffb757ace701b91df7aaab55aee">isMetadataReference</a> (const <a class="el" href="struct_b_f_n_1_1_linear_path.html">LinearPath</a> &amp;path, <a class="el" href="class_p4_1_1_type_map.html">P4::TypeMap</a> *typeMap)</td></tr>
<tr class="separator:a71d55ffb757ace701b91df7aaab55aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72521594675df0eea7af47123fe8afc4" id="r_a72521594675df0eea7af47123fe8afc4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72521594675df0eea7af47123fe8afc4">isMetadataType</a> (const IR::Type *type)</td></tr>
<tr class="separator:a72521594675df0eea7af47123fe8afc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e046fe64220a17484d4266fe0af013" id="r_a19e046fe64220a17484d4266fe0af013"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19e046fe64220a17484d4266fe0af013">isPrimitiveFieldReference</a> (const <a class="el" href="struct_b_f_n_1_1_linear_path.html">LinearPath</a> &amp;path, <a class="el" href="class_p4_1_1_type_map.html">P4::TypeMap</a> *typeMap)</td></tr>
<tr class="separator:a19e046fe64220a17484d4266fe0af013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906cfd73eb8bb47809024f6f948c5a0f" id="r_a906cfd73eb8bb47809024f6f948c5a0f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a906cfd73eb8bb47809024f6f948c5a0f">isPrimitiveReference</a> (const <a class="el" href="struct_b_f_n_1_1_linear_path.html">LinearPath</a> &amp;path, <a class="el" href="class_p4_1_1_type_map.html">P4::TypeMap</a> *typeMap)</td></tr>
<tr class="separator:a906cfd73eb8bb47809024f6f948c5a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e94e344c21616cddb3a23d89b2f833" id="r_a07e94e344c21616cddb3a23d89b2f833"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07e94e344c21616cddb3a23d89b2f833">isPrimitiveType</a> (const IR::Type *type)</td></tr>
<tr class="separator:a07e94e344c21616cddb3a23d89b2f833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f77eb905bef701740d2c359ad449c1a" id="r_a8f77eb905bef701740d2c359ad449c1a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f77eb905bef701740d2c359ad449c1a">isSubobjectOfParameter</a> (const <a class="el" href="struct_b_f_n_1_1_linear_path.html">LinearPath</a> &amp;path, <a class="el" href="class_p4_1_1_reference_map.html">P4::ReferenceMap</a> *refMap)</td></tr>
<tr class="separator:a8f77eb905bef701740d2c359ad449c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac091d49bcd9f9eb014dcc46825e255c5" id="r_ac091d49bcd9f9eb014dcc46825e255c5"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="namespace_p4.html#a19f5abed1a21ad7a5703944aa5099da7">nw_bitrange</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac091d49bcd9f9eb014dcc46825e255c5">lookaheadToExtractRange</a> (<a class="el" href="class_p4_1_1_type_map.html">P4::TypeMap</a> *typeMap, const IR::Expression *expr, int currentBit, bool *partial_hdr_err_proc)</td></tr>
<tr class="separator:ac091d49bcd9f9eb014dcc46825e255c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525093220981a5c276a34a0d8599409d" id="r_a525093220981a5c276a34a0d8599409d"><td class="memItemLeft" align="right" valign="top"><a id="a525093220981a5c276a34a0d8599409d" name="a525093220981a5c276a34a0d8599409d"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const <a class="el" href="struct_b_f_n_1_1_metadata_field.html">BFN::MetadataField</a> &amp;m)</td></tr>
<tr class="separator:a525093220981a5c276a34a0d8599409d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39c6e0ccae5685762f5e810a600b44b" id="r_af39c6e0ccae5685762f5e810a600b44b"><td class="memItemLeft" align="right" valign="top"><a id="af39c6e0ccae5685762f5e810a600b44b" name="af39c6e0ccae5685762f5e810a600b44b"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const <a class="el" href="class_b_f_n_1_1_dynamic_hash_json.html">DynamicHashJson</a> &amp;dyn)</td></tr>
<tr class="separator:af39c6e0ccae5685762f5e810a600b44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb1c5ed07772d58bb4106e3338f6985" id="r_a5eb1c5ed07772d58bb4106e3338f6985"><td class="memItemLeft" align="right" valign="top"><a id="a5eb1c5ed07772d58bb4106e3338f6985" name="a5eb1c5ed07772d58bb4106e3338f6985"></a>
const IR::BFN::PacketRVal *&#160;</td><td class="memItemRight" valign="bottom"><b>resolveLookahead</b> (<a class="el" href="class_p4_1_1_type_map.html">P4::TypeMap</a> *typeMap, const IR::Expression *expr, int currentBit)</td></tr>
<tr class="separator:a5eb1c5ed07772d58bb4106e3338f6985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601d74e34998ca507e55fc2789f07948" id="r_a601d74e34998ca507e55fc2789f07948"><td class="memItemLeft" align="right" valign="top"><a id="a601d74e34998ca507e55fc2789f07948" name="a601d74e34998ca507e55fc2789f07948"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>skipFlexibleHeader</b> (const <a class="el" href="struct_p4_1_1_visitor___context.html">Visitor::Context</a> *, const IR::Type_StructLike *e)</td></tr>
<tr class="separator:a601d74e34998ca507e55fc2789f07948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae430f4c2f6818a99321392bca639add8" id="r_gae430f4c2f6818a99321392bca639add8"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>skipRegisterActionOutput</b> (const <a class="el" href="struct_p4_1_1_visitor___context.html">Visitor::Context</a> *ctxt, const IR::Expression *)</td></tr>
<tr class="separator:gae430f4c2f6818a99321392bca639add8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ecc25d6047260dd3615b8675c2cc723" id="r_a7ecc25d6047260dd3615b8675c2cc723"><td class="memItemLeft" align="right" valign="top"><a id="a7ecc25d6047260dd3615b8675c2cc723" name="a7ecc25d6047260dd3615b8675c2cc723"></a>
const IR::Expression *&#160;</td><td class="memItemRight" valign="bottom"><b>stripReinterpret</b> (const IR::Expression *rhs)</td></tr>
<tr class="separator:a7ecc25d6047260dd3615b8675c2cc723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c173f65b654a16954bc4e1ad2119184" id="r_a1c173f65b654a16954bc4e1ad2119184"><td class="memItemLeft" align="right" valign="top"><a id="a1c173f65b654a16954bc4e1ad2119184" name="a1c173f65b654a16954bc4e1ad2119184"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TEST</b> (BFNTypeCategories, Types)</td></tr>
<tr class="separator:a1c173f65b654a16954bc4e1ad2119184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f0fd0bfb13e14195c2bef849032249" id="r_a33f0fd0bfb13e14195c2bef849032249"><td class="memItemLeft" align="right" valign="top"><a id="a33f0fd0bfb13e14195c2bef849032249" name="a33f0fd0bfb13e14195c2bef849032249"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TEST</b> (TofinoFieldPacking, CreateExtractionState)</td></tr>
<tr class="separator:a33f0fd0bfb13e14195c2bef849032249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd011943fca80026e4680ddf7e7996e" id="r_a4bd011943fca80026e4680ddf7e7996e"><td class="memItemLeft" align="right" valign="top"><a id="a4bd011943fca80026e4680ddf7e7996e" name="a4bd011943fca80026e4680ddf7e7996e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TEST</b> (TofinoFieldPacking, EmptyPackingAlignment)</td></tr>
<tr class="separator:a4bd011943fca80026e4680ddf7e7996e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4edc65099e5a460d1afbb0784249f4d8" id="r_a4edc65099e5a460d1afbb0784249f4d8"><td class="memItemLeft" align="right" valign="top"><a id="a4edc65099e5a460d1afbb0784249f4d8" name="a4edc65099e5a460d1afbb0784249f4d8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TEST</b> (TofinoFieldPacking, <a class="el" href="struct_field_alignment.html">FieldAlignment</a>)</td></tr>
<tr class="separator:a4edc65099e5a460d1afbb0784249f4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a31a04945be67acc06148573cd39c53" id="r_a2a31a04945be67acc06148573cd39c53"><td class="memItemLeft" align="right" valign="top"><a id="a2a31a04945be67acc06148573cd39c53" name="a2a31a04945be67acc06148573cd39c53"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TEST</b> (TofinoFieldPacking, Fields)</td></tr>
<tr class="separator:a2a31a04945be67acc06148573cd39c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0471251b8def2b4c739c9d1ceb3e6c" id="r_a6d0471251b8def2b4c739c9d1ceb3e6c"><td class="memItemLeft" align="right" valign="top"><a id="a6d0471251b8def2b4c739c9d1ceb3e6c" name="a6d0471251b8def2b4c739c9d1ceb3e6c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TEST</b> (TofinoFieldPacking, ForEachField)</td></tr>
<tr class="separator:a6d0471251b8def2b4c739c9d1ceb3e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79f5fdcae3653128c800c883851bc82" id="r_aa79f5fdcae3653128c800c883851bc82"><td class="memItemLeft" align="right" valign="top"><a id="aa79f5fdcae3653128c800c883851bc82" name="aa79f5fdcae3653128c800c883851bc82"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TEST</b> (TofinoFieldPacking, LargePhase)</td></tr>
<tr class="separator:aa79f5fdcae3653128c800c883851bc82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8abc7c7f6250682040f4202bbfe004ba" id="r_a8abc7c7f6250682040f4202bbfe004ba"><td class="memItemLeft" align="right" valign="top"><a id="a8abc7c7f6250682040f4202bbfe004ba" name="a8abc7c7f6250682040f4202bbfe004ba"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TEST</b> (TofinoFieldPacking, Padding)</td></tr>
<tr class="separator:a8abc7c7f6250682040f4202bbfe004ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2060f267dfefc000a52a1cd28c877176" id="r_a2060f267dfefc000a52a1cd28c877176"><td class="memItemLeft" align="right" valign="top"><a id="a2060f267dfefc000a52a1cd28c877176" name="a2060f267dfefc000a52a1cd28c877176"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TEST</b> (TofinoFieldPacking, PaddingAlignment)</td></tr>
<tr class="separator:a2060f267dfefc000a52a1cd28c877176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c84abc50dda17f1150d2fa99a34e26b" id="r_a6c84abc50dda17f1150d2fa99a34e26b"><td class="memItemLeft" align="right" valign="top"><a id="a6c84abc50dda17f1150d2fa99a34e26b" name="a6c84abc50dda17f1150d2fa99a34e26b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TEST</b> (TofinoFieldPacking, ZeroAlignment)</td></tr>
<tr class="separator:a6c84abc50dda17f1150d2fa99a34e26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d111e25d747cb994fa56afee5f8d2b" id="r_a00d111e25d747cb994fa56afee5f8d2b"><td class="memItemLeft" align="right" valign="top"><a id="a00d111e25d747cb994fa56afee5f8d2b" name="a00d111e25d747cb994fa56afee5f8d2b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TEST</b> (TofinoFieldPacking, ZeroPadding)</td></tr>
<tr class="separator:a00d111e25d747cb994fa56afee5f8d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a165c83223462339f872bc6bfad56320d" id="r_a165c83223462339f872bc6bfad56320d"><td class="memItemLeft" align="right" valign="top"><a id="a165c83223462339f872bc6bfad56320d" name="a165c83223462339f872bc6bfad56320d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TEST</b> (TofinoPathLinearizer, HeaderStackIndexing)</td></tr>
<tr class="separator:a165c83223462339f872bc6bfad56320d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306515be7ad87993fddd11e6a1f7efe2" id="r_a306515be7ad87993fddd11e6a1f7efe2"><td class="memItemLeft" align="right" valign="top"><a id="a306515be7ad87993fddd11e6a1f7efe2" name="a306515be7ad87993fddd11e6a1f7efe2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TEST</b> (TofinoPathLinearizer, MemberExpression)</td></tr>
<tr class="separator:a306515be7ad87993fddd11e6a1f7efe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad4a20638011504131f28a3e5ec74bf" id="r_a7ad4a20638011504131f28a3e5ec74bf"><td class="memItemLeft" align="right" valign="top"><a id="a7ad4a20638011504131f28a3e5ec74bf" name="a7ad4a20638011504131f28a3e5ec74bf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TEST</b> (TofinoPathLinearizer, NestedMemberExpressions)</td></tr>
<tr class="separator:a7ad4a20638011504131f28a3e5ec74bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cdfd3b507c63ca6fae1dc5e63f8417b" id="r_a7cdfd3b507c63ca6fae1dc5e63f8417b"><td class="memItemLeft" align="right" valign="top"><a id="a7cdfd3b507c63ca6fae1dc5e63f8417b" name="a7cdfd3b507c63ca6fae1dc5e63f8417b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TEST</b> (TofinoPathLinearizer, PathExpression)</td></tr>
<tr class="separator:a7cdfd3b507c63ca6fae1dc5e63f8417b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3441635af1824ac63b59b27dbb2d7cb" id="r_ad3441635af1824ac63b59b27dbb2d7cb"><td class="memItemLeft" align="right" valign="top"><a id="ad3441635af1824ac63b59b27dbb2d7cb" name="ad3441635af1824ac63b59b27dbb2d7cb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TEST</b> (TofinoPathLinearizer, RejectNonPathlikeExpressions)</td></tr>
<tr class="separator:ad3441635af1824ac63b59b27dbb2d7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca82dcb6549dc4008b2fe7084e4e4dd" id="r_a0ca82dcb6549dc4008b2fe7084e4e4dd"><td class="memItemLeft" align="right" valign="top"><a id="a0ca82dcb6549dc4008b2fe7084e4e4dd" name="a0ca82dcb6549dc4008b2fe7084e4e4dd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TEST</b> (TofinoPathLinearizer, RejectUnexpectedExpressions)</td></tr>
<tr class="separator:a0ca82dcb6549dc4008b2fe7084e4e4dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c73a92ea223c9d8b304c9dcc4b9e29" id="r_ae9c73a92ea223c9d8b304c9dcc4b9e29"><td class="memItemLeft" align="right" valign="top"><a id="ae9c73a92ea223c9d8b304c9dcc4b9e29" name="ae9c73a92ea223c9d8b304c9dcc4b9e29"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_lower</b> (std::smatch::const_reference it)</td></tr>
<tr class="separator:ae9c73a92ea223c9d8b304c9dcc4b9e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac086abe7a2a8eb914f93d0de103724e1" id="r_ac086abe7a2a8eb914f93d0de103724e1"><td class="memItemLeft" align="right" valign="top"><a id="ac086abe7a2a8eb914f93d0de103724e1" name="ac086abe7a2a8eb914f93d0de103724e1"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>algoHandle</b> = 0x0</td></tr>
<tr class="separator:ac086abe7a2a8eb914f93d0de103724e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a3180544e66887c8b083af9dd3a9e3" id="r_aa8a3180544e66887c8b083af9dd3a9e3"><td class="memItemLeft" align="right" valign="top"><a id="aa8a3180544e66887c8b083af9dd3a9e3" name="aa8a3180544e66887c8b083af9dd3a9e3"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>dynHashHandle</b> = 0x0</td></tr>
<tr class="separator:aa8a3180544e66887c8b083af9dd3a9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a2977aaa766f60206560c66d1f670d9" id="r_ga1a2977aaa766f60206560c66d1f670d9"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="class_p4_1_1cstring.html">cstring</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ExternDynamicHashString</b> = &quot;hash&quot;_cs</td></tr>
<tr class="separator:ga1a2977aaa766f60206560c66d1f670d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e0351a5cbf95d2d472097be77ed8487" id="r_ga5e0351a5cbf95d2d472097be77ed8487"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="class_p4_1_1cstring.html">cstring</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ExternPortMetadataUnpackString</b> = &quot;port_metadata_unpack&quot;_cs</td></tr>
<tr class="separator:ga5e0351a5cbf95d2d472097be77ed8487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f352dfcfa9fc208b95e384c22a9a6f" id="r_a37f352dfcfa9fc208b95e384c22a9a6f"><td class="memItemLeft" align="right" valign="top"><a id="a37f352dfcfa9fc208b95e384c22a9a6f" name="a37f352dfcfa9fc208b95e384c22a9a6f"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>fieldListHandle</b> = 0x0</td></tr>
<tr class="separator:a37f352dfcfa9fc208b95e384c22a9a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The namespace encapsulating Barefoot/Intel-specific stuff. </p>
<p>Copyright (C) 2024 Intel Corporation</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p>
<p><a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p>SPDX-License-Identifier: Apache-2.0</p>
<p>Copyright (C) 2024 Intel Corporation</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p>
<p><a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p>SPDX-License-Identifier: Apache-2.0 Collect pipelines form program.</p>
<p>Copyright (C) 2024 Intel Corporation</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p>
<p><a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p>SPDX-License-Identifier: Apache-2.0 Detects multiple pipelines in a program</p>
<p>Copyright (C) 2024 Intel Corporation</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p>
<p><a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p>SPDX-License-Identifier: Apache-2.0 Detects program with multiple pipelines.</p>
<p>Copyright (C) 2024 Intel Corporation</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p>
<p><a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p>SPDX-License-Identifier: Apache-2.0 Impact for Large Packets Dropped at Ingress Deparser Description: If the ingress deparser drops a packet it is possible that no learning digest will be generated, and that ingress MAU byte counters and meters are credited with a byte count less than the actual size of the packet. This may happen if the entire packet is not received before the ingress deparser processes it. The exact packet sizes at which this may occur depend on the latency of the ingress pipeline but are on the order of larger than about 7600 bytes for a 400g interface or about 2200 bytes for a 100g interface. Workaround: Do not drop packets at the ingress deparser, instead mirror them to a disabled mirroring session to drop them by the mirror block. This fix applies to Tofino 1 and 2.</p>
<p>Copyright (C) 2024 Intel Corporation</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p>
<p><a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p>SPDX-License-Identifier: Apache-2.0 Detects registers that are used by ingress and ghost, creates a duplicate tables and registers if needed and attaches a ping-pong mechanism onto them.</p>
<p>This file contains implementation of different methods, refer to the header file for more abstract overview to determine what each method should do and is used for. </p>
</div><hr/><h2 class="groupheader">Class Documentation</h2>
<a name="struct_b_f_n_1_1_bridged_field_info" id="struct_b_f_n_1_1_bridged_field_info"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_b_f_n_1_1_bridged_field_info">&#9670;&#160;</a></span>BFN::BridgedFieldInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct BFN::BridgedFieldInfo</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="aa4120bc96fde85018a2b6a6e0c145361" name="aa4120bc96fde85018a2b6a6e0c145361"></a>const Expression *</td>
<td class="fieldname">
refTemplate</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="ad89c90fe69d1b15a37ad92b68d764248" name="ad89c90fe69d1b15a37ad92b68d764248"></a>const Type *</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="struct_b_f_n_1_1_counter_extern" id="struct_b_f_n_1_1_counter_extern"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_b_f_n_1_1_counter_extern">&#9670;&#160;</a></span>BFN::CounterExtern</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct BFN::CounterExtern</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><div class="compoundTemplParams">template&lt;<a class="el" href="#adefa12a856e855c837cd1769284d8d3c">Arch</a> arch&gt;<br />
struct BFN::CounterExtern&lt; arch &gt;</div></div>
</div>
</div>
<a name="struct_b_f_n_1_1_digest" id="struct_b_f_n_1_1_digest"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_b_f_n_1_1_digest">&#9670;&#160;</a></span>BFN::Digest</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct BFN::Digest</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>The information about a digest instance which is needed to serialize it. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a030a1829d4cdf490b4542fbcd8036fee" name="a030a1829d4cdf490b4542fbcd8036fee"></a>const IAnnotated *</td>
<td class="fieldname">
annotations</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a700c405dca1c564c9c0e7a39c1b8bdfa" name="a700c405dca1c564c9c0e7a39c1b8bdfa"></a>const <a class="el" href="class_p4_1_1cstring.html">cstring</a></td>
<td class="fieldname">
name</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a00906af7e25743593104ed97dc47fdab" name="a00906af7e25743593104ed97dc47fdab"></a>const P4DataTypeSpec *</td>
<td class="fieldname">
typeSpec</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="struct_b_f_n_1_1_dyn_hash" id="struct_b_f_n_1_1_dyn_hash"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_b_f_n_1_1_dyn_hash">&#9670;&#160;</a></span>BFN::DynHash</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct BFN::DynHash</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>The information about a hash instance which is needed to serialize it. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a70d5190d3cda54b1a1b56758de602dda" name="a70d5190d3cda54b1a1b56758de602dda"></a>const IAnnotated *</td>
<td class="fieldname">
annotations</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a861f5ad505d35ac097e34be84bc74f8a" name="a861f5ad505d35ac097e34be84bc74f8a"></a>vector&lt; <a class="el" href="#struct_b_f_n_1_1_dyn_hash_1_1hash_field">hashField</a> &gt;</td>
<td class="fieldname">
hashFieldInfo</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="abd2f53e47e1a39cbf70eab460dd11bc5" name="abd2f53e47e1a39cbf70eab460dd11bc5"></a>const int</td>
<td class="fieldname">
hashWidth</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="aba3820df9e2f031f885f88b2c9b3ba35" name="aba3820df9e2f031f885f88b2c9b3ba35"></a>const <a class="el" href="class_p4_1_1cstring.html">cstring</a></td>
<td class="fieldname">
name</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="aa22c6d751e02489f8c5ce9deda96e4aa" name="aa22c6d751e02489f8c5ce9deda96e4aa"></a>const P4DataTypeSpec *</td>
<td class="fieldname">
typeSpec</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="struct_b_f_n_1_1_match" id="struct_b_f_n_1_1_match"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_b_f_n_1_1_match">&#9670;&#160;</a></span>BFN::Match</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct BFN::Match</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="ae415acaa988ea8b488303b49368d57ee" name="ae415acaa988ea8b488303b49368d57ee"></a>unsigned</td>
<td class="fieldname">
mask = 0</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a670381264fdb1f52f4af00b479687704" name="a670381264fdb1f52f4af00b479687704"></a>unsigned</td>
<td class="fieldname">
value = 0</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="struct_b_f_n_1_1_meter_extern" id="struct_b_f_n_1_1_meter_extern"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_b_f_n_1_1_meter_extern">&#9670;&#160;</a></span>BFN::MeterExtern</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct BFN::MeterExtern</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><div class="compoundTemplParams">template&lt;<a class="el" href="#adefa12a856e855c837cd1769284d8d3c">Arch</a> arch&gt;<br />
struct BFN::MeterExtern&lt; arch &gt;</div></div>
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a80e21fe022c26ebc180922ecc2602c9c" name="a80e21fe022c26ebc180922ecc2602c9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80e21fe022c26ebc180922ecc2602c9c">&#9670;&#160;</a></span>DeclarationConversions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classassoc_1_1map.html">assoc::map</a>&lt;const IR::Declaration_Instance *, const IR::MAU::AttachedMemory *&gt; <a class="el" href="#a80e21fe022c26ebc180922ecc2602c9c">BFN::DeclarationConversions</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The purpose of this code is to translate in each pipeline to Backend structures. At the top of each pipeline, each extern to be used by that pipeline is declared.</p>
<p>At the moment, we only resolve Declaration Instances to create BackendAttached tables. This may need to extend to other features at somepoint, for example Checksums, or other potential parser externs.</p>
<p>Furthermore, there is not always a one-to-one map of Declaration_Instance to BackendAttached table. The two currently known and handled cases are:</p><ol type="1">
<li>An action profile and a action selector share a Declaration_Instance</li>
<li>A stateful selector will also share an instance with an action profile or action selector</li>
</ol>
<p>These two special cases are handled individually in the code, rather than having a total map for the entire gress. Depending on how complicated cases get, this may have to expanded at somepoint. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="adefa12a856e855c837cd1769284d8d3c" name="adefa12a856e855c837cd1769284d8d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adefa12a856e855c837cd1769284d8d3c">&#9670;&#160;</a></span>Arch</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#adefa12a856e855c837cd1769284d8d3c">BFN::Arch</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>We re-use as much code as possible between PSA and TNA. The two architectures have some differences though, in particular regarding naming (of table properties, extern types, parameter names). We define some "traits" for each extern type, templatized by the architecture name (using the Arch enum class defined below), as a convenient way to access architecture-specific names in the unified code. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a03bff8dcfd894c02dfe89e179982d7a1" name="a03bff8dcfd894c02dfe89e179982d7a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03bff8dcfd894c02dfe89e179982d7a1">&#9670;&#160;</a></span>addNewStartState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BFN::addNewStartState </td>
          <td>(</td>
          <td class="paramtype">IR::P4Parser *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1cstring.html">cstring</a></td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1cstring.html">cstring</a></td>          <td class="paramname"><span class="paramname"><em>nextState</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new start state to the given parser, with a potentially non-'start' name applied via an <code>@name</code> annotation. </p>

</div>
</div>
<a id="af802b41a57f832e74d0d80b286d51e02" name="af802b41a57f832e74d0d80b286d51e02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af802b41a57f832e74d0d80b286d51e02">&#9670;&#160;</a></span>collect_diagnostic_checks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BFN::collect_diagnostic_checks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bf_error_reporter.html">BfErrorReporter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>reporter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_b_f_n___options.html">BFN_Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects error/warning checks from the program. </p>
<p>Checks are added by comments containing expect error@OFFSET: "REGEXP" and expect warning@OFFSET: "REGEXP".</p>
<p>OFFSET is the difference between the source line that the comment is on and the line that the compiler is expected to report the error/warning on. It can be omitted together with the '@', in which case it is set to 0, meaning the error/warning is expected on the same line. In case the error/warning has no source line reported, the text NO SOURCE should be written in place of OFFSET, which makes the check not require any source line.</p>
<p>REGEXP is the regular expression for the expected error/warning message.</p>
<p>The expected error/warning messages are EMCAScript regular expressions that messages reported during compilation will be matched against. If the source line number is required, the repored message has to include it. If the reported message has multiple locations, the specified source line can be any of them.</p>
<p>If there is at least one error check in the program, the compiler will return a success return code (0) if each reported error has been matched with one error check and there are no unmatched error checks left at the end of the compilation, otherwise the compiler will report a failure. Warnings are less strict and will cause a failure only if there are unmatched warning checks left at the end of the compilation, but there can be other warnings that are not listed in checks.</p>
<p>Example checks:</p><ul>
<li>Check that requires the same source location as the comment: // expect error: "The action increment indexes .* with .* but it also indexes .* with .*\."</li>
<li>Check that requires the preceding line as the source location: // expect warning-1: "field list cannot be empty"</li>
<li>Check that doesn't require a source location: // expect error@NO SOURCE: "0, "PHV allocation failed" </li>
</ul>

</div>
</div>
<a id="ab751c2e755f97c9d6d0b2431daa97ca2" name="ab751c2e755f97c9d6d0b2431daa97ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab751c2e755f97c9d6d0b2431daa97ca2">&#9670;&#160;</a></span>convertStartStateToNormalState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const IR::ParserState * BFN::convertStartStateToNormalState </td>
          <td>(</td>
          <td class="paramtype">IR::P4Parser *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1cstring.html">cstring</a></td>          <td class="paramname"><span class="paramname"><em>newName</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rename the start state of the given parser and return it. This will leave the parser without a start state, so the caller must create a new one. </p>

</div>
</div>
<a id="a95b18ec73c14a19d79e6585a1e31bce0" name="a95b18ec73c14a19d79e6585a1e31bce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95b18ec73c14a19d79e6585a1e31bce0">&#9670;&#160;</a></span>convertToStdP4Runtime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_p4_1_1_p4_runtime_a_p_i.html">P4::P4RuntimeAPI</a> BFN::convertToStdP4Runtime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p4_1_1_p4_runtime_a_p_i.html">P4::P4RuntimeAPI</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p4RuntimeInput</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Takes a P4Info message generated for a TNA-specific architecture and converts it to a "standard" P4Info message, which can be used with a standard P4Runtime implementation (with no support for TNA-specific extensions). Displays a warning to the user for each extern instance that cannot be converted. </p>

</div>
</div>
<a id="a9a216d4b4f00693bffd96016848a77a7" name="a9a216d4b4f00693bffd96016848a77a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a216d4b4f00693bffd96016848a77a7">&#9670;&#160;</a></span>createAdvanceCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const IR::Statement * BFN::createAdvanceCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p4_1_1cstring.html">cstring</a></td>          <td class="paramname"><span class="paramname"><em>pkt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>bits</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an <code>advance()</code> call that advances by the given number of bits. </dd></dl>

</div>
</div>
<a id="a85964266e506da1f55b19926c650f33c" name="a85964266e506da1f55b19926c650f33c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85964266e506da1f55b19926c650f33c">&#9670;&#160;</a></span>createExtractCall() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const IR::Statement * BFN::createExtractCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p4_1_1cstring.html">cstring</a></td>          <td class="paramname"><span class="paramname"><em>pkt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1cstring.html">cstring</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1cstring.html">cstring</a></td>          <td class="paramname"><span class="paramname"><em>hdr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an <code>extract()</code> call that extracts the given header. </dd></dl>

</div>
</div>
<a id="ab0c2b31b0466af93899a969b328935c0" name="ab0c2b31b0466af93899a969b328935c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0c2b31b0466af93899a969b328935c0">&#9670;&#160;</a></span>createExtractCall() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const IR::Statement * BFN::createExtractCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p4_1_1cstring.html">cstring</a></td>          <td class="paramname"><span class="paramname"><em>pkt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1cstring.html">cstring</a></td>          <td class="paramname"><span class="paramname"><em>typeName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IR::Expression *</td>          <td class="paramname"><span class="paramname"><em>member</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an <code>extract()</code> call that extracts the given header. </dd></dl>

</div>
</div>
<a id="a9cdfdafb642e08d9a0be216dd7a749f0" name="a9cdfdafb642e08d9a0be216dd7a749f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cdfdafb642e08d9a0be216dd7a749f0">&#9670;&#160;</a></span>createExtractCall() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const IR::Statement * BFN::createExtractCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p4_1_1cstring.html">cstring</a></td>          <td class="paramname"><span class="paramname"><em>pkt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IR::Expression *</td>          <td class="paramname"><span class="paramname"><em>member</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an <code>extract()</code> call that extracts the given header. </dd></dl>

</div>
</div>
<a id="a95f27a4285bd491c9dbb4e376b5d6fd6" name="a95f27a4285bd491c9dbb4e376b5d6fd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f27a4285bd491c9dbb4e376b5d6fd6">&#9670;&#160;</a></span>createGeneratedParserState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const IR::ParserState * BFN::createGeneratedParserState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p4_1_1cstring.html">cstring</a></td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1_i_r_1_1_indexed_vector.html">IR::IndexedVector</a>&lt; IR::StatOrDecl &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>statements</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IR::Expression *</td>          <td class="paramname"><span class="paramname"><em>selectExpression</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a parser state with a name that's distinct from the states in the P4 program and an <code>@name</code> annotation with a '$' prefix. Downstream, we search for certain '$' states and replace them with more generated parser code. </dd></dl>

</div>
</div>
<a id="ab1dca5f5e9a7aff278a30cc47c9a5c23" name="ab1dca5f5e9a7aff278a30cc47c9a5c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1dca5f5e9a7aff278a30cc47c9a5c23">&#9670;&#160;</a></span>createLookaheadExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const IR::Expression * BFN::createLookaheadExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p4_1_1cstring.html">cstring</a></td>          <td class="paramname"><span class="paramname"><em>pkt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>bits</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a lookahead expression for the given size of <code>bit&lt;&gt;</code> type. </dd></dl>

</div>
</div>
<a id="ae8eaf6a1775a2c6469ac19be22b47e57" name="ae8eaf6a1775a2c6469ac19be22b47e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8eaf6a1775a2c6469ac19be22b47e57">&#9670;&#160;</a></span>createSelectCase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const IR::SelectCase * BFN::createSelectCase </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>bitWidth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IR::ParserState *</td>          <td class="paramname"><span class="paramname"><em>nextState</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a SelectCase that checks for a constant value with some mask applied. </dd></dl>

</div>
</div>
<a id="aef5558dde70033a8dbac375467b6d209" name="aef5558dde70033a8dbac375467b6d209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5558dde70033a8dbac375467b6d209">&#9670;&#160;</a></span>createSetMetadata() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const IR::Statement * BFN::createSetMetadata </td>
          <td>(</td>
          <td class="paramtype">const IR::Expression *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1cstring.html">cstring</a></td>          <td class="paramname"><span class="paramname"><em>header</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1cstring.html">cstring</a></td>          <td class="paramname"><span class="paramname"><em>field</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an assignment statement of the form <code>dest = header.field</code>. </dd></dl>

</div>
</div>
<a id="a4ee0b62b38d5a626cf1295a924673879" name="a4ee0b62b38d5a626cf1295a924673879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ee0b62b38d5a626cf1295a924673879">&#9670;&#160;</a></span>createSetMetadata() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const IR::Statement * BFN::createSetMetadata </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p4_1_1cstring.html">cstring</a></td>          <td class="paramname"><span class="paramname"><em>header</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1cstring.html">cstring</a></td>          <td class="paramname"><span class="paramname"><em>field</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>bitWidth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>constant</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an assignment statement of the form <code>header.field = constant</code>. </dd></dl>

</div>
</div>
<a id="acbeb50bd2f0b8627287acd80c25f4441" name="acbeb50bd2f0b8627287acd80c25f4441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbeb50bd2f0b8627287acd80c25f4441">&#9670;&#160;</a></span>createSetMetadata() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const IR::Statement * BFN::createSetMetadata </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p4_1_1cstring.html">cstring</a></td>          <td class="paramname"><span class="paramname"><em>param</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1cstring.html">cstring</a></td>          <td class="paramname"><span class="paramname"><em>header</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1cstring.html">cstring</a></td>          <td class="paramname"><span class="paramname"><em>field</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>bitWidth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>constant</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an assignment statement of the form <code>param.header.field = constant</code>. </dd></dl>

</div>
</div>
<a id="ace0ce5293fcf25cf6dfc136281963b9b" name="ace0ce5293fcf25cf6dfc136281963b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace0ce5293fcf25cf6dfc136281963b9b">&#9670;&#160;</a></span>createSetValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const IR::Statement * BFN::createSetValid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1_util_1_1_source_info.html">Util::SourceInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>si</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1cstring.html">cstring</a></td>          <td class="paramname"><span class="paramname"><em>header</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1cstring.html">cstring</a></td>          <td class="paramname"><span class="paramname"><em>field</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an assignment statement of the form <code>header.setValid()</code>. </dd></dl>

</div>
</div>
<a id="a98b5a7ecfb4259bd22073bffadf25e73" name="a98b5a7ecfb4259bd22073bffadf25e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98b5a7ecfb4259bd22073bffadf25e73">&#9670;&#160;</a></span>generateRuntime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BFN::generateRuntime </td>
          <td>(</td>
          <td class="paramtype">const IR::P4Program *</td>          <td class="paramname"><span class="paramname"><em>program</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_b_f_n___options.html">BFN_Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenience wrapper for P4::generateP4Runtime(). This must be called before the translation pass and will generate the correct P4Info message based on the original architecture (v1model, PSA, TNA or JNA). </p>

</div>
</div>
<a id="a3231829d4f7298eff9cb8e8aaf5dbb0f" name="a3231829d4f7298eff9cb8e8aaf5dbb0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3231829d4f7298eff9cb8e8aaf5dbb0f">&#9670;&#160;</a></span>getContainingParameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const IR::Parameter * BFN::getContainingParameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_b_f_n_1_1_linear_path.html">LinearPath</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1_reference_map.html">P4::ReferenceMap</a> *</td>          <td class="paramname"><span class="paramname"><em>refMap</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the parameter which transitively contains this object if <code>isSubobjectOfParameter()</code> would return true, or nullptr otherwise. </dd></dl>

</div>
</div>
<a id="a47b0490ce79fac2d6af8c8489f60ded3" name="a47b0490ce79fac2d6af8c8489f60ded3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47b0490ce79fac2d6af8c8489f60ded3">&#9670;&#160;</a></span>getDeclInst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const IR::Declaration_Instance * BFN::getDeclInst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1_reference_map.html">P4::ReferenceMap</a> *</td>          <td class="paramname"><span class="paramname"><em>refMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IR::PathExpression *</td>          <td class="paramname"><span class="paramname"><em>path</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Auxiliary function to get a declaration instance based on a path expression from a reference map. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">refMap</td><td>Reference map </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The path expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the declaration if exists, nullptr otherwise. </dd></dl>

</div>
</div>
<a id="ace0fdb14b1be228b601b48e3aff79c76" name="ace0fdb14b1be228b601b48e3aff79c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace0fdb14b1be228b601b48e3aff79c76">&#9670;&#160;</a></span>getExternInstanceFromProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="struct_p4_1_1_extern_instance.html">P4::ExternInstance</a> &gt; BFN::getExternInstanceFromProperty </td>
          <td>(</td>
          <td class="paramtype">const IR::P4Table *</td>          <td class="paramname"><span class="paramname"><em>table</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1cstring.html">cstring</a></td>          <td class="paramname"><span class="paramname"><em>propertyName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1_reference_map.html">P4::ReferenceMap</a> *</td>          <td class="paramname"><span class="paramname"><em>refMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1_type_map.html">P4::TypeMap</a> *</td>          <td class="paramname"><span class="paramname"><em>typeMap</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper functions to extract extern instance from table properties. Originally implemented in as part of the control-plane repo.</p>
<dl class="section return"><dt>Returns</dt><dd>an extern instance defined or referenced by the value of <code>table's</code> <code>propertyName</code> property, or std::nullopt if no extern was referenced. </dd></dl>

</div>
</div>
<a id="a318b7dc7ae0b060a7746e786df0936f3" name="a318b7dc7ae0b060a7746e786df0936f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a318b7dc7ae0b060a7746e786df0936f3">&#9670;&#160;</a></span>getExternInstanceFromPropertyByTypeName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="struct_p4_1_1_extern_instance.html">P4::ExternInstance</a> &gt; BFN::getExternInstanceFromPropertyByTypeName </td>
          <td>(</td>
          <td class="paramtype">const IR::P4Table *</td>          <td class="paramname"><span class="paramname"><em>table</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1cstring.html">cstring</a></td>          <td class="paramname"><span class="paramname"><em>propertyName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1cstring.html">cstring</a></td>          <td class="paramname"><span class="paramname"><em>externTypeName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1_reference_map.html">P4::ReferenceMap</a> *</td>          <td class="paramname"><span class="paramname"><em>refMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1_type_map.html">P4::TypeMap</a> *</td>          <td class="paramname"><span class="paramname"><em>typeMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>isConstructedInPlace</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper functions to handle list of extern instances from table properties. </p>

</div>
</div>
<a id="ae781b876fd3ce31697113381fab01f12" name="ae781b876fd3ce31697113381fab01f12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae781b876fd3ce31697113381fab01f12">&#9670;&#160;</a></span>isCompilerGeneratedType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BFN::isCompilerGeneratedType </td>
          <td>(</td>
          <td class="paramtype">const IR::Type *</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the provided type has the <code>@__compiler_generated</code> annotation; the compiler tags types it generates with this annotation. </dd></dl>

</div>
</div>
<a id="a515805e7049521198847a3df49573a59" name="a515805e7049521198847a3df49573a59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a515805e7049521198847a3df49573a59">&#9670;&#160;</a></span>isHeaderReference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BFN::isHeaderReference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_b_f_n_1_1_linear_path.html">LinearPath</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1_type_map.html">P4::TypeMap</a> *</td>          <td class="paramname"><span class="paramname"><em>typeMap</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the provided LinearPath refers to a header - that is, if it refers to one of:<ul>
<li>an object of header type (i.e., <code>isHeaderType()</code> returns true; see that function for the full criteria), or</li>
<li>a field of primitive type on such an object. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ade18b77ae21f74ae8816b7027d6de63e" name="ade18b77ae21f74ae8816b7027d6de63e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade18b77ae21f74ae8816b7027d6de63e">&#9670;&#160;</a></span>isHeaderType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BFN::isHeaderType </td>
          <td>(</td>
          <td class="paramtype">const IR::Type *</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the provided type is logically a header type - that is, if it's a header type for which <code>isMetadataType()</code> returns false. </dd></dl>

</div>
</div>
<a id="a97be3b73e982d19a91f32ea77086e0b6" name="a97be3b73e982d19a91f32ea77086e0b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97be3b73e982d19a91f32ea77086e0b6">&#9670;&#160;</a></span>isIntrinsicMetadataType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BFN::isIntrinsicMetadataType </td>
          <td>(</td>
          <td class="paramtype">const IR::Type *</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the provided type has the <code>@__intrinsic_metadata</code> annotation; the architecture tags types with this annotation if they're intrinsic metadata. </dd></dl>

</div>
</div>
<a id="a71d55ffb757ace701b91df7aaab55aee" name="a71d55ffb757ace701b91df7aaab55aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71d55ffb757ace701b91df7aaab55aee">&#9670;&#160;</a></span>isMetadataReference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BFN::isMetadataReference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_b_f_n_1_1_linear_path.html">LinearPath</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1_type_map.html">P4::TypeMap</a> *</td>          <td class="paramname"><span class="paramname"><em>typeMap</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the provided LinearPath refers to metadata - that is, if it refers to one of:<ul>
<li>an object of metadata type (i.e., <code>isMetadataType()</code> returns true; see that function for the full criteria), or</li>
<li>a field of primitive type on such an object. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a72521594675df0eea7af47123fe8afc4" name="a72521594675df0eea7af47123fe8afc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72521594675df0eea7af47123fe8afc4">&#9670;&#160;</a></span>isMetadataType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BFN::isMetadataType </td>
          <td>(</td>
          <td class="paramtype">const IR::Type *</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the provided type is logically a metadata type - that is, if it's:<ul>
<li>a struct type, or</li>
<li>a non-struct type with the annotation <code>@__intrinsic_metadata</code>. The second case is required for TNA, which represents some types which are logically metadata as headers. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a19e046fe64220a17484d4266fe0af013" name="a19e046fe64220a17484d4266fe0af013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19e046fe64220a17484d4266fe0af013">&#9670;&#160;</a></span>isPrimitiveFieldReference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BFN::isPrimitiveFieldReference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_b_f_n_1_1_linear_path.html">LinearPath</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1_type_map.html">P4::TypeMap</a> *</td>          <td class="paramname"><span class="paramname"><em>typeMap</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the provided LinearPath refers to a field of primitive type on some structlike object. </dd></dl>

</div>
</div>
<a id="a906cfd73eb8bb47809024f6f948c5a0f" name="a906cfd73eb8bb47809024f6f948c5a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a906cfd73eb8bb47809024f6f948c5a0f">&#9670;&#160;</a></span>isPrimitiveReference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BFN::isPrimitiveReference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_b_f_n_1_1_linear_path.html">LinearPath</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1_type_map.html">P4::TypeMap</a> *</td>          <td class="paramname"><span class="paramname"><em>typeMap</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the provided LinearPath refers to an object of primitive type - that is, if it refers to one of:<ul>
<li>a simple object of primitive type, or</li>
<li>a field of primitive type on some structlike object. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a07e94e344c21616cddb3a23d89b2f833" name="a07e94e344c21616cddb3a23d89b2f833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07e94e344c21616cddb3a23d89b2f833">&#9670;&#160;</a></span>isPrimitiveType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BFN::isPrimitiveType </td>
          <td>(</td>
          <td class="paramtype">const IR::Type *</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the provided type is a primitive type, which for the purposes of this function is defined as:<ul>
<li>a bit&lt;&gt; type, or</li>
<li>a Type_InfInt (i.e., a numeric constant of indeterminate width), or</li>
<li>a boolean type. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a8f77eb905bef701740d2c359ad449c1a" name="a8f77eb905bef701740d2c359ad449c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f77eb905bef701740d2c359ad449c1a">&#9670;&#160;</a></span>isSubobjectOfParameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BFN::isSubobjectOfParameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_b_f_n_1_1_linear_path.html">LinearPath</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1_reference_map.html">P4::ReferenceMap</a> *</td>          <td class="paramname"><span class="paramname"><em>refMap</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the provided LinearPath refers to an object which is a subobject of a parameter - that is, if it refers to one of:<ul>
<li>a parameter directly, or</li>
<li>an object which is transitively a subobject of a parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac091d49bcd9f9eb014dcc46825e255c5" name="ac091d49bcd9f9eb014dcc46825e255c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac091d49bcd9f9eb014dcc46825e255c5">&#9670;&#160;</a></span>lookaheadToExtractRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespace_p4.html#a19f5abed1a21ad7a5703944aa5099da7">nw_bitrange</a> &gt; BFN::lookaheadToExtractRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p4_1_1_type_map.html">P4::TypeMap</a> *</td>          <td class="paramname"><span class="paramname"><em>typeMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IR::Expression *</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>currentBit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>partial_hdr_err_proc</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rewrite an expression that is a lookahead or a member of a lookahead value (inc. slices and stack-parts of lookaheads) to a tuple (type of the extracted expression, corresponding range of bits to be extracted from packet). If the input is not such an expression the result will contain nullptr as the first member of the tuple. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.12.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_b_f_n.html">BFN</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
