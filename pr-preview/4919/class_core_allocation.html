<!-- HTML header for doxygen 1.12.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>P4 Compiler Documentation (P4C): CoreAllocation Class Reference</title>
<link rel="icon" href="p4-fav.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!--  Add link to paragraphs   -->
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
  DoxygenAwesomeParagraphLink.init()
</script>
<!-- Add copy button to code fragments  -->
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
  DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add dark mode toggle -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
  DoxygenAwesomeDarkModeToggle.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="cards.css" rel="stylesheet" type="text/css"/>
<link href="flow.css" rel="stylesheet" type="text/css"/>
<link href="p4c_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="p4-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">P4C
   </div>
   <div id="projectbrief">The P4 Compiler</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_core_allocation.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_core_allocation-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">CoreAllocation Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="allocate__phv_8h_source.html">allocate_phv.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acd88f02e8ee6ca9132087b425580f1ce" id="r_acd88f02e8ee6ca9132087b425580f1ce"><td class="memItemLeft" align="right" valign="top"><a id="acd88f02e8ee6ca9132087b425580f1ce" name="acd88f02e8ee6ca9132087b425580f1ce"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CoreAllocation</b> (const <a class="el" href="struct_p_h_v_1_1_alloc_utils.html">PHV::AllocUtils</a> &amp;utils, bool disable_metainit)</td></tr>
<tr class="separator:acd88f02e8ee6ca9132087b425580f1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6acb23831551c6ae5bc83219454f942" id="r_ae6acb23831551c6ae5bc83219454f942"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6acb23831551c6ae5bc83219454f942">can_physical_liverange_overlay</a> (const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;slice, const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;allocated) const</td></tr>
<tr class="separator:ae6acb23831551c6ae5bc83219454f942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e8323a91d837ec07e9c9388262f6b2" id="r_ad3e8323a91d837ec07e9c9388262f6b2"><td class="memItemLeft" align="right" valign="top"><a id="ad3e8323a91d837ec07e9c9388262f6b2" name="ad3e8323a91d837ec07e9c9388262f6b2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>checkDarkOverlay</b> (const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;candidate_slices, const <a class="el" href="class_p_h_v_1_1_transaction.html">PHV::Transaction</a> &amp;alloc) const</td></tr>
<tr class="separator:ad3e8323a91d837ec07e9c9388262f6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc76a93da989d00efb7cd9196ad2f4c0" id="r_afc76a93da989d00efb7cd9196ad2f4c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc76a93da989d00efb7cd9196ad2f4c0">checkParserExtractions</a> (const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;candidate_slices, const <a class="el" href="class_p_h_v_1_1_transaction.html">PHV::Transaction</a> &amp;alloc) const</td></tr>
<tr class="separator:afc76a93da989d00efb7cd9196ad2f4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3ac70cbda5e0bfa7733e5f4fef742de" id="r_ab3ac70cbda5e0bfa7733e5f4fef742de"><td class="memItemLeft" align="right" valign="top"><a id="ab3ac70cbda5e0bfa7733e5f4fef742de" name="ab3ac70cbda5e0bfa7733e5f4fef742de"></a>
std::optional&lt; const PHV::SuperCluster::SliceList * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>find_first_unallocated_slicelist</b> (const <a class="el" href="class_p_h_v_1_1_allocation.html">PHV::Allocation</a> &amp;alloc, const std::list&lt; <a class="el" href="class_p_h_v_1_1_container_group.html">PHV::ContainerGroup</a> * &gt; &amp;container_groups, const <a class="el" href="class_p_h_v_1_1_super_cluster.html">PHV::SuperCluster</a> &amp;cluster) const</td></tr>
<tr class="separator:ab3ac70cbda5e0bfa7733e5f4fef742de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3448d84563eddbd9715d6b413dcbdddf" id="r_a3448d84563eddbd9715d6b413dcbdddf"><td class="memItemLeft" align="right" valign="top"><a id="a3448d84563eddbd9715d6b413dcbdddf" name="a3448d84563eddbd9715d6b413dcbdddf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>generateNewAllocSlices</b> (const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;origSlice, const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;alloced_slices, PHV::DarkInitMap &amp;slices, <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;new_candidate_slices, <a class="el" href="class_p_h_v_1_1_transaction.html">PHV::Transaction</a> &amp;alloc_attempt, const <a class="el" href="class_p4_1_1ordered__set.html">PHV::Allocation::MutuallyLiveSlices</a> &amp;container_state) const</td></tr>
<tr class="separator:a3448d84563eddbd9715d6b413dcbdddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1c652d0a21c3b737319f2be4e52b27" id="r_abd1c652d0a21c3b737319f2be4e52b27"><td class="memItemLeft" align="right" valign="top"><a id="abd1c652d0a21c3b737319f2be4e52b27" name="abd1c652d0a21c3b737319f2be4e52b27"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>get_prioririze_ARA_inits</b> ()</td></tr>
<tr class="separator:abd1c652d0a21c3b737319f2be4e52b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695918757af816612396a2b6e9172d3e" id="r_a695918757af816612396a2b6e9172d3e"><td class="memItemLeft" align="right" valign="top"><a id="a695918757af816612396a2b6e9172d3e" name="a695918757af816612396a2b6e9172d3e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>get_single_gress_parser_group</b> ()</td></tr>
<tr class="separator:a695918757af816612396a2b6e9172d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988d4d8b1e58a626e158992b1b8c8b5b" id="r_a988d4d8b1e58a626e158992b1b8c8b5b"><td class="memItemLeft" align="right" valign="top"><a id="a988d4d8b1e58a626e158992b1b8c8b5b" name="a988d4d8b1e58a626e158992b1b8c8b5b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasARAinits</b> (<a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; slices) const</td></tr>
<tr class="memdesc:a988d4d8b1e58a626e158992b1b8c8b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">@look for ARA inits in set of slices <br /></td></tr>
<tr class="separator:a988d4d8b1e58a626e158992b1b8c8b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf60fed875fe690ab807c5441f7b0925" id="r_aaf60fed875fe690ab807c5441f7b0925"><td class="memItemLeft" align="right" valign="top"><a id="aaf60fed875fe690ab807c5441f7b0925" name="aaf60fed875fe690ab807c5441f7b0925"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasCrossingLiveranges</b> (std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; candidate_slices, <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; alloc_slices) const</td></tr>
<tr class="separator:aaf60fed875fe690ab807c5441f7b0925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fcda22eb1c20b6b2497d95a9d58b08f" id="r_a6fcda22eb1c20b6b2497d95a9d58b08f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p_h_v_1_1_transaction.html">PHV::Transaction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fcda22eb1c20b6b2497d95a9d58b08f">make_speculated_alloc</a> (const <a class="el" href="class_p_h_v_1_1_transaction.html">PHV::Transaction</a> &amp;alloc, const <a class="el" href="class_p_h_v_1_1_super_cluster.html">PHV::SuperCluster</a> &amp;sc, const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;candidates, const <a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a> &amp;c) const</td></tr>
<tr class="separator:a6fcda22eb1c20b6b2497d95a9d58b08f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc52f30328ea2798ac25e095e0b2a3d" id="r_adcc52f30328ea2798ac25e095e0b2a3d"><td class="memItemLeft" align="right" valign="top"><a id="adcc52f30328ea2798ac25e095e0b2a3d" name="adcc52f30328ea2798ac25e095e0b2a3d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>rangesOverlap</b> (const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;slice, const IR::BFN::ParserPrimitive *prim) const</td></tr>
<tr class="memdesc:adcc52f30328ea2798ac25e095e0b2a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do the <code>slice</code> and <code>prim</code> have overlapping field ranges. <br /></td></tr>
<tr class="separator:adcc52f30328ea2798ac25e095e0b2a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dfe0a2422024ff7dbcb40819149fc8a" id="r_a6dfe0a2422024ff7dbcb40819149fc8a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6dfe0a2422024ff7dbcb40819149fc8a">satisfies_constraints</a> (const <a class="el" href="class_p_h_v_1_1_allocation.html">PHV::Allocation</a> &amp;alloc, const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;slice, <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;initFields, std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;candidate_slices) const</td></tr>
<tr class="separator:a6dfe0a2422024ff7dbcb40819149fc8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1117e4f8a3e6ad0d4ba5fba23aabe16" id="r_af1117e4f8a3e6ad0d4ba5fba23aabe16"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1117e4f8a3e6ad0d4ba5fba23aabe16">satisfies_constraints</a> (const <a class="el" href="class_p_h_v_1_1_container_group.html">PHV::ContainerGroup</a> &amp;group, const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *f) const</td></tr>
<tr class="separator:af1117e4f8a3e6ad0d4ba5fba23aabe16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af73a89cf664b2a9a5aae9555485c365b" id="r_af73a89cf664b2a9a5aae9555485c365b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af73a89cf664b2a9a5aae9555485c365b">satisfies_constraints</a> (const <a class="el" href="class_p_h_v_1_1_container_group.html">PHV::ContainerGroup</a> &amp;group, const <a class="el" href="class_p_h_v_1_1_field_slice.html">PHV::FieldSlice</a> &amp;slice) const</td></tr>
<tr class="separator:af73a89cf664b2a9a5aae9555485c365b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b34af355662af9b99a16135005c17bc" id="r_a6b34af355662af9b99a16135005c17bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b34af355662af9b99a16135005c17bc">satisfies_constraints</a> (std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; slices, const <a class="el" href="class_p_h_v_1_1_allocation.html">PHV::Allocation</a> &amp;alloc) const</td></tr>
<tr class="separator:a6b34af355662af9b99a16135005c17bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0305f14d190b47c27c51022892ac030" id="r_ae0305f14d190b47c27c51022892ac030"><td class="memItemLeft" align="right" valign="top"><a id="ae0305f14d190b47c27c51022892ac030" name="ae0305f14d190b47c27c51022892ac030"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_prioritize_ARA_inits</b> ()</td></tr>
<tr class="separator:ae0305f14d190b47c27c51022892ac030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f64549d48955ce56d4027f4c42991b" id="r_ae5f64549d48955ce56d4027f4c42991b"><td class="memItemLeft" align="right" valign="top"><a id="ae5f64549d48955ce56d4027f4c42991b" name="ae5f64549d48955ce56d4027f4c42991b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_single_gress_parser_group</b> ()</td></tr>
<tr class="separator:ae5f64549d48955ce56d4027f4c42991b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f972a7125cfc694793c798362616a1" id="r_a10f972a7125cfc694793c798362616a1"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="class_p_h_v_1_1_transaction.html">PHV::Transaction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10f972a7125cfc694793c798362616a1">try_alloc</a> (const <a class="el" href="class_p_h_v_1_1_allocation.html">PHV::Allocation</a> &amp;alloc, const <a class="el" href="class_p_h_v_1_1_container_group.html">PHV::ContainerGroup</a> &amp;group, <a class="el" href="class_p_h_v_1_1_super_cluster.html">PHV::SuperCluster</a> &amp;cluster, int max_alignment_tries, const <a class="el" href="class_score_context.html">ScoreContext</a> &amp;score_ctx) const</td></tr>
<tr class="separator:a10f972a7125cfc694793c798362616a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c4f47e63b72a0c2912ccc689c5e251" id="r_a31c4f47e63b72a0c2912ccc689c5e251"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="class_p_h_v_1_1_transaction.html">PHV::Transaction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31c4f47e63b72a0c2912ccc689c5e251">try_deparser_zero_alloc</a> (const <a class="el" href="class_p_h_v_1_1_allocation.html">PHV::Allocation</a> &amp;alloc, <a class="el" href="class_p_h_v_1_1_super_cluster.html">PHV::SuperCluster</a> &amp;cluster, <a class="el" href="class_phv_info.html">PhvInfo</a> &amp;phv) const</td></tr>
<tr class="separator:a31c4f47e63b72a0c2912ccc689c5e251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081298cbf693a150115abc87f14529d4" id="r_a081298cbf693a150115abc87f14529d4"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="class_p_h_v_1_1_transaction.html">PHV::Transaction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a081298cbf693a150115abc87f14529d4">tryAllocSliceList</a> (const <a class="el" href="class_p_h_v_1_1_allocation.html">PHV::Allocation</a> &amp;alloc, const <a class="el" href="class_p_h_v_1_1_container_group.html">PHV::ContainerGroup</a> &amp;group, const <a class="el" href="class_p_h_v_1_1_super_cluster.html">PHV::SuperCluster</a> &amp;super_cluster, const <a class="el" href="class_p4_1_1ordered__map.html">PHV::Allocation::ConditionalConstraint</a> &amp;start_positions, const <a class="el" href="class_score_context.html">ScoreContext</a> &amp;score_ctx) const</td></tr>
<tr class="separator:a081298cbf693a150115abc87f14529d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c11dbd774ed881ac465a4e65a9ae1c9" id="r_a0c11dbd774ed881ac465a4e65a9ae1c9"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="class_p_h_v_1_1_transaction.html">PHV::Transaction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c11dbd774ed881ac465a4e65a9ae1c9">tryAllocSliceList</a> (const <a class="el" href="class_p_h_v_1_1_allocation.html">PHV::Allocation</a> &amp;alloc, const <a class="el" href="class_p_h_v_1_1_container_group.html">PHV::ContainerGroup</a> &amp;group, const <a class="el" href="class_p_h_v_1_1_super_cluster.html">PHV::SuperCluster</a> &amp;super_cluster, const PHV::SuperCluster::SliceList &amp;slice_list, const <a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt; <a class="el" href="class_p_h_v_1_1_field_slice.html">PHV::FieldSlice</a>, int &gt; &amp;start_positions, const <a class="el" href="class_score_context.html">ScoreContext</a> &amp;score_ctx) const</td></tr>
<tr class="separator:a0c11dbd774ed881ac465a4e65a9ae1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:abf0f8a6ad6c275ccb8e0885d0fc488a9" id="r_abf0f8a6ad6c275ccb8e0885d0fc488a9"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf0f8a6ad6c275ccb8e0885d0fc488a9">can_overlay</a> (const <a class="el" href="class_p4_1_1_sym_bit_matrix.html">SymBitMatrix</a> &amp;mutually_exclusive_field_ids, const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *f, const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;slices)</td></tr>
<tr class="separator:abf0f8a6ad6c275ccb8e0885d0fc488a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5512a0cd1028e45817ad47fddf602c9b" id="r_a5512a0cd1028e45817ad47fddf602c9b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5512a0cd1028e45817ad47fddf602c9b">satisfies_constraints</a> (const <a class="el" href="class_p_h_v_1_1_container_group.html">PHV::ContainerGroup</a> &amp;container_group, const <a class="el" href="class_p_h_v_1_1_super_cluster.html">PHV::SuperCluster</a> &amp;cluster_group)</td></tr>
<tr class="separator:a5512a0cd1028e45817ad47fddf602c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1e987989c48e51e2dff2d6a43b6b69" id="r_a1b1e987989c48e51e2dff2d6a43b6b69"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b1e987989c48e51e2dff2d6a43b6b69">some_overlay</a> (const <a class="el" href="class_p4_1_1_sym_bit_matrix.html">SymBitMatrix</a> &amp;mutually_exclusive_field_ids, const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *f, const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;slices)</td></tr>
<tr class="separator:a1b1e987989c48e51e2dff2d6a43b6b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A set of functions used in PHV allocation. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="abf0f8a6ad6c275ccb8e0885d0fc488a9" name="abf0f8a6ad6c275ccb8e0885d0fc488a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf0f8a6ad6c275ccb8e0885d0fc488a9">&#9670;&#160;</a></span>can_overlay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CoreAllocation::can_overlay </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1_sym_bit_matrix.html">SymBitMatrix</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mutually_exclusive_field_ids</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>slices</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if <code>f</code> can overlay all fields in <code>slices</code>. </dd></dl>

</div>
</div>
<a id="ae6acb23831551c6ae5bc83219454f942" name="ae6acb23831551c6ae5bc83219454f942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6acb23831551c6ae5bc83219454f942">&#9670;&#160;</a></span>can_physical_liverange_overlay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CoreAllocation::can_physical_liverange_overlay </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slice</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>allocated</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if <code>slice</code> can overlay all fields in <code>allocated</code> in terms of physical liveranges. </dd></dl>

</div>
</div>
<a id="afc76a93da989d00efb7cd9196ad2f4c0" name="afc76a93da989d00efb7cd9196ad2f4c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc76a93da989d00efb7cd9196ad2f4c0">&#9670;&#160;</a></span>checkParserExtractions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CoreAllocation::checkParserExtractions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>candidate_slices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_transaction.html">PHV::Transaction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Verify whether the <code>candidate_slices</code> will produce parser extractions that will lead to data corruption </p>

</div>
</div>
<a id="a6fcda22eb1c20b6b2497d95a9d58b08f" name="a6fcda22eb1c20b6b2497d95a9d58b08f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fcda22eb1c20b6b2497d95a9d58b08f">&#9670;&#160;</a></span>make_speculated_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p_h_v_1_1_transaction.html">PHV::Transaction</a> CoreAllocation::make_speculated_alloc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_transaction.html">PHV::Transaction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_super_cluster.html">PHV::SuperCluster</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>candidates</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate pseudo AllocSlices for field slices that have not been allocated, but their allocation can be speculated upfront: when there is only one valid starting position. </p><dl class="section return"><dt>Returns</dt><dd>a transaction that contains the pseudo AllocSlices. we can infer that field slices will be allocated to a container with corresponding starting positions. This will allow can_pack function to check constraints from action reading side, even if destination has not been allocated yet. This is enabled only when utils_i.settings_.trivial_alloc is true, otherwise, it simply returns <code>alloc</code>. </dd></dl>

</div>
</div>
<a id="a6dfe0a2422024ff7dbcb40819149fc8a" name="a6dfe0a2422024ff7dbcb40819149fc8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dfe0a2422024ff7dbcb40819149fc8a">&#9670;&#160;</a></span>satisfies_constraints() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CoreAllocation::satisfies_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_allocation.html">PHV::Allocation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slice</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>initFields</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>candidate_slices</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if <code>slice</code> is a valid allocation move given the allocation status in <code>alloc</code>. <code>initFields</code> contains a list of fields in this container that will be initialized via metadata initialization. </dd></dl>

</div>
</div>
<a id="a5512a0cd1028e45817ad47fddf602c9b" name="a5512a0cd1028e45817ad47fddf602c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5512a0cd1028e45817ad47fddf602c9b">&#9670;&#160;</a></span>satisfies_constraints() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CoreAllocation::satisfies_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_container_group.html">PHV::ContainerGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>container_group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_super_cluster.html">PHV::SuperCluster</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cluster_group</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if <code>container_group</code> and <code>cluster_group</code> satisfy constraints. TODO: figure out what, if any, constraints should go here. </dd></dl>

</div>
</div>
<a id="af1117e4f8a3e6ad0d4ba5fba23aabe16" name="af1117e4f8a3e6ad0d4ba5fba23aabe16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1117e4f8a3e6ad0d4ba5fba23aabe16">&#9670;&#160;</a></span>satisfies_constraints() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CoreAllocation::satisfies_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_container_group.html">PHV::ContainerGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if field&lt;--&gt;group constraints are satisfied. </dd></dl>

</div>
</div>
<a id="af73a89cf664b2a9a5aae9555485c365b" name="af73a89cf664b2a9a5aae9555485c365b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af73a89cf664b2a9a5aae9555485c365b">&#9670;&#160;</a></span>satisfies_constraints() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CoreAllocation::satisfies_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_container_group.html">PHV::ContainerGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_field_slice.html">PHV::FieldSlice</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slice</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if field slice&lt;--&gt;group constraints are satisfied. </dd></dl>

</div>
</div>
<a id="a6b34af355662af9b99a16135005c17bc" name="a6b34af355662af9b99a16135005c17bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b34af355662af9b99a16135005c17bc">&#9670;&#160;</a></span>satisfies_constraints() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CoreAllocation::satisfies_constraints </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>slices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_allocation.html">PHV::Allocation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if slice list&lt;--&gt;container constraints are satisfied. </dd></dl>
<p>FIXME(vstill): the mutex check seems to be needed also in cases where the data are not comming from the packet</p>

</div>
</div>
<a id="a1b1e987989c48e51e2dff2d6a43b6b69" name="a1b1e987989c48e51e2dff2d6a43b6b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b1e987989c48e51e2dff2d6a43b6b69">&#9670;&#160;</a></span>some_overlay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CoreAllocation::some_overlay </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1_sym_bit_matrix.html">SymBitMatrix</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mutually_exclusive_field_ids</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>slices</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if <code>f</code> can overlay at least one field in <code>slices</code>. </dd></dl>

</div>
</div>
<a id="a10f972a7125cfc694793c798362616a1" name="a10f972a7125cfc694793c798362616a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10f972a7125cfc694793c798362616a1">&#9670;&#160;</a></span>try_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="class_p_h_v_1_1_transaction.html">PHV::Transaction</a> &gt; CoreAllocation::try_alloc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_allocation.html">PHV::Allocation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_container_group.html">PHV::ContainerGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p_h_v_1_1_super_cluster.html">PHV::SuperCluster</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cluster</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>max_alignment_tries</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_score_context.html">ScoreContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>score_ctx</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Try to allocate all fields in <code>cluster</code> to containers in <code>group</code>, using the following techniques (when permissible by constraints), assuming <code>alloc</code> is the allocation so far, possibly including allocations to containers in <code>group:</code> </p>
<ul>
<li>splitting fields across different containers</li>
<li>packing different fields (or field slices) into the same container</li>
<li>overlaying fields</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>an allocation of <code>cluster</code> to <code>group</code> or std::nullopt if no allocation could be found.</dd></dl>
<p>Caveats and TODOs:</p>
<ul>
<li>Only does container_no_pack + overlay so far.</li>
<li>Does not handle partially-allocated clusters, eg. from pragmas.</li>
<li>Does not slice clusters.</li>
<li>Does not slice fields into non-container sized slices.</li>
</ul>
<p>Uses mutex_i and uses_i. </p>

</div>
</div>
<a id="a31c4f47e63b72a0c2912ccc689c5e251" name="a31c4f47e63b72a0c2912ccc689c5e251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31c4f47e63b72a0c2912ccc689c5e251">&#9670;&#160;</a></span>try_deparser_zero_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="class_p_h_v_1_1_transaction.html">PHV::Transaction</a> &gt; CoreAllocation::try_deparser_zero_alloc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_allocation.html">PHV::Allocation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p_h_v_1_1_super_cluster.html">PHV::SuperCluster</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cluster</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_phv_info.html">PhvInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>phv</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function that tries to allocate all fields in the deparser zero supercluster <code>cluster</code> to containers B0 (for ingress) and B16 (for egress). The DeparserZero analysis earlier in PHV allocation already ensures that these fields can be safely allocated to the zero-ed containers. </p>

</div>
</div>
<a id="a081298cbf693a150115abc87f14529d4" name="a081298cbf693a150115abc87f14529d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a081298cbf693a150115abc87f14529d4">&#9670;&#160;</a></span>tryAllocSliceList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="class_p_h_v_1_1_transaction.html">PHV::Transaction</a> &gt; CoreAllocation::tryAllocSliceList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_allocation.html">PHV::Allocation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_container_group.html">PHV::ContainerGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_super_cluster.html">PHV::SuperCluster</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>super_cluster</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1ordered__map.html">PHV::Allocation::ConditionalConstraint</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>start_positions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_score_context.html">ScoreContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>score_ctx</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function for tryAlloc that tries to allocate all fields in <code>start_positions</code> simultaneously. Deparsed fields in particular need to be placed simultaneously with their neighbors; otherwise, the <code>deparsed</code> constraint cannot be satisfied.</p>
<p>For example, consider a header with two 8-bit fields: </p><pre class="fragment">header h { bit&lt;4&gt; f1; bit&lt;4&gt; f2; }
</pre><p>Fields f1 and f2 are deparsed, meaning that each must be placed in a container alone or with other deparsed fields (in order) such that no container bits are unallocated. However, if we check this constraint one field at a time, then neither field can be placed&mdash;one must be placed first, but it only occupies half the container, violating the constraint.</p>
<p>Additionally, <code>start_positions</code> also includes the conditional constraints generated by ActionPhvConstraints.</p>
<p>Uses mutex_i and uses_i.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>the allocation computed so far. </td></tr>
    <tr><td class="paramname">group</td><td>the container group to which the slice list is to be allocated. </td></tr>
    <tr><td class="paramname">super_cluster</td><td>??? </td></tr>
    <tr><td class="paramname">start_positions</td><td>a map. Keys are the field slices to be allocated. Values are the corresponding conditional constraint on the field slice. </td></tr>
    <tr><td class="paramname">score_ctx</td><td>TODO TODO: there is an assumption that only fieldslice of the slice list, shows up in the <code>start_positions</code> map (as there is no slice list passed as args). Better to remove this. </td></tr>
  </table>
  </dd>
</dl>
<ol type="1">
<li>no overlapped slice.</li>
</ol>
<ol type="1">
<li>directly overlaid.</li>
</ol>

</div>
</div>
<a id="a0c11dbd774ed881ac465a4e65a9ae1c9" name="a0c11dbd774ed881ac465a4e65a9ae1c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c11dbd774ed881ac465a4e65a9ae1c9">&#9670;&#160;</a></span>tryAllocSliceList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="class_p_h_v_1_1_transaction.html">PHV::Transaction</a> &gt; CoreAllocation::tryAllocSliceList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_allocation.html">PHV::Allocation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_container_group.html">PHV::ContainerGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_super_cluster.html">PHV::SuperCluster</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>super_cluster</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PHV::SuperCluster::SliceList &amp;</td>          <td class="paramname"><span class="paramname"><em>slice_list</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt; <a class="el" href="class_p_h_v_1_1_field_slice.html">PHV::FieldSlice</a>, int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>start_positions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_score_context.html">ScoreContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>score_ctx</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience method that transforms <code>start_positions</code> map into a map of ConditionalConstraint, which is passed to <code>tryAllocSliceList</code> above. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.12.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_core_allocation.html">CoreAllocation</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
