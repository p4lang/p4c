<!-- HTML header for doxygen 1.12.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>P4 Compiler Documentation (P4C): CLOT allocator and metric</title>
<link rel="icon" href="p4-fav.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!--  Add link to paragraphs   -->
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
  DoxygenAwesomeParagraphLink.init()
</script>
<!-- Add copy button to code fragments  -->
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
  DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add dark mode toggle -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
  DoxygenAwesomeDarkModeToggle.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="cards.css" rel="stylesheet" type="text/css"/>
<link href="flow.css" rel="stylesheet" type="text/css"/>
<link href="p4c_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="p4-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">P4C
   </div>
   <div id="projectbrief">The P4 Compiler</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('clot_alloc_and_metric.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">CLOT allocator and metric</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__2home_2runner_2work_2p4c_2p4c_2backends_2tofino_2bf-p4c_2parde_2clot_2_r_e_a_d_m_e"></a></p>
<p>This documents the design of the CLOT allocator and the metric associated with CLOT allocation.</p>
<h1><a class="anchor" id="definitions-1"></a>
Definitions</h1>
<p>When an object (field, slice, byte, etc.) is allocated to both PHVs and to a CLOT, we say that the object is double-allocated.</p>
<p>We categorize the field slices in the program, as follows:</p><ul>
<li><em>Checksum</em>: These are slices whose values are replaced with checksum calculations in the deparser. While checksum slices will not necessarily have a PHV allocation, it is only useful to allocate these slices to CLOTs when doing so would allow us to join groups of slices into a larger CLOT.</li>
<li><em>Modified</em>: These are non-checksum slices satisfying any of the following conditions.<ul>
<li>The slice is written by the MAU pipeline.</li>
<li>The slice is aliased with a modified slice via <code>@pa_alias.</code></li>
<li>The slice is packed with a modified slice in the same header: the two slices have bits that occupy the same byte in the packet. These slices will be PHV-allocated and deparsed from their PHV containers. It is only useful to double-allocate these slices when doing so would allow us to join groups of unmodified slices into a larger CLOT.</li>
</ul>
</li>
<li><em>Read-only</em>: These are unmodified non-checksum slices that are read by the MAU pipeline. While these will be PHV-allocated, it is useful to double-allocate these slices, so that their PHV containers do not have to be live for the entire MAU pipeline.</li>
<li><em>Unused</em>: These are unmodified non-checksum slices that are not read by the MAU pipeline. Since these do not have to be PHV-allocated, we get the most benefit from CLOT-allocating these slices.</li>
</ul>
<p>A CLOT-allocated field slice is overwritten if the value in the slice’s CLOT is replaced by a value from a PHV container or by a calculated checksum during deparsing. More precisely, a CLOT-allocated slice is overwritten if it satisfies any of the following conditions.</p><ul>
<li>The slice is a checksum slice.</li>
<li>The slice is modified.</li>
<li>The slice is co-allocated to a PHV container with a modified slice.</li>
<li>The slice is co-allocated to a PHV container with a slice that is not allocated to the same CLOT (i.e., the PHV container straddles the CLOT boundary).</li>
</ul>
<h1><a class="anchor" id="objective"></a>
Objective</h1>
<p>The objective of the CLOT allocator is two-fold:</p><ol type="1">
<li>CLOT-allocate as many unused and read-only slices as possible, while minimizing the number of CLOTs used.</li>
<li>Identify checksum and modified slices and compute their offsets within their CLOT. This is so that we can produce the correct overwrite offsets for the slices’ PHV containers and checksum values in the deparser. Because CLOT allocation occurs before PHV allocation, the CLOT allocator needs to do this itself.</li>
</ol>
<h1><a class="anchor" id="clot-layout-constraints"></a>
CLOT layout constraints</h1>
<p>The following are the layout constraints for CLOT allocation.</p><ul>
<li>Each CLOT can hold up to 64 bytes of contiguous packet data. The deparser emits this data in an all-or-none fashion.</li>
<li>Each parser state can issue up to 2 CLOTs.</li>
<li>Consecutive CLOTs in the input packet must be separated by an inter-CLOT gap of at least three bytes.<ul>
<li>Exception. Consecutive CLOTs in the input packet may be directly adjacent (i.e., separated by zero bytes) if all of the following conditions are met.<ul>
<li>Whenever the deparser emits the CLOT that came second in the input packet, it also emits the CLOT that came first.</li>
<li>Whenever the deparser emits both CLOTs, it emits them directly adjacently, in the same order as they are parsed.</li>
</ul>
</li>
</ul>
</li>
<li>There are a total of 64 unique CLOT tags while only up to 16 CLOTs can be live in a packet. These limits apply on a per-gress basis.</li>
<li>The offset + length in the input packet of each CLOT can be no larger than 384 bytes.</li>
</ul>
<h1><a class="anchor" id="clot-eligible-field-slices"></a>
CLOT-eligible field slices</h1>
<p>A field slice is CLOT-eligible if it is part of a CLOT-eligible field. A field is CLOT-eligible if it is extracted by the parser and satisfies all of the following properties.</p><ul>
<li>The field’s header is not added by the MAU pipeline. This ensures that a CLOT allocated to the field is not deparsed when the field is not part of the input packet, but is added by the MAU pipeline.</li>
<li>The field is emitted by the deparser.</li>
<li>The field is not used in multiple checksum-update computations. It is fine, however, to be part of a single checksum-update computation that is used to update multiple checksum fields.</li>
<li>The field is extracted at most once by the parser: if the field is extracted in multiple parser states, then those states are mutually exclusive.</li>
<li>The field has the same bit-in-byte offset (i.e., the same bit offset, modulo 8) in all parser states that extract the field.</li>
<li>The parser extracts the full width of the field from the packet.</li>
<li>The field is extracted on all parser paths through that any state that marks the field’s header as valid.</li>
</ul>
<h1><a class="anchor" id="clot-candidates"></a>
CLOT candidates</h1>
<p>A CLOT candidate consists of a maximal sequence of CLOT-eligible field slices whose extracts satisfy all of the following properties.</p><ul>
<li>A contiguous, byte-aligned sequence of bits is extracted from the packet.</li>
<li>All extracted field slices are contiguous when emitted by the deparser.</li>
<li>All extracted field slices have emits that are controlled by the same set of POV bits. This ensures that all field slices in a CLOT are deparsed together by the P4 program.</li>
<li>Neither the first nor last field slice in the sequence of extracts is modified or a checksum.1</li>
<li>The offset in the input packet of the last bit of the sequence of extracts is no larger than 384 × 8 = 3072.</li>
<li>The extracts are all made in the same set of parser states: if a parser state extracts one field slice in a candidate, then also it extracts all other field slices in the same candidate.</li>
</ul>
<p>While CLOTs can span more than one parser state, this allocation algorithm does not use this property.</p>
<h2><a class="anchor" id="identifying-clot-candidates"></a>
Identifying CLOT candidates</h2>
<p>An initial set of CLOT candidates is identified and created through the following sequence of phases.</p><ol type="1">
<li>Finding pseudoheaders. With the decaf optimization, headers are no longer the units of deparsing: fields may be emitted separately from the rest of their header. Fields are therefore grouped into pseudoheaders, which are contiguous sequences of fields emitted by the deparser, with all fields sharing the same set of POV bits.2</li>
<li>Grouping field extracts by pseudoheader. CLOT-eligible fields are grouped by pseudoheader. Each CLOT-eligible field is associated with a map from each parser state in which it is extracted to the field’s offset from the start of the parser state.</li>
<li>Creating CLOT candidates. The sequence of fields in each pseudoheader is traversed, and the parser-state and field-offset information from Phase 2 is used to find corresponding contiguous sequences of field extracts that satisfy the requirements for CLOT candidacy.</li>
</ol>
<h1><a class="anchor" id="clot_alloc"></a>
Allocation algorithm</h1>
<p>The CLOT allocator uses a greedy algorithm to allocate CLOTs in each gress independently. For each gress, it identifies CLOT candidates and allocates them in descending order of number of unused bits. Ties are broken by preferring candidates with more read-only bits. As each candidate is allocated, the remaining candidates are adjusted by splitting, shrinking, or removing from candidacy as needed, to account for the inter-CLOT-gap requirement. This adjustment must account for overlapping fields and look-ahead extracts. The numbers of unused and read-only bits in each candidate are updated to account for this adjustment. Shrinking of candidates is done at the granularity of slices.</p>
<h2><a class="anchor" id="candidate-adjustment"></a>
Candidate adjustment</h2>
<p>After allocating a CLOT candidate C, we adjust the remaining candidates by splitting, shrinking, or removing from candidacy as needed to ensure the bytes in the remaining candidates do not overlap with C in the input packet. We further remove the beginning and end of every remaining unallocated candidate C’ to account for the inter-CLOT gap. First, a couple of definitions.</p>
<ul>
<li>Define a CLOT-candidate gap function, GAPS, which summarizes all possible gaps between two CLOT candidates: GAPS(C, C’) gives the set of all possible gap sizes between C and C’ when C is parsed before C’ in the input packet. Some examples:<ul>
<li>∅ = GAPS(C, C’) if C is never parsed before C’.</li>
<li>0 ∈ GAPS(C, C’) if there is a path through the parser in which C is parsed before C’ and the two are immediately adjacent.</li>
<li>1 ∈ GAPS(C, C’) if there is a path through the parser in which C is parsed before C’ and the two are separated in the packet by 1 byte.</li>
</ul>
</li>
<li>Define a predicate, SEP, for determining when adjacent CLOT candidates can become separated during deparsing.<ul>
<li>Assume 0 ∈ GAPS(C1, C3) and C1 is deparsed before C3.</li>
<li>SEP(C1, C3) = true exactly when any of the following is satisfied:<ul>
<li>The deparser emits a constant between C1 and C3.</li>
<li>There is a pseudoheader H2 that is deparsed between C1 and C3, satisfying any of the following:<ul>
<li>H2 might be added by the MAU pipeline.</li>
<li>There is a path through the parser in which C1 is parsed immediately before C3, and H2 is also parsed.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>If C may be parsed before C’ (i.e., GAPS(C, C’) ≠ ∅), then we remove the first few bytes at the beginning of C’ if any of the following is satisfied.</p><ul>
<li>C never appears immediately before C’ in the input packet: 0 ∉ GAPS(C, C’)).</li>
<li>When C appears before C’ in the packet, the two might be separated by 1 or 2 bytes: GAPS(C, C’) ∩ {1, 2} ≠ ∅.</li>
<li>C might be set invalid by the MAU pipeline when C’ remains valid.</li>
<li>C’ is deparsed before C.</li>
<li>C and C’ can become separated during deparsing: SEP(C, C’) = true.</li>
</ul>
<p>Dually, if C’ may be parsed before C (i.e., GAPS(C’, C) ≠ ∅), then we remove the last few bytes at the end of C’ if any of the following is satisfied.</p><ul>
<li>C’ never appears immediately before C in the input packet: 0 ∉ GAPS(C’, C)).</li>
<li>When C’ appears before C in the packet, the two might be separated by 1 or 2 bytes: GAPS(C’, C) ∩ {1, 2} ≠ ∅.</li>
<li>C’ might be set invalid by the MAU pipeline when C remains valid.</li>
<li>C is deparsed before C’.</li>
<li>C and C’ can become separated during deparsing: SEP(C’, C) = true.</li>
</ul>
<p>These adjustments are not mutually exclusive; adjustments may be necessary at both the beginning and end of C’. The number of bytes removed by these adjustments is computed to be the smallest amount needed to achieve the required inter-CLOT gap separation between C and C’ on all paths through the parser.</p>
<h1><a class="anchor" id="clot_alloc_adjust"></a>
Allocation adjustment</h1>
<p>Once PHV allocation is complete, the allocated CLOTs are adjusted to account for PHV container packing. Consider the example shown below. The CLOT begins with the field f2, which is double-allocated, read-only, and packed into a PHV container with f1. The PHV container also has a slice of f3 to ensure the container is byte-aligned.</p>
<p>Because f1 is modified, the PHV container will be deparsed, and will overwrite the CLOT. But the overwriting container straddles the CLOT boundary, which is not permitted. The CLOT, therefore, needs to be adjusted to exclude those portions that overlap the PHV container. A similar situation occurs for overwrites straddling the end of CLOTs.</p>
<div class="fragment"><div class="line">header h_t {</div>
<div class="line">  bit&lt;8&gt;  f1;  // modified</div>
<div class="line">  bit&lt;4&gt;  f2;  // read-only</div>
<div class="line">  bit&lt;12&gt; f3;  // unused</div>
<div class="line">  ...</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> PHV container           CLOT</div>
<div class="line">       │                   │</div>
<div class="line">       │                   │</div>
<div class="line">       │                   ▼</div>
<div class="line">       ▼     ──── ──── ──── ──── ──── ────</div>
<div class="line">┌ ─ ─ ─ ─ ─ ┴ ─ ─ ─ ─ ─                   │</div>
<div class="line"> ┌──────────┬────┬─────┴──────────┐       │</div>
<div class="line">││    f1    │ f2 │       f3       │  ...  │</div>
<div class="line"> └──────────┴────┴─────┬──────────┘       │</div>
<div class="line">└ ─ ─ ─ ─ ─ ┬ ─ ─ ─ ─ ─</div>
<div class="line">            └ ──── ──── ──── ──── ──── ───┘</div>
</div><!-- fragment --><p>To make these adjustments, we shrink all allocated CLOTs until they neither start nor end with an overwritten field slice. If the entire CLOT is overwritten, then the CLOT is unnecessary, and is de-allocated.</p>
<h1><a class="anchor" id="metrics"></a>
Metrics</h1>
<p>We form a metric for CLOT allocation by first identifying header bis that can benefit from CLOT allocation. These are bits satisfying all of the following conditions.</p>
<ul>
<li>Belongs to a field whose full width is extracted by the parser.</li>
<li>Emitted by the deparser.</li>
<li>Not contained in a header that is added by the MAU pipeline.</li>
<li>Not written by the MAU pipeline (either directly, or through an alias).</li>
<li>Not used in multiple checksum-update computations.</li>
</ul>
<p>We then report:</p><ul>
<li>How many of these bits do not have a CLOT allocation. This measures “lost opportunity”, since these bits could be allocated to CLOTs (ignoring the inter-CLOT gap constraint).</li>
<li>How many of these bits have both a CLOT allocation and a PHV allocation. This measures redundancy in the PHV allocation, since there is no benefit to having these bits be allocated to PHVs. In keeping with the other metrics reported by the compiler, lower is better for these metrics.</li>
</ul>
<p>We could categorize these bytes into sub-metrics, as follows:</p>
<ul>
<li>Bytes that fall into the 3-byte inter-CLOT gap requirement (hardware limitation).</li>
<li>Bytes that are not CLOT-allocated for other reasons.</li>
</ul>
<p>Not all of these sub-metrics will necessarily be indicative of a better CLOT allocation, however. For example, an allocator that allocates an additional CLOT might reduce the overall number of bytes that are not CLOT-allocated, but increase the number of inter-CLOT gap bytes. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.12.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
