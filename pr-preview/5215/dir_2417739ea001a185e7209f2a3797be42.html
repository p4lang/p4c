<!-- HTML header for doxygen 1.13.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>P4 Compiler Documentation (P4C): walle Directory Reference</title>
<link rel="icon" href="p4-fav.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!--  Add link to paragraphs   -->
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
  DoxygenAwesomeParagraphLink.init()
</script>
<!-- Add copy button to code fragments  -->
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
  DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add dark mode toggle -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
  DoxygenAwesomeDarkModeToggle.init()
</script>
<!-- Add interactive TOC -->
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
  DoxygenAwesomeInteractiveToc.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-interactive-toc.js" rel="stylesheet" type="text/css"/>
<link href="cards.css" rel="stylesheet" type="text/css"/>
<link href="flow.css" rel="stylesheet" type="text/css"/>
<link href="p4c_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="p4-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">P4C
   </div>
   <div id="projectbrief">The P4 Compiler</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dir_2417739ea001a185e7209f2a3797be42.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">walle Directory Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Directory dependency graph for walle:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="dir_2417739ea001a185e7209f2a3797be42_dep.svg" width="112" height="104"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Walle serves as a layer of abstraction between the Tofino compiler and chip, presenting the chip's memory hierarchy to the compiler as a set of JSON structures that contain register/memory names and their values, while abstracting away the actual addresses of these registers and the methods by which they are programmed (DMA/direct PCIe writes/indirect instruction lists).</p>
<p>Walle stores the exact structure of the chip's memory hierarchy in a "chip.schema" file, which has to be generated from raw register data whenever the chip registers change, and is then used afterwards to crunch compiler output into a binary config file. It can also be used to generate "template" JSON that looks like compiler output with the hardware's default values for all fields (in most cases, 0). These templates are used by the compiler to enforce the correct structure on its output data, and also in general should be regenerated whenever the chip's registers change.</p>
<h1><a class="anchor" id="using-walle"></a>
Using Walle</h1>
<h2><a class="anchor" id="basic-usage"></a>
Basic usage</h2>
<h3><a class="anchor" id="generating-a-schema"></a>
Generating a schema</h3>
<p>First, generate a chip schema. Invoke Walle with the <code>--generate-schema</code> flag followed by the directory containing raw CSV files output by csrCompiler. If the bfnregs repo is cloned into ~/bfnregs, this would be: </p><pre class="fragment">./walle.py --generate-schema ~/bfnregs/modules/tofino_regs/module/csv/
</pre><p>This will generate a file named <code>chip.schema</code> in the current working directory, which is where it will look for the chip schema by default. The <code>--schema SCHEMA-FILE</code> flag can be used to point Walle to a different schema, or a different location to output the schema it is generating.</p>
<h3><a class="anchor" id="crunching-compiler-output"></a>
Crunching compiler output</h3>
<p>The most common use case for Walle is taking multiple config JSONs and crunching them into a binary file Tofino's drivers can read. Just invoke Walle with the names of all relevant JSON files, and optionally the name of the file to output: </p><pre class="fragment">./walle.py cfg1.json cfg2.json cfg3.json -o chip_config.bin
</pre><p>If the compiler was set up to dump all of its config output into an otherwise empty directory, shell wildcards can be used to shorten this command. If that dir is called 'cfgs', this would look like: </p><pre class="fragment">./walle.py cfgs/*.json -o chip_config.bin
</pre><h3><a class="anchor" id="generating-templates"></a>
Generating templates</h3>
<p>Walle can be used to generate blank register templates to be filled in by the compiler. These templates are the JSON files that Walle would expect to see given the current chip schema, but with all of the data set to the corresponding hardware register's power-on default (in most cases, 0).</p>
<p>To do so, Walle must be fed a JSON file enumerating the Semifore addressmap objects it should generate templates for. This file must take this structure:</p>
<p>{ "generated": { "memories":[ // memory addressmap names ], "regs":[ // register addressmap names ] }, "ignored": { "memories":[ // memory addressmap names ], "regs":[ // register addressmap names ] } }</p>
<p>Names under 'memories' keys refer to addressmaps included by the top-level 'pipe_top_level.csr' file, while names under 'regs' keys refer to those included by 'tofino.csr'.</p>
<p>Address maps listed under 'generated' will cause a JSON template file to be generated. Wherever that address map appears elsewhere in the hierarchy will be replaced with a string reference to said JSON file.</p>
<p>Address maps listed under 'ignored' will be replaced with a 0 when they appear elsewhere in the hierarchy, and no JSON template file will be generated.</p>
<p>Use the <code>--generate-templates</code> flag followed by the path to a file of the format just discussed to generate template JSONs in a directory called <code>templates</code> (which will be created in the working directory if it doesn't already exist): </p><pre class="fragment">./walle.py --generate-templates templates_file
</pre><p>These files can then be copied to the compiler's source tree.</p>
<p>The templates themselves end in the extension '.cfg.json'. Walle will also generate an identical hierarchy containing the bit-widths of each field, and these files end in the extension '.size.json'.</p>
<h2><a class="anchor" id="advanced-usage"></a>
Advanced usage</h2>
<h3><a class="anchor" id="directing-the-crunch-process"></a>
Directing the crunch process</h3>
<p>Walle crunches by first loading all provided JSON files and verifying them against its chip schema, and then drilling down from specified "top-level" points in that cloud of JSON data. By default, these points are called <code>memories.top</code> and <code>regs.top</code> and represent the memory and register hierarchies of the chip, respectively.</p>
<p>The <code>--top NAME</code> flag can be used to manually specify the top-level points to drill down from. Multiple <code>--top NAME</code> flags can be included, and if any are present the default top-level names are not used.</p>
<p>This is equivalent to the default behavior: </p><pre class="fragment">./walle.py cfgs/*.json --top memories.top --top regs.top -o chip_config.bin
</pre><p>One of them can be left out to only generate, say, only register configuration: </p><pre class="fragment">./walle.py cfgs/*.json --top regs.top -o chip_config.bin
</pre><p>Walle calculates addresses relative to the top-level points specified, so it is important that these points only ever refer to actual top-level points in the Semifore register hierarchy. If it is desired to only generate, for example, config data for the MAU or one pipe, the top-level JSON files should be hand-tweaked to disable other parts of the configuration binary. See the specification of the JSON config format for more details.</p>
<h3><a class="anchor" id="directing-the-template-generation-process"></a>
Directing the template generation process</h3>
<p>Walle generates a template file for each addressmap type specified in the <code>template_objects</code> file which sits in the same folder as the Walle script. If Walle encounters an instance of these addressmap types during template generation, it leaves that tree of the JSON data unexpanded and replaces it with a string indicating it expects a template to be plugged in to that location.</p>
<p>The type names of these addressmaps can be found by viewing the Semifore HTML output of the reg and memory hierarchies and checking 'Header File Information' at the top of the page. The 'Type Name' field that then appears within each address map indicates the type which should be passed to Walle for templatization. Semifore incorrectly capitlizes the first letter of the type name - it should be all lowercase when specified to Walle.</p>
<p>Note that the JSON fed to Walle does <em>not</em> have to follow the same template structure as specified in the <code>template_objects</code> file - this templatization control is just for convenience and reducing the file size of the generated blank templates.</p>
<h1><a class="anchor" id="configuration-json-format"></a>
Configuration JSON format</h1>
<p>Walle consumes JSON files that specify values to be written registers named in the chip's Semifore specification. The structure of these JSON files directly mirrors the structure found in the chip's Semifore specification.</p>
<p>Each JSON file contains a dictionary that represents one instance of a Semifore addressmap. Addressmap dictionaries' keys represent the Semifore names of registers and nested addressmaps, while the values are either:</p>
<ul>
<li>Dictionaries representing those objects</li>
<li>Lists of dictionaries, in the case the object in question is an array</li>
<li>Lists of lists (of lists of lists of lists of...) in the case the object in question is an N-dimensional array</li>
</ul>
<p>Register dictionaries have field names as keys and integers as values. They follow the same rules for lists in the event of a field array. The outer-most dictionary also has these special Walle keys: <br  />
</p>
<ul>
<li><code>_type</code> : The full type name that this file provides values for, of the form <code>section.semifore_type</code>. For example, the parser's memories are of type <code>memories.prsr_mem_rspec</code>, while its registers are of type <code>regs.prsr_reg_rspec</code></li>
<li><code>_name</code> : A name used to reference this file and its data elsewhere in the config JSON</li>
<li><code>_schema_hash</code>: The MD5 hash of the raw Semifore output used to generate the chip schema from which this file's structure was derived, used to ensure the chip schema and JSON input match</li>
<li><code>_reg_version</code>: The git tag of the bfnregs repo commit used to generate the chip schema from which this file's structure was derived. This value isn't used by Walle itself, but is useful to manually determine which version of the compiler or model a given config JSON was created for.</li>
</ul>
<p>At any point in the hierarchy, a register/addressmap value may be replaced with:</p>
<ul>
<li>A string containing the name of another JSON input file, which "stamps" that other data down at this point in the memory hierarchy</li>
<li>0, indicating no write operation should be generated for the given object</li>
</ul>
<p>Fields cannot be "disabled with 0s" the way registers and addressmaps can, since the register is the level of granularity at which the drivers write data.</p>
<p>Config JSON can be hand-tweaked with 0's to produce a binary blob that only writes to specific registers and leaves everything else alone, in order to produce "initial boot" config blobs and then "soft reboot" config blobs.</p>
<h3><a class="anchor" id="error-checking"></a>
Error checking</h3>
<p>Walle will fail to generate output if:</p>
<ul>
<li>A field value ever exceeds the field's bit width as specified in the chip schema</li>
<li>A template is instantiated at a point in the hierarchy that does not match the type expected by the chip schema (eg, naming an instance of <code>memories.prsr_mem_rspec</code> in the top-level <em>register</em> JSON)</li>
<li><p class="startli">A file's <code>_schema_hash</code> value does not match the hash stored in the chip schema. This check can be suppressed with the flag <code>--ignore-schema-mismatch</code>:</p>
<p class="startli">./walle.py cfgs/*.json &ndash;ignore-schema-mismatch -o chip_config.bin</p>
<p class="startli">This flag is provided for development purposes, because even a small change at one end of the register hierarchy (like correcting a typo in a register <em>description</em>) will change the hash without actually affecting the structure of the chip schema, and it would be a pain to have to regenerate all templates and copy them over into the compiler source tree just to get things working again.</p>
<p class="startli">In the long run, however, this flag should not be used and schema hashes should be consistent.</p>
</li>
</ul>
<h1><a class="anchor" id="binary-blob-format"></a>
Binary blob format</h1>
<p>Walle generates a sequence of binary write instructions for the driver which are of the following types:</p>
<ul>
<li>Direct register write - For 32 bit registers that can be addressed directly from the PCIe bus, a simple address-data pair of the form: <pre class="fragment">  4 bytes: "\0\0\0R"
  4 bytes: 32-bit PCIe address
  4 bytes: Data
  All fields little-endian
</pre></li>
</ul>
<ul>
<li><p class="startli">Indirect register write - For registers wider than 32 bits, or to compose many direct register writes into one write list that can be transmitted across PCIe as a single transaction.</p>
<p class="startli">TODO: not actually implemented driver-or-Walle-side yet, since the model doesn't currently support indirect reg addressing</p>
</li>
<li><p class="startli">DMA block write - Automatically chosen for arrays of registers larger than 4 elements, a base address and block of data: </p><pre class="fragment">  4 bytes: "\0\0\0D"
  8 bytes: 42-bit chip address
  4 bytes: Bit-length of word
  4 bytes: Number of words
  Following: Data, in 32-bit word chunks
  All fields little-endian
</pre><p class="startli">TODO: currently only registers in the 'memories' half of the hierarchy will get rolled into DMA blocks, again because the model doesn't currently support indirect reg addressing. Eventually this won't be a problem</p>
</li>
</ul>
<p>The driver should execute these instructions in the order they are read. The binary blob has no header or structure aside from these write instructions, so multiple binary files can be concatenated together or split into parts as needed.</p>
<p>Walle can be optionally instructed to generate a direct register write to address 0xFFFFFFFF at the very end of the file to signify to the model the end of configuration data. This is enabled with the flag <code>--append-sentinel</code>: </p><pre class="fragment">./walle.py cfgs/*.json --append-sentinel -o chip_config.bin
</pre> </div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_dec21994cd756836ecefab773235960a.html">backends</a></li><li class="navelem"><a class="el" href="dir_c4ded715df726299fc9cd18b15628924.html">tofino</a></li><li class="navelem"><a class="el" href="dir_e3e152015c473544e5818afd3f21296d.html">bf-asm</a></li><li class="navelem"><a class="el" href="dir_2417739ea001a185e7209f2a3797be42.html">walle</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
