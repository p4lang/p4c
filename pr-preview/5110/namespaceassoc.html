<!-- HTML header for doxygen 1.13.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>P4 Compiler Documentation (P4C): assoc Namespace Reference</title>
<link rel="icon" href="p4-fav.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!--  Add link to paragraphs   -->
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
  DoxygenAwesomeParagraphLink.init()
</script>
<!-- Add copy button to code fragments  -->
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
  DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add dark mode toggle -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
  DoxygenAwesomeDarkModeToggle.init()
</script>
<!-- Add interactive TOC -->
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
  DoxygenAwesomeInteractiveToc.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-interactive-toc.js" rel="stylesheet" type="text/css"/>
<link href="cards.css" rel="stylesheet" type="text/css"/>
<link href="flow.css" rel="stylesheet" type="text/css"/>
<link href="p4c_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="p4-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">P4C
   </div>
   <div id="projectbrief">The P4 Compiler</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespaceassoc.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">assoc Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceassoc_1_1detail.html">detail</a></td></tr>
<tr class="memdesc:namespaceassoc_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation details of for the namespace assoc. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classassoc_1_1hash__map.html">hash_map</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classassoc_1_1hash__set.html">hash_set</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classassoc_1_1map.html">map</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classassoc_1_1set.html">set</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a9a15de3146d4338e2e4dbfb830592957" id="r_a9a15de3146d4338e2e4dbfb830592957"><td class="memTemplParams" colspan="2"><a id="a9a15de3146d4338e2e4dbfb830592957" name="a9a15de3146d4338e2e4dbfb830592957"></a>
template&lt;typename Key, typename T, typename Compare = std::less&lt;Key&gt;, typename Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt; </td></tr>
<tr class="memitem:a9a15de3146d4338e2e4dbfb830592957"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>iterable_map</b> = <a class="el" href="classassoc_1_1map.html">map</a>&lt;Key, T, Compare, Allocator, Iterable::Yes&gt;</td></tr>
<tr class="separator:a9a15de3146d4338e2e4dbfb830592957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3118cdb75249f9c558c353f5d2f0ab6" id="r_aa3118cdb75249f9c558c353f5d2f0ab6"><td class="memTemplParams" colspan="2"><a id="aa3118cdb75249f9c558c353f5d2f0ab6" name="aa3118cdb75249f9c558c353f5d2f0ab6"></a>
template&lt;typename Key, typename Compare = std::less&lt;Key&gt;, typename Allocator = std::allocator&lt;Key&gt;&gt; </td></tr>
<tr class="memitem:aa3118cdb75249f9c558c353f5d2f0ab6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>iterable_set</b> = <a class="el" href="classassoc_1_1set.html">set</a>&lt;Key, Compare, Allocator, Iterable::Yes&gt;</td></tr>
<tr class="separator:aa3118cdb75249f9c558c353f5d2f0ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c2f1c5b0df519712f54974f81f9b3e" id="r_ad2c2f1c5b0df519712f54974f81f9b3e"><td class="memTemplParams" colspan="2"><a id="ad2c2f1c5b0df519712f54974f81f9b3e" name="ad2c2f1c5b0df519712f54974f81f9b3e"></a>
template&lt;typename Key, typename T, typename Compare = std::less&lt;Key&gt;, typename Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt; </td></tr>
<tr class="memitem:ad2c2f1c5b0df519712f54974f81f9b3e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>non_iterable_map</b> = <a class="el" href="classassoc_1_1map.html">map</a>&lt;Key, T, Compare, Allocator, Iterable::No&gt;</td></tr>
<tr class="separator:ad2c2f1c5b0df519712f54974f81f9b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531af47025dc1e30a9cfe4cfcbf686bf" id="r_a531af47025dc1e30a9cfe4cfcbf686bf"><td class="memTemplParams" colspan="2"><a id="a531af47025dc1e30a9cfe4cfcbf686bf" name="a531af47025dc1e30a9cfe4cfcbf686bf"></a>
template&lt;typename Key, typename Compare = std::less&lt;Key&gt;, typename Allocator = std::allocator&lt;Key&gt;&gt; </td></tr>
<tr class="memitem:a531af47025dc1e30a9cfe4cfcbf686bf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>non_iterable_set</b> = <a class="el" href="classassoc_1_1set.html">set</a>&lt;Key, Compare, Allocator, Iterable::No&gt;</td></tr>
<tr class="separator:a531af47025dc1e30a9cfe4cfcbf686bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53cf3294a5e8a1a1606590d206c20b4e" id="r_a53cf3294a5e8a1a1606590d206c20b4e"><td class="memTemplParams" colspan="2"><a id="a53cf3294a5e8a1a1606590d206c20b4e" name="a53cf3294a5e8a1a1606590d206c20b4e"></a>
template&lt;typename Key, typename T, typename Compare = std::less&lt;Key&gt;, typename Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt; </td></tr>
<tr class="memitem:a53cf3294a5e8a1a1606590d206c20b4e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ordered_map</b> = <a class="el" href="class_p4_1_1ordered__map.html">::P4::ordered_map</a>&lt;Key, T, Compare, Allocator&gt;</td></tr>
<tr class="separator:a53cf3294a5e8a1a1606590d206c20b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb65a9f9c83567e9550da2e323b4a2b" id="r_accb65a9f9c83567e9550da2e323b4a2b"><td class="memTemplParams" colspan="2"><a id="accb65a9f9c83567e9550da2e323b4a2b" name="accb65a9f9c83567e9550da2e323b4a2b"></a>
template&lt;typename Key, typename Compare = std::less&lt;Key&gt;, typename Allocator = std::allocator&lt;Key&gt;&gt; </td></tr>
<tr class="memitem:accb65a9f9c83567e9550da2e323b4a2b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ordered_set</b> = <a class="el" href="class_p4_1_1ordered__set.html">::P4::ordered_set</a>&lt;Key, Compare, Allocator&gt;</td></tr>
<tr class="separator:accb65a9f9c83567e9550da2e323b4a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ad5bb5065b018805af02ed74b6af3c657" id="r_ad5bb5065b018805af02ed74b6af3c657"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5bb5065b018805af02ed74b6af3c657">Iterable</a> { <b>Auto</b>
, <b>No</b>
, <b>Yes</b>
 }</td></tr>
<tr class="separator:ad5bb5065b018805af02ed74b6af3c657"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac17a2614ab31d088d03aaf330fc677d5" id="r_ac17a2614ab31d088d03aaf330fc677d5"><td class="memTemplParams" colspan="2"><a id="ac17a2614ab31d088d03aaf330fc677d5" name="ac17a2614ab31d088d03aaf330fc677d5"></a>
template&lt;class K, class T, class V, class Comp, class Alloc, <a class="el" href="#ad5bb5065b018805af02ed74b6af3c657">Iterable</a> It&gt; </td></tr>
<tr class="memitem:ac17a2614ab31d088d03aaf330fc677d5"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const <a class="el" href="classassoc_1_1map.html">map</a>&lt; K, V, Comp, Alloc, It &gt; &amp;m, T key, V def=V())</td></tr>
<tr class="separator:ac17a2614ab31d088d03aaf330fc677d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47461a959a9ce0c726c03254fd9a71e9" id="r_a47461a959a9ce0c726c03254fd9a71e9"><td class="memTemplParams" colspan="2"><a id="a47461a959a9ce0c726c03254fd9a71e9" name="a47461a959a9ce0c726c03254fd9a71e9"></a>
template&lt;class K, class T, class V, class Comp, class Alloc, <a class="el" href="#ad5bb5065b018805af02ed74b6af3c657">Iterable</a> It&gt; </td></tr>
<tr class="memitem:a47461a959a9ce0c726c03254fd9a71e9"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const <a class="el" href="classassoc_1_1map.html">map</a>&lt; K, V, Comp, Alloc, It &gt; *m, T key, V def=V())</td></tr>
<tr class="separator:a47461a959a9ce0c726c03254fd9a71e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4675a7f21893f0e61a4b2c79c2807a" id="r_add4675a7f21893f0e61a4b2c79c2807a"><td class="memTemplParams" colspan="2"><a id="add4675a7f21893f0e61a4b2c79c2807a" name="add4675a7f21893f0e61a4b2c79c2807a"></a>
template&lt;class K, class T, class V, class Comp, class Alloc, <a class="el" href="#ad5bb5065b018805af02ed74b6af3c657">Iterable</a> It&gt; </td></tr>
<tr class="memitem:add4675a7f21893f0e61a4b2c79c2807a"><td class="memTemplItemLeft" align="right" valign="top">const V *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getref</b> (const <a class="el" href="classassoc_1_1map.html">map</a>&lt; K, V, Comp, Alloc, It &gt; &amp;m, T key)</td></tr>
<tr class="separator:add4675a7f21893f0e61a4b2c79c2807a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6021f4562c1d3eac57375903c8991620" id="r_a6021f4562c1d3eac57375903c8991620"><td class="memTemplParams" colspan="2"><a id="a6021f4562c1d3eac57375903c8991620" name="a6021f4562c1d3eac57375903c8991620"></a>
template&lt;class K, class T, class V, class Comp, class Alloc, <a class="el" href="#ad5bb5065b018805af02ed74b6af3c657">Iterable</a> It&gt; </td></tr>
<tr class="memitem:a6021f4562c1d3eac57375903c8991620"><td class="memTemplItemLeft" align="right" valign="top">const V *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getref</b> (const <a class="el" href="classassoc_1_1map.html">map</a>&lt; K, V, Comp, Alloc, It &gt; *m, T key)</td></tr>
<tr class="separator:a6021f4562c1d3eac57375903c8991620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e4a1c701d3d0fbdca0c51109043d2e9" id="r_a3e4a1c701d3d0fbdca0c51109043d2e9"><td class="memTemplParams" colspan="2"><a id="a3e4a1c701d3d0fbdca0c51109043d2e9" name="a3e4a1c701d3d0fbdca0c51109043d2e9"></a>
template&lt;class K, class T, class V, class Comp, class Alloc, <a class="el" href="#ad5bb5065b018805af02ed74b6af3c657">Iterable</a> It&gt; </td></tr>
<tr class="memitem:a3e4a1c701d3d0fbdca0c51109043d2e9"><td class="memTemplItemLeft" align="right" valign="top">V *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getref</b> (<a class="el" href="classassoc_1_1map.html">map</a>&lt; K, V, Comp, Alloc, It &gt; &amp;m, T key)</td></tr>
<tr class="separator:a3e4a1c701d3d0fbdca0c51109043d2e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4815661ba6cf258c7d17348fd9879faf" id="r_a4815661ba6cf258c7d17348fd9879faf"><td class="memTemplParams" colspan="2"><a id="a4815661ba6cf258c7d17348fd9879faf" name="a4815661ba6cf258c7d17348fd9879faf"></a>
template&lt;class K, class T, class V, class Comp, class Alloc, <a class="el" href="#ad5bb5065b018805af02ed74b6af3c657">Iterable</a> It&gt; </td></tr>
<tr class="memitem:a4815661ba6cf258c7d17348fd9879faf"><td class="memTemplItemLeft" align="right" valign="top">V *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getref</b> (<a class="el" href="classassoc_1_1map.html">map</a>&lt; K, V, Comp, Alloc, It &gt; *m, T key)</td></tr>
<tr class="separator:a4815661ba6cf258c7d17348fd9879faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb4c3d637a8c01261af36fde606cbd1" id="r_afcb4c3d637a8c01261af36fde606cbd1"><td class="memTemplParams" colspan="2"><a id="afcb4c3d637a8c01261af36fde606cbd1" name="afcb4c3d637a8c01261af36fde606cbd1"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:afcb4c3d637a8c01261af36fde606cbd1"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const <a class="el" href="classassoc_1_1hash__set.html">assoc::hash_set</a>&lt; T &gt; &amp;<a class="el" href="classassoc_1_1set.html">set</a>)</td></tr>
<tr class="separator:afcb4c3d637a8c01261af36fde606cbd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa73c9dd53e9158d536e137eaad494a6" id="r_afa73c9dd53e9158d536e137eaad494a6"><td class="memTemplParams" colspan="2"><a id="afa73c9dd53e9158d536e137eaad494a6" name="afa73c9dd53e9158d536e137eaad494a6"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:afa73c9dd53e9158d536e137eaad494a6"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const <a class="el" href="classassoc_1_1set.html">assoc::set</a>&lt; T &gt; &amp;<a class="el" href="classassoc_1_1set.html">set</a>)</td></tr>
<tr class="separator:afa73c9dd53e9158d536e137eaad494a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Copyright (C) 2024 Intel Corporation</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p>
<p><a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p>SPDX-License-Identifier: Apache-2.0 The assoc namespace contains wrappers over various associative containers that can be used more safely in the compiler. In particular, it tries to keep track of possible sources of nondeterminism &ndash; cases when repeated compilation of the same P4 code produces different results. If using the containers from assoc namespace, the code does not compile if it iterates over sorted containers that use pointers as keys or if it iterates over unordered containers. The reason is that such iteration often introduces dependency on particular ordering of pointers that can differ between runs of the compiler.</p>
<p>The downside of this approach is that it is an approximation &ndash; there can be cases when this is perfectly correct and does not introduce nondeterminism: e.g. if the code looks for if some value in a map matches some predicate (but does not return the actual value).</p>
<p>In general, the iteration (using container.begin()) is forbidden for:</p><ul>
<li>all unsorted (hash-based) containers;</li>
<li>containers that have pointers or tuples/pairs containing pointers as keys, if the containers do not use explicit non-standard comparator.</li>
</ul>
<p>This behaviour can be overridden by:</p><ul>
<li>using .unstable_iterable() on the container at the place where it is actually safe to iterate as the result does not really depend on the iteration order.</li>
<li>using .unstable_begin() (together with .end()) in similar cases e.g. in standard algorithms such as std::any_of/stdall_of/stdnone_of.</li>
<li>declaring the data structure as assoc::iterable_* (e.g. assoc::iterable_map) to allow the iteration always (not recommended). </li>
</ul>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ad5bb5065b018805af02ed74b6af3c657" name="ad5bb5065b018805af02ed74b6af3c657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5bb5065b018805af02ed74b6af3c657">&#9670;&#160;</a></span>Iterable</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#ad5bb5065b018805af02ed74b6af3c657">assoc::Iterable</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Used to specify if the associative container should be iterable</p>
<ul>
<li>Yes: always iterable</li>
<li>No: always not iterable</li>
<li>Auto: iterable for sorted containers over keys that are not pointers or tuples/pairs containing pointers. </li>
</ul>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceassoc.html">assoc</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
