<!-- HTML header for doxygen 1.12.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>P4 Compiler Documentation (P4C): PHV::Field Class Reference</title>
<link rel="icon" href="p4-fav.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!--  Add link to paragraphs   -->
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
  DoxygenAwesomeParagraphLink.init()
</script>
<!-- Add copy button to code fragments  -->
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
  DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add dark mode toggle -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
  DoxygenAwesomeDarkModeToggle.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="cards.css" rel="stylesheet" type="text/css"/>
<link href="flow.css" rel="stylesheet" type="text/css"/>
<link href="p4c_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="p4-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">P4C
   </div>
   <div id="projectbrief">The P4 Compiler</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_p_h_v_1_1_field.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_p_h_v_1_1_field-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">PHV::Field Class Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for PHV::Field:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_p_h_v_1_1_field__inherit__graph.svg" width="143" height="110"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_h_v_1_1_field_1_1mirror__field__list__t.html">mirror_field_list_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mirror field points to its field list (one of eight)  <a href="struct_p_h_v_1_1_field_1_1mirror__field__list__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0b6077d2acc27b1a05d475689c0c4b0f" id="r_a0b6077d2acc27b1a05d475689c0c4b0f"><td class="memItemLeft" align="right" valign="top"><a id="a0b6077d2acc27b1a05d475689c0c4b0f" name="a0b6077d2acc27b1a05d475689c0c4b0f"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>alloc_code_t</b> { <br />
&#160;&#160;<b>EMPTY</b> = 0
, <b>REFERENCED</b> = 1 &lt;&lt; 0
, <b>HAS_PHV_ALLOCATION</b> = 1 &lt;&lt; 1
, <b>FULLY_PHV_ALLOCATED</b> = 1 &lt;&lt; 2
, <br />
&#160;&#160;<b>HAS_CLOT_ALLOCATION</b> = 1 &lt;&lt; 3
<br />
 }</td></tr>
<tr class="separator:a0b6077d2acc27b1a05d475689c0c4b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888dbd6c73096005ee352a8d61dc9be2" id="r_a888dbd6c73096005ee352a8d61dc9be2"><td class="memItemLeft" align="right" valign="top"><a id="a888dbd6c73096005ee352a8d61dc9be2" name="a888dbd6c73096005ee352a8d61dc9be2"></a>
typedef unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>AllocState</b></td></tr>
<tr class="separator:a888dbd6c73096005ee352a8d61dc9be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a99c815eb77c6bb38584ba2582c58fa60" id="r_a99c815eb77c6bb38584ba2582c58fa60"><td class="memItemLeft" align="right" valign="top"><a id="a99c815eb77c6bb38584ba2582c58fa60" name="a99c815eb77c6bb38584ba2582c58fa60"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>add_alloc</b> (const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;alloc)</td></tr>
<tr class="memdesc:a99c815eb77c6bb38584ba2582c58fa60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a slice of this field. <br /></td></tr>
<tr class="separator:a99c815eb77c6bb38584ba2582c58fa60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ef687175ecc392a4c2bc1fc17c9234" id="r_a79ef687175ecc392a4c2bc1fc17c9234"><td class="memItemLeft" align="right" valign="top"><a id="a79ef687175ecc392a4c2bc1fc17c9234" name="a79ef687175ecc392a4c2bc1fc17c9234"></a>
<a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>add_and_return_alloc</b> (const <a class="el" href="class_p_h_v_1_1_field.html">Field</a> *f, <a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a> c, int fb, int cb, int w, const <a class="el" href="class_p4_1_1ordered__set.html">ActionSet</a> &amp;a)</td></tr>
<tr class="separator:a79ef687175ecc392a4c2bc1fc17c9234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a549b8bb2a3681c1dcb28ad2658727005" id="r_a549b8bb2a3681c1dcb28ad2658727005"><td class="memItemLeft" align="right" valign="top"><a id="a549b8bb2a3681c1dcb28ad2658727005" name="a549b8bb2a3681c1dcb28ad2658727005"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>add_wide_arith_start_bit</b> (int start_bit)</td></tr>
<tr class="separator:a549b8bb2a3681c1dcb28ad2658727005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a080e2f543188692029705871c9d70803" id="r_a080e2f543188692029705871c9d70803"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a080e2f543188692029705871c9d70803">alloc_size</a> () const</td></tr>
<tr class="separator:a080e2f543188692029705871c9d70803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280692ca16acbdbaa36b6a0e1b447c98" id="r_a280692ca16acbdbaa36b6a0e1b447c98"><td class="memItemLeft" align="right" valign="top"><a id="a280692ca16acbdbaa36b6a0e1b447c98" name="a280692ca16acbdbaa36b6a0e1b447c98"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>bit_is_wide_arith_lo</b> (int slice_bit) const</td></tr>
<tr class="separator:a280692ca16acbdbaa36b6a0e1b447c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8893c30da16f0da54acb68ff7fc036b" id="r_aa8893c30da16f0da54acb68ff7fc036b"><td class="memItemLeft" align="right" valign="top"><a id="aa8893c30da16f0da54acb68ff7fc036b" name="aa8893c30da16f0da54acb68ff7fc036b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>bit_used_in_wide_arith</b> (int slice_bit) const</td></tr>
<tr class="separator:aa8893c30da16f0da54acb68ff7fc036b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619905bddda92e02d9bb54565b1a3a87" id="r_a619905bddda92e02d9bb54565b1a3a87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a619905bddda92e02d9bb54565b1a3a87">byteAlignedRangeInBits</a> () const</td></tr>
<tr class="separator:a619905bddda92e02d9bb54565b1a3a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2de2df68b196307135eab89cb7b2ce" id="r_add2de2df68b196307135eab89cb7b2ce"><td class="memItemLeft" align="right" valign="top"><a id="add2de2df68b196307135eab89cb7b2ce" name="add2de2df68b196307135eab89cb7b2ce"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear_alloc</b> ()</td></tr>
<tr class="memdesc:add2de2df68b196307135eab89cb7b2ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear any PHV allocation for this field. <br /></td></tr>
<tr class="separator:add2de2df68b196307135eab89cb7b2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4eb6d2cc03fc0d22b4dd52d6e1388a" id="r_afc4eb6d2cc03fc0d22b4dd52d6e1388a"><td class="memItemLeft" align="right" valign="top"><a id="afc4eb6d2cc03fc0d22b4dd52d6e1388a" name="afc4eb6d2cc03fc0d22b4dd52d6e1388a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearExternalName</b> ()</td></tr>
<tr class="memdesc:afc4eb6d2cc03fc0d22b4dd52d6e1388a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the external name, if any has been set. <br /></td></tr>
<tr class="separator:afc4eb6d2cc03fc0d22b4dd52d6e1388a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80de3f3191e532be5fadb526f5eb744" id="r_ab80de3f3191e532be5fadb526f5eb744"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab80de3f3191e532be5fadb526f5eb744">container_bytes</a> (std::optional&lt; <a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> &gt; bits=std::nullopt) const</td></tr>
<tr class="separator:ab80de3f3191e532be5fadb526f5eb744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ad303d4472f88019892e412296aa63" id="r_a57ad303d4472f88019892e412296aa63"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57ad303d4472f88019892e412296aa63">deparsed</a> () const</td></tr>
<tr class="separator:a57ad303d4472f88019892e412296aa63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0a42ecf785b5b204e697bccbd22c86" id="r_a6a0a42ecf785b5b204e697bccbd22c86"><td class="memItemLeft" align="right" valign="top"><a id="a6a0a42ecf785b5b204e697bccbd22c86" name="a6a0a42ecf785b5b204e697bccbd22c86"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>deparsed_bottom_bits</b> () const</td></tr>
<tr class="separator:a6a0a42ecf785b5b204e697bccbd22c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f44193356e555b22b3da10a4cb0999" id="r_a57f44193356e555b22b3da10a4cb0999"><td class="memItemLeft" align="right" valign="top"><a id="a57f44193356e555b22b3da10a4cb0999" name="a57f44193356e555b22b3da10a4cb0999"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>deparsed_to_tm</b> () const</td></tr>
<tr class="separator:a57f44193356e555b22b3da10a4cb0999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68cfb6819cb7031af435e12175c756d3" id="r_a68cfb6819cb7031af435e12175c756d3"><td class="memItemLeft" align="right" valign="top"><a id="a68cfb6819cb7031af435e12175c756d3" name="a68cfb6819cb7031af435e12175c756d3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>deparsed_top_bits</b> () const</td></tr>
<tr class="separator:a68cfb6819cb7031af435e12175c756d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557950c5b1c7c36a5d49a1f29a8d09fe" id="r_a557950c5b1c7c36a5d49a1f29a8d09fe"><td class="memItemLeft" align="right" valign="top"><a id="a557950c5b1c7c36a5d49a1f29a8d09fe" name="a557950c5b1c7c36a5d49a1f29a8d09fe"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>emitted</b> () const</td></tr>
<tr class="separator:a557950c5b1c7c36a5d49a1f29a8d09fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4f964856ec6728f477b1e41e0b1cbc2" id="r_aa4f964856ec6728f477b1e41e0b1cbc2"><td class="memItemLeft" align="right" valign="top"><a id="aa4f964856ec6728f477b1e41e0b1cbc2" name="aa4f964856ec6728f477b1e41e0b1cbc2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>erase_alignment</b> ()</td></tr>
<tr class="separator:aa4f964856ec6728f477b1e41e0b1cbc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03010531b8f29ba2c5ca6348736bdeed" id="r_a03010531b8f29ba2c5ca6348736bdeed"><td class="memItemLeft" align="right" valign="top"><a id="a03010531b8f29ba2c5ca6348736bdeed" name="a03010531b8f29ba2c5ca6348736bdeed"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>eraseAlignment</b> ()</td></tr>
<tr class="memdesc:a03010531b8f29ba2c5ca6348736bdeed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the alignment requirement for this field. <br /></td></tr>
<tr class="separator:a03010531b8f29ba2c5ca6348736bdeed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365e21aceabe91d6b5e83d3df06f52ab" id="r_a365e21aceabe91d6b5e83d3df06f52ab"><td class="memItemLeft" align="right" valign="top"><a id="a365e21aceabe91d6b5e83d3df06f52ab" name="a365e21aceabe91d6b5e83d3df06f52ab"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>exact_containers</b> () const</td></tr>
<tr class="separator:a365e21aceabe91d6b5e83d3df06f52ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645488aa0046cbf0084c9d3497b2ebc3" id="r_a645488aa0046cbf0084c9d3497b2ebc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p4_1_1cstring.html">cstring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a645488aa0046cbf0084c9d3497b2ebc3">externalName</a> () const</td></tr>
<tr class="separator:a645488aa0046cbf0084c9d3497b2ebc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07440949e4fae928574c2d0ed26c52ea" id="r_a07440949e4fae928574c2d0ed26c52ea"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07440949e4fae928574c2d0ed26c52ea">for_bit</a> (int bit) const</td></tr>
<tr class="separator:a07440949e4fae928574c2d0ed26c52ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50c188b2516687521d149ccbfa8f9e7" id="r_ac50c188b2516687521d149ccbfa8f9e7"><td class="memItemLeft" align="right" valign="top"><a id="ac50c188b2516687521d149ccbfa8f9e7" name="ac50c188b2516687521d149ccbfa8f9e7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>foreach_alloc</b> (const IR::MAU::Table *ctxt, const <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> *use, std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;)&gt; fn, SliceMatch useTblRefs=SliceMatch::DFLT) const</td></tr>
<tr class="separator:ac50c188b2516687521d149ccbfa8f9e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4832adfece75380b23fce3a41b0aa889" id="r_a4832adfece75380b23fce3a41b0aa889"><td class="memItemLeft" align="right" valign="top"><a id="a4832adfece75380b23fce3a41b0aa889" name="a4832adfece75380b23fce3a41b0aa889"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>foreach_alloc</b> (const <a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> *r, const IR::MAU::Table *ctxt, const <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> *use, std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;)&gt; fn, SliceMatch useTblRefs=SliceMatch::DFLT) const</td></tr>
<tr class="separator:a4832adfece75380b23fce3a41b0aa889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1d944fe8d84f67d98ba20261b760a0" id="r_a1d1d944fe8d84f67d98ba20261b760a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d1d944fe8d84f67d98ba20261b760a0">foreach_alloc</a> (const <a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> *r, const <a class="el" href="class_p_h_v_1_1_alloc_context.html">PHV::AllocContext</a> *ctxt, const <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> *use, std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;)&gt; fn, SliceMatch useTblRefs=SliceMatch::DFLT) const</td></tr>
<tr class="separator:a1d1d944fe8d84f67d98ba20261b760a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa728164df95cd98f9d943e69a6675a3b" id="r_aa728164df95cd98f9d943e69a6675a3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa728164df95cd98f9d943e69a6675a3b">foreach_alloc</a> (const <a class="el" href="class_p_h_v_1_1_alloc_context.html">PHV::AllocContext</a> *ctxt, const <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> *use, std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;)&gt; fn, SliceMatch useTblRefs=SliceMatch::DFLT) const</td></tr>
<tr class="separator:aa728164df95cd98f9d943e69a6675a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef6c79a3f3a4ab119dc93594e3d0aff" id="r_afef6c79a3f3a4ab119dc93594e3d0aff"><td class="memItemLeft" align="right" valign="top"><a id="afef6c79a3f3a4ab119dc93594e3d0aff" name="afef6c79a3f3a4ab119dc93594e3d0aff"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>foreach_alloc</b> (<a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> r, const IR::MAU::Table *ctxt, const <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> *use, std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;)&gt; fn, SliceMatch useTblRefs=SliceMatch::DFLT) const</td></tr>
<tr class="separator:afef6c79a3f3a4ab119dc93594e3d0aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa850790d78f97f6b7aa3ca8de1d4e44" id="r_afa850790d78f97f6b7aa3ca8de1d4e44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa850790d78f97f6b7aa3ca8de1d4e44">foreach_alloc</a> (<a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> r, const <a class="el" href="class_p_h_v_1_1_alloc_context.html">PHV::AllocContext</a> *ctxt, const <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> *use, std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;)&gt; fn, SliceMatch useTblRefs=SliceMatch::DFLT) const</td></tr>
<tr class="separator:afa850790d78f97f6b7aa3ca8de1d4e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f22f23b07dfca7f88825109997a8de" id="r_a27f22f23b07dfca7f88825109997a8de"><td class="memItemLeft" align="right" valign="top"><a id="a27f22f23b07dfca7f88825109997a8de" name="a27f22f23b07dfca7f88825109997a8de"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>foreach_alloc</b> (<a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> r, std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;)&gt; fn, SliceMatch useTblRefs=SliceMatch::DFLT) const</td></tr>
<tr class="separator:a27f22f23b07dfca7f88825109997a8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7237c602ea66018ac5ac271b85b478ba" id="r_a7237c602ea66018ac5ac271b85b478ba"><td class="memItemLeft" align="right" valign="top"><a id="a7237c602ea66018ac5ac271b85b478ba" name="a7237c602ea66018ac5ac271b85b478ba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>foreach_alloc</b> (std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;)&gt; fn, SliceMatch useTblRefs=SliceMatch::DFLT) const</td></tr>
<tr class="separator:a7237c602ea66018ac5ac271b85b478ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00be6f0735f48e1fca31613ee2b2782a" id="r_a00be6f0735f48e1fca31613ee2b2782a"><td class="memItemLeft" align="right" valign="top"><a id="a00be6f0735f48e1fca31613ee2b2782a" name="a00be6f0735f48e1fca31613ee2b2782a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>foreach_byte</b> (const IR::MAU::Table *ctxt, const <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> *use, std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;)&gt; fn, SliceMatch useTblRefs=SliceMatch::DFLT) const</td></tr>
<tr class="separator:a00be6f0735f48e1fca31613ee2b2782a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d68cfce1d0f13a104ccdcca8f75003" id="r_a10d68cfce1d0f13a104ccdcca8f75003"><td class="memItemLeft" align="right" valign="top"><a id="a10d68cfce1d0f13a104ccdcca8f75003" name="a10d68cfce1d0f13a104ccdcca8f75003"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>foreach_byte</b> (const <a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> *r, const IR::MAU::Table *ctxt, const <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> *use, std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;)&gt; fn, SliceMatch useTblRefs=SliceMatch::DFLT) const</td></tr>
<tr class="separator:a10d68cfce1d0f13a104ccdcca8f75003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef007f89d88ad70e582927c9519c0b4d" id="r_aef007f89d88ad70e582927c9519c0b4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef007f89d88ad70e582927c9519c0b4d">foreach_byte</a> (const <a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> *r, const <a class="el" href="class_p_h_v_1_1_alloc_context.html">PHV::AllocContext</a> *ctxt, const <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> *use, std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;)&gt; fn, SliceMatch useTblRefs=SliceMatch::DFLT) const</td></tr>
<tr class="separator:aef007f89d88ad70e582927c9519c0b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab723e4c848c9833c764f59ebc5912300" id="r_ab723e4c848c9833c764f59ebc5912300"><td class="memItemLeft" align="right" valign="top"><a id="ab723e4c848c9833c764f59ebc5912300" name="ab723e4c848c9833c764f59ebc5912300"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>foreach_byte</b> (const <a class="el" href="class_p_h_v_1_1_alloc_context.html">PHV::AllocContext</a> *ctxt, const <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> *use, std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;)&gt; fn, SliceMatch useTblRefs=SliceMatch::DFLT) const</td></tr>
<tr class="separator:ab723e4c848c9833c764f59ebc5912300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9862cfd6292ee875091528c163044a" id="r_a6e9862cfd6292ee875091528c163044a"><td class="memItemLeft" align="right" valign="top"><a id="a6e9862cfd6292ee875091528c163044a" name="a6e9862cfd6292ee875091528c163044a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>foreach_byte</b> (<a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> r, const IR::MAU::Table *ctxt, const <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> *use, std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;)&gt; fn, SliceMatch useTblRefs=SliceMatch::DFLT) const</td></tr>
<tr class="separator:a6e9862cfd6292ee875091528c163044a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d1afd09e3442906797d5af349508b2" id="r_af4d1afd09e3442906797d5af349508b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4d1afd09e3442906797d5af349508b2">foreach_byte</a> (<a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> r, const <a class="el" href="class_p_h_v_1_1_alloc_context.html">PHV::AllocContext</a> *ctxt, const <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> *use, std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;)&gt; fn, SliceMatch useTblRefs=SliceMatch::DFLT) const</td></tr>
<tr class="separator:af4d1afd09e3442906797d5af349508b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2cde564a21cf02a7110ec7166fc5c4f" id="r_aa2cde564a21cf02a7110ec7166fc5c4f"><td class="memItemLeft" align="right" valign="top"><a id="aa2cde564a21cf02a7110ec7166fc5c4f" name="aa2cde564a21cf02a7110ec7166fc5c4f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>fullyPhvAllocated</b> (AllocState s) const</td></tr>
<tr class="separator:aa2cde564a21cf02a7110ec7166fc5c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100f3923c18d5c3c23e5859d84e09023" id="r_a100f3923c18d5c3c23e5859d84e09023"><td class="memItemLeft" align="right" valign="top"><a id="a100f3923c18d5c3c23e5859d84e09023" name="a100f3923c18d5c3c23e5859d84e09023"></a>
<a class="el" href="class_p4_1_1safe__vector.html">safe_vector</a>&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_alloc</b> ()</td></tr>
<tr class="separator:a100f3923c18d5c3c23e5859d84e09023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05070321f34c626e18accc2b4b18229c" id="r_a05070321f34c626e18accc2b4b18229c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_p4_1_1safe__vector.html">safe_vector</a>&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05070321f34c626e18accc2b4b18229c">get_alloc</a> () const</td></tr>
<tr class="separator:a05070321f34c626e18accc2b4b18229c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5109d5b3aefc31cd3a504f2f0191a273" id="r_a5109d5b3aefc31cd3a504f2f0191a273"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5109d5b3aefc31cd3a504f2f0191a273">get_combined_alloc_bytes</a> (const <a class="el" href="class_p_h_v_1_1_alloc_context.html">PHV::AllocContext</a> *ctxt, const <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> *use, SliceMatch useTblRefs=SliceMatch::DFLT) const</td></tr>
<tr class="separator:a5109d5b3aefc31cd3a504f2f0191a273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab81afbdc01e19643677d9c58a45302a0" id="r_ab81afbdc01e19643677d9c58a45302a0"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab81afbdc01e19643677d9c58a45302a0">get_combined_alloc_slices</a> (<a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> bits, const <a class="el" href="class_p_h_v_1_1_alloc_context.html">PHV::AllocContext</a> *ctxt, const <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> *use) const</td></tr>
<tr class="separator:ab81afbdc01e19643677d9c58a45302a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22fdb432d64a5eeb01046cb948a83fdb" id="r_a22fdb432d64a5eeb01046cb948a83fdb"><td class="memItemLeft" align="right" valign="top"><a id="a22fdb432d64a5eeb01046cb948a83fdb" name="a22fdb432d64a5eeb01046cb948a83fdb"></a>
const <a class="el" href="class_constraints_1_1_alignment_constraint.html">Constraints::AlignmentConstraint</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getAlignmentConstraint</b> () const</td></tr>
<tr class="separator:a22fdb432d64a5eeb01046cb948a83fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae76ca1781374ed9ed2beb4852a0af2c" id="r_aae76ca1781374ed9ed2beb4852a0af2c"><td class="memItemLeft" align="right" valign="top"><a id="aae76ca1781374ed9ed2beb4852a0af2c" name="aae76ca1781374ed9ed2beb4852a0af2c"></a>
const <a class="el" href="class_constraints_1_1_digest_constraint.html">Constraints::DigestConstraint</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getDigestConstraint</b> () const</td></tr>
<tr class="separator:aae76ca1781374ed9ed2beb4852a0af2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35009966d2d1e175873c80c78a6a2f83" id="r_a35009966d2d1e175873c80c78a6a2f83"><td class="memItemLeft" align="right" valign="top"><a id="a35009966d2d1e175873c80c78a6a2f83" name="a35009966d2d1e175873c80c78a6a2f83"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getMaxContainerBytes</b> () const</td></tr>
<tr class="separator:a35009966d2d1e175873c80c78a6a2f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0991cbd6ae8a046412733c506226da9d" id="r_a0991cbd6ae8a046412733c506226da9d"><td class="memItemLeft" align="right" valign="top"><a id="a0991cbd6ae8a046412733c506226da9d" name="a0991cbd6ae8a046412733c506226da9d"></a>
const <a class="el" href="class_constraints_1_1_solitary_constraint.html">Constraints::SolitaryConstraint</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getSolitaryConstraint</b> () const</td></tr>
<tr class="separator:a0991cbd6ae8a046412733c506226da9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4ca9afe978f5cb14e7860b6f87acfc" id="r_a4c4ca9afe978f5cb14e7860b6f87acfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p4_1_1bitvec.html">bitvec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c4ca9afe978f5cb14e7860b6f87acfc">getStartBits</a> (<a class="el" href="namespace_p_h_v.html#a3ff115c4ef9dcfb7a3565ddc263f0ece">PHV::Size</a> <a class="el" href="#a10a198e7adff85104913040f88af6081">size</a>) const</td></tr>
<tr class="separator:a4c4ca9afe978f5cb14e7860b6f87acfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e9e56274e757145ddc213465a68b3c" id="r_ad2e9e56274e757145ddc213465a68b3c"><td class="memItemLeft" align="right" valign="top"><a id="ad2e9e56274e757145ddc213465a68b3c" name="ad2e9e56274e757145ddc213465a68b3c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_no_split_at_pos</b> () const</td></tr>
<tr class="separator:ad2e9e56274e757145ddc213465a68b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa5fe7bba632323082f79140b7fd0c1" id="r_abaa5fe7bba632323082f79140b7fd0c1"><td class="memItemLeft" align="right" valign="top"><a id="abaa5fe7bba632323082f79140b7fd0c1" name="abaa5fe7bba632323082f79140b7fd0c1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasAllocation</b> (AllocState s) const</td></tr>
<tr class="memdesc:abaa5fe7bba632323082f79140b7fd0c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether <code>s</code> has a PHV allocation or a CLOT allocation. <br /></td></tr>
<tr class="separator:abaa5fe7bba632323082f79140b7fd0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2293bc71c5537205e674a380c1929ea1" id="r_a2293bc71c5537205e674a380c1929ea1"><td class="memItemLeft" align="right" valign="top"><a id="a2293bc71c5537205e674a380c1929ea1" name="a2293bc71c5537205e674a380c1929ea1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasClotAllocation</b> (AllocState s) const</td></tr>
<tr class="separator:a2293bc71c5537205e674a380c1929ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad456ed5385ab9c7b5e0489da225d5e4b" id="r_ad456ed5385ab9c7b5e0489da225d5e4b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad456ed5385ab9c7b5e0489da225d5e4b">hasExternalName</a> () const</td></tr>
<tr class="separator:ad456ed5385ab9c7b5e0489da225d5e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde837817f1dc0208f6dfb05a8d72d44" id="r_adde837817f1dc0208f6dfb05a8d72d44"><td class="memItemLeft" align="right" valign="top"><a id="adde837817f1dc0208f6dfb05a8d72d44" name="adde837817f1dc0208f6dfb05a8d72d44"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasMaxContainerBytesConstraint</b> () const</td></tr>
<tr class="separator:adde837817f1dc0208f6dfb05a8d72d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7508f3101a56779adcda30c2ae086a" id="r_a1f7508f3101a56779adcda30c2ae086a"><td class="memItemLeft" align="right" valign="top"><a id="a1f7508f3101a56779adcda30c2ae086a" name="a1f7508f3101a56779adcda30c2ae086a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasPhvAllocation</b> (AllocState s) const</td></tr>
<tr class="memdesc:a1f7508f3101a56779adcda30c2ae086a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility functions to get field allocation status. <br /></td></tr>
<tr class="separator:a1f7508f3101a56779adcda30c2ae086a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a6d6b14acb95881dd97317b20d17a1" id="r_aa2a6d6b14acb95881dd97317b20d17a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p4_1_1cstring.html">cstring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2a6d6b14acb95881dd97317b20d17a1">header</a> () const</td></tr>
<tr class="separator:aa2a6d6b14acb95881dd97317b20d17a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd93e383eee3de2c21b5e07813aa6b9" id="r_acfd93e383eee3de2c21b5e07813aa6b9"><td class="memItemLeft" align="right" valign="top"><a id="acfd93e383eee3de2c21b5e07813aa6b9" name="acfd93e383eee3de2c21b5e07813aa6b9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_avoid_alloc</b> () const</td></tr>
<tr class="separator:acfd93e383eee3de2c21b5e07813aa6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade69f0d6a4cbf08525ae2b4d186fe575" id="r_ade69f0d6a4cbf08525ae2b4d186fe575"><td class="memItemLeft" align="right" valign="top"><a id="ade69f0d6a4cbf08525ae2b4d186fe575" name="ade69f0d6a4cbf08525ae2b4d186fe575"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_checksummed</b> () const</td></tr>
<tr class="separator:ade69f0d6a4cbf08525ae2b4d186fe575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de31832f6229a32b0d3451ec987888b" id="r_a1de31832f6229a32b0d3451ec987888b"><td class="memItemLeft" align="right" valign="top"><a id="a1de31832f6229a32b0d3451ec987888b" name="a1de31832f6229a32b0d3451ec987888b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_dark_candidate</b> () const</td></tr>
<tr class="separator:a1de31832f6229a32b0d3451ec987888b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32789b31800d9064a9b4739d338a0684" id="r_a32789b31800d9064a9b4739d338a0684"><td class="memItemLeft" align="right" valign="top"><a id="a32789b31800d9064a9b4739d338a0684" name="a32789b31800d9064a9b4739d338a0684"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_deparser_zero_candidate</b> () const</td></tr>
<tr class="separator:a32789b31800d9064a9b4739d338a0684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3414effd7e21dfd8f57134de5cace108" id="r_a3414effd7e21dfd8f57134de5cace108"><td class="memItemLeft" align="right" valign="top"><a id="a3414effd7e21dfd8f57134de5cace108" name="a3414effd7e21dfd8f57134de5cace108"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_digest</b> () const</td></tr>
<tr class="separator:a3414effd7e21dfd8f57134de5cace108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa42fd32fc626411d7a07aa9189c785" id="r_a9fa42fd32fc626411d7a07aa9189c785"><td class="memItemLeft" align="right" valign="top"><a id="a9fa42fd32fc626411d7a07aa9189c785" name="a9fa42fd32fc626411d7a07aa9189c785"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_fixed_size_header</b> () const</td></tr>
<tr class="separator:a9fa42fd32fc626411d7a07aa9189c785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a980ac202069c814a9ad84a7939e1d9" id="r_a6a980ac202069c814a9ad84a7939e1d9"><td class="memItemLeft" align="right" valign="top"><a id="a6a980ac202069c814a9ad84a7939e1d9" name="a6a980ac202069c814a9ad84a7939e1d9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_flexible</b> () const</td></tr>
<tr class="separator:a6a980ac202069c814a9ad84a7939e1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59804dc2a9266aa66faa300a4e9d749a" id="r_a59804dc2a9266aa66faa300a4e9d749a"><td class="memItemLeft" align="right" valign="top"><a id="a59804dc2a9266aa66faa300a4e9d749a" name="a59804dc2a9266aa66faa300a4e9d749a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_ignore_alloc</b> () const</td></tr>
<tr class="separator:a59804dc2a9266aa66faa300a4e9d749a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1df4382325de22e2bd704d036d52155" id="r_aa1df4382325de22e2bd704d036d52155"><td class="memItemLeft" align="right" valign="top"><a id="aa1df4382325de22e2bd704d036d52155" name="aa1df4382325de22e2bd704d036d52155"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_intrinsic</b> () const</td></tr>
<tr class="separator:aa1df4382325de22e2bd704d036d52155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f20f38439ed21ae5618fd5c8da8315" id="r_a92f20f38439ed21ae5618fd5c8da8315"><td class="memItemLeft" align="right" valign="top"><a id="a92f20f38439ed21ae5618fd5c8da8315" name="a92f20f38439ed21ae5618fd5c8da8315"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_invalidate_from_arch</b> () const</td></tr>
<tr class="separator:a92f20f38439ed21ae5618fd5c8da8315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb8debdb2fcea8a073cd5e1fff6f8d3" id="r_a9bb8debdb2fcea8a073cd5e1fff6f8d3"><td class="memItemLeft" align="right" valign="top"><a id="a9bb8debdb2fcea8a073cd5e1fff6f8d3" name="a9bb8debdb2fcea8a073cd5e1fff6f8d3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_marshaled</b> () const</td></tr>
<tr class="separator:a9bb8debdb2fcea8a073cd5e1fff6f8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8e7645b36dea94db0c993760da4870" id="r_a1d8e7645b36dea94db0c993760da4870"><td class="memItemLeft" align="right" valign="top"><a id="a1d8e7645b36dea94db0c993760da4870" name="a1d8e7645b36dea94db0c993760da4870"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_mocha_candidate</b> () const</td></tr>
<tr class="separator:a1d8e7645b36dea94db0c993760da4870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476f63b2953ebb19bfc11ea4ae4c4281" id="r_a476f63b2953ebb19bfc11ea4ae4c4281"><td class="memItemLeft" align="right" valign="top"><a id="a476f63b2953ebb19bfc11ea4ae4c4281" name="a476f63b2953ebb19bfc11ea4ae4c4281"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_overlayable</b> () const</td></tr>
<tr class="separator:a476f63b2953ebb19bfc11ea4ae4c4281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ec39824d9c31a6c63e3876d669ec31" id="r_a24ec39824d9c31a6c63e3876d669ec31"><td class="memItemLeft" align="right" valign="top"><a id="a24ec39824d9c31a6c63e3876d669ec31" name="a24ec39824d9c31a6c63e3876d669ec31"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_padding</b> () const</td></tr>
<tr class="separator:a24ec39824d9c31a6c63e3876d669ec31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9c28af451d98350d127e95fa9fefed" id="r_aee9c28af451d98350d127e95fa9fefed"><td class="memItemLeft" align="right" valign="top"><a id="aee9c28af451d98350d127e95fa9fefed" name="aee9c28af451d98350d127e95fa9fefed"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_solitary</b> () const</td></tr>
<tr class="separator:aee9c28af451d98350d127e95fa9fefed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad1d2ab2a098e6d3c281bbf1615be09" id="r_aaad1d2ab2a098e6d3c281bbf1615be09"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaad1d2ab2a098e6d3c281bbf1615be09">is_tphv_candidate</a> (const <a class="el" href="class_phv_use.html">PhvUse</a> &amp;uses) const</td></tr>
<tr class="separator:aaad1d2ab2a098e6d3c281bbf1615be09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba26e64059e50345fe648aa6d6661de" id="r_acba26e64059e50345fe648aa6d6661de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acba26e64059e50345fe648aa6d6661de">is_unallocated</a> () const</td></tr>
<tr class="separator:acba26e64059e50345fe648aa6d6661de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a456ac026abe222254627d9b55976e" id="r_a83a456ac026abe222254627d9b55976e"><td class="memItemLeft" align="right" valign="top"><a id="a83a456ac026abe222254627d9b55976e" name="a83a456ac026abe222254627d9b55976e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_upcasted</b> () const</td></tr>
<tr class="separator:a83a456ac026abe222254627d9b55976e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16320c02eef51398a1897f3745ce5be1" id="r_a16320c02eef51398a1897f3745ce5be1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16320c02eef51398a1897f3745ce5be1">isCompilerGeneratedPaddingField</a> () const</td></tr>
<tr class="separator:a16320c02eef51398a1897f3745ce5be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93ede68cb6db7baeec0e32680d166b2" id="r_ad93ede68cb6db7baeec0e32680d166b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad93ede68cb6db7baeec0e32680d166b2">isGhostField</a> () const</td></tr>
<tr class="separator:ad93ede68cb6db7baeec0e32680d166b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30be98d708c3b0d88fc582c4da0e81d" id="r_aa30be98d708c3b0d88fc582c4da0e81d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa30be98d708c3b0d88fc582c4da0e81d">isPacketField</a> () const</td></tr>
<tr class="separator:aa30be98d708c3b0d88fc582c4da0e81d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3a09255b7f4fb4e8f1aab191b8d88c" id="r_a9f3a09255b7f4fb4e8f1aab191b8d88c"><td class="memItemLeft" align="right" valign="top"><a id="a9f3a09255b7f4fb4e8f1aab191b8d88c" name="a9f3a09255b7f4fb4e8f1aab191b8d88c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isReferenced</b> (AllocState s) const</td></tr>
<tr class="separator:a9f3a09255b7f4fb4e8f1aab191b8d88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9cce1f926ec5607ceedc7ade903d03c" id="r_af9cce1f926ec5607ceedc7ade903d03c"><td class="memItemLeft" align="right" valign="top"><a id="af9cce1f926ec5607ceedc7ade903d03c" name="af9cce1f926ec5607ceedc7ade903d03c"></a>
const std::optional&lt; <a class="el" href="class_p4_1_1bitvec.html">bitvec</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>limited_container_ids</b> () const</td></tr>
<tr class="separator:af9cce1f926ec5607ceedc7ade903d03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc66934d503168f44fe303f8f7b61164" id="r_acc66934d503168f44fe303f8f7b61164"><td class="memItemLeft" align="right" valign="top"><a id="acc66934d503168f44fe303f8f7b61164" name="acc66934d503168f44fe303f8f7b61164"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>no_holes</b> () const</td></tr>
<tr class="separator:acc66934d503168f44fe303f8f7b61164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369947c6ceb5d1436d9e98cb96254c0c" id="r_a369947c6ceb5d1436d9e98cb96254c0c"><td class="memItemLeft" align="right" valign="top"><a id="a369947c6ceb5d1436d9e98cb96254c0c" name="a369947c6ceb5d1436d9e98cb96254c0c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>no_split</b> () const</td></tr>
<tr class="separator:a369947c6ceb5d1436d9e98cb96254c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac613a0c7e8e70bdc35dc71b329ac1bab" id="r_ac613a0c7e8e70bdc35dc71b329ac1bab"><td class="memItemLeft" align="right" valign="top"><a id="ac613a0c7e8e70bdc35dc71b329ac1bab" name="ac613a0c7e8e70bdc35dc71b329ac1bab"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>no_split_at</b> (int pos) const</td></tr>
<tr class="separator:ac613a0c7e8e70bdc35dc71b329ac1bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4cec3fbd123b35ccdc1192cf8bc3d1" id="r_a4c4cec3fbd123b35ccdc1192cf8bc3d1"><td class="memItemLeft" align="right" valign="top"><a id="a4c4cec3fbd123b35ccdc1192cf8bc3d1" name="a4c4cec3fbd123b35ccdc1192cf8bc3d1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>no_split_container_size</b> () const</td></tr>
<tr class="separator:a4c4cec3fbd123b35ccdc1192cf8bc3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef758dcc55875b983026b0c9ac00b4c" id="r_a7ef758dcc55875b983026b0c9ac00b4c"><td class="memItemLeft" align="right" valign="top"><a id="a7ef758dcc55875b983026b0c9ac00b4c" name="a7ef758dcc55875b983026b0c9ac00b4c"></a>
std::vector&lt; <a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>no_split_ranges</b> () const</td></tr>
<tr class="separator:a7ef758dcc55875b983026b0c9ac00b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b5064af7a5838d23e20302404a984f" id="r_aa8b5064af7a5838d23e20302404a984f"><td class="memItemLeft" align="right" valign="top"><a id="aa8b5064af7a5838d23e20302404a984f" name="aa8b5064af7a5838d23e20302404a984f"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>num_pack_conflicts</b> () const</td></tr>
<tr class="separator:aa8b5064af7a5838d23e20302404a984f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44a7ec07d7afa6927bed54018d38a70b" id="r_a44a7ec07d7afa6927bed54018d38a70b"><td class="memItemLeft" align="right" valign="top"><a id="a44a7ec07d7afa6927bed54018d38a70b" name="a44a7ec07d7afa6927bed54018d38a70b"></a>
<a class="el" href="class_p4_1_1safe__vector.html">safe_vector</a>&lt; <a class="el" href="struct_p_h_v_1_1_field_operation.html">FieldOperation</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operations</b> ()</td></tr>
<tr class="separator:a44a7ec07d7afa6927bed54018d38a70b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c9f868cb598b6deddadd5088950633c" id="r_a4c9f868cb598b6deddadd5088950633c"><td class="memItemLeft" align="right" valign="top"><a id="a4c9f868cb598b6deddadd5088950633c" name="a4c9f868cb598b6deddadd5088950633c"></a>
const <a class="el" href="class_p4_1_1safe__vector.html">safe_vector</a>&lt; <a class="el" href="struct_p_h_v_1_1_field_operation.html">FieldOperation</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operations</b> () const</td></tr>
<tr class="separator:a4c9f868cb598b6deddadd5088950633c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb2842c76b9bc66e829b74cc5206988" id="r_a5bb2842c76b9bc66e829b74cc5206988"><td class="memItemLeft" align="right" valign="top"><a id="a5bb2842c76b9bc66e829b74cc5206988" name="a5bb2842c76b9bc66e829b74cc5206988"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="class_p_h_v_1_1_field.html">Field</a> &amp;other) const</td></tr>
<tr class="memdesc:a5bb2842c76b9bc66e829b74cc5206988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orders by name. <br /></td></tr>
<tr class="separator:a5bb2842c76b9bc66e829b74cc5206988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c177aec194cf8edaa86de820c59afee" id="r_a9c177aec194cf8edaa86de820c59afee"><td class="memItemLeft" align="right" valign="top"><a id="a9c177aec194cf8edaa86de820c59afee" name="a9c177aec194cf8edaa86de820c59afee"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>parsed</b> () const</td></tr>
<tr class="separator:a9c177aec194cf8edaa86de820c59afee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f9271b0f3614bd30ddd59f7b925966" id="r_a68f9271b0f3614bd30ddd59f7b925966"><td class="memItemLeft" align="right" valign="top"><a id="a68f9271b0f3614bd30ddd59f7b925966" name="a68f9271b0f3614bd30ddd59f7b925966"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>partiallyPhvAllocated</b> (AllocState s) const</td></tr>
<tr class="separator:a68f9271b0f3614bd30ddd59f7b925966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af471fe5ddf96f4c3dd52714facf5426b" id="r_af471fe5ddf96f4c3dd52714facf5426b"><td class="memItemLeft" align="right" valign="top"><a id="af471fe5ddf96f4c3dd52714facf5426b" name="af471fe5ddf96f4c3dd52714facf5426b"></a>
<a class="el" href="namespace_p_h_v.html#a3ff115c4ef9dcfb7a3565ddc263f0ece">PHV::Size</a>&#160;</td><td class="memItemRight" valign="bottom"><b>prefer_container_size</b> () const</td></tr>
<tr class="separator:af471fe5ddf96f4c3dd52714facf5426b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f3fd127b3c3aa5f35d31166fe1c3761" id="r_a2f3fd127b3c3aa5f35d31166fe1c3761"><td class="memItemLeft" align="right" valign="top"><a id="a2f3fd127b3c3aa5f35d31166fe1c3761" name="a2f3fd127b3c3aa5f35d31166fe1c3761"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>same_container_group</b> () const</td></tr>
<tr class="separator:a2f3fd127b3c3aa5f35d31166fe1c3761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41326436d4beb35e040bb4220f991ea0" id="r_a41326436d4beb35e040bb4220f991ea0"><td class="memItemLeft" align="right" valign="top"><a id="a41326436d4beb35e040bb4220f991ea0" name="a41326436d4beb35e040bb4220f991ea0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_alignment</b> (<a class="el" href="class_constraints_1_1_alignment_constraint.html">Constraints::AlignmentConstraint</a> &amp;c)</td></tr>
<tr class="separator:a41326436d4beb35e040bb4220f991ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e855d0ed4f673a764ef9fbcc8992a1" id="r_a57e855d0ed4f673a764ef9fbcc8992a1"><td class="memItemLeft" align="right" valign="top"><a id="a57e855d0ed4f673a764ef9fbcc8992a1" name="a57e855d0ed4f673a764ef9fbcc8992a1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_alignment</b> (unsigned r, unsigned v)</td></tr>
<tr class="separator:a57e855d0ed4f673a764ef9fbcc8992a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707ec20fab2aa314f0873586243fc459" id="r_a707ec20fab2aa314f0873586243fc459"><td class="memItemLeft" align="right" valign="top"><a id="a707ec20fab2aa314f0873586243fc459" name="a707ec20fab2aa314f0873586243fc459"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_alloc</b> (const <a class="el" href="class_p4_1_1safe__vector.html">safe_vector</a>&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;alloc)</td></tr>
<tr class="memdesc:a707ec20fab2aa314f0873586243fc459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all allocated slices of this field. <br /></td></tr>
<tr class="separator:a707ec20fab2aa314f0873586243fc459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c553e63280171c8fecd367dcf89db88" id="r_a8c553e63280171c8fecd367dcf89db88"><td class="memItemLeft" align="right" valign="top"><a id="a8c553e63280171c8fecd367dcf89db88" name="a8c553e63280171c8fecd367dcf89db88"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_avoid_alloc</b> (bool a)</td></tr>
<tr class="separator:a8c553e63280171c8fecd367dcf89db88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e3f9d34d4fb46a6e468499b030dcd4" id="r_a61e3f9d34d4fb46a6e468499b030dcd4"><td class="memItemLeft" align="right" valign="top"><a id="a61e3f9d34d4fb46a6e468499b030dcd4" name="a61e3f9d34d4fb46a6e468499b030dcd4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_dark_candidate</b> (bool c)</td></tr>
<tr class="separator:a61e3f9d34d4fb46a6e468499b030dcd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5859b9600768fc5cc6f3b5902431fe4" id="r_ae5859b9600768fc5cc6f3b5902431fe4"><td class="memItemLeft" align="right" valign="top"><a id="ae5859b9600768fc5cc6f3b5902431fe4" name="ae5859b9600768fc5cc6f3b5902431fe4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_deparsed</b> (bool b)</td></tr>
<tr class="separator:ae5859b9600768fc5cc6f3b5902431fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e689b5053d9e49d8cbe2ddca4d4dd1" id="r_af6e689b5053d9e49d8cbe2ddca4d4dd1"><td class="memItemLeft" align="right" valign="top"><a id="af6e689b5053d9e49d8cbe2ddca4d4dd1" name="af6e689b5053d9e49d8cbe2ddca4d4dd1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_deparsed_bottom_bits</b> (bool b)</td></tr>
<tr class="separator:af6e689b5053d9e49d8cbe2ddca4d4dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd1abdb7d0cd993c270898a583261207" id="r_afd1abdb7d0cd993c270898a583261207"><td class="memItemLeft" align="right" valign="top"><a id="afd1abdb7d0cd993c270898a583261207" name="afd1abdb7d0cd993c270898a583261207"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_deparsed_to_tm</b> (bool b)</td></tr>
<tr class="separator:afd1abdb7d0cd993c270898a583261207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3c2c29d7c36b659ce930dcd0834727" id="r_a8c3c2c29d7c36b659ce930dcd0834727"><td class="memItemLeft" align="right" valign="top"><a id="a8c3c2c29d7c36b659ce930dcd0834727" name="a8c3c2c29d7c36b659ce930dcd0834727"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_deparsed_top_bits</b> (bool b)</td></tr>
<tr class="separator:a8c3c2c29d7c36b659ce930dcd0834727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833229d7c62e46c143e05c1c31cb9716" id="r_a833229d7c62e46c143e05c1c31cb9716"><td class="memItemLeft" align="right" valign="top"><a id="a833229d7c62e46c143e05c1c31cb9716" name="a833229d7c62e46c143e05c1c31cb9716"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_deparser_zero_candidate</b> (bool c)</td></tr>
<tr class="separator:a833229d7c62e46c143e05c1c31cb9716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe6ea14bcddd9f00ba29fc1df343351" id="r_a3fe6ea14bcddd9f00ba29fc1df343351"><td class="memItemLeft" align="right" valign="top"><a id="a3fe6ea14bcddd9f00ba29fc1df343351" name="a3fe6ea14bcddd9f00ba29fc1df343351"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_digest</b> (uint32_t source)</td></tr>
<tr class="separator:a3fe6ea14bcddd9f00ba29fc1df343351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955ae1dcb59a00bcdbf43c3b210fd562" id="r_a955ae1dcb59a00bcdbf43c3b210fd562"><td class="memItemLeft" align="right" valign="top"><a id="a955ae1dcb59a00bcdbf43c3b210fd562" name="a955ae1dcb59a00bcdbf43c3b210fd562"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_emitted</b> (bool b)</td></tr>
<tr class="separator:a955ae1dcb59a00bcdbf43c3b210fd562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0abeabf6fa694b4d7794378e9bd60fa" id="r_ac0abeabf6fa694b4d7794378e9bd60fa"><td class="memItemLeft" align="right" valign="top"><a id="ac0abeabf6fa694b4d7794378e9bd60fa" name="ac0abeabf6fa694b4d7794378e9bd60fa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_exact_containers</b> (bool b)</td></tr>
<tr class="separator:ac0abeabf6fa694b4d7794378e9bd60fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b0705524d311f2baf381961340b2c4" id="r_ad5b0705524d311f2baf381961340b2c4"><td class="memItemLeft" align="right" valign="top"><a id="ad5b0705524d311f2baf381961340b2c4" name="ad5b0705524d311f2baf381961340b2c4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_fixed_size_header</b> (bool f)</td></tr>
<tr class="separator:ad5b0705524d311f2baf381961340b2c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8444f8f1603370d4e04b6f80f44c65b" id="r_ae8444f8f1603370d4e04b6f80f44c65b"><td class="memItemLeft" align="right" valign="top"><a id="ae8444f8f1603370d4e04b6f80f44c65b" name="ae8444f8f1603370d4e04b6f80f44c65b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_flexible</b> (bool b)</td></tr>
<tr class="separator:ae8444f8f1603370d4e04b6f80f44c65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d5f7d05ef9e00b4c09ed9a1919b901" id="r_a79d5f7d05ef9e00b4c09ed9a1919b901"><td class="memItemLeft" align="right" valign="top"><a id="a79d5f7d05ef9e00b4c09ed9a1919b901" name="a79d5f7d05ef9e00b4c09ed9a1919b901"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_ignore_alloc</b> (bool b)</td></tr>
<tr class="separator:a79d5f7d05ef9e00b4c09ed9a1919b901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac47a47afe8c7a7071a6a1d255bb635c" id="r_aac47a47afe8c7a7071a6a1d255bb635c"><td class="memItemLeft" align="right" valign="top"><a id="aac47a47afe8c7a7071a6a1d255bb635c" name="aac47a47afe8c7a7071a6a1d255bb635c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_intrinsic</b> (bool b)</td></tr>
<tr class="separator:aac47a47afe8c7a7071a6a1d255bb635c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbcd766689f4534e698a76bcf832ea94" id="r_adbcd766689f4534e698a76bcf832ea94"><td class="memItemLeft" align="right" valign="top"><a id="adbcd766689f4534e698a76bcf832ea94" name="adbcd766689f4534e698a76bcf832ea94"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_invalidate_from_arch</b> (bool b)</td></tr>
<tr class="separator:adbcd766689f4534e698a76bcf832ea94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8605c32598834da105aef5ed2ac80b" id="r_aea8605c32598834da105aef5ed2ac80b"><td class="memItemLeft" align="right" valign="top"><a id="aea8605c32598834da105aef5ed2ac80b" name="aea8605c32598834da105aef5ed2ac80b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_is_checksummed</b> (bool b)</td></tr>
<tr class="separator:aea8605c32598834da105aef5ed2ac80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259edb0fb9e95db20704cb39ac5baefb" id="r_a259edb0fb9e95db20704cb39ac5baefb"><td class="memItemLeft" align="right" valign="top"><a id="a259edb0fb9e95db20704cb39ac5baefb" name="a259edb0fb9e95db20704cb39ac5baefb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_is_marshaled</b> (bool b)</td></tr>
<tr class="separator:a259edb0fb9e95db20704cb39ac5baefb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab050adac3d71ba78c174b6abe1dcbb88" id="r_ab050adac3d71ba78c174b6abe1dcbb88"><td class="memItemLeft" align="right" valign="top"><a id="ab050adac3d71ba78c174b6abe1dcbb88" name="ab050adac3d71ba78c174b6abe1dcbb88"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_limited_container_ids</b> (const std::optional&lt; <a class="el" href="class_p4_1_1bitvec.html">bitvec</a> &gt; &amp;ids)</td></tr>
<tr class="separator:ab050adac3d71ba78c174b6abe1dcbb88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0f0c52980e06aee67782190386dffd" id="r_a3d0f0c52980e06aee67782190386dffd"><td class="memItemLeft" align="right" valign="top"><a id="a3d0f0c52980e06aee67782190386dffd" name="a3d0f0c52980e06aee67782190386dffd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_mocha_candidate</b> (bool c)</td></tr>
<tr class="separator:a3d0f0c52980e06aee67782190386dffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9afc36f12e0685a6bb3b8331656ac2f" id="r_af9afc36f12e0685a6bb3b8331656ac2f"><td class="memItemLeft" align="right" valign="top"><a id="af9afc36f12e0685a6bb3b8331656ac2f" name="af9afc36f12e0685a6bb3b8331656ac2f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_no_holes</b> (bool b)</td></tr>
<tr class="separator:af9afc36f12e0685a6bb3b8331656ac2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451ae604a4c2bce8b8ca84b8429d3f39" id="r_a451ae604a4c2bce8b8ca84b8429d3f39"><td class="memItemLeft" align="right" valign="top"><a id="a451ae604a4c2bce8b8ca84b8429d3f39" name="a451ae604a4c2bce8b8ca84b8429d3f39"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_no_split</b> (bool b)</td></tr>
<tr class="separator:a451ae604a4c2bce8b8ca84b8429d3f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87fef10f941abb2dce543c018c0e220b" id="r_a87fef10f941abb2dce543c018c0e220b"><td class="memItemLeft" align="right" valign="top"><a id="a87fef10f941abb2dce543c018c0e220b" name="a87fef10f941abb2dce543c018c0e220b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_no_split_at</b> (<a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> range)</td></tr>
<tr class="separator:a87fef10f941abb2dce543c018c0e220b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17eb0f0a570052091d98e47c649cfac6" id="r_a17eb0f0a570052091d98e47c649cfac6"><td class="memItemLeft" align="right" valign="top"><a id="a17eb0f0a570052091d98e47c649cfac6" name="a17eb0f0a570052091d98e47c649cfac6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_no_split_container_size</b> (int <a class="el" href="#a10a198e7adff85104913040f88af6081">size</a>)</td></tr>
<tr class="separator:a17eb0f0a570052091d98e47c649cfac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7a9bee9c8cd03843085d66fb5466f0" id="r_a0b7a9bee9c8cd03843085d66fb5466f0"><td class="memItemLeft" align="right" valign="top"><a id="a0b7a9bee9c8cd03843085d66fb5466f0" name="a0b7a9bee9c8cd03843085d66fb5466f0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_num_pack_conflicts</b> (size_t no)</td></tr>
<tr class="separator:a0b7a9bee9c8cd03843085d66fb5466f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333f57caa991d65a568fa996af6052af" id="r_a333f57caa991d65a568fa996af6052af"><td class="memItemLeft" align="right" valign="top"><a id="a333f57caa991d65a568fa996af6052af" name="a333f57caa991d65a568fa996af6052af"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_overlayable</b> (bool p)</td></tr>
<tr class="separator:a333f57caa991d65a568fa996af6052af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5295b562401c5e09d002bed0a9d900d" id="r_ae5295b562401c5e09d002bed0a9d900d"><td class="memItemLeft" align="right" valign="top"><a id="ae5295b562401c5e09d002bed0a9d900d" name="ae5295b562401c5e09d002bed0a9d900d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_padding</b> (bool p)</td></tr>
<tr class="separator:ae5295b562401c5e09d002bed0a9d900d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a549708e3da389040a7d3380acb196e5c" id="r_a549708e3da389040a7d3380acb196e5c"><td class="memItemLeft" align="right" valign="top"><a id="a549708e3da389040a7d3380acb196e5c" name="a549708e3da389040a7d3380acb196e5c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_parsed</b> (bool b)</td></tr>
<tr class="separator:a549708e3da389040a7d3380acb196e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa58aef4de913db7a31c75ab37d2f0716" id="r_aa58aef4de913db7a31c75ab37d2f0716"><td class="memItemLeft" align="right" valign="top"><a id="aa58aef4de913db7a31c75ab37d2f0716" name="aa58aef4de913db7a31c75ab37d2f0716"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_prefer_container_size</b> (<a class="el" href="namespace_p_h_v.html#a3ff115c4ef9dcfb7a3565ddc263f0ece">PHV::Size</a> cnt_size)</td></tr>
<tr class="separator:aa58aef4de913db7a31c75ab37d2f0716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00d252e492b61cdd108c6a8d8ea4af3" id="r_ae00d252e492b61cdd108c6a8d8ea4af3"><td class="memItemLeft" align="right" valign="top"><a id="ae00d252e492b61cdd108c6a8d8ea4af3" name="ae00d252e492b61cdd108c6a8d8ea4af3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_same_container_group</b> (bool b)</td></tr>
<tr class="separator:ae00d252e492b61cdd108c6a8d8ea4af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e42b790348dd83ec18a26543b491e5" id="r_a03e42b790348dd83ec18a26543b491e5"><td class="memItemLeft" align="right" valign="top"><a id="a03e42b790348dd83ec18a26543b491e5" name="a03e42b790348dd83ec18a26543b491e5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_solitary</b> (uint32_t reason)</td></tr>
<tr class="separator:a03e42b790348dd83ec18a26543b491e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe7e37b88704c115afa98de13de4521" id="r_abbe7e37b88704c115afa98de13de4521"><td class="memItemLeft" align="right" valign="top"><a id="abbe7e37b88704c115afa98de13de4521" name="abbe7e37b88704c115afa98de13de4521"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_upcasted</b> (bool c)</td></tr>
<tr class="separator:abbe7e37b88704c115afa98de13de4521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be62317512899a871fa90a07a6cf087" id="r_a9be62317512899a871fa90a07a6cf087"><td class="memItemLeft" align="right" valign="top"><a id="a9be62317512899a871fa90a07a6cf087" name="a9be62317512899a871fa90a07a6cf087"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_written_in_force_immediate</b> (bool b)</td></tr>
<tr class="separator:a9be62317512899a871fa90a07a6cf087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163eb297d6f56ad9e6212cf6a7ce1845" id="r_a163eb297d6f56ad9e6212cf6a7ce1845"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a163eb297d6f56ad9e6212cf6a7ce1845">setExternalName</a> (<a class="el" href="class_p4_1_1cstring.html">cstring</a> <a class="el" href="#a6dc1459985650d5003fe4638787556c8">name</a>)</td></tr>
<tr class="separator:a163eb297d6f56ad9e6212cf6a7ce1845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5468a845f98f079ae7bef10c4a35c77" id="r_ac5468a845f98f079ae7bef10c4a35c77"><td class="memItemLeft" align="right" valign="top"><a id="ac5468a845f98f079ae7bef10c4a35c77" name="ac5468a845f98f079ae7bef10c4a35c77"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setMaxContainerBytes</b> (int <a class="el" href="#a10a198e7adff85104913040f88af6081">size</a>)</td></tr>
<tr class="separator:ac5468a845f98f079ae7bef10c4a35c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82512864023bb78386efe053ae8f07c2" id="r_a82512864023bb78386efe053ae8f07c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82512864023bb78386efe053ae8f07c2">setStartBits</a> (<a class="el" href="namespace_p_h_v.html#a3ff115c4ef9dcfb7a3565ddc263f0ece">PHV::Size</a> <a class="el" href="#a10a198e7adff85104913040f88af6081">size</a>, <a class="el" href="class_p4_1_1bitvec.html">bitvec</a> startPositions)</td></tr>
<tr class="separator:a82512864023bb78386efe053ae8f07c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d2f455b34713d10ecb41dc5f91b8b0" id="r_ae6d2f455b34713d10ecb41dc5f91b8b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6d2f455b34713d10ecb41dc5f91b8b0">setStartBitsToLowerBitsOfBottomByte</a> ()</td></tr>
<tr class="separator:ae6d2f455b34713d10ecb41dc5f91b8b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9e51f4d992dcdf9d55f7826428ffc5" id="r_a3d9e51f4d992dcdf9d55f7826428ffc5"><td class="memItemLeft" align="right" valign="top"><a id="a3d9e51f4d992dcdf9d55f7826428ffc5" name="a3d9e51f4d992dcdf9d55f7826428ffc5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sort_alloc</b> ()</td></tr>
<tr class="memdesc:a3d9e51f4d992dcdf9d55f7826428ffc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort by field MSB. <br /></td></tr>
<tr class="separator:a3d9e51f4d992dcdf9d55f7826428ffc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7bb5db7971bcbe3b337b76583a5130e" id="r_ae7bb5db7971bcbe3b337b76583a5130e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7bb5db7971bcbe3b337b76583a5130e">updateAlignment</a> (PHV::AlignmentReason, const <a class="el" href="struct_field_alignment.html">FieldAlignment</a> &amp;newAlignment, const <a class="el" href="class_p4_1_1_util_1_1_source_info.html">Util::SourceInfo</a> &amp;newAlignmentSource)</td></tr>
<tr class="separator:ae7bb5db7971bcbe3b337b76583a5130e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a39a8e5fb79e8b4989634dbc2396a21" id="r_a0a39a8e5fb79e8b4989634dbc2396a21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a39a8e5fb79e8b4989634dbc2396a21">updateValidContainerRange</a> (<a class="el" href="namespace_p4.html#a19f5abed1a21ad7a5703944aa5099da7">nw_bitrange</a> newValidRange)</td></tr>
<tr class="separator:a0a39a8e5fb79e8b4989634dbc2396a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a937edfff1d88dad9358a6e58176e5760" id="r_a937edfff1d88dad9358a6e58176e5760"><td class="memItemLeft" align="right" valign="top"><a id="a937edfff1d88dad9358a6e58176e5760" name="a937edfff1d88dad9358a6e58176e5760"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>used_in_wide_arith</b> () const</td></tr>
<tr class="separator:a937edfff1d88dad9358a6e58176e5760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e0e91bc716c5af1c7c0c042478e535" id="r_af1e0e91bc716c5af1c7c0c042478e535"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_p4.html#a19f5abed1a21ad7a5703944aa5099da7">nw_bitrange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1e0e91bc716c5af1c7c0c042478e535">validContainerRange</a> () const</td></tr>
<tr class="separator:af1e0e91bc716c5af1c7c0c042478e535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e8fde333378ea3e772226da070cd38" id="r_a00e8fde333378ea3e772226da070cd38"><td class="memItemLeft" align="right" valign="top"><a id="a00e8fde333378ea3e772226da070cd38" name="a00e8fde333378ea3e772226da070cd38"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>written_in_force_immediate_table</b> () const</td></tr>
<tr class="separator:a00e8fde333378ea3e772226da070cd38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_lift_less"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_class_lift_less')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_lift_less.html">LiftLess&lt; Field &gt;</a></td></tr>
<tr class="memitem:ac9d1be93a9a9238205edbe6d884fa2e9 inherit pub_methods_class_lift_less" id="r_ac9d1be93a9a9238205edbe6d884fa2e9"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR</b> (equal, Equal)</td></tr>
<tr class="separator:ac9d1be93a9a9238205edbe6d884fa2e9 inherit pub_methods_class_lift_less"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a22ca4e6fd2ebe84d954d07160307eb inherit pub_methods_class_lift_less" id="r_a4a22ca4e6fd2ebe84d954d07160307eb"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR</b> (greater, Greater)</td></tr>
<tr class="separator:a4a22ca4e6fd2ebe84d954d07160307eb inherit pub_methods_class_lift_less"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7d21bbd0fc325488393aeb9b8062ff inherit pub_methods_class_lift_less" id="r_a6f7d21bbd0fc325488393aeb9b8062ff"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR</b> (greater_equal, GreaterEqual)</td></tr>
<tr class="separator:a6f7d21bbd0fc325488393aeb9b8062ff inherit pub_methods_class_lift_less"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6504181e2a46fa71670e44f9db60e9 inherit pub_methods_class_lift_less" id="r_a0f6504181e2a46fa71670e44f9db60e9"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR</b> (less, Less)</td></tr>
<tr class="separator:a0f6504181e2a46fa71670e44f9db60e9 inherit pub_methods_class_lift_less"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d058359e7920d2ae77200def30694d4 inherit pub_methods_class_lift_less" id="r_a7d058359e7920d2ae77200def30694d4"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR</b> (less_equal, LessEqual)</td></tr>
<tr class="separator:a7d058359e7920d2ae77200def30694d4 inherit pub_methods_class_lift_less"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7530753bb8a8ba5a58353a1dee0daed inherit pub_methods_class_lift_less" id="r_ac7530753bb8a8ba5a58353a1dee0daed"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR</b> (not_equal, NotEqual)</td></tr>
<tr class="separator:ac7530753bb8a8ba5a58353a1dee0daed inherit pub_methods_class_lift_less"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e3e1a23762704ba9b499994bc05393 inherit pub_methods_class_lift_less" id="r_ab9e3e1a23762704ba9b499994bc05393"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const Field &amp;other) const</td></tr>
<tr class="separator:ab9e3e1a23762704ba9b499994bc05393 inherit pub_methods_class_lift_less"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302351e829dc1c3583ab45bafa63891b inherit pub_methods_class_lift_less" id="r_a302351e829dc1c3583ab45bafa63891b"><td class="memItemLeft" align="right" valign="top">
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const Field &amp;) const=0</td></tr>
<tr class="separator:a302351e829dc1c3583ab45bafa63891b inherit pub_methods_class_lift_less"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb4e5cdc6dacc195fdab82e7d1cb5cd inherit pub_methods_class_lift_less" id="r_a0bb4e5cdc6dacc195fdab82e7d1cb5cd"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;=</b> (const Field &amp;other) const</td></tr>
<tr class="separator:a0bb4e5cdc6dacc195fdab82e7d1cb5cd inherit pub_methods_class_lift_less"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79c61d1f3e398cafb2a69098bb6835b inherit pub_methods_class_lift_less" id="r_ac79c61d1f3e398cafb2a69098bb6835b"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const Field &amp;other) const</td></tr>
<tr class="separator:ac79c61d1f3e398cafb2a69098bb6835b inherit pub_methods_class_lift_less"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f51e2f23e6e5ef8a00af96840dbc20 inherit pub_methods_class_lift_less" id="r_af1f51e2f23e6e5ef8a00af96840dbc20"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;</b> (const Field &amp;other) const</td></tr>
<tr class="separator:af1f51e2f23e6e5ef8a00af96840dbc20 inherit pub_methods_class_lift_less"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5600d14ca6d499ed0931b1d537f3c646 inherit pub_methods_class_lift_less" id="r_a5600d14ca6d499ed0931b1d537f3c646"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;=</b> (const Field &amp;other) const</td></tr>
<tr class="separator:a5600d14ca6d499ed0931b1d537f3c646 inherit pub_methods_class_lift_less"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ab3cc4195b4753cdfd96d7304f634168c" id="r_ab3cc4195b4753cdfd96d7304f634168c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3cc4195b4753cdfd96d7304f634168c">aliasSource</a> = nullptr</td></tr>
<tr class="separator:ab3cc4195b4753cdfd96d7304f634168c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086243ace1d14197dac4311827936006" id="r_a086243ace1d14197dac4311827936006"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="struct_field_alignment.html">FieldAlignment</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a086243ace1d14197dac4311827936006">alignment</a></td></tr>
<tr class="separator:a086243ace1d14197dac4311827936006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af124e1a34342828c2e3614fe57fa5c02" id="r_af124e1a34342828c2e3614fe57fa5c02"><td class="memItemLeft" align="right" valign="top"><a id="af124e1a34342828c2e3614fe57fa5c02" name="af124e1a34342828c2e3614fe57fa5c02"></a>
std::list&lt; std::pair&lt; <a class="el" href="struct_field_alignment.html">FieldAlignment</a>, <a class="el" href="class_p4_1_1_util_1_1_source_info.html">Util::SourceInfo</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>alignmentSources</b></td></tr>
<tr class="memdesc:af124e1a34342828c2e3614fe57fa5c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of alignment sources for this field (mainly for error printing) <br /></td></tr>
<tr class="separator:af124e1a34342828c2e3614fe57fa5c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8621a5edf58e28fde136f3a0e59c187" id="r_aa8621a5edf58e28fde136f3a0e59c187"><td class="memItemLeft" align="right" valign="top"><a id="aa8621a5edf58e28fde136f3a0e59c187" name="aa8621a5edf58e28fde136f3a0e59c187"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>bridged</b> = false</td></tr>
<tr class="memdesc:aa8621a5edf58e28fde136f3a0e59c187"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this Field is metadata bridged from ingress to egress. <br /></td></tr>
<tr class="separator:aa8621a5edf58e28fde136f3a0e59c187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2400d1b9099379cb7a497ac267b507" id="r_afd2400d1b9099379cb7a497ac267b507"><td class="memItemLeft" align="right" valign="top"><a id="afd2400d1b9099379cb7a497ac267b507" name="afd2400d1b9099379cb7a497ac267b507"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>emitted_i</b> = false</td></tr>
<tr class="memdesc:afd2400d1b9099379cb7a497ac267b507"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this field is emitted by the deparser onto the wire. <br /></td></tr>
<tr class="separator:afd2400d1b9099379cb7a497ac267b507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6262d2f5baa4d007b672a90432d91c6" id="r_af6262d2f5baa4d007b672a90432d91c6"><td class="memItemLeft" align="right" valign="top"><a id="af6262d2f5baa4d007b672a90432d91c6" name="af6262d2f5baa4d007b672a90432d91c6"></a>
gress_t&#160;</td><td class="memItemRight" valign="bottom"><b>gress</b> = INGRESS</td></tr>
<tr class="memdesc:af6262d2f5baa4d007b672a90432d91c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the Field is ingress or egress. <br /></td></tr>
<tr class="separator:af6262d2f5baa4d007b672a90432d91c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116fa1a523b6f5d9136355f7d3c46cc8" id="r_a116fa1a523b6f5d9136355f7d3c46cc8"><td class="memItemLeft" align="right" valign="top"><a id="a116fa1a523b6f5d9136355f7d3c46cc8" name="a116fa1a523b6f5d9136355f7d3c46cc8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>id</b> = 0</td></tr>
<tr class="memdesc:a116fa1a523b6f5d9136355f7d3c46cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unique field ID. <br /></td></tr>
<tr class="separator:a116fa1a523b6f5d9136355f7d3c46cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e974d4d0f9ae2d59744ea6058350f9" id="r_a91e974d4d0f9ae2d59744ea6058350f9"><td class="memItemLeft" align="right" valign="top"><a id="a91e974d4d0f9ae2d59744ea6058350f9" name="a91e974d4d0f9ae2d59744ea6058350f9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>intrinsic_i</b> = false</td></tr>
<tr class="memdesc:a91e974d4d0f9ae2d59744ea6058350f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this Field is intrinsic. <br /></td></tr>
<tr class="separator:a91e974d4d0f9ae2d59744ea6058350f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c9d3ef11d7a6187281901a38f54972c" id="r_a4c9d3ef11d7a6187281901a38f54972c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c9d3ef11d7a6187281901a38f54972c">invalidate_from_arch_i</a> = false</td></tr>
<tr class="separator:a4c9d3ef11d7a6187281901a38f54972c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc4b0042d28ceca7add4ea73f9b4a25" id="r_afbc4b0042d28ceca7add4ea73f9b4a25"><td class="memItemLeft" align="right" valign="top"><a id="afbc4b0042d28ceca7add4ea73f9b4a25" name="afbc4b0042d28ceca7add4ea73f9b4a25"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>metadata</b> = false</td></tr>
<tr class="memdesc:afbc4b0042d28ceca7add4ea73f9b4a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this Field is metadata. <br /></td></tr>
<tr class="separator:afbc4b0042d28ceca7add4ea73f9b4a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb209509b8480564f60f5071bb9a82c" id="r_a6eb209509b8480564f60f5071bb9a82c"><td class="memItemLeft" align="right" valign="top"><a id="a6eb209509b8480564f60f5071bb9a82c" name="a6eb209509b8480564f60f5071bb9a82c"></a>
struct <a class="el" href="struct_p_h_v_1_1_field_1_1mirror__field__list__t.html">PHV::Field::mirror_field_list_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mirror_field_list</b> = {nullptr, -1}</td></tr>
<tr class="separator:a6eb209509b8480564f60f5071bb9a82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc1459985650d5003fe4638787556c8" id="r_a6dc1459985650d5003fe4638787556c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p4_1_1cstring.html">cstring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6dc1459985650d5003fe4638787556c8">name</a></td></tr>
<tr class="separator:a6dc1459985650d5003fe4638787556c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb0f973812431ea37b65f7b76797c8b" id="r_a3cb0f973812431ea37b65f7b76797c8b"><td class="memItemLeft" align="right" valign="top"><a id="a3cb0f973812431ea37b65f7b76797c8b" name="a3cb0f973812431ea37b65f7b76797c8b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>offset</b> = 0</td></tr>
<tr class="memdesc:a3cb0f973812431ea37b65f7b76797c8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset of lsb from lsb (last) bit of containing header. <br /></td></tr>
<tr class="separator:a3cb0f973812431ea37b65f7b76797c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a126872581bb3cff5a10369cfe932351c" id="r_a126872581bb3cff5a10369cfe932351c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a126872581bb3cff5a10369cfe932351c">overlayable</a> = false</td></tr>
<tr class="separator:a126872581bb3cff5a10369cfe932351c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f34f8b751c2fb7ce38154ad13971fe3" id="r_a3f34f8b751c2fb7ce38154ad13971fe3"><td class="memItemLeft" align="right" valign="top"><a id="a3f34f8b751c2fb7ce38154ad13971fe3" name="a3f34f8b751c2fb7ce38154ad13971fe3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>padding</b> = false</td></tr>
<tr class="memdesc:a3f34f8b751c2fb7ce38154ad13971fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this Field is a padding field. <br /></td></tr>
<tr class="separator:a3f34f8b751c2fb7ce38154ad13971fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa088557d6ac28ad96694360685396466" id="r_aa088557d6ac28ad96694360685396466"><td class="memItemLeft" align="right" valign="top"><a id="aa088557d6ac28ad96694360685396466" name="aa088557d6ac28ad96694360685396466"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>pov</b> = false</td></tr>
<tr class="memdesc:aa088557d6ac28ad96694360685396466"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this Field is a validity bit. <br /></td></tr>
<tr class="separator:aa088557d6ac28ad96694360685396466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a198e7adff85104913040f88af6081" id="r_a10a198e7adff85104913040f88af6081"><td class="memItemLeft" align="right" valign="top"><a id="a10a198e7adff85104913040f88af6081" name="a10a198e7adff85104913040f88af6081"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> = 0</td></tr>
<tr class="memdesc:a10a198e7adff85104913040f88af6081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total size of Field in bits. <br /></td></tr>
<tr class="separator:a10a198e7adff85104913040f88af6081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8631797d1714eb0b9b2e9e23dba82fd3" id="r_a8631797d1714eb0b9b2e9e23dba82fd3"><td class="memItemLeft" align="right" valign="top"><a id="a8631797d1714eb0b9b2e9e23dba82fd3" name="a8631797d1714eb0b9b2e9e23dba82fd3"></a>
std::optional&lt; <a class="el" href="class_p4_1_1_util_1_1_source_info.html">Util::SourceInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>srcInfo</b></td></tr>
<tr class="memdesc:a8631797d1714eb0b9b2e9e23dba82fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate source info to each field. <br /></td></tr>
<tr class="separator:a8631797d1714eb0b9b2e9e23dba82fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0311021b775df3f9a3c5cc1f458d7eb4" id="r_a0311021b775df3f9a3c5cc1f458d7eb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_p4.html#a19f5abed1a21ad7a5703944aa5099da7">nw_bitrange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0311021b775df3f9a3c5cc1f458d7eb4">validContainerRange_i</a> = <a class="el" href="struct_p4_1_1_bit_range_1_1_zero_to_max.html">ZeroToMax</a>()</td></tr>
<tr class="separator:a0311021b775df3f9a3c5cc1f458d7eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ab84dc20e1b7f9045cb03a401bfc6fcec" id="r_ab84dc20e1b7f9045cb03a401bfc6fcec"><td class="memItemLeft" align="right" valign="top"><a id="ab84dc20e1b7f9045cb03a401bfc6fcec" name="ab84dc20e1b7f9045cb03a401bfc6fcec"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const <a class="el" href="class_p_h_v_1_1_field.html">Field</a> &amp;field)</td></tr>
<tr class="separator:ab84dc20e1b7f9045cb03a401bfc6fcec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a080e2f543188692029705871c9d70803" name="a080e2f543188692029705871c9d70803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a080e2f543188692029705871c9d70803">&#9670;&#160;</a></span>alloc_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t PHV::Field::alloc_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of allocated slices of this field. </dd></dl>

</div>
</div>
<a id="a619905bddda92e02d9bb54565b1a3a87" name="a619905bddda92e02d9bb54565b1a3a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619905bddda92e02d9bb54565b1a3a87">&#9670;&#160;</a></span>byteAlignedRangeInBits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> PHV::Field::byteAlignedRangeInBits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a range of bits in the header that captures the byte aligned offset of this field within its header. </p>

</div>
</div>
<a id="ab80de3f3191e532be5fadb526f5eb744" name="ab80de3f3191e532be5fadb526f5eb744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab80de3f3191e532be5fadb526f5eb744">&#9670;&#160;</a></span>container_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHV::Field::container_bytes </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; <a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>bits</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of distinct container bytes that contain slices of the <code>bits</code> of this field. </dd></dl>

</div>
</div>
<a id="a57ad303d4472f88019892e412296aa63" name="a57ad303d4472f88019892e412296aa63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57ad303d4472f88019892e412296aa63">&#9670;&#160;</a></span>deparsed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PHV::Field::deparsed </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>NB: Fields satisfying the deparsed constraint are not necessarily emitted. To determine whether a field is emitted by the deparser onto the wire, see <em>emitted_i</em>. </p>

</div>
</div>
<a id="a645488aa0046cbf0084c9d3497b2ebc3" name="a645488aa0046cbf0084c9d3497b2ebc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a645488aa0046cbf0084c9d3497b2ebc3">&#9670;&#160;</a></span>externalName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p4_1_1cstring.html">cstring</a> PHV::Field::externalName </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the external name of this field. If PHV::Field::externalName is not std::nullopt, use that; otherwise, use PHV::Field::name. </p>

</div>
</div>
<a id="a07440949e4fae928574c2d0ed26c52ea" name="a07440949e4fae928574c2d0ed26c52ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07440949e4fae928574c2d0ed26c52ea">&#9670;&#160;</a></span>for_bit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp; PHV::Field::for_bit </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>bit</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the PHV::AllocSlice in which field <code>bit</code> is allocated. Fails catastrophically if <code>bit</code> is not allocated or not within the range of this field's size. FIXME &ndash; should take an AllocContext and FieldUse like foreach_byte below? </dd></dl>

</div>
</div>
<a id="a1d1d944fe8d84f67d98ba20261b760a0" name="a1d1d944fe8d84f67d98ba20261b760a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d1d944fe8d84f67d98ba20261b760a0">&#9670;&#160;</a></span>foreach_alloc() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PHV::Field::foreach_alloc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> *</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_alloc_context.html">PHV::AllocContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctxt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> *</td>          <td class="paramname"><span class="paramname"><em>use</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;)&gt;</td>          <td class="paramname"><span class="paramname"><em>fn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SliceMatch</td>          <td class="paramname"><span class="paramname"><em>useTblRefs</em></span><span class="paramdefsep"> = </span><span class="paramdefval">SliceMatch::DFLT</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Equivalent to <code>foreach_alloc(StartLen(0, this-&gt;size), ctxt, use, fn)</code>, or to <code>foreach_alloc(ctxt, fn)</code> when <code>r</code> is null.</p>
<dl class="section see"><dt>See also</dt><dd>foreach_alloc(le_bitrange, const IR::BFN::Unit *,
                   std::function&lt;void(const PHV::AllocSlice&amp;)&gt;). </dd></dl>

</div>
</div>
<a id="aa728164df95cd98f9d943e69a6675a3b" name="aa728164df95cd98f9d943e69a6675a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa728164df95cd98f9d943e69a6675a3b">&#9670;&#160;</a></span>foreach_alloc() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PHV::Field::foreach_alloc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_alloc_context.html">PHV::AllocContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctxt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> *</td>          <td class="paramname"><span class="paramname"><em>use</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;)&gt;</td>          <td class="paramname"><span class="paramname"><em>fn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SliceMatch</td>          <td class="paramname"><span class="paramname"><em>useTblRefs</em></span><span class="paramdefsep"> = </span><span class="paramdefval">SliceMatch::DFLT</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Equivalent to <code>foreach_alloc(StartLen(0, this-&gt;size), ctxt, fn)</code>.</p>
<dl class="section see"><dt>See also</dt><dd>foreach_alloc(le_bitrange, const IR::BFN::Unit *, const PHV::FieldUse&amp;,
                   std::function&lt;void(const PHV::AllocSlice&amp;)&gt;). </dd></dl>

</div>
</div>
<a id="afa850790d78f97f6b7aa3ca8de1d4e44" name="afa850790d78f97f6b7aa3ca8de1d4e44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa850790d78f97f6b7aa3ca8de1d4e44">&#9670;&#160;</a></span>foreach_alloc() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PHV::Field::foreach_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_alloc_context.html">PHV::AllocContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctxt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> *</td>          <td class="paramname"><span class="paramname"><em>use</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;)&gt;</td>          <td class="paramname"><span class="paramname"><em>fn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SliceMatch</td>          <td class="paramname"><span class="paramname"><em>useTblRefs</em></span><span class="paramdefsep"> = </span><span class="paramdefval">SliceMatch::DFLT</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply <code>fn</code> to each PHV::AllocSlice within the specified <code>ctxt</code> to which this has been allocated (if any). <code>ctxt</code> can be one of ParserState, Table, Deparser, or null for no filter. <code>use</code> can be READ or WRITE. For now, the context is the entire pipeline, as PHV allocation is global. </p>

</div>
</div>
<a id="aef007f89d88ad70e582927c9519c0b4d" name="aef007f89d88ad70e582927c9519c0b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef007f89d88ad70e582927c9519c0b4d">&#9670;&#160;</a></span>foreach_byte() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PHV::Field::foreach_byte </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> *</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_alloc_context.html">PHV::AllocContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctxt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> *</td>          <td class="paramname"><span class="paramname"><em>use</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;)&gt;</td>          <td class="paramname"><span class="paramname"><em>fn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SliceMatch</td>          <td class="paramname"><span class="paramname"><em>useTblRefs</em></span><span class="paramdefsep"> = </span><span class="paramdefval">SliceMatch::DFLT</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Equivalent to <code>foreach_byte(*r, fn)</code>, or <code>foreach_byte(StartLen(0, this-&gt;size), fn)</code> when <code>r</code> is null.</p>
<dl class="section see"><dt>See also</dt><dd>foreach_byte(le_bitrange, std::function&lt;void(const PHV::AllocSlice&amp;)&gt;). </dd></dl>

</div>
</div>
<a id="af4d1afd09e3442906797d5af349508b2" name="af4d1afd09e3442906797d5af349508b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d1afd09e3442906797d5af349508b2">&#9670;&#160;</a></span>foreach_byte() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PHV::Field::foreach_byte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_alloc_context.html">PHV::AllocContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctxt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> *</td>          <td class="paramname"><span class="paramname"><em>use</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;)&gt;</td>          <td class="paramname"><span class="paramname"><em>fn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PHV::SliceMatch</td>          <td class="paramname"><span class="paramname"><em>useTblRefs</em></span><span class="paramdefsep"> = </span><span class="paramdefval">SliceMatch::DFLT</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For each byte-aligned container byte of each allocated slice of this field, construct an alloc_slice representing that allocated byte (or fraction thereof) and apply <code>fn</code> to it, BUT ONLY if the container is NOT a TPHV container.</p>
<p>For example, suppose a 16b field (f) is allocated as follows:</p>
<p>C8 [4:0] &lt;— f [15:11] C8 [7:7] &lt;— f [10:10] C16 [9:0] &lt;— f [9:0]</p>
<p>Where C8 is an 8b container and C16 is a 16b container.</p>
<p>Invoking `f-&gt;foreach_byte(1, 14, fn)` should invoke fn on the following alloc_slices (in this order):</p>
<p>C16 [7:1] &lt;— f [7:1] C16 [9:8] &lt;— f [9:8] C8 [7:7] &lt;— f [10:10] C8 [3:0] &lt;— f [14:11] </p>

</div>
</div>
<a id="a05070321f34c626e18accc2b4b18229c" name="a05070321f34c626e18accc2b4b18229c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05070321f34c626e18accc2b4b18229c">&#9670;&#160;</a></span>get_alloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_p4_1_1safe__vector.html">safe_vector</a>&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp; PHV::Field::get_alloc </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the PHV allocation for this field, if any. </dd></dl>

</div>
</div>
<a id="a5109d5b3aefc31cd3a504f2f0191a273" name="a5109d5b3aefc31cd3a504f2f0191a273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5109d5b3aefc31cd3a504f2f0191a273">&#9670;&#160;</a></span>get_combined_alloc_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; PHV::Field::get_combined_alloc_bytes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_alloc_context.html">PHV::AllocContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctxt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> *</td>          <td class="paramname"><span class="paramname"><em>use</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SliceMatch</td>          <td class="paramname"><span class="paramname"><em>useTblRefs</em></span><span class="paramdefsep"> = </span><span class="paramdefval">SliceMatch::DFLT</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a vector of PHV::AllocSlice, such that multiple PHV::AllocSlice within the same byte of the same container are combined into the same new PHV::AllocSlice. This is necessary because input crossbar allocation combines multiple slices of the same field in the same container into a single Use object. </dd></dl>

</div>
</div>
<a id="ab81afbdc01e19643677d9c58a45302a0" name="ab81afbdc01e19643677d9c58a45302a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab81afbdc01e19643677d9c58a45302a0">&#9670;&#160;</a></span>get_combined_alloc_slices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; PHV::Field::get_combined_alloc_slices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a></td>          <td class="paramname"><span class="paramname"><em>bits</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_alloc_context.html">PHV::AllocContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctxt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> *</td>          <td class="paramname"><span class="paramname"><em>use</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a vector of PHV::AllocSlice, such that multiple PHV::AllocSlice within the same container are combined into the same new PHV::AllocSlice, if the ranges of the two PHV::AllocSlice are contiguous. This is necessary because parser validation checks has this invariant. </dd></dl>

</div>
</div>
<a id="a4c4ca9afe978f5cb14e7860b6f87acfc" name="a4c4ca9afe978f5cb14e7860b6f87acfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c4ca9afe978f5cb14e7860b6f87acfc">&#9670;&#160;</a></span>getStartBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p4_1_1bitvec.html">bitvec</a> PHV::Field::getStartBits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_p_h_v.html#a3ff115c4ef9dcfb7a3565ddc263f0ece">PHV::Size</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the bit positions (little Endian) at which the least significant bit of this field may be placed. </dd></dl>

</div>
</div>
<a id="ad456ed5385ab9c7b5e0489da225d5e4b" name="ad456ed5385ab9c7b5e0489da225d5e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad456ed5385ab9c7b5e0489da225d5e4b">&#9670;&#160;</a></span>hasExternalName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PHV::Field::hasExternalName </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if this field as an external name set independently of its name. </dd></dl>

</div>
</div>
<a id="aa2a6d6b14acb95881dd97317b20d17a1" name="aa2a6d6b14acb95881dd97317b20d17a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2a6d6b14acb95881dd97317b20d17a1">&#9670;&#160;</a></span>header()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p4_1_1cstring.html">cstring</a> PHV::Field::header </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the header to which this field belongs. </dd></dl>

</div>
</div>
<a id="aaad1d2ab2a098e6d3c281bbf1615be09" name="aaad1d2ab2a098e6d3c281bbf1615be09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad1d2ab2a098e6d3c281bbf1615be09">&#9670;&#160;</a></span>is_tphv_candidate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PHV::Field::is_tphv_candidate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_phv_use.html">PhvUse</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>uses</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if this field can be placed in TPHV containers. </dd></dl>

</div>
</div>
<a id="acba26e64059e50345fe648aa6d6661de" name="acba26e64059e50345fe648aa6d6661de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba26e64059e50345fe648aa6d6661de">&#9670;&#160;</a></span>is_unallocated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PHV::Field::is_unallocated </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if there are no allocated slices of this field. </dd></dl>

</div>
</div>
<a id="a16320c02eef51398a1897f3745ce5be1" name="a16320c02eef51398a1897f3745ce5be1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16320c02eef51398a1897f3745ce5be1">&#9670;&#160;</a></span>isCompilerGeneratedPaddingField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PHV::Field::isCompilerGeneratedPaddingField </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the field has been generated by the compiler for padding marshalled fields. </dd></dl>

</div>
</div>
<a id="ad93ede68cb6db7baeec0e32680d166b2" name="ad93ede68cb6db7baeec0e32680d166b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad93ede68cb6db7baeec0e32680d166b2">&#9670;&#160;</a></span>isGhostField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PHV::Field::isGhostField </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the Field is a ghost field. TODO: Right now, ghost fields are marked as ingress fields, so we use string comparison for this method. Ideally, we should use the gress member directly and not have a separate ghost field. </dd></dl>

</div>
</div>
<a id="aa30be98d708c3b0d88fc582c4da0e81d" name="aa30be98d708c3b0d88fc582c4da0e81d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa30be98d708c3b0d88fc582c4da0e81d">&#9670;&#160;</a></span>isPacketField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PHV::Field::isPacketField </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if this field is a packet field. </dd></dl>

</div>
</div>
<a id="a163eb297d6f56ad9e6212cf6a7ce1845" name="a163eb297d6f56ad9e6212cf6a7ce1845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a163eb297d6f56ad9e6212cf6a7ce1845">&#9670;&#160;</a></span>setExternalName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PHV::Field::setExternalName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p4_1_1cstring.html">cstring</a></td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the external name of this field, which will be used in place of PHV::Field::name when generating assembly. </p>

</div>
</div>
<a id="a82512864023bb78386efe053ae8f07c2" name="a82512864023bb78386efe053ae8f07c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82512864023bb78386efe053ae8f07c2">&#9670;&#160;</a></span>setStartBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PHV::Field::setStartBits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_p_h_v.html#a3ff115c4ef9dcfb7a3565ddc263f0ece">PHV::Size</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1bitvec.html">bitvec</a></td>          <td class="paramname"><span class="paramname"><em>startPositions</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the valid starting bit positions (little Endian) for this field. For example, setStartBits(PHV::Size::b8, bitvec(0,1)) means that the least significant bit of this field must start at bit 0 in 8b containers. </p>

</div>
</div>
<a id="ae6d2f455b34713d10ecb41dc5f91b8b0" name="ae6d2f455b34713d10ecb41dc5f91b8b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d2f455b34713d10ecb41dc5f91b8b0">&#9670;&#160;</a></span>setStartBitsToLowerBitsOfBottomByte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PHV::Field::setStartBitsToLowerBitsOfBottomByte </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>setStartBitsToLowerBitsOfBottomByte will set the start bit of this field to be limited to the [0..x]-th (little endian) bit of any-sized containers, where x equals to (1) for field.size &lt;= 8-bit, x = 8 - size; (2) for 8 &lt; field.size &lt;= 16, x = 16 - size; (3) for 16 &lt; field.size, x = 7. </p>

</div>
</div>
<a id="ae7bb5db7971bcbe3b337b76583a5130e" name="ae7bb5db7971bcbe3b337b76583a5130e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7bb5db7971bcbe3b337b76583a5130e">&#9670;&#160;</a></span>updateAlignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PHV::Field::updateAlignment </td>
          <td>(</td>
          <td class="paramtype">PHV::AlignmentReason</td>          <td class="paramname"><span class="paramname"><em>reason</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_field_alignment.html">FieldAlignment</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>newAlignment</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1_util_1_1_source_info.html">Util::SourceInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>newAlignmentSource</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the alignment requirement for this field. Reports an error if conflicting requirements render the alignment unsatisfiable. </p>

</div>
</div>
<a id="a0a39a8e5fb79e8b4989634dbc2396a21" name="a0a39a8e5fb79e8b4989634dbc2396a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a39a8e5fb79e8b4989634dbc2396a21">&#9670;&#160;</a></span>updateValidContainerRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PHV::Field::updateValidContainerRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_p4.html#a19f5abed1a21ad7a5703944aa5099da7">nw_bitrange</a></td>          <td class="paramname"><span class="paramname"><em>newValidRange</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the valid range of container positions for this field. Reports an error if conflicting requirements render the constraint unsatisfiable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newValidRange</td><td>A new valid range constraint. This is intersected with any existing valid range constraint to produce a new overall valid container range for this field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1e0e91bc716c5af1c7c0c042478e535" name="af1e0e91bc716c5af1c7c0c042478e535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1e0e91bc716c5af1c7c0c042478e535">&#9670;&#160;</a></span>validContainerRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_p4.html#a19f5abed1a21ad7a5703944aa5099da7">nw_bitrange</a> PHV::Field::validContainerRange </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The range of possible bit positions at which this field can be placed in a container, in network order. For example, suppose we have an 8-bit field with <code>validContainerRange = [0, 11]</code> and a 16-bit container. </p><pre class="fragment"> 0              15  (network order)
</pre><p> | -------------&mdash; | container ^ ^ X Y</p>
<p>The entire field must be placed between X and Y (inclusive).</p>
<p>Note that field--&gt;container assignment is usually in <em>little Endian</em>. From that perspective the picture looks like: </p><pre class="fragment"> 15             0   (little Endian order)
</pre><p> | -------------&mdash; | container ^ ^ X Y</p>
<p>And so the field must be placed in what are considered the "upper" bits of the container.</p>
<p>TODO: This range always starts at 0, which is an invariant that other parts of the compiler rely on. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ab3cc4195b4753cdfd96d7304f634168c" name="ab3cc4195b4753cdfd96d7304f634168c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3cc4195b4753cdfd96d7304f634168c">&#9670;&#160;</a></span>aliasSource</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a>* PHV::Field::aliasSource = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If this field is an alias destination, then maintain a pointer to the alias source. Alias destinations are the canonical representation for alias sources.</p>
<p>For example, if we have </p><div class="fragment"><div class="line">@pa_alias(<span class="stringliteral">&quot;ingress&quot;</span>, <span class="stringliteral">&quot;h.f&quot;</span>, <span class="stringliteral">&quot;h.f1&quot;</span>)</div>
<div class="line">@pa_alias(<span class="stringliteral">&quot;ingress&quot;</span>, <span class="stringliteral">&quot;h.f&quot;</span>, <span class="stringliteral">&quot;h.f2&quot;</span>)</div>
</div><!-- fragment --><p>then h.f (the first field mentioned in each annotation) is an alias destination for h.f1 and h.f2, which are sources (the second field in each annotation). The ReplaceAllAliases pass replaces references to h.f1 with an h.f reference that has h.f1 as its alias source, and similarly for references to h.f2. </p>

</div>
</div>
<a id="a086243ace1d14197dac4311827936006" name="a086243ace1d14197dac4311827936006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a086243ace1d14197dac4311827936006">&#9670;&#160;</a></span>alignment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;<a class="el" href="struct_field_alignment.html">FieldAlignment</a>&gt; PHV::Field::alignment</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The alignment requirement of this field. If std::nullopt, there is no particular alignment requirement. </p>

</div>
</div>
<a id="a4c9d3ef11d7a6187281901a38f54972c" name="a4c9d3ef11d7a6187281901a38f54972c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c9d3ef11d7a6187281901a38f54972c">&#9670;&#160;</a></span>invalidate_from_arch_i</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PHV::Field::invalidate_from_arch_i = false</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>True if this field needs to invalid when reaching the deparser and is not written by the user (on Tofino). </p>

</div>
</div>
<a id="a6dc1459985650d5003fe4638787556c8" name="a6dc1459985650d5003fe4638787556c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dc1459985650d5003fe4638787556c8">&#9670;&#160;</a></span>name</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p4_1_1cstring.html">cstring</a> PHV::Field::name</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Field name, following this scheme:</p><ul>
<li>"gress::header.field"</li>
<li>"gress::header.field[i]" where "i" is a positive integer</li>
<li>"gress::header.$valid" </li>
</ul>

</div>
</div>
<a id="a126872581bb3cff5a10369cfe932351c" name="a126872581bb3cff5a10369cfe932351c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a126872581bb3cff5a10369cfe932351c">&#9670;&#160;</a></span>overlayable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PHV::Field::overlayable = false</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>True if this Field can always be overlayable with other fields. Used for padding fields for bridged metadata. </p>

</div>
</div>
<a id="a0311021b775df3f9a3c5cc1f458d7eb4" name="a0311021b775df3f9a3c5cc1f458d7eb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0311021b775df3f9a3c5cc1f458d7eb4">&#9670;&#160;</a></span>validContainerRange_i</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_p4.html#a19f5abed1a21ad7a5703944aa5099da7">nw_bitrange</a> PHV::Field::validContainerRange_i = <a class="el" href="struct_p4_1_1_bit_range_1_1_zero_to_max.html">ZeroToMax</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>Field::validContainerRange(). </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.12.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_p_h_v.html">PHV</a></li><li class="navelem"><a class="el" href="class_p_h_v_1_1_field.html">Field</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
