<!-- HTML header for doxygen 1.12.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>P4 Compiler Documentation (P4C): Slicing Iterator Made Easy</title>
<link rel="icon" href="p4-fav.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!--  Add link to paragraphs   -->
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
  DoxygenAwesomeParagraphLink.init()
</script>
<!-- Add copy button to code fragments  -->
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
  DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add dark mode toggle -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
  DoxygenAwesomeDarkModeToggle.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="cards.css" rel="stylesheet" type="text/css"/>
<link href="flow.css" rel="stylesheet" type="text/css"/>
<link href="p4c_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="p4-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">P4C
   </div>
   <div id="projectbrief">The P4 Compiler</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md__2home_2runner_2work_2p4c_2p4c_2backends_2tofino_2bf-p4c_2phv_2slicing_2_r_e_a_d_m_e.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Slicing Iterator Made Easy</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="slicing-iterator-made-easy"></a></p>
<p>The slicing iterator takes a super cluster and some other constraints, like <code>packingConflict</code>, <code>pa_container_size</code>, then returns all possible valid slicings of the input cluster. A slicing is valid if all super clusters in the result can be allocated to a container group. The iterator also accepts feedback from the allocation algorithm through the <code>invalidate(const SuperCluster::SliceList* sl)</code> interface, which tells the iterator to not generate results that contain the input slice list.</p>
<p>All files related to slicing are under <code>phv/slicing</code> directory, the general structure is</p><ul>
<li><code>types.h</code> - basic type definitions for slicing.</li>
<li><code>phv_slicing_split.h</code> - static functions that can split a SuperCluster according to a schema. These are inherited from the previous implementation, and should be refactored later.</li>
<li><code>phv_slicing_iterator.h</code> - <code>PImpl</code> class for slicing iterator, to isolate the implementation and allows us to write white-box tests on the actual implementation.</li>
<li><code>phv_slicing_dfs_iterator.h</code> - implementation of a DFS-based slicing algorithm.</li>
</ul>
<p>This document explains the DFS-based algorithm, as follows. We start with the basic constraint-free algorithm, and incrementally enhance it by adding constraints. At each stage, we demonstrate how the algorithm handles the additional constraint. We assume no knowledge about Tofino. The discussion will be based on an informal mathematical model, extracted from the hardware details. All unrelated details of hardware are elided.</p>
<h1><a class="anchor" id="the-basic-slicing-problem"></a>
The basic slicing problem</h1>
<p>Let's start with a few definitions:</p><ul>
<li>A <em>field</em> is a sequence of bits with a name.</li>
<li>A <em>field slice</em> is a bitrange of a field. For example, <code>f1&lt;32&gt;[0:7]</code> represents the first 8 bits of <code>f1</code>. For slices that encompass an entire field, we use the field as shorthand. For example, <code>f1&lt;32&gt;</code> is short for <code>f1&lt;32&gt;[0:31]</code>.</li>
<li>A <em>header</em> is a list of field slices. This is sometimes referred to as a <em>slice list</em>. The basic problem is to splin N unrelated headers into smaller headers, such that that the size of each is 8, 16, or 32 bits.</li>
</ul>
<p>For example, suppose we have four headers A,B,C,D, with this layout: </p><div class="fragment"><div class="line">Headers:</div>
<div class="line">A: [a1&lt;12&gt;, a2&lt;12&gt;, a3&lt;8&gt;]</div>
<div class="line">B: [b1&lt;128&gt;, b2&lt;128&gt;[0:11], b2&lt;128&gt;[12:127]]</div>
<div class="line">C: [c1&lt;1&gt;, c2&lt;2&gt;, c3&lt;5&gt;, c4&lt;8&gt;]</div>
<div class="line">D: [d1&lt;32&gt;, d2&lt;16&gt;[0:7], d2&lt;16&gt;[8:15], d3&lt;8&gt;]</div>
</div><!-- fragment --><p> A valid slicing can be </p><div class="fragment"><div class="line">slicing: {</div>
<div class="line">    [a1&lt;12&gt;, a2&lt;12&gt;, a3&lt;8&gt;]</div>
<div class="line">    [b1&lt;128&gt;[0:31]],</div>
<div class="line">    [b1&lt;128&gt;[32:63]],</div>
<div class="line">    [b1&lt;128&gt;[64:95]],</div>
<div class="line">    [b1&lt;128&gt;[96:127]],</div>
<div class="line">    [b2&lt;128&gt;[0:11], b2[12:31]]</div>
<div class="line">    [b2&lt;128&gt;[32:63]],</div>
<div class="line">    [b2&lt;128&gt;[64:95]],</div>
<div class="line">    [b2&lt;128&gt;[96:127]],</div>
<div class="line">    [c1&lt;1&gt;, c2&lt;2&gt;, c3&lt;5&gt;, c4&lt;8&gt;],</div>
<div class="line">    [d1&lt;32&gt;],</div>
<div class="line">    [d2&lt;16&gt;[0:7], d2&lt;16&gt;[8:15]],</div>
<div class="line">    [d3&lt;8&gt;],</div>
<div class="line">}</div>
</div><!-- fragment --><p>The above problem can be solved by a simple DFS algorithm. The algorithm maintains two pieces of state: a header list that contains headers to be split, and a result list of headers that has been split. The algorithm is as follows:</p>
<ol type="1">
<li>If the header list is empty, return the result list as a solution.</li>
<li>Pick a header that has not yet been split. Remove it from the header list.</li>
<li>For N in {8, 16, 32}:<ol type="a">
<li>Split out the first N bits of the header. We call the first N bits the <em>head</em>, and the remaining part the <em>tail</em>.</li>
<li>Add the <em>head</em> to result list and the <em>tail</em> to header list, and recurse.</li>
<li>Restore the state by removing <em>head</em> from result and <em>tail</em> from header.</li>
</ol>
</li>
</ol>
<p>Pseudo codes of the DFS: </p><div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="comment">// global states</span></div>
<div class="line">Headers = [A, B, C, D];</div>
<div class="line">Result = []</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> dfs() {</div>
<div class="line">    <span class="keywordflow">if</span> (Headers.empty()) {</div>
<div class="line">        print(<span class="stringliteral">&quot;solution: &quot;</span>, Result); <span class="comment">// we found a solution</span></div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">auto</span> target_header = Headers.front();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">int</span> split_choice : {8, 16, 32}) {</div>
<div class="line">        <span class="comment">// head will be the first split_choice bits of the target_header</span></div>
<div class="line">        (head, tail, ok) = split_first_n_bits(target_header, split_choice)</div>
<div class="line">        <span class="keywordflow">if</span> (!ok) <span class="keywordflow">continue</span>;</div>
<div class="line">        <span class="keywordflow">if</span> (tail) Headers.append(tail)</div>
<div class="line">        Headers.remove(target_header)</div>
<div class="line">        Result.push_back(head)</div>
<div class="line">        dfs()  <span class="comment">// recurse</span></div>
<div class="line">        Result.pop_back()</div>
<div class="line">        Headers.add(target_header)</div>
<div class="line">        if (tail) Headers.remove(tail)</div>
<div class="line">    }</div>
<div class="line">    return;</div>
<div class="line">}</div>
</div><!-- fragment --><p>If the input <code>Headers</code> is <code>[A, C]</code>, then we expect to see: </p><div class="fragment"><div class="line">solution: {</div>
<div class="line">   [a1&lt;12&gt;[0:7]], [a1&lt;12&gt;[8:11], a2&lt;12&gt;[0:3]], [a2&lt;4:11&gt;], [a3&lt;8&gt;],</div>
<div class="line">   [c1&lt;1&gt;, c2&lt;2&gt;, c3&lt;5&gt;], [c4&lt;8&gt;]</div>
<div class="line">}</div>
<div class="line">solution: {</div>
<div class="line">   [a1&lt;12&gt;[0:7]], [a1&lt;12&gt;[8:11], a2&lt;12&gt;[0:3]], [a2&lt;4:11&gt;], [a3&lt;8&gt;],</div>
<div class="line">   [c1&lt;1&gt;, c2&lt;2&gt;, c3&lt;5&gt;, c4&lt;8&gt;]</div>
<div class="line">}</div>
<div class="line">solution: {</div>
<div class="line">   [a1&lt;12&gt;[0:7]], [a1&lt;12&gt;[8:11], a2&lt;12&gt;[0:3]], [a2&lt;4:11&gt;, a3&lt;8&gt;],</div>
<div class="line">   [c1&lt;1&gt;, c2&lt;2&gt;, c3&lt;5&gt;], [c4&lt;8&gt;]</div>
<div class="line">}</div>
<div class="line">solution: {</div>
<div class="line">   [a1&lt;12&gt;[0:7]], [a1&lt;12&gt;[8:11], a2&lt;12&gt;[0:3]], [a2&lt;4:11&gt;, a3&lt;8&gt;],</div>
<div class="line">   [c1&lt;1&gt;, c2&lt;2&gt;, c3&lt;5&gt;, c4&lt;8&gt;]</div>
<div class="line">}</div>
<div class="line">solution: {</div>
<div class="line">   [a1&lt;12&gt;, a2&lt;12&gt;[0:3]], [a2&lt;4:11&gt;], [a3&lt;8&gt;],</div>
<div class="line">   [c1&lt;1&gt;, c2&lt;2&gt;, c3&lt;5&gt;], [c4&lt;8&gt;]</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">...</div>
</div><!-- fragment --><p>The time complexity for finding all solutions is ~O(2^(M/8)), where M is the total bit sizes of all N headers. Note that there are no constraints on any fields: because those headers are unrelated, all possible slicings are valid. So, the time complexity of finding the first solution is O(M).</p>
<h1><a class="anchor" id="enhancement-1-rotational-constraint-on-field-slices"></a>
Enhancement 1: Rotational constraint on field slices</h1>
<p>Let's add a new constraint to field slices. Define a rotational cluster as a set of field slices that all must be allocated to same-sized containers. That is, in the slicing result, the slices must reside in lists that have the same bit-length. We also require that the field slices in each rotational cluster be split at the same bit.</p>
<p>For example, here is a header list with rotational constraints: </p><div class="fragment"><div class="line">Headers:</div>
<div class="line">A: [a1&lt;12&gt;, a2&lt;12&gt;, a3&lt;8&gt;]</div>
<div class="line">B: [b1&lt;128&gt;, b2&lt;128&gt;[0:11], b2&lt;128&gt;[12:127]]</div>
<div class="line">C: [c1&lt;1&gt;, c2&lt;2&gt;, c3&lt;5&gt;, c4&lt;8&gt;]</div>
<div class="line">D: [d1&lt;32&gt;, d2&lt;16&gt;[0:7], d2&lt;16&gt;[8:15], d3&lt;8&gt;]</div>
<div class="line"> </div>
<div class="line">Rotational Cluster Constraints:</div>
<div class="line">{ a3&lt;8&gt;, d2&lt;16&gt;[8:15], c4&lt;8&gt;   }</div>
<div class="line">{ a1&lt;12&gt;, b2&lt;128&gt;[0:11] }</div>
</div><!-- fragment --><p>The rotational cluster <code>{ a1&lt;12&gt;, b2&lt;128&gt;[0:11] }</code> means that if we split <code>a1</code> at the 8th bit, then we must also split <code>b2&lt;128&gt;[0:11]</code> at the 8th bit. Making this split would result in two additional rotational-cluster constraints: </p><div class="fragment"><div class="line">{ a1&lt;12&gt;[0:7], b2&lt;128&gt;[0:7]   }</div>
<div class="line">{ a1&lt;12&gt;[8:11], b2&lt;128&gt;[8:11] }</div>
</div><!-- fragment --><p>This constraint transitively links different headers into a set that is called a <em>super cluster</em>. Because of this constraint, some slicings are no longer valid. For example, the 3rd solution </p><div class="fragment"><div class="line">solution: {</div>
<div class="line">   [a1&lt;12&gt;[0:7]],</div>
<div class="line">   [a1&lt;12&gt;[8:11], a2&lt;12&gt;[0:3]],</div>
<div class="line">   [a2&lt;4:11&gt;, a3&lt;8&gt;],</div>
<div class="line">   [c1&lt;1&gt;, c2&lt;2&gt;, c3&lt;5&gt;],</div>
<div class="line">   [c4&lt;8&gt;]</div>
<div class="line">}</div>
</div><!-- fragment --><p> is now invalid because <code>c4</code> ends up in a 8-bit list while <code>a3</code> is in a 16-bit list.</p>
<p>We refine the previous algorithm with some pruning strategies to speed up the search. These pruning strategies are early validations for detecting whether the current search state is doomed to produce an invalid result.</p>
<h2><a class="anchor" id="after-split-constraint"></a>
After-split constraint</h2>
<p>Let's introduce the <em>after-split constraint</em>. An after-split constraint of a field slice represents a requirement on the bit-size of the list containing the field slice in the output. We can deduce after-split constraints for field slices in the result list, as they won't be split again. For example, suppose the current state is </p><div class="fragment"><div class="line">Header List: [</div>
<div class="line">    [c1&lt;1&gt;, c2&lt;2&gt;, c3&lt;5&gt;, c4&lt;8&gt;]</div>
<div class="line">]</div>
<div class="line">Result List: [</div>
<div class="line">    [a1&lt;12&gt;, a2&lt;12&gt;, a3&lt;8&gt;]</div>
<div class="line">]</div>
</div><!-- fragment --><p> then <code>a1</code>, <code>a2</code>, and <code>a3</code> will be in a 32-bit list for any sub-states derived. The implementation prints out after-split constraints with LOG5: </p><div class="fragment"><div class="line">a1 must =32,</div>
<div class="line">a2 must =32,</div>
<div class="line">a3 must =32,</div>
</div><!-- fragment --><p> (if we re-define after-split constraints so that they are propagated through rotational clusters, then the second and third pruning strategies are redundant with the first.)</p>
<h2><a class="anchor" id="pruning-strategy-conflicting-after-split-constraints"></a>
Pruning strategy: Conflicting after-split constraints</h2>
<p>If there are field slices in the same rotational cluster with incompatible after-split constraints, then the current search state can be pruned.</p>
<p>Let's use the example from the above: </p><div class="fragment"><div class="line">Headers:</div>
<div class="line">A: [a1&lt;12&gt;, a2&lt;12&gt;, a3&lt;8&gt;]</div>
<div class="line">B: [b1&lt;128&gt;, b2&lt;128&gt;[0:11], b2&lt;128&gt;[12:127]]</div>
<div class="line">C: [c1&lt;1&gt;, c2&lt;2&gt;, c3&lt;5&gt;, c4&lt;8&gt;]</div>
<div class="line">D: [d1&lt;32&gt;, d2&lt;16&gt;[0:7], d2&lt;16&gt;[8:15], d3&lt;8&gt;]</div>
<div class="line"> </div>
<div class="line">Rotational Cluster Constraints:</div>
<div class="line">{ a3&lt;8&gt;, d2&lt;16&gt;[8:15], c4&lt;8&gt;   }</div>
<div class="line">{ a1&lt;12&gt;, b2&lt;128&gt;[0:11] }</div>
</div><!-- fragment --><p>If the current state is </p><div class="fragment"><div class="line">Header List: [</div>
<div class="line">    [b1&lt;128&gt;, b2&lt;128&gt;[0:11], b2&lt;128&gt;[12:127]]</div>
<div class="line">    [d1&lt;32&gt;, d2&lt;16&gt;[0:7], d2&lt;16&gt;[8:15], d3&lt;8&gt;]</div>
<div class="line">]</div>
<div class="line">Result List: [</div>
<div class="line">   [a1&lt;12&gt;[0:7]],</div>
<div class="line">   [a1&lt;12&gt;[8:11], a2&lt;12&gt;[0:3]],</div>
<div class="line">   [a2&lt;4:11&gt;, a3&lt;8&gt;],</div>
<div class="line">   [c1&lt;1&gt;, c2&lt;2&gt;, c3&lt;5&gt;],</div>
<div class="line">   [c4&lt;8&gt;]</div>
<div class="line">]</div>
</div><!-- fragment --><p> then we know there is a conflict on <code>a3</code> and <code>c4</code> because they are in the same super cluster, but their after-split constraints are incompatible: <code>a3</code> is in a 16-bit list, while <code>c4</code> is in an 8-bit list. </p><div class="fragment"><div class="line">a1[0:7]  must =8</div>
<div class="line">a1[8:11] must =8</div>
<div class="line">a2[0:3]  must =8</div>
<div class="line">a2[4:11] must =16</div>
<div class="line">a3       must =16 !conflicts</div>
<div class="line">c1       must =8</div>
<div class="line">c2       must =8</div>
<div class="line">c3       must =8</div>
<div class="line">c4       must =8  !conflicts</div>
<div class="line"> </div>
<div class="line">// pasted from above</div>
<div class="line">Rotational Cluster Constraints:</div>
<div class="line">{ a3&lt;8&gt;, d2&lt;16&gt;[8:15], c4&lt;8&gt;   }</div>
</div><!-- fragment --><p> At this point, we should backtrack instead of further splitting header B or D in the header list. By pruning the search here, we eliminate <em>2^37</em> invalid results!</p>
<p>The time complexity for this strategy is O(N), where N is the number of field slices. It can eliminate O(2^(K/8)) invalid solutions, where K is the number of bits remaining in the header list. Note that this strategy will prune more invalid states if K is larger. We will talk about this in [Optimization: Search order].</p>
<h2><a class="anchor" id="pruning-strategy-slice-list-size-limitation"></a>
Pruning strategy: Slice-list size limitation</h2>
<p>Since headers (i.e., slice lists) only get smaller as the search progresses, we can check the after-split constraints on a field slice against the bit-length of the slice list containing that slice. That is, if an after-split constraint on a field slice <em>f1</em> requires a list larger than the list currently holding slice <em>f2</em>, and <em>f1</em> and <em>f2</em> are in the same rotational cluster, then current state is invalid and can be pruned.</p>
<p>Example: </p><div class="fragment"><div class="line">Header List: [</div>
<div class="line">    [b1&lt;128&gt;, b2&lt;128&gt;[0:11], b2&lt;128&gt;[12:127]]</div>
<div class="line">    [c1&lt;1&gt;, c2&lt;2&gt;, c3&lt;5&gt;, c4&lt;8&gt;]</div>
<div class="line">    [d1&lt;32&gt;, d2&lt;16&gt;[0:7], d2&lt;16&gt;[8:15], d3&lt;8&gt;]</div>
<div class="line">]</div>
<div class="line">Result List: [</div>
<div class="line">    [a1&lt;12&gt;, a2&lt;12&gt;, a3&lt;8&gt;]</div>
<div class="line">]</div>
<div class="line"> </div>
<div class="line">After split constraint:</div>
<div class="line">a3       must =32</div>
<div class="line"> </div>
<div class="line">// pasted from the above</div>
<div class="line">Rotational Cluster Constraints:</div>
<div class="line">{ a3&lt;8&gt;, d2&lt;16&gt;[8:15], c4&lt;8&gt;   }</div>
</div><!-- fragment --><ol type="1">
<li>a3 and c4 are in a rotational cluster.</li>
<li>a3 will be in a 32-bit list.</li>
<li>c4 resides in a 16-bit list, can never be allocated to 32-bit list, backtrack!</li>
</ol>
<p>Time Complexity: O(n), where n equals to the number of field slices.</p>
<h2><a class="anchor" id="pruning-strategy-not-all-constraints-are-satisfiable"></a>
Pruning strategy: Not all constraints are satisfiable</h2>
<p>Consider a header <code>[f1&lt;24&gt;, f2&lt;8&gt;]</code>, and two after-split constraints enforced by other field slices in the same rotational cluster with f1/f2, <code>f1 must =32, f2 must =16</code>, there is no valid solution, because only one after-split constraint can be satisfied. Generally, after we collect after-split constraints for all field slices in a list, we can check whether they can all be satisfied on that header/slicelist.</p>
<p>To check whether all after-split constraints of a slice list can be satisfied, we create a bitmap that has the same size as the list, representing after-split constraints on each bit of the list. Then for each field slice, the algorithm will seek back to the left-most possible starting bit, <em>leftmost</em>, then mark bits in [leftmost, leftmost + after-split-constraint.size] to the after-split constraints by taking an intersection of constraint of the field and the constraint recorded on the bitmap. If the intersection of two constraints on the bit is empty, then it means there exists two constraints that cannot be satisfied together. Please refer to <code>DfsItrContext::dfs_prune_unsat_slicelist_constraints</code> in the implementation for more details.</p>
<p>Example: </p><div class="fragment"><div class="line">Header List: [</div>
<div class="line">   [f1&lt;24&gt;, f2&lt;8&gt;]</div>
<div class="line">]</div>
<div class="line">Result List: [</div>
<div class="line">   ***</div>
<div class="line">]</div>
<div class="line"> </div>
<div class="line">After split constraint:</div>
<div class="line">f1 must =32, f2 must =16</div>
<div class="line"> </div>
<div class="line">constraint bitmap:</div>
<div class="line">0                              31</div>
<div class="line">................................</div>
<div class="line">WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW   &lt;-- f1</div>
<div class="line">................HHHHHHHHHHHHHHHH   &lt;-- f2</div>
<div class="line">                ^</div>
<div class="line">                |</div>
<div class="line">            conflicts!</div>
</div><!-- fragment --><p>The time complexity is O(M), where M is the total number of bits of the input super cluster.</p>
<h1><a class="anchor" id="enhancement-2-super-cluster-slice-list-size-constraint"></a>
Enhancement 2: Super-cluster slice-list size constraint</h1>
<p>Recall that in Enhancement 1, we stated that rotational clusters transitively link headers into a super cluster. We add another constraint: all slicelists in a super cluster must have a same size. We say that a super cluster is well-formed if it satisfies this constraint.</p>
<p>Example: </p><div class="fragment"><div class="line">well-formed:</div>
<div class="line">[f1&lt;8&gt;]</div>
<div class="line">[f3&lt;32&gt;[0:7]]</div>
<div class="line">{f1, f3[0:7]}</div>
<div class="line"> </div>
<div class="line">not well-formed:</div>
<div class="line">[f1&lt;8&gt;, f2&lt;8&gt;]</div>
<div class="line">[f3&lt;32&gt;[0:7], f3[8:31]]</div>
<div class="line">{f1, f3[0:7]}</div>
</div><!-- fragment --><h2><a class="anchor" id="pruning-strategy-malformed-cluster"></a>
Pruning strategy: Malformed cluster</h2>
<p>This strategy is simple. If we find a super cluster whose slice lists are all in the result list, we check whether this cluster is well-formed.</p>
<h2><a class="anchor" id="same-container-group-constraint"></a>
Same container group constraint</h2>
<p>For slices of a field with <code>same_container_group</code> constraint, all those slices will end up in a same supercluster, so they share same aftersplit constraints just slices in a rotation cluster. AfterSplitConstraint of any fieldslice will be propagated to all other slices of the same field.</p>
<h1><a class="anchor" id="enhancement-3-metadata-list"></a>
Enhancement 3: Metadata list</h1>
<p>The above discussion assumes that the size of a slice list must be one of the 8, 16, or 32. In this enhancement, we introduce a new type of list, whose size is not subject to this constraint.</p>
<p>Metadata is a special type of field that has virtual padding at the beginning of the field. The size of the virtual padding can any integer from 0 to 7. On Tofino, this virtual padding corresponds to the alignment constraint, and is called <code>Alignment</code> in the code as well. In this document, we prefer the term "virtual padding". We write <code>fieldname^5&lt;8&gt;</code> to represent a metadata field that is 8-bits long, preceded by 5 bits of virtual padding.</p>
<p>Metadata fields form metadata slice lists, and we cannot mix metadata fields with normal fields to form a list. Metadata can be in a rotational cluster with other normal fields. Define the <em>virtual size</em> of a metadata list to be the combined length of the slicess in the list, plus the size of the virtual padding on the first field slice. The size of a metadata list is not limited to 8, 16, or 32; instead, its virtual size cannot exceed 32 bits.</p>
<p>Example: </p><div class="fragment"><div class="line">[m1^5&lt;8&gt;] ==&gt; ok, virtual size 13 bits long.</div>
<div class="line">[m2^3&lt;30&gt;] ==&gt; bad, virtual 33 bits long.</div>
</div><!-- fragment --><h2><a class="anchor" id="updated-rotational-and-super-cluster-slice-list-size-constraints"></a>
Updated rotational and super-cluster slice-list size constraints</h2>
<p>Metadata field slices in a rotational cluster, are not required to be in same-sized lists. However, if there are normal fields in the rotational cluster, then the virtual size of those metadata lists cannot exceed the size of list normal fields(they are supposed to be equal).</p>
<p>Also, for super-cluster slice-list constraint, the constraint becomes that normal slice lists must have the same size, and metadata list's virtual size cannot be larger than that size.</p>
<p>(Not sure I follow this section. Examples would help.)</p>
<h2><a class="anchor" id="enhanced-after-split-constraint"></a>
Enhanced after-split constraint</h2>
<p>Although it seems that metadata type complicates the problem, we can handle them by simply enhancing our after-split constraint. Previously, an after-split constraint can only specify the 'exact' requirement. We introduce a less restricted form of after-split constraint, which specifies a minimum size of the list that a metadata resides in.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">struct </span>AfterSplitConstraint {</div>
<div class="line">    <span class="keyword">enum class</span> ConstraintType {</div>
<div class="line">        EXACT = 0,  <span class="comment">// must be placed in container of the size.</span></div>
<div class="line">        MIN = 1,    <span class="comment">// must be placed in container at least the size.</span></div>
<div class="line">        NONE = 2,   <span class="comment">// no new constraint.</span></div>
<div class="line">    };</div>
<div class="line">    ConstraintType t;</div>
<div class="line">    <span class="keywordtype">int</span> size;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// returns the intersection of two AfterSplitConstraint.</span></div>
<div class="line">    <span class="comment">// e.g. MIN(8)   ^ EXACT(32) = EXACT(32)</span></div>
<div class="line">    <span class="comment">//      MIN(8)   ^ MIN(16)   = MIN(16)</span></div>
<div class="line">    <span class="comment">//      EXACT(8) ^ EXACT(16) = boost::none</span></div>
<div class="line">    boost::optional&lt;AfterSplitConstraint&gt; intersect(<span class="keyword">const</span> AfterSplitConstraint&amp; other) <span class="keyword">const</span>;</div>
<div class="line">};</div>
</div><!-- fragment --><p>With the enhanced <code>AfterSplitConstraint</code> class, the above pruning strategies still apply.</p>
<h2><a class="anchor" id="pruning-strategy-metadata-list-joining-two-exact-containers-slicelists-with-different-sizes"></a>
Pruning strategy: metadata list joining two exact containers slicelists with different sizes</h2>
<p>When a medatada list joins two exact containers lists of different sizes into one supercluster, we should prune early because the supercluster cannot be well-formed already. For example, </p><div class="fragment"><div class="line">sl_1: [f1&lt;16&gt;, f2&lt;8&gt;, f3&lt;8&gt;[0:1], f3&lt;8&gt;[2:7]], total 32, exact.</div>
<div class="line">sl_2: [f2&#39;&lt;8&gt;, f4&lt;8&gt;[0:3], f4&lt;8&gt;[4:7]], total 16, exact.</div>
<div class="line">sl_3: [md1&lt;2&gt;, pad&lt;2&gt;, md2&lt;4&gt;]</div>
<div class="line">rotational clusters:</div>
<div class="line">{f3[0:1], md1}, {f4&lt;8&gt;[0:3], md2}</div>
</div><!-- fragment --><p> sl3 will join sl1 and sl2 into one super cluster, and we can infer that this cluster is invalid because there are a 32-bit exact list and a 16-bit exact list.</p>
<h1><a class="anchor" id="enhancement-4-pack-conflicts-between-fields"></a>
Enhancement 4: Pack conflicts between fields</h1>
<p>Two fields exhibit a pack conflict when they cannot end up in the same list. This constraint is orthogonal to the above constraints. The algorithm checks all splitted slice lists to ensure that no slice list contains a pair of pack-conflicted fields.</p>
<p>Because we only split at byte boundaries (i.e., we only split out the first 8, 16, or 32 bits from the front of the list), fields that share a byte will inevitably end up in the same list. For these fields, we skip the pack-confict check. Doing so is consistent with the action-PHV constraint check in the PHV-allocation algorithm.</p>
<div class="fragment"><div class="line">pack conflicts:</div>
<div class="line">(f1, f2), (f2, f3), (f3, f4)</div>
<div class="line">ok:</div>
<div class="line">[f1&lt;8&gt;, f4&lt;8&gt;]</div>
<div class="line">[f1&lt;4&gt;, f2&lt;4&gt;] --&gt; sharing a byte</div>
<div class="line">[f1&lt;20&gt;[0:10], f1&lt;20&gt;[11:18], f1[19:19], f2[0:11]] --&gt;sharing a byte.</div>
<div class="line"> </div>
<div class="line">not ok:</div>
<div class="line">[f1&lt;8&gt;, f2&lt;8&gt;]</div>
<div class="line">[f1&lt;4&gt;, f2&lt;4&gt;, f3&lt;8&gt;] --&gt; (f1,f3) and (f2,f3) were not sharing a byte</div>
</div><!-- fragment --><h1><a class="anchor" id="enhancement-5-container-size-pragma"></a>
Enhancement 5: Container-size pragma</h1>
<p>The <code>@pa_container_size</code> pragma specifies the sizes of lists that contain a field after slicing. This pragma is surprisingly powerful in that it supports two modes.</p>
<p>The pragma is used in exact-size mode if the specified container sizes add up to the size of the field (e.g., <code>@pa_container_size(f1&lt;32&gt;, 32)</code> or <code>@pa_container_size(f1&lt;32&gt;, 16, 8, 8)</code>). To handle this constraint, before doing DFS, we do a pre-slicing following the specified schema, that fully splits out those smaller chunks of fields.</p>
<p>For example, </p><div class="fragment"><div class="line">@pa_container_size(b2, 32, 32, 32, 32)</div>
<div class="line">@pa_container_size(d1, 32)</div>
<div class="line">Headers:</div>
<div class="line">A: [a1&lt;12&gt;, a2&lt;12&gt;, a3&lt;8&gt;]</div>
<div class="line">B: [b1&lt;128&gt;, b2&lt;128&gt;[0:11], b2&lt;128&gt;[12:127]]</div>
<div class="line">C: [c1&lt;1&gt;, c2&lt;2&gt;, c3&lt;5&gt;, c4&lt;8&gt;]</div>
<div class="line">D: [d1&lt;32&gt;, d2&lt;16&gt;[0:7], d2&lt;16&gt;[8:15], d3&lt;8&gt;]</div>
</div><!-- fragment --><p> headers will be pre-sliced into </p><div class="fragment"><div class="line">Headers:</div>
<div class="line">   [a1&lt;12&gt;, a2&lt;12&gt;, a3&lt;8&gt;]</div>
<div class="line">   [b1&lt;128&gt;]</div>
<div class="line">   [b2&lt;128&gt;[0:11], b2&lt;128&gt;[12:31]]      *</div>
<div class="line">   [b2&lt;128&gt;[32:63]]                     *</div>
<div class="line">   [b2&lt;128&gt;[64:95]]                     *</div>
<div class="line">   [b2&lt;128&gt;[96:127]]                    *</div>
<div class="line">   [c1&lt;1&gt;, c2&lt;2&gt;, c3&lt;5&gt;, c4&lt;8&gt;]</div>
<div class="line">   [d1&lt;32&gt;]                             *</div>
<div class="line">   [d2&lt;16&gt;[0:7], d2&lt;16&gt;[8:15], d3&lt;8&gt;]</div>
</div><!-- fragment --><p>The pragma also has an up-casting mode, wherein the sum of container sizes is larger than the size of the field (e.g., <code>@pa_container_size(f1&lt;20&gt;, 32)</code> or <code>@pa_container_size(f2&lt;20&gt;, 16, 8)</code>). In this mode, we can only do a limited pre-slicing. For example, with the first example usage, we don't know where to split around <code>f1</code> so that it ends up in a 32-bit list: it can either be 12 bits before <code>f1</code> or 12 bits after <code>f1</code>. The good news is, for <code>f2</code> in the second example, we can know where to split even in up-casting mode. The code implements this by giving the tailing field slice an after-split constraint.</p>
<p>(Not following this last point. An example would help.)</p>
<h1><a class="anchor" id="optimization-search-order"></a>
Optimization: Search order</h1>
<p>A general optimization for a DFS algorithm is to schedule the search order at each step to form a thinner search tree by leveraging pruning strategies. For example, <code>A*</code> sorts its search frontier according to <code>f(n) = h(n) + g(n)</code>. In our slicing DFS algorithm, the decision at each step is to choose N and X, and split out first N bits from list X. For picking the X, similar to <a href="https://en.wikipedia.org/wiki/Knuth%27s_Algorithm_X">Algorithm X</a>, we want to choose the list with most constraints. There is a class called <code>NextSplitTargetMetrics</code> that can sort lists by constraints. For picking the N, the <code>make_choices</code> function will return a sorted list where preferred values of N are at front of the list. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.12.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
