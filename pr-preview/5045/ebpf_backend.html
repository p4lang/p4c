<!-- HTML header for doxygen 1.12.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>P4 Compiler Documentation (P4C): eBPF Backend</title>
<link rel="icon" href="p4-fav.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!--  Add link to paragraphs   -->
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
  DoxygenAwesomeParagraphLink.init()
</script>
<!-- Add copy button to code fragments  -->
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
  DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add dark mode toggle -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
  DoxygenAwesomeDarkModeToggle.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="cards.css" rel="stylesheet" type="text/css"/>
<link href="flow.css" rel="stylesheet" type="text/css"/>
<link href="p4c_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="p4-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">P4C
   </div>
   <div id="projectbrief">The P4 Compiler</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('ebpf_backend.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">eBPF Backend</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul>
  <li class="level1 empty">
    <ul>
      <li class="level2">
        <a href="#target-architectures">Target architectures</a>
      </li>
      <li class="level2">
        <a href="#background">Background</a>
        <ul>
          <li class="level3">
            <a href="#p4">P4</a>
          </li>
          <li class="level3">
            <a href="#ebpf">eBPF</a>
            <ul>
              <li class="level4">
                <a href="#safe-code">Safe code</a>
              </li>
              <li class="level4">
                <a href="#kernel-hooks">Kernel hooks</a>
              </li>
              <li class="level4">
                <a href="#ebpf-tables">eBPF Tables</a>
              </li>
              <li class="level4">
                <a href="#concurrency">Concurrency</a>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li class="level2">
        <a href="#compiling-p4-to-ebpf">Compiling P4 to eBPF</a>
        <ul>
          <li class="level3">
            <a href="#dependencies-2">Dependencies</a>
          </li>
          <li class="level3">
            <a href="#supported-capabilities">Supported capabilities</a>
          </li>
          <li class="level3">
            <a href="#translating-p4-to-c">Translating P4 to C</a>
            <ul>
              <li class="level4">
                <a href="#translating-parsers">Translating parsers</a>
              </li>
              <li class="level4">
                <a href="#translating-match-action-pipelines">Translating match-action pipelines</a>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li class="level2">
        <a href="#autotoc_md0">autotoc_md0</a>
        <ul>
          <li class="level3 empty">
            <ul>
              <li class="level4">
                <a href="#generating-code-from-a-p4-file">Generating code from a .p4 file</a>
              </li>
              <li class="level4">
                <a href="#using-the-generated-code">Using the generated code</a>
                <ul>
                  <li class="level5">
                    <a href="#connecting-the-generated-program-with-the-tc">Connecting the generated program with the TC</a>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#how-to-run-the-generated-ebpf-program">How to run the generated eBPF program</a>
  </li>
  <li class="level1">
    <a href="#how-to-inject-custom-extern-function-to-the-generated-ebpf-program">How to inject custom extern function to the generated eBPF program?</a>
    <ul>
      <li class="level2">
        <a href="#basic-principles">Basic principles</a>
      </li>
      <li class="level2">
        <a href="#definition">Definition</a>
      </li>
      <li class="level2">
        <a href="#compilation">Compilation</a>
      </li>
      <li class="level2">
        <a href="#calling-convention">Calling convention</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#psa-implementation-for-ebpf-backend">PSA implementation for eBPF backend</a>
  </li>
  <li class="level1">
    <a href="#prerequisites">Prerequisites</a>
  </li>
  <li class="level1">
    <a href="#design">Design</a>
    <ul>
      <li class="level2">
        <a href="#tc-based-design-default">TC-based design (default)</a>
      </li>
      <li class="level2">
        <a href="#xdp-based-design">XDP-based design</a>
      </li>
      <li class="level2">
        <a href="#packet-paths">Packet paths</a>
        <ul>
          <li class="level3">
            <a href="#ntk-normal-packet-to-kernel">NTK (Normal Packet To Kernel)</a>
          </li>
          <li class="level3">
            <a href="#nfp-normal-packet-from-port">NFP (Normal Packet From Port)</a>
          </li>
          <li class="level3">
            <a href="#resubmit">RESUBMIT</a>
          </li>
          <li class="level3">
            <a href="#nu-normal-unicast-nm-normal-multicast-ci2e-clone-ingress-to-egress">NU (Normal Unicast), NM (Normal Multicast), CI2E (Clone Ingress to Egress)</a>
          </li>
          <li class="level3">
            <a href="#ce2e-clone-egress-to-egress">CE2E (Clone Egress to Egress)</a>
          </li>
          <li class="level3">
            <a href="#sending-packet-to-cpu">Sending packet to CPU</a>
          </li>
          <li class="level3">
            <a href="#ntp-normal-packet-to-port">NTP (Normal packet to port)</a>
          </li>
          <li class="level3">
            <a href="#recirculate">RECIRCULATE</a>
          </li>
        </ul>
      </li>
      <li class="level2">
        <a href="#metadata">Metadata</a>
      </li>
      <li class="level2">
        <a href="#xdp2tc-mode">XDP2TC mode</a>
      </li>
      <li class="level2">
        <a href="#control-plane-api">Control-plane API</a>
      </li>
      <li class="level2">
        <a href="#p4-match-kinds">P4 match kinds</a>
        <ul>
          <li class="level3">
            <a href="#exact">exact</a>
          </li>
          <li class="level3">
            <a href="#lpm">lpm</a>
          </li>
          <li class="level3">
            <a href="#ternary">ternary</a>
          </li>
        </ul>
      </li>
      <li class="level2">
        <a href="#psa-externs">PSA externs</a>
        <ul>
          <li class="level3">
            <a href="#actionprofile">ActionProfile</a>
          </li>
          <li class="level3">
            <a href="#actionselector">ActionSelector</a>
          </li>
          <li class="level3">
            <a href="#digest">Digest</a>
          </li>
          <li class="level3">
            <a href="#meters">Meters</a>
            <ul>
              <li class="level4">
                <a href="#direct-meter">Direct Meter</a>
              </li>
            </ul>
          </li>
          <li class="level3">
            <a href="#value_set">value_set</a>
          </li>
          <li class="level3">
            <a href="#random">Random</a>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#getting-started-1">Getting started</a>
    <ul>
      <li class="level2">
        <a href="#installation-1">Installation</a>
      </li>
      <li class="level2">
        <a href="#using-psa-ebpf">Using PSA-eBPF</a>
        <ul>
          <li class="level3">
            <a href="#prerequisites-1">Prerequisites</a>
          </li>
          <li class="level3">
            <a href="#compilation-1">Compilation</a>
            <ul>
              <li class="level4">
                <a href="#optional-flags">Optional flags</a>
              </li>
            </ul>
          </li>
          <li class="level3">
            <a href="#nikss-api-and-nikss-ctl">NIKSS API and nikss-ctl</a>
          </li>
        </ul>
      </li>
      <li class="level2">
        <a href="#running-ptf-tests">Running PTF tests</a>
      </li>
      <li class="level2">
        <a href="#troubleshooting">Troubleshooting</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#performance-optimizations">Performance optimizations</a>
    <ul>
      <li class="level2">
        <a href="#table-caching">Table caching</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#todo--limitations">TODO / Limitations</a>
  </li>
  <li class="level1">
    <a href="#roadmap">Roadmap</a>
    <ul>
      <li class="level2">
        <a href="#planned-features">Planned features</a>
      </li>
      <li class="level2">
        <a href="#long-term-goals">Long-term goals</a>
      </li>
      <li class="level2">
        <a href="#support">Support</a>
      </li>
    </ul>
  </li>
</ul>
</div>
<div class="textblock"><p>The back-end accepts only P4_16 code written for the <code>ebpf_model.p4</code> or <code>xdp_model.p4</code> filter models. It generates C code that can be afterwards compiled into <a href="https://en.wikipedia.org/wiki/Berkeley_Packet_Filter">eBPF (extended Berkeley Packet Filters)</a> using clang/llvm or <a href="https://github.com/iovisor/bcc.git">bcc</a>.</p>
<p>An older version of this compiler for compiling P4_14 is available <a href="https://github.com/iovisor/bcc/tree/master/src/cc/frontends/p4">here</a> (historical reference only).</p>
<p>Identifiers starting with ebpf_ are reserved in P4 programs, including for structure field names.</p>
<h2><a class="anchor" id="target-architectures"></a>
Target architectures</h2>
<p>The <code>ebpf_model.p4</code> target is a classifier-only: the program returns a boolean which controls whether the packet is passed or dropped. In P4 terms, this means there is no deparser.</p>
<p>The <code>xdp_model.p4</code> target adds packet editing support, and is meant to replicate the capabilities of the Linux kernel's XDP environment. It can be viewed as an extension of the previous model which adds a deparser.</p>
<h2><a class="anchor" id="background"></a>
Background</h2>
<p>In this section we give a brief overview of P4 and EBPF. A detailed treatment of these topics is outside the scope of this text.</p>
<h3><a class="anchor" id="p4"></a>
P4</h3>
<p><a href="http://p4.org">P4</a> is a domain-specific programming language for specifying the behavior of the dataplanes of network-forwarding elements. The name of the programming language comes from the title of a paper published in the proceedings of SIGCOMM Computer Communications Review in 2014: <a href="http://www.sigcomm.org/ccr/papers/2014/July/0000000.0000004">Programming Protocol-Independent Packet Processors</a></p>
<p>P4 itself is protocol-independent but allows programmers to express a rich set of data plane behaviors and protocols. This back-end only supports the newest version of the P4 programming language, <a href="https://p4.org/specs">P4_16</a>. The core P4 abstractions are:</p>
<ul>
<li>Headers describe the format (the set of fields and their sizes) of each header within a packet.</li>
<li>Parser (finite-state machines) describe the permitted header sequences within received packets.</li>
<li>Tables associate keys to actions. P4 tables generalize traditional forwarding tables; they can be used to implement routing tables, flow lookup tables, access-control lists, etc.</li>
<li>Actions describe how packet header fields and metadata are manipulated.</li>
<li>Match-action units stitch together tables and actions, and perform the following sequence of operations:<ul>
<li>Construct lookup keys from packet fields or computed metadata,</li>
<li>Use the constructed lookup key to index into tables, choosing an action to execute,</li>
<li>Finally, execute the selected action.</li>
</ul>
</li>
<li>Control flow is expressed as an imperative program describing the data-dependent packet processing within a pipeline, including the data-dependent sequence of match-action unit invocations.</li>
</ul>
<p>P4 programs describe the behavior of network-processing dataplanes. A P4 program is designed to operate in concert with a separate <em>control plane</em> program. The control plane is responsible for managing at runtime the contents of the P4 tables. P4 cannot be used to specify control-planes; however, a P4 program implicitly specifies the interface between the data-plane and the control-plane.</p>
<h3><a class="anchor" id="ebpf"></a>
eBPF</h3>
<h4><a class="anchor" id="safe-code"></a>
Safe code</h4>
<p>eBPF is a acronym that stands for Extended Berkeley Packet Filters. In essence eBPF is a low-level programming language (similar to machine code); eBPF programs are traditionally executed by a virtual machine that resides in the Linux kernel. eBPF programs can be inserted and removed from a live kernel using dynamic code instrumentation. The main feature of eBPF programs is their <em>static safety</em>: prior to execution all eBPF programs have to be validated as being safe, and unsafe programs cannot be executed. A safe program provably cannot compromise the machine it is running on:</p>
<ul>
<li>it can only access a restricted memory region (on the local stack)</li>
<li>it can run only for a limited amount of time; during execution it cannot block, sleep or take any locks</li>
<li>it cannot use any kernel resources with the exception of a limited set of kernel services which have been specifically whitelisted, including operations to manipulate tables (described below)</li>
</ul>
<h4><a class="anchor" id="kernel-hooks"></a>
Kernel hooks</h4>
<p>eBPF programs are inserted into the kernel using <em>hooks</em>. There are several types of hooks available:</p>
<ul>
<li>any function entry point in the kernel can act as a hook; attaching an eBPF program to a function <code>foo()</code> will cause the eBPF program to execute every time some kernel thread executes <code>foo()</code>.</li>
<li>eBPF programs can also be attached using the Linux Traffic Control (TC) subsystem, in the network packet processing datapath. Such programs can be used as TC classifiers and actions.</li>
<li>eBPF programs can also be attached to sockets or network interfaces. In this case they can be used for processing packets that flow through the socket/interface.</li>
</ul>
<p>eBPF programs can be used for many purposes; the main use cases are dynamic tracing and monitoring, and packet processing. We are mostly interested in the latter use case in this document.</p>
<h4><a class="anchor" id="ebpf-tables"></a>
eBPF Tables</h4>
<p>The eBPF runtime exposes a bi-directional kernel-userspace data communication channel, called <em>tables</em> (also called maps in some eBPF documents and code samples). eBPF tables are essentially key-value stores, where keys and values are arbitrary fixed-size bitstrings. The key width, value width and table size (maximum number of entries that can be stored) are declared statically, at table creation time.</p>
<p>In user-space tables handles are exposed as file descriptors. Both user- and kernel-space programs can manipulate tables, by inserting, deleting, looking up, modifying, and enumerating entries in a table.</p>
<p>In kernel space the keys and values are exposed as pointers to the raw underlying data stored in the table, whereas in user-space the pointers point to copies of the data.</p>
<h4><a class="anchor" id="concurrency"></a>
Concurrency</h4>
<p>An important aspect to understand related to eBPF is the execution model. An eBPF program is triggered by a kernel hook; multiple instances of the same kernel hook can be running simultaneously on different cores.</p>
<p>Each table however has a single instances across all the cores. A single table may be accessed simultaneously by multiple instances of the same eBPF program running as separate kernel threads on different cores. eBPF tables are native kernel objects, and access to the table contents is protected using the kernel RCU mechanism. This makes access to table entries safe under concurrent execution; for example, the memory associated to a value cannot be accidentally freed while an eBPF program holds a pointer to the respective value. However, accessing tables is prone to data races; since eBPF programs cannot use locks, some of these races often cannot be avoided.</p>
<p>eBPF and the associated tools are also under active development, and new capabilities are added frequently.</p>
<h2><a class="anchor" id="compiling-p4-to-ebpf"></a>
Compiling P4 to eBPF</h2>
<p>From the above description it is apparent that the P4 and eBPF programming languages have different expressive powers. However, there is a significant overlap in their capabilities, in particular, in the domain of network packet processing. The following image illustrates the situation:</p>
<div class="image">
<img src="scope.png" alt=""/>
<div class="caption">
P4 and eBPF overlap in capabilities</div></div>
    <p>We expect that the overlapping region will grow in size as both P4 and eBPF continue to mature.</p>
<p>The current version of the P4 to eBPF compiler translates programs written in the version P4_16 of the programming language to programs written in a restricted subset of C. The subset of C is chosen such that it should be compilable to eBPF using clang and/or <a href="https://github.com/iovisor/bcc">bcc (the BPF Compiler Collection)</a>.</p>
<div class="fragment"><div class="line">         --------------              -------</div>
<div class="line">P4 ---&gt;  | P4-to-eBPF | ---&gt; C ----&gt; | clang/BCC | --&gt; eBPF</div>
<div class="line">         --------------              -------</div>
</div><!-- fragment --><p>The P4 program only describes the packet processing <em>data plane</em>, that runs in the Linux kernel. The <em>control plane</em> must be separately implemented by the user. BCC tools simplify this task considerably, by generating C and/or Python APIs that expose the dataplane/control-plane APIs.</p>
<h3><a class="anchor" id="dependencies-2"></a>
Dependencies</h3>
<p>Our eBPF programs require a Linux kernel with version 4.15 or newer. The eBPF backend relies on <a href="https://github.com/libbpf/libbpf">libbpf</a>, which provides kernel- and distribution-independent header files. libbpf must be available in order to compile the generated eBPF C code into eBPF byte code. To install libbpf, run <code>python3 backends/ebpf/build_libbpf</code> in the p4c folder.</p>
<p>In addition the following packages and programs are required to run the full test suite:</p>
<ul>
<li>Clang 3.3 and llvm 3.7.1 or later are required. (Note: In some versions of Ubuntu Xenial (16.04.4) CMake crashes when checking for llvm. Until the bugfix is committed upstream, workarounds are available in <a href="https://github.com/p4lang/p4c/issues/1376">this issue</a>:</li>
<li>libpcap-dev to parse and generate .pcap files.</li>
<li>libelf-dev to compile C-programs to eBPF byte code.</li>
<li>zlib1g as libelf dependency.</li>
<li>a recent version of iproute2 that supports <code>clsact</code> to load eBPF programs via <code>tc</code> and <code>ip</code>.</li>
<li>net-tools (if not installed already)</li>
</ul>
<p>Additionally, the eBPF compiler test suite has the following python dependencies:</p>
<ul>
<li>The python iproute2 package to create virtual interfaces.</li>
<li>The python ply package to parse .stf testing files.</li>
<li>The python scapy package to read and write pcap files.</li>
</ul>
<p>You can install these using: </p><div class="fragment"><div class="line">$ sudo apt-get install clang llvm libpcap-dev libelf-dev iproute2 net-tools</div>
<div class="line">$ pip3 install --user pyroute2 ply==3.8 scapy==2.4.0</div>
</div><!-- fragment --><h3><a class="anchor" id="supported-capabilities"></a>
Supported capabilities</h3>
<p>The current version of the P4 to eBPF compiler supports a relatively narrow subset of the P4 language, but still powerful enough to write very complex packet filters and simple packet forwarding engines. We expect that the compiler's capabilities will improve gradually.</p>
<p>Here are some limitations imposed on the P4 programs:</p>
<ul>
<li>arbitrary parsers can be compiled, but the BCC compiler will reject parsers that contain cycles</li>
<li>arithmetic on data wider than 32 bits is not supported</li>
<li>eBPF does not offer support for ternary table matches</li>
</ul>
<h3><a class="anchor" id="translating-p4-to-c"></a>
Translating P4 to C</h3>
<p>To simplify the translation, the P4 programmer should refrain using identifiers whose name starts with <code>ebpf_</code>.</p>
<p>The following table provides a brief summary of how each P4 construct is mapped to a corresponding C construct:</p>
<h4><a class="anchor" id="translating-parsers"></a>
Translating parsers</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">P4 Construct   </th><th class="markdownTableHeadNone">C Translation    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>header</code>   </td><td class="markdownTableBodyNone"><code>struct</code> type with an additional <code>valid</code> bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>struct</code>   </td><td class="markdownTableBodyNone"><code>struct</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">parser state   </td><td class="markdownTableBodyNone">code block    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">state transition   </td><td class="markdownTableBodyNone"><code>goto</code> statement    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>extract</code>   </td><td class="markdownTableBodyNone">load/shift/mask data from packet buffer   </td></tr>
</table>
<h4><a class="anchor" id="translating-match-action-pipelines"></a>
Translating match-action pipelines</h4>
<h2><a class="anchor" id="autotoc_md0"></a>
autotoc_md0</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">P4 Construct   </th><th class="markdownTableHeadNone">C Translation    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">table   </td><td class="markdownTableBodyNone">2 eBPF tables: second one used just for the default action    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">table key   </td><td class="markdownTableBodyNone"><code>struct</code> type    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">table <code>actions</code> block   </td><td class="markdownTableBodyNone">tagged <code>union</code> with all possible actions    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>action</code> arguments   </td><td class="markdownTableBodyNone"><code>struct</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">table <code>reads</code>   </td><td class="markdownTableBodyNone">eBPF table access    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>action</code> body   </td><td class="markdownTableBodyNone">code block    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">table <code>apply</code>   </td><td class="markdownTableBodyNone"><code>switch</code> statement    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">counters   </td><td class="markdownTableBodyNone">additional eBPF table   </td></tr>
</table>
<h4><a class="anchor" id="generating-code-from-a-p4-file"></a>
Generating code from a .p4 file</h4>
<p>The C code can be generated using the following command:</p>
<p><code>p4c-ebpf PROGRAM.p4 -o out.c</code></p>
<p>This will generate the C-file and its corresponding header. The architecture (ebpf_model or xdp_model) is auto-detected.</p>
<h4><a class="anchor" id="using-the-generated-code"></a>
Using the generated code</h4>
<p>The resulting file contains the complete data structures, tables, and a C function named <code>ebpf_filter</code> that implements the P4-specified data-plane. This C file can be manipulated using clang or BCC tools; please refer to the BCC project documentation and sample test files of the P4 to eBPF source code for an in-depth understanding.</p>
<p>The general C-file alone will not compile. It depends on headers specific to the generated target. For the default target, this is the <code>kernel_ebpf.h</code> file which can be found in the P4 backend under <code>p4c/backends/ebpf/runtime</code>. The P4 backend also provides a makefile and sample header which allow for quick generation and automatic compilation of the generated file.</p>
<p><code>make -f p4c/backends/ebpf/runtime/kernel.mk BPFOBJ=out.o P4FILE=PROGRAM.p4</code></p>
<p>where -f path is the path to the makefile, BPFOBJ is the output ebpf byte code and P4FILE is the input P4 program. This command sequence will generate an eBPF program, which can be loaded into the kernel using TC.</p>
<h5><a class="anchor" id="connecting-the-generated-program-with-the-tc"></a>
Connecting the generated program with the TC</h5>
<p>The eBPF code that is generated is can be used as a classifier attached to the ingress packet path using the Linux TC subsystem. The same eBPF code should be attached to all interfaces. Note however that all eBPF code instances share a single set of tables, which are used to control the program behavior.</p>
<p><code>tc qdisc add dev IFACE clsact</code></p>
<p>Creates a classifier qdisc on the respective interface. Once created, eBPF programs can be attached to it using the following command:</p>
<p><code>tc filter add dev IFACE egress bpf da obj YOUREBPFCODE section prog verbose</code></p>
<p><code>da</code> implies that tc takes action input directly from the return codes provided by the eBPF program. We currently support <code>TC_ACT_SHOT</code> and <code>TC_ACT_OK</code>. More information avaiable <a href="http://docs.cilium.io/en/latest/bpf/#tc-traffic-control">here</a>.</p>
<h1><a class="anchor" id="how-to-run-the-generated-ebpf-program"></a>
How to run the generated eBPF program</h1>
<p>Once the eBPF program is loaded, various methods exist to manipulate the tables. The easiest and simplest way is to use the <a href="http://docs.cilium.io/en/latest/bpf/#bpftool">bpftool</a> provided by the kernel.</p>
<p>An alternative is to use explicit syscalls (an example can be found in the <a href="https://github.com/torvalds/linux/blob/master/tools/lib/bpf/bpf.c">kernel tools folder</a>.</p>
<p>The P4 compiler automatically provides a set of table initializers, which may also serve as example, in the header of the generated C-file.</p>
<p>The following tests run ebpf programs:</p>
<ul>
<li><code>make check-ebpf</code>: runs the basic ebpf user-space tests</li>
<li><code>make check-ebpf-bcc</code>: runs the user-space tests using bcc to compile ebpf</li>
<li><code>sudo -E make check-ebpf-kernel</code>: runs the kernel-level tests. Requires root privileges to install the ebpf program in the Linux kernel. Note: by default the kernel ebpf tests are disabled; if you want to enable them you can modify the file <code>backends/ebpf/CMakeLists.txt</code> by setting this variable to <code>True</code>: <code>set (SUPPORTS_KERNEL True)</code></li>
</ul>
<h1><a class="anchor" id="how-to-inject-custom-extern-function-to-the-generated-ebpf-program"></a>
How to inject custom extern function to the generated eBPF program?</h1>
<p>The P4 to eBPF compiler comes with the support for custom C extern functions. It means that a developer can write a custom, eBPF-compatible (acceptable by BPF verifier) C function and call it from the P4 program as a normal P4 action. As a result, P4 program can be extended with functionality, which is not supported natively by the P4 language. This feature is briefly described below.</p>
<h2><a class="anchor" id="basic-principles"></a>
Basic principles</h2>
<p>The C extern function can effectively enhance the functionality of P4 program. A programmer should be able to write own function, declare it in the P4 program and invoke from within P4 action or P4 control block.</p>
<p>The C extern can use BPF helpers in order to make syscalls to eBPF subsystem. In particular, the C extern can define and have control over its own set of BPF maps. However, the C extern must not read or write to BPF maps implementing P4 tables and used by the main P4 program.</p>
<p>The C extern could be also allowed to access packet’s payload, but this feature is not implemented in the first version of the C Custom Externs feature.</p>
<h2><a class="anchor" id="definition"></a>
Definition</h2>
<p>The custom C extern function should be explicitly declared in the P4 program making use of that extern. For example:</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="keyword">extern</span> <span class="keywordtype">bool</span> verify_ipv4_checksum(in IPv4_h iphdr);</div>
</div><!-- fragment --><h2><a class="anchor" id="compilation"></a>
Compilation</h2>
<p>The <code>--emit-externs</code> flag must be appended to the <code>p4c-ebpf</code> compiler to instruct it that there are some C extern functions defined in the P4 program and compiler should not warn about them.</p>
<div class="fragment"><div class="line">p4c-ebpf -o OUTPUT.c PROGRAM.p4 --emit-externs</div>
</div><!-- fragment --><p>Furthermore, the C file including definition of the C extern function should be provided to <code>clang</code>:</p>
<div class="fragment"><div class="line">clang -O2 -include C-EXTERN-FILE.c -target bpf -c OUTPUT.c -o OUTPUT.o</div>
</div><!-- fragment --><h2><a class="anchor" id="calling-convention"></a>
Calling convention</h2>
<ul>
<li>Basic types are converted from P4 representation to C representation as follows:<ul>
<li>fields shorter than 64 bits are rounded up to the nearest C unsigned integer (e.g. bit&lt;1&gt; → u8, bit&lt;48&gt; → u64).</li>
<li>fields wider than 64 bits are converted to the array of u8. If the field has custom width (e.g. 123 bits) the last element of the array is also u8 (according to the first rule). For example, IPv6 address is converted from bit&lt;128&gt; to u8[16].</li>
<li><b>Boolean (bool)</b> type is converted to u8.</li>
<li><b>header</b> type is converted to C structure. The rules above are applied to each field of a header. Moreover, each C structure representing <b>header</b> type contains additional valid bit field, implemented as u8.</li>
<li><b>struct</b> type is converted to C structure. The rules above are applied to each field of a struct.</li>
</ul>
</li>
<li>A direction of parameter passed to C extern function is handled as follows:<ul>
<li><b>in</b> parameters are prepended with “const” qualifier in C and are passed by value to C extern function.</li>
<li><b>inout</b> parameters are are passed by reference to C extern function.</li>
<li><b>out</b> parameters are passed by reference to C extern function.</li>
</ul>
</li>
<li><p class="startli">Using BPF maps:</p><ul>
<li>BPF maps can be defined inside the C extern function to provide statefulness. BPF map can be defined as follows:</li>
</ul>
<div class="fragment"><div class="line">REGISTER_START()</div>
<div class="line">REGISTER_TABLE(&lt;NAME&gt;, BPF_MAP_TYPE_HASH, &lt;KEY-SIZE&gt;, &lt;VALUE-SIZE&gt;&gt;, &lt;MAX_ENTRIES&gt;)</div>
<div class="line">REGISTER_END()</div>
</div><!-- fragment --><ul>
<li>The C extern function must not access BPF maps that are used to implement P4 tables and defined in the main C program generated from the P4 language.</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="psa-implementation-for-ebpf-backend"></a>
PSA implementation for eBPF backend</h1>
<p>The <a href="https://github.com/p4lang/p4c/tree/main/backends/ebpf/psa"><code>backends/ebpf/psa</code> directory</a> implements PSA (Portable Switch Architecture) for the eBPF backend.</p>
<h1><a class="anchor" id="prerequisites"></a>
Prerequisites</h1>
<ul>
<li>Refer to the <a href="https://docs.cilium.io/en/latest/bpf/">Cilium docs</a> to learn more about eBPF.</li>
<li>This guide assumes at least basic familiarity with <a href="https://p4.org/p4-spec/docs/PSA.html">the PSA specification</a>.</li>
<li>The PSA implementation inherits some mechanisms (e.g. generation of Parser and Control block) from <code>ebpf_model</code>. Please, get familiar with the base eBPF backend first.</li>
</ul>
<h1><a class="anchor" id="design"></a>
Design</h1>
<p>The PSA to eBPF compiler provides two flavors of generated eBPF code: TC-based design and XDP-based design. The TC-based design leverages eBPF TC (Traffic Control) hook and is able to implement any PSA program. The XDP-based design offloads packet processing to eBPF XDP (eXpress Data Path) hook and provides better performance than the TC-based flavor. However, the XDP-based design lacks support for packet recirculation, QoS (no integration with TC qdisc) and CLONE_E2E packet path.</p>
<h2><a class="anchor" id="tc-based-design-default"></a>
TC-based design (default)</h2>
<p>P4 packet processing is translated into a set of eBPF programs attached to the TC hook. The eBPF programs implement packet processing defined in a P4 program written according to the PSA model. The TC hook is used as a main engine, because it enables a full implementation of the PSA specification. The XDP-based version of the PSA implementation does not implement the full specification, but provides better performance.</p>
<p>The TC-based design of PSA for eBPF is depicted in Figure below.</p>
<div class="image">
<img src="psa-ebpf-design.png" alt=""/>
<div class="caption">
TC-based PSA-eBPF design</div></div>
    <ul>
<li><code>xdp-helper</code> - the fixed, non-programmable "helper" program attached to the XDP hook. The role of the <code>xdp-helper</code> program is to prepare a packet for further processing in the TC subsystem. Why do we need the XDP helper program? Some eBPF helpers for the TC hook depend on the <code>skb-&gt;protocol</code> type (in particular, IPv4/IPv6 EtherType), which is read by the TC layer before a packet enters the eBPF program. This limitation prevents from using TC as a protocol-independent packet processing engine. If a packet arriving at the XDP level isn't an IPv4 packet, the XDP helper replaces it's original EtherType with IPv4 EtherType. The original EtherType is passed to TC according to the XDP2TC mode specified by a user (see XDP2TC metadata section). The <code>tc-ingress</code> program reads original EtherType and puts it back into the packet. We verified that this workaround enables handling other protocols in the TC layer (e.g., MPLS).</li>
<li><code>tc-ingress</code> - In the TC Ingress, the PSA Ingress pipeline as well as so-called "Traffic Manager" eBPF program is attached. The Ingress pipeline is composed of Parser, Control block and Deparser. The details of Parser, Control block and Deparser implementation will be explained further in this document. The same eBPF program in TC contains also the Traffic Manager. The role of Traffic Manager is to redirect traffic between the Ingress (TC) and Egress (TC). It is also responsible for packet replication via clone sessions or multicast groups and sending packet to CPU.</li>
<li><code>tc-egress</code> - The PSA Egress pipeline (composed of Parser, Control block and Deparser) is attached to the TC Egress hook. As there is no XDP hook in the Egress path, the use of TC is mandatory for the egress processing. <b>Note!</b> If the PSA Egress pipeline is not used (i.e. it is left empty by a developer), the PSA-eBPF compiler will not generate the TC Egress program. This brings a noticeable performance gain, if the egress pipeline is not used.</li>
</ul>
<h2><a class="anchor" id="xdp-based-design"></a>
XDP-based design</h2>
<p>The XDP-based design of PSA for eBPF is depicted in Figure below.</p>
<div class="image">
<img src="psa-ebpf-xdp-design.png" alt=""/>
<div class="caption">
XDP-based PSA-eBPF design</div></div>
    <p><code>xdp-helper</code> does not exist in this design, instead the PSA Ingress pipeline is attached to XDP hook. Since XDP does not provide a hook on the egress path, we mimic the PSA Egress pipeline by using eBPF program attached to <code>BPF_MAP_TYPE_DEVMAP</code>, a special type of BPF map used to perform packet redirection with <code>bpf_redirect_map()</code> helper. Also, XDP hook in the currently supported kernel version (up to 5.13) does not support packet cloning. Therefore, packets to be cloned are passed up to the TC hook, where the Packet Replication Engine is implemented. Once a packet reaches the TC hook, it is further processed by TC exclusively. Thus, the PSA-eBPF compiler generates a TC Egress program, which is a mirror reflection of the PSA Egress pipeline attached to the XDP DEVMAP. The packets to be cloned are passed up to TC with additional metadata. The mechanism used to transfer the metadata depends on the XDP2TC mode, we support <code>cpumap</code> and <code>head</code> modes for XDP-based design (<code>meta</code> mode is not supported).</p>
<p>There is no difference (comparing to TC-based design) in how PSA externs, P4 match kinds and parser primitives are implemented for XDP-based design.</p>
<p>To compile P4 programs for XDP, use <code>--xdp</code> compiler option.</p>
<h2><a class="anchor" id="packet-paths"></a>
Packet paths</h2>
<h3><a class="anchor" id="ntk-normal-packet-to-kernel"></a>
NTK (Normal Packet To Kernel)</h3>
<p><b>WARNING!</b> The NTK packet path is a custom packet path used for the PSA-eBPF only! It is not a standardized PSA packet path.</p>
<p>The NTK packet path allows integrating P4/PSA programs for eBPF with the standard Linux kernel stack. The main use case is handling ICMP/ARP requests and sending packet to the userspace process listening on a socket.</p>
<p>The NTK path is enforced if <code>drop</code> is set to <code>false</code> and <code>egress_port</code> is left unchanged or set to 0 (it's a special implicit port number that forwards packets to the kernel stack). Since packets can be modified in the PSA ingress pipeline before they are sent to the kernel stack, a P4 programmer should make sure that packets use standard headers and are properly formatted. Otherwise, the kernel stack will drop them.</p>
<p><b>NOTE!</b> There is no symmetric packet path <em>from kernel</em> - once a packet enters the kernel network stack, it is further processed exclusively by the kernel. As a consequence, all packets that have not been processed by the PSA Ingress pipeline (e.g., packets sent from userspace application) will not be handled by the PSA Egress pipeline!</p>
<h3><a class="anchor" id="nfp-normal-packet-from-port"></a>
NFP (Normal Packet From Port)</h3>
<p><b>TC-based design</b></p>
<p>Packet arriving on an interface is intercepted in the XDP hook by the <code>xdp-helper</code> program. It performs pre-processing and packet is passed for further processing to the TC ingress. Note that there is no P4-related processing done in the <code>xdp-helper</code> program.</p>
<p>By default, a packet is further passed to the TC subsystem. It is done by <code>XDP_PASS</code> action and packet is further handled by <code>tc-ingress</code> program.</p>
<p><b>XDP-based design</b></p>
<p>No specific processing is done. Packets are just received by the eBPF programm attached to XDP.</p>
<h3><a class="anchor" id="resubmit"></a>
RESUBMIT</h3>
<p>The purpose of <code>RESUBMIT</code> is to transfer packet processing back to the Ingress Parser from Ingress Deparser.</p>
<p>We implement packet resubmission by calling main <code>ingress()</code> function (implementing the PSA Ingress pipeline) in a loop. The <code>MAX_RESUBMIT_DEPTH</code> variable specifies maximum number of resubmit operations (the <code>MAX_RESUBMIT_DEPTH</code> value is currently hardcoded and is set to 4). The <code>resubmit</code> flag defines whether the <code>tc-ingress</code> program should enter next iteration (resubmit) or break the loop. The pseudocode looks as follows:</p>
<p><code>c int i = 0; int ret = TC_ACT_UNSPEC; for (i = 0; i &lt; MAX_RESUBMIT_DEPTH; i++) { out_md.resubmit = 0; ret = ingress(skb, &amp;out_md); if (out_md.resubmit == 0) { break; } } </code></p>
<p>The same mechanism for RESUBMIT is used in the TC-based and XDP-based design.</p>
<h3><a class="anchor" id="nu-normal-unicast-nm-normal-multicast-ci2e-clone-ingress-to-egress"></a>
NU (Normal Unicast), NM (Normal Multicast), CI2E (Clone Ingress to Egress)</h3>
<p><b>TC-based design</b></p>
<p>NU, NM and CI2E refer to process of sending packet from the PSA Ingress Pipeline (more specifically from the Traffic Manager) to the PSA Egress pipeline. The NU path is implemented in the eBPF subsystem by invoking the <code>bpf_redirect()</code> helper from the <code>tc-ingress</code> program. This helper sets an output port for a packet and the packet is further intercepted by the TC egress.</p>
<p>Both NM and CI2E require the <code>bpf_clone_redirect()</code> helper to be used. It redirects a packet to an output port, but also clones a packet buffer, so that a packet can be copied and sent to multiple interfaces. From the eBPF program's perspective, <code>bpf_clone_redirect()</code> must be invoked in the loop to send packets to all ports from a clone session/multicast group.</p>
<p>Clone sessions or multicast groups and theirs members are stored as a BPF array map of maps (<code>BPF_MAP_TYPE_ARRAY_OF_MAPS</code>). The P4-eBPF compiler generates two outer BPF maps: <code>multicast_grp_tbl</code> and <code>clone_session_tbl</code>. Both of them store inner maps indexed by the clone session or multicast group identifier, respectively. The clone session/multicast group members (defining <code>egress_port</code>, <code>instance</code> or other parameters used by clone sessions) are stored in the inner hash map.</p>
<p>While performing the packet replication, the eBPF program does a lookup to the outer map based on the clone session/multicast group identifier and, then, does another lookup to the inner map to find all members.</p>
<p><b>XDP-based design</b></p>
<p>The NU path is implemented by calling <code>bpf_redirect_map()</code> after the ingress processing is completed. The NM and CI2E paths are not possible in the XDP layer. Packets marked to be cloned are sent up to the TC hook with additional metadata (e.g., parsed headers) and they are cloned by the eBPF program attached to the TC Ingress by using <code>bpf_clone_redirect()</code>. The clone sessions and multicast groups are implemented exactly like for the TC-based design.</p>
<h3><a class="anchor" id="ce2e-clone-egress-to-egress"></a>
CE2E (Clone Egress to Egress)</h3>
<p><b>TC-based design</b></p>
<p>CE2E refers to process of copying a packet that was handled by the Egress pipeline and resubmitting the cloned packet to the Egress Parser.</p>
<p>CE2E is implemented by invoking <code>bpf_clone_redirect()</code> helper in the Egress path. Output ports are determined based on the <code>clone_session_id</code> and lookup to "clone_session" BPF map, which is shared among TC ingress and egress (eBPF subsystem allows for map sharing between programs).</p>
<p><b>XDP-based design</b></p>
<p>CE2E is not supported by the XDP-based design.</p>
<h3><a class="anchor" id="sending-packet-to-cpu"></a>
Sending packet to CPU</h3>
<p>The PSA implementation for eBPF backend assumes a special interface called <code>PSA_PORT_CPU</code> that is used for communication between a control plane application and data plane. Sending packet to CPU does not differ significantly from normal packet unicast. A control plane application should listen for new packets on the interface identified by <code>PSA_PORT_CPU</code> in a P4 program. By redirecting a packet to <code>PSA_PORT_CPU</code> in the Ingress pipeline the packet is forwarded via Traffic Manager to the Egress pipeline and then, sent to the "CPU" interface.</p>
<p>The mechanism is common for both design options (TC/XDP).</p>
<h3><a class="anchor" id="ntp-normal-packet-to-port"></a>
NTP (Normal packet to port)</h3>
<p><b>TC-based design</b></p>
<p>Packets from <code>tc-egress</code> are sent out to the egress port. The egress port is determined in the Ingress pipeline and is not changed in the Egress pipeline.</p>
<p>Note that before a packet is sent to the output port, it's processed by <code>TC qdisc</code> first. The <code>TC qdisc</code> is the Linux QoS engine. The eBPF programs generated by P4-eBPF compiler sets <code>skb-&gt;priority</code> value based on the PSA <code>class_of_service</code> metadata. The <code>skb-&gt;priority</code> is used to interact between eBPF programs and <code>TC qdisc</code>. A user can configure different QoS behaviors via TC CLI and send a packet from PSA pipeline to a specific QoS class identified by <code>skb-&gt;priority</code>.</p>
<p><b>XDP-based design</b></p>
<p>Packets from the XDP egress program attached to BPF_DEVMAP are directly sent out to the egress port. There is no equivalent of Buffering &amp; Queueing Engine in the XDP-based design.</p>
<h3><a class="anchor" id="recirculate"></a>
RECIRCULATE</h3>
<p><b>TC-based design</b></p>
<p>The purpose of <code>RECIRCULATE</code> is to transfer packet processing back from the Egress Deparser to the Ingress Parser.</p>
<p>In order to implement <code>RECIRCULATE</code> we assume the existence of <code>PSA_PORT_RECIRCULATE</code> ports. Therefore, packet recirculation is simply performed by invoking <code>bpf_redirect()</code> to the <code>PSA_PORT_RECIRCULATE</code> port with <code>BPF_F_INGRESS</code> flag to enforce processing a packet by the Ingress pipeline.</p>
<p><b>XDP-based design</b></p>
<p>The RECIRCULATE path is not supported by the XDP-based design.</p>
<h2><a class="anchor" id="metadata"></a>
Metadata</h2>
<p>There are some global metadata defined for the PSA architecture. For example, <code>packet_path</code> must be shared among different pipelines. To share a global metadata between pipelines we use <code>skb-&gt;cb</code> (control buffer), which gives us 20B that are free to use.</p>
<h2><a class="anchor" id="xdp2tc-mode"></a>
XDP2TC mode</h2>
<p>The XDP2TC mode determines how the metadata (containing original EtherType) is passed from XDP up to TC. By default, PSA-eBPF uses the <code>bpf_xdp_adjust_meta()</code> helper to append the original EtherType to the <code>skb</code>’s <code>data_meta</code> field, which is further read by the TC Ingress to restore the original format of the packet. The way of passing metadata is determined by the user-configurable <code>--xdp2tc</code> compiler flag. We have noticed that some NIC drivers does not support the <code>bpf_xdp_adjust_meta()</code> BPF helper and the default mode cannot be used. Therefore, we come up with a more generic mode called <code>head</code>, which uses <code>bpf_xdp_adjust_head()</code> instead to prepend a packet with metadata. In this mode, the helper must be invoked twice - in the XDP helper program to append the metadata and in the TC Ingress to strip the metadata out of a packet. We also introduce the third mode - <code>cpumap</code>, which is an experimental features and should be used carefully. The <code>cpumap</code> assumes that the single CPU core handles a packet in the run-to-completion mode from XDP up to the TC layer (in other words, for a given packet, the CPU core running the TC program is the same as the one for XDP). If the above condition is met, the <code>cpumap</code> mode uses the per-CPU BPF array map to transfer metadata from XDP to TC. Hence, the <code>cpumap</code> mode should only be used, if there is a guarantee that the same CPU core handles the packet in both XDP and TC hooks. Note that the XDP helper program introduces a constant but noticeable per-packet overhead. Though, it is necessary to implement P4 processing in the TC layer.</p>
<p>To sum up, the <code>--xdp2tc</code> compiler flag can take the following values:</p><ul>
<li><code>meta</code> (default) - uses the <code>bpf_xdp_adjust_meta()</code> BPF helper. It's the most efficient way and should be used wherever possible.</li>
<li><code>head</code> - uses the <code>bpf_xdp_adjust_head()</code> BPF helper and should be used if <code>meta</code> is not supported by a NIC driver.</li>
<li><code>cpumap</code> - uses the BPF per-CPU array map. It should rather be used for testing purposes only.</li>
</ul>
<h2><a class="anchor" id="control-plane-api"></a>
Control-plane API</h2>
<p>The PSA-eBPF compiler assumes that any control plane software managing eBPF programs generated by the P4 compiler must be in line with the Control-plane API (a kind of contract or set of instructions that must be followed to make use of PSA-eBPF programs). The Control-plane API is summarized below, but we suggest using the <a href="https://github.com/NIKSS-vSwitch/nikss">NIKSS API</a> that already implements the control-plane API and exposes higher level C API.</p>
<ul>
<li><b>Pipeline initialization</b> - eBPF programs must be first loaded to the eBPF subsystem. The C files generated by the P4 compiler are compatible with <code>libbpf</code> loader and are annotated with BTF. All eBPF objects (programs, maps) must be pinned to the BPF filesystem under <code>/sys/fs/bpf/</code>. Once eBPF objects are loaded and pinned, a control plane application must invoke <code>map_initialize()</code> BPF function - it can be done using <code>bpf_prog_test_run</code>. The <code>map_initialize()</code> function is auto-generated by the PSA-eBPF compiler and configures all initial state, i.e. it initializes default actions, const entries, etc.</li>
<li><b>Table management</b> - a control plane software is responsible for inserting BPF map entries that are in line with types generated by the P4 compiler. The PSA-eBPF compiler generates C <code>struct</code> for BPF map's key and value. (e.g. <code>ingress_tbl_fwd_key</code> and <code>ingress_tbl_fwd_value</code>). The <code>exact</code> match table is implemented as BPF hash map. The <code>lpm</code> match table is implemented as BPF <code>LPM_TRIE</code>. Both key and value fields must be provided in the host byte order.</li>
<li><b>Clone sessions or multicast groups management</b> - Clone sessions or multicast groups are represented as a BPF array map of maps (<code>BPF_MAP_TYPE_ARRAY_OF_MAPS</code>) in the eBPF subsystem. Each entry of an outer map represents a single clone session or multicast group. An inner map is a hash map storing clone session/multicast group members, according to the structure defined by <code>struct list_key_t</code> (BPF map key) and <code>struct element</code> (value). To add a new clone session/mutlicast group, a control plane must add a new element to the outer map (indexed by clone session or multicast group identifier referenced by <code>clone_session_id</code> or <code>multicast_group</code> in a PSA program) and initialize an inner map. To add a new clone session/multicast group member, a con1trol plane must add new element to the inner map.</li>
</ul>
<h2><a class="anchor" id="p4-match-kinds"></a>
P4 match kinds</h2>
<p>The PSA-eBPF compiler currently supports the following P4 match kinds: <code>exact</code>, <code>lpm</code>, <code>ternary</code>.</p>
<h3><a class="anchor" id="exact"></a>
exact</h3>
<p>An <code>exact</code> table is implemented using the BPF hash map. A P4 table is considered an <code>exact</code> table if all its match fields are defined as <code>exact</code>. Then, the PSA-eBPF compiler generates a BPF hash map instance for each P4 table instance. The hash map key as a concatenation of P4 match fields translated to eBPF representation. Each <code>apply()</code> operation is translated into a lookup to the BPF hash map. The value is used to determine an action and its parameters.</p>
<h3><a class="anchor" id="lpm"></a>
lpm</h3>
<p>An <code>lpm</code> table is implemented using the BPF <code>LPM_TRIE</code> map. A P4 table is considered an <code>lpm</code> table if it contains a single <code>lpm</code> field and no <code>ternary</code> fields. The PSA-eBPF compiler generates a BPF <code>LPM_TRIE</code> map instance for each P4 table instance. The hash map key as a concatenation of P4 match fields translated to eBPF representation. Moreover, the PSA-eBPF compiler shuffles the match fields and places the <code>lpm</code> field in the last position. Each <code>apply()</code> operation is translated into a lookup to the <code>LPM_TRIE</code> map. A control plane should populate the <code>LPM_TRIE</code> map with entries composed of a value and prefix.</p>
<h3><a class="anchor" id="ternary"></a>
ternary</h3>
<p>There is no built-in BPF map for ternary (wildcard) matching. Hence, the PSA-eBPF compiler leverages the Tuple Space Search (TSS) algorithm for ternary matching (refer to the <a href="https://dl.acm.org/doi/10.1145/316194.316216">research paper</a> to learn more about the TSS algorithm). A <code>ternary</code> table is implemented using a combination of hash and array BPF maps that realizes the TSS algorithm. A P4 table is considered a <code>ternary</code> table if it contains at least one <code>ternary</code> field (exact and lpm fields are converted to ternary fields with an appropriate mask).</p>
<p><b>Note!</b> The PSA-eBPF compiler requires match keys in a ternary table to be sorted by size in descending order.</p>
<p>The PSA-eBPF compiler generates 2 BPF maps for each ternary table instance (+ the default action map):</p><ul>
<li>the <code>&lt;TBL-NAME&gt;_prefixes</code> map is a BPF hash map that stores all unique ternary masks. The ternary masks are created based on the runtime table entries that are installed by a user.</li>
<li>the <code>&lt;TBL-NAME&gt;_tuples_map</code> map is a BPF array map of maps that stores all "tuples". A single tuple is a BPF hash map that stores all flow rules with the same ternary mask.</li>
</ul>
<p>Note that the <code>nikss-ctl table add</code> CLI command greatly simplifies the process of adding/removing flow rules to ternary tables.</p>
<p>For each <code>apply()</code> operation, the PSA-eBPF compiler generates the piece of code performing lookup to the above maps. The lookup code iterates over the <code>&lt;TBL-NAME&gt;_prefixes</code> map to retrieve a ternary mask. Next, the lookup key (a concatenation of match keys) is masked with the obtained ternary mask and lookup to a corresponding tuple map is performed. If a match is found, the best match with the highest priority is saved, and the algorithm continues to examine other tuples. If an entry with a higher priority is found, the best match is overwritten. The algorithm exists when there is no more tuples left.</p>
<p>The snippet below shows the C code generated by the PSA-eBPF compiler for a lookup into a ternary table. The steps are explained below.</p>
<p>```c struct ingress_tbl_ternary_1_key key = {}; key.field0 = hdr-&gt;ipv4.dstAddr; key.field1 = hdr-&gt;ipv4.diffserv; struct ingress_tbl_ternary_1_value *value = NULL; struct ingress_tbl_ternary_1_key_mask head = {0}; struct ingress_tbl_ternary_1_value_mask *val = BPF_MAP_LOOKUP_ELEM(ingress_tbl_ternary_1_prefixes, &amp;head); if (val &amp;&amp; val-&gt;has_next != 0) { struct ingress_tbl_ternary_1_key_mask next = val-&gt;next_tuple_mask; pragma clang loop unroll(disable) for (int i = 0; i &lt; MAX_INGRESS_TBL_TERNARY_1_KEY_MASKS; i++) { // (1) struct ingress_tbl_ternary_1_value_mask *v = BPF_MAP_LOOKUP_ELEM(ingress_tbl_ternary_1_prefixes, &amp;next); if (!v) { break; } // (2) struct ingress_tbl_ternary_1_key k = {}; __u32 *chunk = ((__u32 *) &amp;k); __u32 *mask = ((__u32 *) &amp;next); pragma clang loop unroll(disable) for (int i = 0; i &lt; sizeof(struct ingress_tbl_ternary_1_key_mask) / 4; i++) { chunk[i] = ((__u32 *) &amp;key)[i] &amp; mask[i]; } __u32 tuple_id = v-&gt;tuple_id; next = v-&gt;next_tuple_mask; // (3) struct bpf_elf_map *tuple = BPF_MAP_LOOKUP_ELEM(ingress_tbl_ternary_1_tuples_map, &amp;tuple_id); if (!tuple) { break; }</p>
<p>// (4) struct ingress_tbl_ternary_1_value *tuple_entry = bpf_map_lookup_elem(tuple, &amp;k); if (!tuple_entry) { if (v-&gt;has_next == 0) { break; } continue; } // (5) if (value == NULL || tuple_entry-&gt;priority &gt; value-&gt;priority) { value = tuple_entry; } if (v-&gt;has_next == 0) { break; } } }</p>
<p>// (6): go to default action if value == NULL ```</p>
<p>The description of annotated lines:</p><ol type="1">
<li>The algorithm starts to iterate over the ternary masks map. The loop is bounded by the <code>MAX_INGRESS_TBL_TERNARY_1_KEY_MASKS</code> which is configured by <code>--max-ternary-masks</code> compiler option (defaults to 128). Note that the eBPF program complexity (instruction count) depends on this constant, so some more complex P4 program may not compile if the max ternary masks value is too high (see the Limitations section).</li>
<li>A lookup key to a next tuple map is created by masking the concatenation of match keys with the ternary masks retrieved from the <code>&lt;TBL-NAME&gt;_prefixes</code> map. Note that the key is masked in 4-byte chunks.</li>
<li>A lookup to the <code>&lt;TBL-NAME&gt;_tuples_map</code> outer BPF map is done to find a tuple map based on the tuple ID. The lookup returns the inner BPF map, which stores all entries related to a tuple.</li>
<li>Next, a lookup to the inner BPF map (a tuple map) is performed. The returned value stores the action ID, action params and priority.</li>
<li>The priority of an obtained value is compared with a current "best match" entry. An entry that is returned from the ternary classification is the one with the highest priority among different tuples.</li>
</ol>
<p>Note that the TSS algorithm has linear O(n) packet classification complexity, where "n" is a number of unique ternary masks.</p>
<h2><a class="anchor" id="psa-externs"></a>
PSA externs</h2>
<h3><a class="anchor" id="actionprofile"></a>
ActionProfile</h3>
<p><a href="https://p4.org/p4-spec/docs/PSA.html#sec-action-profile">ActionProfile</a> is a table implementation that separates actions (and its parameters) from a P4 table, introducing a level of indirection. The P4-eBPF compiler generates an additional BPF hash map, if the Action Profile is specified for a P4 table. The additional BPF map stores the mapping between the ActionProfile member reference and a P4 action specification. During the lookup to the P4 table with Action Profile, eBPF program first queries the first BPF map using the match key composed from the packet fields and expects the ActionProfile member reference to be returned. Next, the eBPF programs uses the obtained member reference as a lookup key to a second map to retrieve the action specification. Hence, the eBPF program does one additional lookup to the additional BPF map, if the ActionProfile is specified for a P4 table.</p>
<h3><a class="anchor" id="actionselector"></a>
ActionSelector</h3>
<p><a href="https://p4.org/p4-spec/docs/PSA-v1.1.0.html#sec-action-selector">ActionSelector</a> is a table implementation similar to an ActionProfile, but extends its functionality with support for groups of actions. If a table entry contains a member reference, the ActionSelector behaves in the same way as an ActionProfile. In case of group references, the PSA-eBPF compiler generates additional BPF maps. One of additional BPF maps (hash map of maps) maps a group reference ID to an inner map that contains a group of entries. The inner map (might be created at runtime by <code>nikss-ctl</code>) stores a number of all members in a group as the first element of the inner map. The rest of entries contains members of the ActionSelector group. To choose a member from a group, a checksum is calculated from all <code>selector</code> match keys. Next, the obtained member from the group map is used to get and execute an action.</p>
<p>The second compiler-created map contains an action for an empty group. For the ActionSelector, there are two fields stored in a table that uses given ActionSelector instance, one is reference, second is marker whether reference points to group or member.</p>
<p>Before action execution, following source code will be generated (and some additional comments to it) for table lookup, which has implementation <code>ActionSelector</code>: <code>c struct ingress_as_value * as_value = NULL; // pointer to an action data u32 as_action_ref = value-&gt;ingress_as_ref; // value-&gt;ingress_as_ref is entry from table (reference) u8 as_group_state = 0; // which map contains action data if (value-&gt;ingress_as_is_group_ref != 0) { // (1) bpf_trace_message("ActionSelector: group reference %u\n", as_action_ref); void * as_group_map = BPF_MAP_LOOKUP_ELEM(ingress_as_groups, &amp;as_action_ref); // get group map if (as_group_map != NULL) { u32 * num_of_members = bpf_map_lookup_elem(as_group_map, &amp;ebpf_zero); // (2) if (num_of_members != NULL) { if (*num_of_members != 0) { u32 ingress_as_hash_reg = 0xffffffff; // start calculation of hash { u8 ingress_as_hash_tmp = 0; crc32_update(&amp;ingress_as_hash_reg, (u8 *) &amp;(hdr-&gt;ethernet.etherType), 2, 3988292384); bpf_trace_message("CRC: checksum state: %llx\n", (u64) ingress_as_hash_reg); bpf_trace_message("CRC: final checksum: %llx\n", (u64) crc32_finalize(ingress_as_hash_reg)); } u64 as_checksum_val = crc32_finalize(ingress_as_hash_reg) &amp; 0xffff; // (3) as_action_ref = 1 + (as_checksum_val % (*num_of_members)); // (4) bpf_trace_message("ActionSelector: selected action %u from group\n", as_action_ref); u32 * as_map_entry = bpf_map_lookup_elem(as_group_map, &amp;as_action_ref); // (5) if (as_map_entry != NULL) { as_action_ref = *as_map_entry; } else { /* Not found, probably bug. Skip further execution of the extern. */ bpf_trace_message("ActionSelector: Entry with action reference was not found, dropping packet. Bug?\n"); return TC_ACT_SHOT; } } else { bpf_trace_message("ActionSelector: empty group, going to default action\n"); as_group_state = 1; } } else { bpf_trace_message("ActionSelector: entry with number of elements not found, dropping packet. Bug?\n"); return TC_ACT_SHOT; } } else { bpf_trace_message("ActionSelector: group map was not found, dropping packet. Bug?\n"); return TC_ACT_SHOT; } } if (as_group_state == 0) { bpf_trace_message("ActionSelector: member reference %u\n", as_action_ref); as_value = BPF_MAP_LOOKUP_ELEM(ingress_as_actions, &amp;as_action_ref); // (6) } else if (as_group_state == 1) { bpf_trace_message("ActionSelector: empty group, executing default group action\n"); as_value = BPF_MAP_LOOKUP_ELEM(ingress_as_defaultActionGroup, &amp;ebpf_zero); // (7) } </code> Description of marked lines:</p><ol type="1">
<li>Detect if a reference is a group reference. When the <code>_is_group_ref</code> field is non-zero, the reference is assumed to be a group reference.</li>
<li>Read a first entry in a group. This gives the number of members in a group.</li>
<li>From calculated hash N LSB bits are taken into account. N is obtained from last parameter of constructor of <code>ActionSelector</code>.</li>
<li>The number of members in a group is known (the first entry in a table) and one of them must be dynamically selected. An action ID in a group is chosen based on the calculated hash value. A valid value of an action ID in a group is within the following range: {1, 2, ... number of members}.</li>
<li>This lookup is necessary to translate the action ID in a group into a member reference.</li>
<li>When a member reference is found, action data is read from the <code>_actions</code> map.</li>
<li>For an empty group (without members), action data is read from the <code>_defaultActionGroup</code> table.</li>
</ol>
<p>To manage the ActionSelector instance (do not confuse with a table that uses this implementation), you can use <code>nikss-ctl action-selector</code> command or C API from NIKSS.</p>
<h3><a class="anchor" id="digest"></a>
Digest</h3>
<p><a href="https://p4.org/p4-spec/docs/PSA.html#sec-packet-digest">Digests</a> are intended to carry a small piece of user-defined data from the data plane to a control plane. The PSA-eBPF compiler translates each Digest instance into <code>BPF_MAP_TYPE_QUEUE</code> that implements a FIFO queue. If a deparser triggers the <code>pack()</code> method, an eBPF program inserts data defined for a Digest into the BPF queue map using <code>bpf_map_push_elem</code>. A user space application is responsible for performing periodic queries to this map to read a Digest message. It can use either <code>nikss-ctl digest get pipe</code>, <code>nikss_digest_get_next</code> from NIKSS C API or <code>bpf_map_lookup_and_delete_elem</code> from <code>libbpf</code> API.</p>
<h3><a class="anchor" id="meters"></a>
Meters</h3>
<p><a href="https://p4.org/p4-spec/docs/PSA.html#sec-meters">Meters</a> are a mechanism for "marking" packets that exceed an average packet or bit rate. Meters implement Dual Token Bucket Algorithm with both "color aware" and "color blind" modes. The PSA-eBPF implementation uses a BPF hash map to store a Meter state. The current implementation in eBPF uses BPF spinlocks to make operations on Meters atomic. The <code>bpf_ktime_get_ns()</code> helper is used to get a packet arrival timestamp.</p>
<p>The best way to configure a Meter is to use <code>nikss-ctl meter</code> tool as in the following example: <code>bash @section autotoc_md1mbs---128-000-bytess-132-kbytess-pir-128-kbytess-cir-let-cbs-pbs---10-kbytes 1Mb/s -&gt; 128 000 bytes/s (132 kbytes/s PIR, 128 kbytes/s CIR), let CBS, PBS -&gt; 10 kbytes $ nikss-ctl meter update pipe "$PIPELINE" DemoIngress_meter index 0 132000:10000 128000:10000 </code></p>
<p><code>nikss-ctl</code> accepts PIR and CIR values in bytes/s units or packets/s. PBS and CBS in bytes or packets.</p>
<h4><a class="anchor" id="direct-meter"></a>
Direct Meter</h4>
<p><a href="https://p4.org/p4-spec/docs/PSA.html#sec-direct-meters">Direct Meter</a> is always associated with the table entry that matched. The Direct Meter state is stored within the table entry value.</p>
<h3><a class="anchor" id="value_set"></a>
value_set</h3>
<p><a href="https://p4.org/p4-spec/docs/P4-16-v1.2.2.html#sec-value-set">value_set</a> is a P4 lang construct allowing to determine next parser state based on runtime values. The P4-eBPF compiler generates additional hash map for each <code>ValueSet</code> instance. In select case expression each <code>select()</code> on <code>ValueSet</code> is translated into a lookup into the BPF hash map to check if an entry for a given key exists. A value of the BPF map is ignored.</p>
<h3><a class="anchor" id="random"></a>
Random</h3>
<p>The <a href="https://p4.org/p4-spec/docs/PSA.html#sec-random">Random</a> extern is a mean to retrieve a pseudo-random number in a specified range within a P4 program. The PSA-eBPF compiler uses the <code>bpf_get_prandom_u32()</code> BPF helper to get a pseudo-random number. Each <code>read()</code> operation on the Random extern in a P4 program is translated into a call to the BPF helper.</p>
<h1><a class="anchor" id="getting-started-1"></a>
Getting started</h1>
<h2><a class="anchor" id="installation-1"></a>
Installation</h2>
<p>Follow standard steps for the P4 compiler to install the eBPF backend with the PSA support.</p>
<h2><a class="anchor" id="using-psa-ebpf"></a>
Using PSA-eBPF</h2>
<h3><a class="anchor" id="prerequisites-1"></a>
Prerequisites</h3>
<p>The PSA implemented for eBPF backend is verified to work with the kernel version 5.8+ and <code>x86-64</code> CPU architecture. Moreover, make sure that the BPF filesystem is mounted under <code>/sys/fs/bpf</code>.</p>
<p>Also, make sure you have the following packages installed:</p>
<p><code>bash $ sudo apt install -y clang llvm libelf-dev </code></p>
<p>You should also install a static <code>libbpf</code> library. Run the following commands:</p>
<p><code>bash $ python3 backends/ebpf/build_libbpf </code></p>
<h3><a class="anchor" id="compilation-1"></a>
Compilation</h3>
<p>You can compile a P4-16 PSA program for eBPF in a single step using:</p>
<p><code>bash make -f backends/ebpf/runtime/kernel.mk BPFOBJ=out.o P4FILE=&lt;P4-PROGRAM&gt;.p4 P4C=p4c-ebpf psa </code></p>
<p>You can also perform compilation step by step:</p>
<p><code> $ p4c-ebpf --arch psa --target kernel -o out.c &lt;program&gt;.p4 $ clang -Ibackends/ebpf/runtime -Ibackends/ebpf/runtime/usr/include -O2 -g -c -emit-llvm -o out.bc out.c $ llc -march=bpf -mcpu=generic -filetype=obj -o out.o out.bc </code></p>
<p>Note that you can use <code>-mcpu</code> flag to define the eBPF instruction set. Visit <a href="https://pchaigno.github.io/bpf/2021/10/20/ebpf-instruction-sets.html">this blog post</a> to learn more about eBPF instruction sets.</p>
<p>The above steps generate <code>out.o</code> BPF object file that can be loaded to the kernel.</p>
<h4><a class="anchor" id="optional-flags"></a>
Optional flags</h4>
<p>Supposing we want to use a packet recirculation we have to specify the <code>PSA_PORT_RECIRCULATE</code> port. We can use <code>-DPSA_PORT_RECIRCULATE=&lt;RECIRCULATE_PORT_IDX&gt;</code> Clang flag via <code>kernel.mk</code> <code>bash make -f backends/ebpf/runtime/kernel.mk BPFOBJ=out.o ARGS="-DPSA_PORT_RECIRCULATE=&lt;RECIRCULATE_PORT_IDX&gt;" P4FILE=&lt;P4-PROGRAM&gt;.p4 P4C=p4c-ebpf psa </code> or directly: <code>clang ... -DPSA_PORT_RECIRCULATE=&lt;RECIRCULATE_PORT_IDX&gt; ...</code>, <br  />
 where <code>RECIRCULATE_PORT_IDX</code> is a number of a <code>psa_recirc</code> interface (this number can be obtained from <code>ip -n switch link</code>).</p>
<p>By default <code>PSA_PORT_RECIRCULATE</code> is set to 0.</p>
<h3><a class="anchor" id="nikss-api-and-nikss-ctl"></a>
NIKSS API and nikss-ctl</h3>
<p>We provide the <code>NIKSS</code> C API and the <code>nikss-ctl</code> CLI tool that can be used to manage eBPF programs generated by P4-eBPF compiler. To install the CLI tool, follow the guide in <a href="https://github.com/NIKSS-vSwitch/nikss">the NIKSS repository</a>. Use <code>nikss-ctl help</code> to get all possible commands.</p>
<p><b>Note!</b> Although eBPF objects can be loaded and managed by other tools (e.g. <code>bpftool</code>), we recommend using <code>nikss-ctl</code>. Some features (e.g., default actions) will only work when using <code>nikss-ctl</code>.</p>
<p>To load eBPF programs generated by P4-eBPF compiler run:</p>
<p><code>bash nikss-ctl pipeline load id &lt;PIPELINE-ID&gt; out.o </code></p>
<p><code>PIPELINE-ID</code> is a user-defined value used to uniquely identify PSA-eBPF pipeline (we are going to support for multiple PSA-eBPF pipelines running in parallel). In the next step, for each interface that should be attached to PSA-eBPF run:</p>
<p><code>bash nikss-ctl add-port pipe &lt;PIPELINE-ID&gt; dev &lt;INTF&gt; </code></p>
<h2><a class="anchor" id="running-ptf-tests"></a>
Running PTF tests</h2>
<p>PSA implementation for eBPF backend is covered by a set of PTF tests that verify a correct behavior of various PSA mechanisms. The test scripts, PTF test cases and test P4 programs are located under <code>backends/ebpf/tests</code>. The tests must be executed from this directory.</p>
<p>To run all PTF tests:</p>
<p><code> sudo ./test.sh </code></p>
<p>You can also specify a single PTF test to run:</p>
<p><code> sudo ./test.sh test.BridgedMetadataPSATest </code></p>
<p>It might be also useful to enable tracing for troubleshooting with <code>bpftool prog tracelog</code>:</p>
<p><code> sudo ./test.sh --trace=on </code></p>
<h2><a class="anchor" id="troubleshooting"></a>
Troubleshooting</h2>
<p>The PSA implementation for eBPF backend generates standard BPF objects that can be inspected using <code>bpftool</code>.</p>
<p>To troubleshoot PSA-eBPF program you will probably need <code>bpftool</code>. Follow the steps below to install it.</p>
<p>You should be able to see <code>bpftool help</code>:</p>
<p>```bash $ bpftool help Usage: bpftool [OPTIONS] OBJECT { COMMAND | help } bpftool batch file FILE bpftool version</p>
<p>OBJECT := { prog | map | link | cgroup | perf | net | feature | btf | gen | struct_ops | iter } OPTIONS := { {-j|&ndash;json} [{-p|&ndash;pretty}] | {-f|&ndash;bpffs} | {-m|&ndash;mapcompat} | {-n|&ndash;nomount} } ```</p>
<p>Refer to <a href="https://manpages.ubuntu.com/manpages/focal/man8/bpftool-prog.8.html">the bpftool guide</a> for more examples how to use it.</p>
<h1><a class="anchor" id="performance-optimizations"></a>
Performance optimizations</h1>
<h2><a class="anchor" id="table-caching"></a>
Table caching</h2>
<p>Table caching optimizes P4 table lookups by adding a cache with all <code>exact</code> matches for time-consuming lookups including:</p><ul>
<li>table with <code>ternary</code> (and/or lpm, exact) key - skip slow TSS algorithm if the key was matched earlier.</li>
<li>table with <code>lpm</code> (and/or exact) key - skip slow <code>LPM_TRIE</code> map (especially when there is many entries) if the key was matched earlier.</li>
<li><code>ActionSelector</code> member selection from group - skip slow checksum calculation for <code>selector</code> key if it was calculated earlier.</li>
</ul>
<p>The fast exact-match map is added in front of each instance of a table that contains a <code>lpm</code>, <code>ternary</code> or <code>selector</code> match key. The table cache is implemented with <code>BPF_MAP_TYPE_LRU_HASH</code>, which shares its implementation with the BPF hash map. The LRU map provides a good lookup performance, but lower performance on map updates due to a maintenance process. Thus, this optimization fits into use cases, where a value of table key changes infrequently between packets.</p>
<p>This optimization may not improve performance in every case, so it must be explicitly enabled by compiler option. To enable table caching pass <code>--table-caching</code> to the compiler.</p>
<h1><a class="anchor" id="todo--limitations"></a>
TODO / Limitations</h1>
<p>We list the known bugs/limitations below. Refer to the Roadmap section for features planned in the near future.</p>
<ul>
<li>Fields wider than 64 bits must have size multiple of 8 bits, otherwise they may have unexpected value in the LSB byte. These fields may not work with all the externs and not all the operations on them are possible.</li>
<li>We noticed that <code>bpf_xdp_adjust_meta()</code> isn't implemented by some NIC drivers, so the <code>meta</code> XDP2TC mode may not work with some NICs. So far, we have verified the correct behavior with Intel 82599ES. If a NIC doesn't support the <code>meta</code> XDP2TC mode you can use <code>head</code> or <code>cpumap</code> modes.</li>
<li><code>lookahead()</code> with bit fields (e.g., <code>bit&lt;16&gt;</code>) doesn't work.</li>
<li><code>@atomic</code> operation is not supported yet.</li>
<li><code>psa_idle_timeout</code> is not supported yet.</li>
<li>DirectCounter and DirectMeter externs are not supported for P4 tables with implementation (ActionProfile or ActionSelector).</li>
<li>The <code>xdp2tc=head</code> mode works only for packets larger than 34 bytes (the size of Ethernet and IPv4 header).</li>
<li><code>value_set</code> only supports the exact match type and can only match on a single field in the <code>select()</code> expression.</li>
<li>The number of entries in ternary tables are limited by the number of unique ternary masks. If a P4 program uses many ternary tables and the <code>--max-ternary-masks</code> (default: 128) is set to a high value, the P4 program may not load into the BPF subsystem due to the BPF complexity issue (the 1M instruction limit exceeded). This is the limitation of the current implementation of the TSS algorithm that requires iteration over BPF maps. Note that the recent kernel introduced the <a href="https://lwn.net/Articles/846504/">bpf_for_each_map_elem()</a> helper that should simplify the iteration process and help to overcome the current limitation.</li>
<li>Setting a size of ternary tables does not currently work.</li>
<li>DirectMeter cannot be used if a table defines <code>ternary</code> match fields, as <a href="https://patchwork.ozlabs.org/project/netdev/patch/20190124041403.2100609-2-ast@kernel.org/">BPF spinlocks are not allowed in inner maps of map-in-map</a>.</li>
<li>Table cache optimization can't be enabled on tables with DirectCounter or DirectMeter due to two different states of a table entry. Tables with these externs will not have enabled cache optimization even when enabled by compiler option.</li>
<li>When table cache optimization is enabled for a table, the number of cached entries is determined as a half of table size. This would be more configurable or smart during compilation.</li>
<li>Updates to tables or ActionSelector with enabled table cache optimization require cache invalidation. <code>nikss</code> library will remove all cached entries if it detects cache.</li>
</ul>
<h1><a class="anchor" id="roadmap"></a>
Roadmap</h1>
<h2><a class="anchor" id="planned-features"></a>
Planned features</h2>
<p>All the below features are already implemented and will be contributed to the P4 compiler in subsequent pull requests.</p>
<ul>
<li><b>Extended ValueSet support.</b> We plan to extend implementation to support other match kinds and multiple fields in the <code>select()</code> expression.</li>
</ul>
<h2><a class="anchor" id="long-term-goals"></a>
Long-term goals</h2>
<p>The below features are not implemented yet, but they are considered for the future extensions:</p>
<ul>
<li><b>Range matching.</b> P4-eBPF compiler does not support <code>range</code> match kind and there is a further investigation needed on how to implement range matching for eBPF programs.</li>
<li><b>Optional matching.</b> P4-eBPF compiler does not support <code>optional</code> match kind yet. However, it can be implemented based on the same algorithm that is used for ternary matching.</li>
<li><b>Investigate support for PNA.</b> We plan to investigate the PNA implementation for eBPF backend. We believe that the PNA implementation can be significantly based on the PSA implementation.</li>
<li><b>Meet parity with the latest version of Linux kernel.</b> The latest Linux kernel brings a few improvements/extensions to eBPF subsystem. We plan to incorporate them to the P4-eBPF compiler to extend functionalities or improve performance.</li>
<li><b>P4Runtime support.</b> Currently, PSA-eBPF programs can only be managed by <code>NIKSS API</code>. We plan to integrate PSA-eBPF with the P4Runtime software stack (e.g., Stratum, TDI or P4-OvS).</li>
</ul>
<h2><a class="anchor" id="support"></a>
Support</h2>
<p>To report any other kind of problem, feel free to open a GitHub Issue or reach out to the project maintainers on the P4 Community Slack or via email.</p>
<p>Project maintainers:</p>
<ul>
<li>Tomasz Osiński (tomasz [at] opennetworking.org / osinstom [at] gmail.com)</li>
<li>Mateusz Kossakowski (mateusz.kossakowski [at] orange.com / mateusz.kossakowski.10 [at] gmail.com)</li>
<li>Jan Palimąka (jan.palimaka [at] orange.com / jan.palimaka95 [at] gmail.com)   </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.12.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
