<!-- HTML header for doxygen 1.12.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>P4 Compiler Documentation (P4C): PHV::SuperCluster Class Reference</title>
<link rel="icon" href="p4-fav.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!--  Add link to paragraphs   -->
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
  DoxygenAwesomeParagraphLink.init()
</script>
<!-- Add copy button to code fragments  -->
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
  DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add dark mode toggle -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
  DoxygenAwesomeDarkModeToggle.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="cards.css" rel="stylesheet" type="text/css"/>
<link href="flow.css" rel="stylesheet" type="text/css"/>
<link href="p4c_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="p4-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">P4C
   </div>
   <div id="projectbrief">The P4 Compiler</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_p_h_v_1_1_super_cluster.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_p_h_v_1_1_super_cluster-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">PHV::SuperCluster Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="phv_2utils_2utils_8h_source.html">utils.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PHV::SuperCluster:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_p_h_v_1_1_super_cluster__inherit__graph.svg" width="150" height="110"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa60598d33fa7ba0a5feb6968dfa470ad" id="r_aa60598d33fa7ba0a5feb6968dfa470ad"><td class="memItemLeft" align="right" valign="top"><a id="aa60598d33fa7ba0a5feb6968dfa470ad" name="aa60598d33fa7ba0a5feb6968dfa470ad"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SliceList</b> = std::list&lt;<a class="el" href="class_p_h_v_1_1_field_slice.html">PHV::FieldSlice</a>&gt;</td></tr>
<tr class="separator:aa60598d33fa7ba0a5feb6968dfa470ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aca558f127d3c1bd4f464e71685462fd9" id="r_aca558f127d3c1bd4f464e71685462fd9"><td class="memItemLeft" align="right" valign="top"><a id="aca558f127d3c1bd4f464e71685462fd9" name="aca558f127d3c1bd4f464e71685462fd9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SuperCluster</b> (<a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const <a class="el" href="class_p_h_v_1_1_rotational_cluster.html">PHV::RotationalCluster</a> * &gt; <a class="el" href="#a01b292c7b58be3ad9795b034140832cd">clusters</a>, <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; SliceList * &gt; <a class="el" href="#aa786cc9826446e15bb99007ae315d7d6">slice_lists</a>)</td></tr>
<tr class="separator:aca558f127d3c1bd4f464e71685462fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed122a948a2f3a710c9973d0c03bd0e" id="r_abed122a948a2f3a710c9973d0c03bd0e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abed122a948a2f3a710c9973d0c03bd0e">aggregate_size</a> () const override</td></tr>
<tr class="separator:abed122a948a2f3a710c9973d0c03bd0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46b4a321270e24fe190c9cfc9c8fa8a" id="r_ae46b4a321270e24fe190c9cfc9c8fa8a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_p_h_v_1_1_aligned_cluster.html">AlignedCluster</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae46b4a321270e24fe190c9cfc9c8fa8a">aligned_cluster</a> (const <a class="el" href="class_p_h_v_1_1_field_slice.html">PHV::FieldSlice</a> &amp;slice) const</td></tr>
<tr class="separator:ae46b4a321270e24fe190c9cfc9c8fa8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab992252cdbd653a20312c2cc9f5a285d" id="r_ab992252cdbd653a20312c2cc9f5a285d"><td class="memItemLeft" align="right" valign="top"><a id="ab992252cdbd653a20312c2cc9f5a285d" name="ab992252cdbd653a20312c2cc9f5a285d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>all_of_fieldslices</b> (const std::function&lt; bool(const <a class="el" href="class_p_h_v_1_1_field_slice.html">PHV::FieldSlice</a> &amp;)&gt; func) const</td></tr>
<tr class="memdesc:ab992252cdbd653a20312c2cc9f5a285d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply <code>func</code> on all field slices in this super cluster. <br /></td></tr>
<tr class="separator:ab992252cdbd653a20312c2cc9f5a285d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9b2c569d483f1beefbfecaf04587b6" id="r_a1f9b2c569d483f1beefbfecaf04587b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f9b2c569d483f1beefbfecaf04587b6">any_of_fieldslices</a> (const std::function&lt; bool(const <a class="el" href="class_p_h_v_1_1_field_slice.html">PHV::FieldSlice</a> &amp;)&gt; func) const</td></tr>
<tr class="separator:a1f9b2c569d483f1beefbfecaf04587b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73cd014e4e18a46891e8496329c8e99e" id="r_a73cd014e4e18a46891e8496329c8e99e"><td class="memItemLeft" align="right" valign="top"><a id="a73cd014e4e18a46891e8496329c8e99e" name="a73cd014e4e18a46891e8496329c8e99e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>calc_pack_conflicts</b> ()</td></tr>
<tr class="memdesc:a73cd014e4e18a46891e8496329c8e99e"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates the value of num_pack_conflicts_i (to be performed after PackConflicts analysis) <br /></td></tr>
<tr class="separator:a73cd014e4e18a46891e8496329c8e99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cea515b37e588d0756a61cbf4cc35b3" id="r_a0cea515b37e588d0756a61cbf4cc35b3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_p_h_v_1_1_rotational_cluster.html">RotationalCluster</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0cea515b37e588d0756a61cbf4cc35b3">cluster</a> (const <a class="el" href="class_p_h_v_1_1_field_slice.html">PHV::FieldSlice</a> &amp;slice) const</td></tr>
<tr class="separator:a0cea515b37e588d0756a61cbf4cc35b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b292c7b58be3ad9795b034140832cd" id="r_a01b292c7b58be3ad9795b034140832cd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const <a class="el" href="class_p_h_v_1_1_rotational_cluster.html">RotationalCluster</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01b292c7b58be3ad9795b034140832cd">clusters</a> () const</td></tr>
<tr class="separator:a01b292c7b58be3ad9795b034140832cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23747ca053d875d5ddbc6de939ceb6f9" id="r_a23747ca053d875d5ddbc6de939ceb6f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23747ca053d875d5ddbc6de939ceb6f9">contains</a> (const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *f) const override</td></tr>
<tr class="separator:a23747ca053d875d5ddbc6de939ceb6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f08dc6ff82f739c499ac91467b17db5" id="r_a1f08dc6ff82f739c499ac91467b17db5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f08dc6ff82f739c499ac91467b17db5">contains</a> (const <a class="el" href="class_p_h_v_1_1_field_slice.html">PHV::FieldSlice</a> &amp;slice) const override</td></tr>
<tr class="separator:a1f08dc6ff82f739c499ac91467b17db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afffcb20ac65809439691c89987c89866" id="r_afffcb20ac65809439691c89987c89866"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afffcb20ac65809439691c89987c89866">deparsed</a> () const override</td></tr>
<tr class="separator:afffcb20ac65809439691c89987c89866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18715cf7f45bdbb8c4bd63a8507b1732" id="r_a18715cf7f45bdbb8c4bd63a8507b1732"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18715cf7f45bdbb8c4bd63a8507b1732">exact_containers</a> () const override</td></tr>
<tr class="separator:a18715cf7f45bdbb8c4bd63a8507b1732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054e1f5330c1d0719586750864630b2c" id="r_a054e1f5330c1d0719586750864630b2c"><td class="memItemLeft" align="right" valign="top">SuperCluster::SliceList *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a054e1f5330c1d0719586750864630b2c">findLinkedWideArithSliceList</a> (const SuperCluster::SliceList *sl) const</td></tr>
<tr class="separator:a054e1f5330c1d0719586750864630b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d7c97c41b6d80d129319e4c841dff0" id="r_ac4d7c97c41b6d80d129319e4c841dff0"><td class="memItemLeft" align="right" valign="top"><a id="ac4d7c97c41b6d80d129319e4c841dff0" name="ac4d7c97c41b6d80d129319e4c841dff0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>forall_fieldslices</b> (const std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_field_slice.html">PHV::FieldSlice</a> &amp;)&gt; func) const</td></tr>
<tr class="memdesc:ac4d7c97c41b6d80d129319e4c841dff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply <code>func</code> on all field slices in this super cluster. <br /></td></tr>
<tr class="separator:ac4d7c97c41b6d80d129319e4c841dff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38accc025e422a2432a091e565b2b362" id="r_a38accc025e422a2432a091e565b2b362"><td class="memItemLeft" align="right" valign="top">gress_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38accc025e422a2432a091e565b2b362">gress</a> () const override</td></tr>
<tr class="separator:a38accc025e422a2432a091e565b2b362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976f5dbcdb094df7d1cd6b8abe480746" id="r_a976f5dbcdb094df7d1cd6b8abe480746"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a976f5dbcdb094df7d1cd6b8abe480746">is_deparser_zero_candidate</a> () const</td></tr>
<tr class="separator:a976f5dbcdb094df7d1cd6b8abe480746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a639a649ba54653a288d337033f84e089" id="r_a639a649ba54653a288d337033f84e089"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a639a649ba54653a288d337033f84e089">max_width</a> () const override</td></tr>
<tr class="separator:a639a649ba54653a288d337033f84e089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78eda49ca28ec9b4a13a4305562d9c4d" id="r_a78eda49ca28ec9b4a13a4305562d9c4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78eda49ca28ec9b4a13a4305562d9c4d">merge</a> (const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *sc1)</td></tr>
<tr class="separator:a78eda49ca28ec9b4a13a4305562d9c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c55dea2064339d049a9b2dad859b3d" id="r_ae0c55dea2064339d049a9b2dad859b3d"><td class="memItemLeft" align="right" valign="top"><a id="ae0c55dea2064339d049a9b2dad859b3d" name="ae0c55dea2064339d049a9b2dad859b3d"></a>
<a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>merge</b> (const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *sc1) const</td></tr>
<tr class="memdesc:ae0c55dea2064339d049a9b2dad859b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the merged supercluster. <br /></td></tr>
<tr class="separator:ae0c55dea2064339d049a9b2dad859b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e13218dffef89042bcc03bb052e570" id="r_a81e13218dffef89042bcc03bb052e570"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81e13218dffef89042bcc03bb052e570">mergeAndSortBasedOnWideArith</a> (const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *sc1) const</td></tr>
<tr class="separator:a81e13218dffef89042bcc03bb052e570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c86f44052a519db55fc4973f89416a" id="r_a16c86f44052a519db55fc4973f89416a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16c86f44052a519db55fc4973f89416a">needsStridedAlloc</a> () const</td></tr>
<tr class="separator:a16c86f44052a519db55fc4973f89416a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf63e94d1eaa30fae43add92f2f0e46b" id="r_aaf63e94d1eaa30fae43add92f2f0e46b"><td class="memItemLeft" align="right" valign="top"><a id="aaf63e94d1eaa30fae43add92f2f0e46b" name="aaf63e94d1eaa30fae43add92f2f0e46b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>needsStridedAlloc</b> (bool val)</td></tr>
<tr class="separator:aaf63e94d1eaa30fae43add92f2f0e46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaceb489c97eedad476b397e1ad8a74aa" id="r_aaceb489c97eedad476b397e1ad8a74aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaceb489c97eedad476b397e1ad8a74aa">needToMergeForWideArith</a> (const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *sc) const</td></tr>
<tr class="separator:aaceb489c97eedad476b397e1ad8a74aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29681bcbf6384e91c88b58317bca948" id="r_ad29681bcbf6384e91c88b58317bca948"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad29681bcbf6384e91c88b58317bca948">num_constraints</a> () const override</td></tr>
<tr class="separator:ad29681bcbf6384e91c88b58317bca948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bdbbf1c6adce11070231ff75ef37231" id="r_a8bdbbf1c6adce11070231ff75ef37231"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8bdbbf1c6adce11070231ff75ef37231">num_pack_conflicts</a> () const</td></tr>
<tr class="separator:a8bdbbf1c6adce11070231ff75ef37231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5938e6b44be1e0f73fd5443188e81900" id="r_a5938e6b44be1e0f73fd5443188e81900"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5938e6b44be1e0f73fd5443188e81900">okIn</a> (<a class="el" href="namespace_p_h_v.html#aba5418d9e37657e37eb63ee0aa0a435f">PHV::Kind</a> kind) const override</td></tr>
<tr class="separator:a5938e6b44be1e0f73fd5443188e81900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd27096e06aa110f69f55fd4df1e9b0" id="r_affd27096e06aa110f69f55fd4df1e9b0"><td class="memItemLeft" align="right" valign="top"><a id="affd27096e06aa110f69f55fd4df1e9b0" name="affd27096e06aa110f69f55fd4df1e9b0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> &amp;other) const</td></tr>
<tr class="memdesc:affd27096e06aa110f69f55fd4df1e9b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Semantic equality. <br /></td></tr>
<tr class="separator:affd27096e06aa110f69f55fd4df1e9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1fca3a40f7f1d55c2acd79b290c523d" id="r_ad1fca3a40f7f1d55c2acd79b290c523d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const SliceList * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1fca3a40f7f1d55c2acd79b290c523d">slice_list</a> (const <a class="el" href="class_p_h_v_1_1_field_slice.html">PHV::FieldSlice</a> &amp;slice) const</td></tr>
<tr class="separator:ad1fca3a40f7f1d55c2acd79b290c523d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa786cc9826446e15bb99007ae315d7d6" id="r_aa786cc9826446e15bb99007ae315d7d6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; SliceList * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa786cc9826446e15bb99007ae315d7d6">slice_lists</a> () const</td></tr>
<tr class="separator:aa786cc9826446e15bb99007ae315d7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db1027641aa8f7550ffd87e5c7fe178" id="r_a0db1027641aa8f7550ffd87e5c7fe178"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_field_slice.html">PHV::FieldSlice</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0db1027641aa8f7550ffd87e5c7fe178">slices</a> () const</td></tr>
<tr class="separator:a0db1027641aa8f7550ffd87e5c7fe178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_p_h_v_1_1_cluster_stats"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_class_p_h_v_1_1_cluster_stats')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_p_h_v_1_1_cluster_stats.html">PHV::ClusterStats</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae1afb96ab709ad0edf713ed5e5c419c7" id="r_ae1afb96ab709ad0edf713ed5e5c419c7"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1afb96ab709ad0edf713ed5e5c419c7">is_well_formed</a> (const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *sc, <a class="el" href="class_p_h_v_1_1_error.html">PHV::Error</a> *err=new <a class="el" href="class_p_h_v_1_1_error.html">PHV::Error</a>())</td></tr>
<tr class="separator:ae1afb96ab709ad0edf713ed5e5c419c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10753826dee1c8bb521b127f0dad104f" id="r_a10753826dee1c8bb521b127f0dad104f"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10753826dee1c8bb521b127f0dad104f">slice_list_exact_containers</a> (const SliceList &amp;list)</td></tr>
<tr class="separator:a10753826dee1c8bb521b127f0dad104f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a807137860df0a454af790ccbf7a7ba8a" id="r_a807137860df0a454af790ccbf7a7ba8a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a807137860df0a454af790ccbf7a7ba8a">slice_list_has_exact_containers</a> (const SliceList &amp;list)</td></tr>
<tr class="separator:a807137860df0a454af790ccbf7a7ba8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46abde2b826e753d528e8a0a7d8c5be6" id="r_a46abde2b826e753d528e8a0a7d8c5be6"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; SuperCluster::SliceList * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46abde2b826e753d528e8a0a7d8c5be6">slice_list_split_by_byte</a> (const SuperCluster::SliceList &amp;sl)</td></tr>
<tr class="separator:a46abde2b826e753d528e8a0a7d8c5be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1aab48c1058a0149b0be67945dd4626" id="r_ac1aab48c1058a0149b0be67945dd4626"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1aab48c1058a0149b0be67945dd4626">slice_list_total_bits</a> (const SliceList &amp;list)</td></tr>
<tr class="separator:ac1aab48c1058a0149b0be67945dd4626"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_attribs_class_p_h_v_1_1_cluster_stats"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_attribs_class_p_h_v_1_1_cluster_stats')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="class_p_h_v_1_1_cluster_stats.html">PHV::ClusterStats</a></td></tr>
<tr class="memitem:accb3c956f4a6cfff738e36219359f353 inherit pub_attribs_class_p_h_v_1_1_cluster_stats" id="r_accb3c956f4a6cfff738e36219359f353"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>uid</b> = nextId++</td></tr>
<tr class="separator:accb3c956f4a6cfff738e36219359f353 inherit pub_attribs_class_p_h_v_1_1_cluster_stats"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A group of rotational clusters that must be placed in the same MAU group of PHV containers.</p>
<p>Invariants on membership:</p><ul>
<li>every field slice in each slice list exists in exactly one aligned cluster, although the same slice may appear in multiple slice lists.</li>
<li>every aligned cluster exists in exactly one rotational cluster.</li>
<li>every rotational cluster exists in exactly one super cluster.</li>
</ul>
<p>Any attempt to place a SuperCluster into a container group will fail if:</p><ul>
<li>any slice is wider than the container size.</li>
<li>the aggregate width of any slice list is wider than the container size.</li>
</ul>
<p>Slicing a SuperCluster can fail if:</p><ul>
<li>a field slice would be split but has the <code>no_split</code> property.</li>
<li>two adjacent slices of the same field in a slice list would be split into different slice lists, but the field has the <code>no_split</code> property.</li>
</ul>
<p>Note that slice lists are formed from lists of header fields (among other things). In this case, the order of slices in the slice list is in little Endian, but headers are often written in big Endian order, and so the order in the slice list will appear reversed. </p><dl class="section see"><dt>See also</dt><dd>PHV::MakeSuperClusters in make_clusters.h for more details. </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="abed122a948a2f3a710c9973d0c03bd0e" name="abed122a948a2f3a710c9973d0c03bd0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abed122a948a2f3a710c9973d0c03bd0e">&#9670;&#160;</a></span>aggregate_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t PHV::SuperCluster::aggregate_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the aggregate size of all slices in all clusters in this group. </dd></dl>

<p>Implements <a class="el" href="class_p_h_v_1_1_cluster_stats.html#ab604772a7b4d5d24675565100d5288a3">PHV::ClusterStats</a>.</p>

</div>
</div>
<a id="ae46b4a321270e24fe190c9cfc9c8fa8a" name="ae46b4a321270e24fe190c9cfc9c8fa8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46b4a321270e24fe190c9cfc9c8fa8a">&#9670;&#160;</a></span>aligned_cluster()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_p_h_v_1_1_aligned_cluster.html">AlignedCluster</a> &amp; PHV::SuperCluster::aligned_cluster </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_field_slice.html">PHV::FieldSlice</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slice</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the aligned cluster containing <code>slice</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>fails catastrophicaly if <code>slice</code> is not in any cluster in this group; all slices in every slice list are guaranteed to be present in exactly one cluster. </dd></dl>

</div>
</div>
<a id="a1f9b2c569d483f1beefbfecaf04587b6" name="a1f9b2c569d483f1beefbfecaf04587b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f9b2c569d483f1beefbfecaf04587b6">&#9670;&#160;</a></span>any_of_fieldslices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PHV::SuperCluster::any_of_fieldslices </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="class_p_h_v_1_1_field_slice.html">PHV::FieldSlice</a> &amp;)&gt;</td>          <td class="paramname"><span class="paramname"><em>func</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if any_of <code>func</code> is true on a fieldslice. </dd></dl>

</div>
</div>
<a id="a0cea515b37e588d0756a61cbf4cc35b3" name="a0cea515b37e588d0756a61cbf4cc35b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cea515b37e588d0756a61cbf4cc35b3">&#9670;&#160;</a></span>cluster()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_p_h_v_1_1_rotational_cluster.html">RotationalCluster</a> &amp; PHV::SuperCluster::cluster </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_field_slice.html">PHV::FieldSlice</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slice</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the rotational cluster containing <code>slice</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>fails catastrophicaly if <code>slice</code> is not in any cluster in this group; all slices in every slice list are guaranteed to be present in exactly one cluster. </dd></dl>

</div>
</div>
<a id="a01b292c7b58be3ad9795b034140832cd" name="a01b292c7b58be3ad9795b034140832cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b292c7b58be3ad9795b034140832cd">&#9670;&#160;</a></span>clusters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const <a class="el" href="class_p_h_v_1_1_rotational_cluster.html">RotationalCluster</a> * &gt; &amp; PHV::SuperCluster::clusters </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the aligned clusters in this group. </dd></dl>

</div>
</div>
<a id="a23747ca053d875d5ddbc6de939ceb6f9" name="a23747ca053d875d5ddbc6de939ceb6f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23747ca053d875d5ddbc6de939ceb6f9">&#9670;&#160;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PHV::SuperCluster::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if this cluster contains <code>f</code>. </dd></dl>

<p>Implements <a class="el" href="class_p_h_v_1_1_cluster_stats.html#a81fa817e199890105109af86507a9363">PHV::ClusterStats</a>.</p>

</div>
</div>
<a id="a1f08dc6ff82f739c499ac91467b17db5" name="a1f08dc6ff82f739c499ac91467b17db5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f08dc6ff82f739c499ac91467b17db5">&#9670;&#160;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PHV::SuperCluster::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_field_slice.html">PHV::FieldSlice</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slice</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if this cluster contains <code>slice</code>. </dd></dl>

<p>Implements <a class="el" href="class_p_h_v_1_1_cluster_stats.html#a62f64ddc4f95187c95dbb7c1919d7ff5">PHV::ClusterStats</a>.</p>

</div>
</div>
<a id="afffcb20ac65809439691c89987c89866" name="afffcb20ac65809439691c89987c89866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afffcb20ac65809439691c89987c89866">&#9670;&#160;</a></span>deparsed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PHV::SuperCluster::deparsed </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if any slice in the cluster is deparsed (either to the wire or the TM). </dd></dl>

<p>Implements <a class="el" href="class_p_h_v_1_1_cluster_stats.html#a9f7eee9594316e17bbbd3eeafdc3aa8f">PHV::ClusterStats</a>.</p>

</div>
</div>
<a id="a18715cf7f45bdbb8c4bd63a8507b1732" name="a18715cf7f45bdbb8c4bd63a8507b1732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18715cf7f45bdbb8c4bd63a8507b1732">&#9670;&#160;</a></span>exact_containers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PHV::SuperCluster::exact_containers </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of clusters in this group with the exact_containers constraint. </dd></dl>

<p>Implements <a class="el" href="class_p_h_v_1_1_cluster_stats.html#a4097671344908914defecd629df5f445">PHV::ClusterStats</a>.</p>

</div>
</div>
<a id="a054e1f5330c1d0719586750864630b2c" name="a054e1f5330c1d0719586750864630b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a054e1f5330c1d0719586750864630b2c">&#9670;&#160;</a></span>findLinkedWideArithSliceList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PHV::SuperCluster::SliceList * PHV::SuperCluster::findLinkedWideArithSliceList </td>
          <td>(</td>
          <td class="paramtype">const SuperCluster::SliceList *</td>          <td class="paramname"><span class="paramname"><em>sl</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a SliceList within a SuperCluster, find its linked wide arithmetic SliceList. </p>

</div>
</div>
<a id="a38accc025e422a2432a091e565b2b362" name="a38accc025e422a2432a091e565b2b362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38accc025e422a2432a091e565b2b362">&#9670;&#160;</a></span>gress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">gress_t PHV::SuperCluster::gress </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the gress requirement of this cluster. </dd></dl>

<p>Implements <a class="el" href="class_p_h_v_1_1_cluster_stats.html#a7e547f9460949b091d1a2864cd711fd6">PHV::ClusterStats</a>.</p>

</div>
</div>
<a id="a976f5dbcdb094df7d1cd6b8abe480746" name="a976f5dbcdb094df7d1cd6b8abe480746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a976f5dbcdb094df7d1cd6b8abe480746">&#9670;&#160;</a></span>is_deparser_zero_candidate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PHV::SuperCluster::is_deparser_zero_candidate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if all field slices are deparser_zero_candidate. </dd></dl>

</div>
</div>
<a id="ae1afb96ab709ad0edf713ed5e5c419c7" name="ae1afb96ab709ad0edf713ed5e5c419c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1afb96ab709ad0edf713ed5e5c419c7">&#9670;&#160;</a></span>is_well_formed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PHV::SuperCluster::is_well_formed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *</td>          <td class="paramname"><span class="paramname"><em>sc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p_h_v_1_1_error.html">PHV::Error</a> *</td>          <td class="paramname"><span class="paramname"><em>err</em></span><span class="paramdefsep"> = </span><span class="paramdefval">new&#160;<a class="el" href="class_p_h_v_1_1_error.html">PHV::Error</a>()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if no structural constraints prevent this super cluster from fitting.</dd>
<dd>
true if all slices lists and slices are smaller than 32b and no slice list contains more than one slice per aligned cluster. TODO: Also check that slice lists with exact_container requirements are all the same size. We should check this ahead of time, though. TODO: Also check that deparsed bottom bits fields are at the front of their slice lists. </dd></dl>

</div>
</div>
<a id="a639a649ba54653a288d337033f84e089" name="a639a649ba54653a288d337033f84e089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a639a649ba54653a288d337033f84e089">&#9670;&#160;</a></span>max_width()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PHV::SuperCluster::max_width </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the width of the maximum slice in any cluster in this group. </dd></dl>

<p>Implements <a class="el" href="class_p_h_v_1_1_cluster_stats.html#a0af76d23ac2e86bdfa9ac0c59158ab8f">PHV::ClusterStats</a>.</p>

</div>
</div>
<a id="a78eda49ca28ec9b4a13a4305562d9c4d" name="a78eda49ca28ec9b4a13a4305562d9c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78eda49ca28ec9b4a13a4305562d9c4d">&#9670;&#160;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> * PHV::SuperCluster::merge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *</td>          <td class="paramname"><span class="paramname"><em>sc1</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a new SuperCluster object that is the union of the provided SuperCluster inputs. </dd></dl>

</div>
</div>
<a id="a81e13218dffef89042bcc03bb052e570" name="a81e13218dffef89042bcc03bb052e570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e13218dffef89042bcc03bb052e570">&#9670;&#160;</a></span>mergeAndSortBasedOnWideArith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p_h_v_1_1_super_cluster.html">PHV::SuperCluster</a> * PHV::SuperCluster::mergeAndSortBasedOnWideArith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *</td>          <td class="paramname"><span class="paramname"><em>sc1</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merge this SuperCluster with the input SuperCluster, and return a new SuperCluster. This function is only intended to be called when the two SuperClusters are linked by wide arithmetic allocation requirements. This function merges the slice lists such that slice lists that are paired by wide arithmetic requirements are adjacent in the list, and the slice list destined for an even container (the lo slice) appears before the slice list destined for an odd container (the hi slice). </p>

</div>
</div>
<a id="a16c86f44052a519db55fc4973f89416a" name="a16c86f44052a519db55fc4973f89416a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c86f44052a519db55fc4973f89416a">&#9670;&#160;</a></span>needsStridedAlloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PHV::SuperCluster::needsStridedAlloc </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if this super cluster needs strided allocation </dd></dl>

</div>
</div>
<a id="aaceb489c97eedad476b397e1ad8a74aa" name="aaceb489c97eedad476b397e1ad8a74aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaceb489c97eedad476b397e1ad8a74aa">&#9670;&#160;</a></span>needToMergeForWideArith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PHV::SuperCluster::needToMergeForWideArith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *</td>          <td class="paramname"><span class="paramname"><em>sc</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if two SuperClusters need to be merged, because they container hi/lo field slices that participate in a wide arithmetic operation. </dd></dl>

</div>
</div>
<a id="ad29681bcbf6384e91c88b58317bca948" name="ad29681bcbf6384e91c88b58317bca948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad29681bcbf6384e91c88b58317bca948">&#9670;&#160;</a></span>num_constraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PHV::SuperCluster::num_constraints </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the sum of constraints of all clusters in this group. </dd></dl>

<p>Implements <a class="el" href="class_p_h_v_1_1_cluster_stats.html#a7d506e0ed10c0b13292adf08a460037a">PHV::ClusterStats</a>.</p>

</div>
</div>
<a id="a8bdbbf1c6adce11070231ff75ef37231" name="a8bdbbf1c6adce11070231ff75ef37231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bdbbf1c6adce11070231ff75ef37231">&#9670;&#160;</a></span>num_pack_conflicts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t PHV::SuperCluster::num_pack_conflicts </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of pack conflicts of all slices in all clusters in this group. A pack conflict indicates that the field of a given slice cannot be packed with some other field referenced in the program. </dd></dl>

</div>
</div>
<a id="a5938e6b44be1e0f73fd5443188e81900" name="a5938e6b44be1e0f73fd5443188e81900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5938e6b44be1e0f73fd5443188e81900">&#9670;&#160;</a></span>okIn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PHV::SuperCluster::okIn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_p_h_v.html#aba5418d9e37657e37eb63ee0aa0a435f">PHV::Kind</a></td>          <td class="paramname"><span class="paramname"><em>kind</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if this cluster can be assigned to containers of kind <code>kind</code>. </dd></dl>

<p>Implements <a class="el" href="class_p_h_v_1_1_cluster_stats.html#a464adc74cac2d9fab80b0cf04942c647">PHV::ClusterStats</a>.</p>

</div>
</div>
<a id="ad1fca3a40f7f1d55c2acd79b290c523d" name="ad1fca3a40f7f1d55c2acd79b290c523d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1fca3a40f7f1d55c2acd79b290c523d">&#9670;&#160;</a></span>slice_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const PHV::SuperCluster::SliceList * &gt; &amp; PHV::SuperCluster::slice_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_field_slice.html">PHV::FieldSlice</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slice</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the slice lists holding <code>slice</code>. </dd></dl>

</div>
</div>
<a id="a10753826dee1c8bb521b127f0dad104f" name="a10753826dee1c8bb521b127f0dad104f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10753826dee1c8bb521b127f0dad104f">&#9670;&#160;</a></span>slice_list_exact_containers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> &gt; PHV::SuperCluster::slice_list_exact_containers </td>
          <td>(</td>
          <td class="paramtype">const SliceList &amp;</td>          <td class="paramname"><span class="paramname"><em>list</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the vector of le_bitrange instances identified for each PHV::FieldSlice </dd></dl>

</div>
</div>
<a id="a807137860df0a454af790ccbf7a7ba8a" name="a807137860df0a454af790ccbf7a7ba8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a807137860df0a454af790ccbf7a7ba8a">&#9670;&#160;</a></span>slice_list_has_exact_containers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PHV::SuperCluster::slice_list_has_exact_containers </td>
          <td>(</td>
          <td class="paramtype">const SliceList &amp;</td>          <td class="paramname"><span class="paramname"><em>list</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true iff the slice list has any exact container inside </dd></dl>

</div>
</div>
<a id="a46abde2b826e753d528e8a0a7d8c5be6" name="a46abde2b826e753d528e8a0a7d8c5be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46abde2b826e753d528e8a0a7d8c5be6">&#9670;&#160;</a></span>slice_list_split_by_byte()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; PHV::SuperCluster::SliceList * &gt; PHV::SuperCluster::slice_list_split_by_byte </td>
          <td>(</td>
          <td class="paramtype">const SuperCluster::SliceList &amp;</td>          <td class="paramname"><span class="paramname"><em>sl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a vector of slice list split by bytes with prepending alignment considered. </dd></dl>

</div>
</div>
<a id="ac1aab48c1058a0149b0be67945dd4626" name="ac1aab48c1058a0149b0be67945dd4626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1aab48c1058a0149b0be67945dd4626">&#9670;&#160;</a></span>slice_list_total_bits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PHV::SuperCluster::slice_list_total_bits </td>
          <td>(</td>
          <td class="paramtype">const SliceList &amp;</td>          <td class="paramname"><span class="paramname"><em>list</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the total bits in a <code>list</code> paramter </dd></dl>

</div>
</div>
<a id="aa786cc9826446e15bb99007ae315d7d6" name="aa786cc9826446e15bb99007ae315d7d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa786cc9826446e15bb99007ae315d7d6">&#9670;&#160;</a></span>slice_lists()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; SliceList * &gt; &amp; PHV::SuperCluster::slice_lists </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the slice lists that induced this grouping. </dd></dl>

</div>
</div>
<a id="a0db1027641aa8f7550ffd87e5c7fe178" name="a0db1027641aa8f7550ffd87e5c7fe178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0db1027641aa8f7550ffd87e5c7fe178">&#9670;&#160;</a></span>slices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_field_slice.html">PHV::FieldSlice</a> &gt; PHV::SuperCluster::slices </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>all field slices in this cluster </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.12.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_p_h_v.html">PHV</a></li><li class="navelem"><a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
