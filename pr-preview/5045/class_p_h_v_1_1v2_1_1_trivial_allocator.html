<!-- HTML header for doxygen 1.12.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>P4 Compiler Documentation (P4C): PHV::v2::TrivialAllocator Class Reference</title>
<link rel="icon" href="p4-fav.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!--  Add link to paragraphs   -->
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
  DoxygenAwesomeParagraphLink.init()
</script>
<!-- Add copy button to code fragments  -->
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
  DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add dark mode toggle -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
  DoxygenAwesomeDarkModeToggle.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="cards.css" rel="stylesheet" type="text/css"/>
<link href="flow.css" rel="stylesheet" type="text/css"/>
<link href="p4c_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="p4-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">P4C
   </div>
   <div id="projectbrief">The P4 Compiler</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_p_h_v_1_1v2_1_1_trivial_allocator.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_p_h_v_1_1v2_1_1_trivial_allocator-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">PHV::v2::TrivialAllocator Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="trivial__allocator_8h_source.html">trivial_allocator.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PHV::v2::TrivialAllocator:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_p_h_v_1_1v2_1_1_trivial_allocator__inherit__graph.svg" width="188" height="110"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_h_v_1_1v2_1_1_trivial_allocator_1_1_partial_alloc_result.html">PartialAllocResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_h_v_1_1v2_1_1_trivial_allocator_1_1_phv_status.html">PhvStatus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">PhvStatus bookkeeper for containers.  <a href="class_p_h_v_1_1v2_1_1_trivial_allocator_1_1_phv_status.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_p_h_v_1_1v2_1_1_trivial_allocator_1_1_pre_slicing_result" id="r_struct_p_h_v_1_1v2_1_1_trivial_allocator_1_1_pre_slicing_result"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#struct_p_h_v_1_1v2_1_1_trivial_allocator_1_1_pre_slicing_result">PreSlicingResult</a></td></tr>
<tr class="separator:struct_p_h_v_1_1v2_1_1_trivial_allocator_1_1_pre_slicing_result"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae346d8cf49eb64ddf37cca4069786602" id="r_ae346d8cf49eb64ddf37cca4069786602"><td class="memItemLeft" align="right" valign="top"><a id="ae346d8cf49eb64ddf37cca4069786602" name="ae346d8cf49eb64ddf37cca4069786602"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TrivialAllocator</b> (const <a class="el" href="struct_p_h_v_1_1v2_1_1_phv_kit.html">PhvKit</a> &amp;kit, <a class="el" href="class_phv_info.html">PhvInfo</a> &amp;phv, int pipe_id)</td></tr>
<tr class="separator:ae346d8cf49eb64ddf37cca4069786602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac45a229f519d13740e8343ee369125" id="r_a3ac45a229f519d13740e8343ee369125"><td class="memItemLeft" align="right" valign="top"><a id="a3ac45a229f519d13740e8343ee369125" name="a3ac45a229f519d13740e8343ee369125"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>allocate</b> (const std::list&lt; <a class="el" href="class_p_h_v_1_1_super_cluster.html">PHV::SuperCluster</a> * &gt; &amp;clusters, <a class="el" href="class_p_h_v_1_1v2_1_1_allocator_metrics.html">AllocatorMetrics</a> &amp;alloc_metrics)</td></tr>
<tr class="memdesc:a3ac45a229f519d13740e8343ee369125"><td class="mdescLeft">&#160;</td><td class="mdescRight">run trivial PHV allocator to allocate all <code>clusters</code> and update phv_i. <br /></td></tr>
<tr class="separator:a3ac45a229f519d13740e8343ee369125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e98262aad527bb68bbfc3eb03143483" id="r_a0e98262aad527bb68bbfc3eb03143483"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e98262aad527bb68bbfc3eb03143483">can_be_allocated</a> (const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;empty_alloc, const <a class="el" href="class_p_h_v_1_1_super_cluster.html">PHV::SuperCluster</a> *sc, <a class="el" href="class_p_h_v_1_1v2_1_1_allocator_metrics.html">AllocatorMetrics</a> &amp;alloc_metrics, const int max_slicings=128) const</td></tr>
<tr class="separator:a0e98262aad527bb68bbfc3eb03143483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe73f2b63f5cda38a5e6091702297ec" id="r_aebe73f2b63f5cda38a5e6091702297ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#struct_p_h_v_1_1v2_1_1_trivial_allocator_1_1_pre_slicing_result">PreSlicingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebe73f2b63f5cda38a5e6091702297ec">pre_slice</a> (const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;empty_alloc, <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *sc, <a class="el" href="class_p_h_v_1_1v2_1_1_allocator_metrics.html">AllocatorMetrics</a> &amp;alloc_metrics, const int n_max_slicing=128, bool baseline_mode=false) const</td></tr>
<tr class="separator:aebe73f2b63f5cda38a5e6091702297ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad376c144c72cd64a835776c74e62196b" id="r_ad376c144c72cd64a835776c74e62196b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_p_h_v_1_1v2_1_1_trivial_allocator_1_1_partial_alloc_result.html">PartialAllocResult</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad376c144c72cd64a835776c74e62196b">slice_and_allocate_sc</a> (const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;empty_alloc, const <a class="el" href="class_p_h_v_1_1_super_cluster.html">PHV::SuperCluster</a> *sc, <a class="el" href="class_p_h_v_1_1v2_1_1_trivial_allocator_1_1_phv_status.html">PhvStatus</a> phv_status, const ContainerGroupsBySize &amp;container_groups, <a class="el" href="class_p_h_v_1_1v2_1_1_allocator_metrics.html">AllocatorMetrics</a> &amp;alloc_metrics, bool homogeneous_sizes=false, bool minimal_packing_slicing=true, const int max_slicings=128, std::ostream *history=nullptr) const</td></tr>
<tr class="separator:ad376c144c72cd64a835776c74e62196b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_p_h_v_1_1v2_1_1_allocator_base"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_class_p_h_v_1_1v2_1_1_allocator_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_p_h_v_1_1v2_1_1_allocator_base.html">PHV::v2::AllocatorBase</a></td></tr>
<tr class="memitem:a3754ab089e8ae1c76dd69fd4ea515f9e inherit pub_methods_class_p_h_v_1_1v2_1_1_allocator_base" id="r_a3754ab089e8ae1c76dd69fd4ea515f9e"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>AllocatorBase</b> (const <a class="el" href="struct_p_h_v_1_1v2_1_1_phv_kit.html">PhvKit</a> &amp;kit)</td></tr>
<tr class="separator:a3754ab089e8ae1c76dd69fd4ea515f9e inherit pub_methods_class_p_h_v_1_1v2_1_1_allocator_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5745d0e64c03b0fe67871fb211d65ab inherit pub_methods_class_p_h_v_1_1v2_1_1_allocator_base" id="r_aa5745d0e64c03b0fe67871fb211d65ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p_h_v_1_1_transaction.html">PHV::Transaction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_h_v_1_1v2_1_1_allocator_base.html#aa5745d0e64c03b0fe67871fb211d65ab">alloc_deparser_zero_cluster</a> (const <a class="el" href="class_p_h_v_1_1v2_1_1_score_context.html">ScoreContext</a> &amp;ctx, const <a class="el" href="class_p_h_v_1_1_allocation.html">PHV::Allocation</a> &amp;alloc, const <a class="el" href="class_p_h_v_1_1_super_cluster.html">PHV::SuperCluster</a> *sc, <a class="el" href="class_phv_info.html">PhvInfo</a> &amp;phv) const</td></tr>
<tr class="separator:aa5745d0e64c03b0fe67871fb211d65ab inherit pub_methods_class_p_h_v_1_1v2_1_1_allocator_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0eed40f5f4c367101599a90fb8f2ded inherit pub_methods_class_p_h_v_1_1v2_1_1_allocator_base" id="r_ac0eed40f5f4c367101599a90fb8f2ded"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_p_h_v_1_1v2_1_1_alloc_result.html">AllocResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_h_v_1_1v2_1_1_allocator_base.html#ac0eed40f5f4c367101599a90fb8f2ded">alloc_strided_super_clusters</a> (const <a class="el" href="class_p_h_v_1_1v2_1_1_score_context.html">ScoreContext</a> &amp;ctx, const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;alloc, const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *sc, const ContainerGroupsBySize &amp;groups, <a class="el" href="class_p_h_v_1_1v2_1_1_allocator_metrics.html">AllocatorMetrics</a> &amp;alloc_metrics, const int max_n_slicings=64) const</td></tr>
<tr class="separator:ac0eed40f5f4c367101599a90fb8f2ded inherit pub_methods_class_p_h_v_1_1v2_1_1_allocator_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39381cf2e304bb5c2eab40bd8e8be7a5 inherit pub_methods_class_p_h_v_1_1v2_1_1_allocator_base" id="r_a39381cf2e304bb5c2eab40bd8e8be7a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_p_h_v_1_1v2_1_1_alloc_result.html">AllocResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_h_v_1_1v2_1_1_allocator_base.html#a39381cf2e304bb5c2eab40bd8e8be7a5">try_sliced_super_cluster</a> (const <a class="el" href="class_p_h_v_1_1v2_1_1_score_context.html">ScoreContext</a> &amp;ctx, const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;alloc, const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *sc, const ContainerGroupsBySize &amp;groups, <a class="el" href="class_p_h_v_1_1v2_1_1_allocator_metrics.html">AllocatorMetrics</a> &amp;alloc_metrics) const</td></tr>
<tr class="memdesc:a39381cf2e304bb5c2eab40bd8e8be7a5 inherit pub_methods_class_p_h_v_1_1v2_1_1_allocator_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">ALLOCATION functions common to trivial and greedy allocation.  <br /></td></tr>
<tr class="separator:a39381cf2e304bb5c2eab40bd8e8be7a5 inherit pub_methods_class_p_h_v_1_1v2_1_1_allocator_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_types_class_p_h_v_1_1v2_1_1_allocator_base"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_types_class_p_h_v_1_1v2_1_1_allocator_base')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="class_p_h_v_1_1v2_1_1_allocator_base.html">PHV::v2::AllocatorBase</a></td></tr>
<tr class="memitem:aee78b3f77214bcdcfce8b32e9343f04f inherit pro_types_class_p_h_v_1_1v2_1_1_allocator_base" id="r_aee78b3f77214bcdcfce8b32e9343f04f"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>DfsAllocCb</b> = std::function&lt;bool(const <a class="el" href="class_p_h_v_1_1_transaction.html">Transaction</a> &amp;)&gt;</td></tr>
<tr class="memdesc:aee78b3f77214bcdcfce8b32e9343f04f inherit pro_types_class_p_h_v_1_1v2_1_1_allocator_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal type of callback. <br /></td></tr>
<tr class="separator:aee78b3f77214bcdcfce8b32e9343f04f inherit pro_types_class_p_h_v_1_1v2_1_1_allocator_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_p_h_v_1_1v2_1_1_allocator_base"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_class_p_h_v_1_1v2_1_1_allocator_base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_p_h_v_1_1v2_1_1_allocator_base.html">PHV::v2::AllocatorBase</a></td></tr>
<tr class="memitem:a37cd280273f8de614f615700f4bb3df9 inherit pro_methods_class_p_h_v_1_1v2_1_1_allocator_base" id="r_a37cd280273f8de614f615700f4bb3df9"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="struct_p_h_v_1_1v2_1_1_alloc_result.html">AllocResult</a>&#160;</td><td class="memItemRight" valign="bottom"><b>alloc_stride</b> (const <a class="el" href="class_p_h_v_1_1v2_1_1_score_context.html">ScoreContext</a> &amp;ctx, const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;alloc, const std::vector&lt; <a class="el" href="class_p_h_v_1_1_field_slice.html">FieldSlice</a> &gt; &amp;stride, const ContainerGroupsBySize &amp;groups, <a class="el" href="class_p_h_v_1_1v2_1_1_allocator_metrics.html">AllocatorMetrics</a> &amp;alloc_metrics) const</td></tr>
<tr class="separator:a37cd280273f8de614f615700f4bb3df9 inherit pro_methods_class_p_h_v_1_1v2_1_1_allocator_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaac0a080923600c9038bcd82c2873c8 inherit pro_methods_class_p_h_v_1_1v2_1_1_allocator_base" id="r_aeaac0a080923600c9038bcd82c2873c8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_p_h_v_1_1v2_1_1_alloc_error.html">AllocError</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_h_v_1_1v2_1_1_allocator_base.html#aeaac0a080923600c9038bcd82c2873c8">check_container_scope_constraints</a> (const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;alloc, const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &gt; &amp;candidates, const <a class="el" href="class_p_h_v_1_1_container.html">Container</a> &amp;c) const</td></tr>
<tr class="separator:aeaac0a080923600c9038bcd82c2873c8 inherit pro_methods_class_p_h_v_1_1v2_1_1_allocator_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060368723f64ebb31bcdc0a5b26c8f01 inherit pro_methods_class_p_h_v_1_1v2_1_1_allocator_base" id="r_a060368723f64ebb31bcdc0a5b26c8f01"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="namespace_p_h_v.html#a3ff115c4ef9dcfb7a3565ddc263f0ece">PHV::Size</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_h_v_1_1v2_1_1_allocator_base.html#a060368723f64ebb31bcdc0a5b26c8f01">compute_valid_container_sizes</a> (const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *sc) const</td></tr>
<tr class="separator:a060368723f64ebb31bcdc0a5b26c8f01 inherit pro_methods_class_p_h_v_1_1v2_1_1_allocator_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa39be8a2bcdc418e990e4c8009b420 inherit pro_methods_class_p_h_v_1_1v2_1_1_allocator_base" id="r_a0fa39be8a2bcdc418e990e4c8009b420"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_p_h_v_1_1v2_1_1_alloc_error.html">AllocError</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_h_v_1_1v2_1_1_allocator_base.html#a0fa39be8a2bcdc418e990e4c8009b420">is_container_bytes_ok</a> (const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;alloc, const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &gt; &amp;candidates, const <a class="el" href="class_p_h_v_1_1_container.html">Container</a> &amp;c) const</td></tr>
<tr class="separator:a0fa39be8a2bcdc418e990e4c8009b420 inherit pro_methods_class_p_h_v_1_1v2_1_1_allocator_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a874e205e39a00ab516aeac0533462052 inherit pro_methods_class_p_h_v_1_1v2_1_1_allocator_base" id="r_a874e205e39a00ab516aeac0533462052"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_p_h_v_1_1v2_1_1_alloc_error.html">AllocError</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_h_v_1_1v2_1_1_allocator_base.html#a874e205e39a00ab516aeac0533462052">is_container_gress_ok</a> (const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;alloc, const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &amp;sl, const <a class="el" href="class_p_h_v_1_1_container.html">Container</a> &amp;c) const</td></tr>
<tr class="separator:a874e205e39a00ab516aeac0533462052 inherit pro_methods_class_p_h_v_1_1v2_1_1_allocator_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d9480df75fd7754233358510e79b5b inherit pro_methods_class_p_h_v_1_1v2_1_1_allocator_base" id="r_a55d9480df75fd7754233358510e79b5b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_p_h_v_1_1v2_1_1_alloc_error.html">AllocError</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_h_v_1_1v2_1_1_allocator_base.html#a55d9480df75fd7754233358510e79b5b">is_container_solitary_ok</a> (const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;alloc, const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &amp;candidate, const <a class="el" href="class_p_h_v_1_1_container.html">Container</a> &amp;c) const</td></tr>
<tr class="separator:a55d9480df75fd7754233358510e79b5b inherit pro_methods_class_p_h_v_1_1v2_1_1_allocator_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d61123d926efc9b603d211fbf86cee inherit pro_methods_class_p_h_v_1_1v2_1_1_allocator_base" id="r_ae6d61123d926efc9b603d211fbf86cee"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_p_h_v_1_1v2_1_1_alloc_error.html">AllocError</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_h_v_1_1v2_1_1_allocator_base.html#ae6d61123d926efc9b603d211fbf86cee">is_container_type_ok</a> (const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &amp;sl, const <a class="el" href="class_p_h_v_1_1_container.html">Container</a> &amp;c) const</td></tr>
<tr class="memdesc:ae6d61123d926efc9b603d211fbf86cee inherit pro_methods_class_p_h_v_1_1v2_1_1_allocator_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">CONSTRAINT CHECKING Functions common to trivial and greedy allocation.  <br /></td></tr>
<tr class="separator:ae6d61123d926efc9b603d211fbf86cee inherit pro_methods_class_p_h_v_1_1v2_1_1_allocator_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9154a1de0ac22d117a8697c5cf380bf inherit pro_methods_class_p_h_v_1_1v2_1_1_allocator_base" id="r_ab9154a1de0ac22d117a8697c5cf380bf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_p_h_v_1_1v2_1_1_alloc_error.html">AllocError</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_h_v_1_1v2_1_1_allocator_base.html#ab9154a1de0ac22d117a8697c5cf380bf">is_container_write_mode_ok</a> (const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;alloc, const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &amp;sl, const <a class="el" href="class_p_h_v_1_1_container.html">Container</a> &amp;c) const</td></tr>
<tr class="separator:ab9154a1de0ac22d117a8697c5cf380bf inherit pro_methods_class_p_h_v_1_1v2_1_1_allocator_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb4332040f2167739065956e9048a32 inherit pro_methods_class_p_h_v_1_1v2_1_1_allocator_base" id="r_a1cb4332040f2167739065956e9048a32"><td class="memItemLeft" align="right" valign="top">std::vector&lt; const SuperCluster::SliceList * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_h_v_1_1v2_1_1_allocator_base.html#a1cb4332040f2167739065956e9048a32">make_alloc_order</a> (const <a class="el" href="class_p_h_v_1_1v2_1_1_score_context.html">ScoreContext</a> &amp;ctx, const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *sc, const <a class="el" href="namespace_p_h_v.html#a3ff115c4ef9dcfb7a3565ddc263f0ece">PHV::Size</a> width) const</td></tr>
<tr class="separator:a1cb4332040f2167739065956e9048a32 inherit pro_methods_class_p_h_v_1_1v2_1_1_allocator_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c34f31dc4dcc0af7b630cb8f0155fd inherit pro_methods_class_p_h_v_1_1v2_1_1_allocator_base" id="r_a53c34f31dc4dcc0af7b630cb8f0155fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p_h_v_1_1_transaction.html">Transaction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_h_v_1_1v2_1_1_allocator_base.html#a53c34f31dc4dcc0af7b630cb8f0155fd">make_speculated_alloc</a> (const <a class="el" href="class_p_h_v_1_1v2_1_1_score_context.html">ScoreContext</a> &amp;ctx, const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;alloc, const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *sc, const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &gt; &amp;candidates, const <a class="el" href="class_p_h_v_1_1_container.html">Container</a> &amp;candidates_cont) const</td></tr>
<tr class="separator:a53c34f31dc4dcc0af7b630cb8f0155fd inherit pro_methods_class_p_h_v_1_1v2_1_1_allocator_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58a8c2ef56c1493bed01d530ec02eab inherit pro_methods_class_p_h_v_1_1v2_1_1_allocator_base" id="r_ac58a8c2ef56c1493bed01d530ec02eab"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_h_v_1_1v2_1_1_allocator_base.html#ac58a8c2ef56c1493bed01d530ec02eab">make_start_positions</a> (const <a class="el" href="class_p_h_v_1_1v2_1_1_score_context.html">ScoreContext</a> &amp;ctx, const SuperCluster::SliceList *sl, const <a class="el" href="namespace_p_h_v.html#a3ff115c4ef9dcfb7a3565ddc263f0ece">PHV::Size</a> width) const</td></tr>
<tr class="separator:ac58a8c2ef56c1493bed01d530ec02eab inherit pro_methods_class_p_h_v_1_1v2_1_1_allocator_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4507a5a412176d3195393265cd685d inherit pro_methods_class_p_h_v_1_1v2_1_1_allocator_base" id="r_a3c4507a5a412176d3195393265cd685d"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="class_p_h_v_1_1_transaction.html">Transaction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_h_v_1_1v2_1_1_allocator_base.html#a3c4507a5a412176d3195393265cd685d">try_hints</a> (const <a class="el" href="class_p_h_v_1_1v2_1_1_score_context.html">ScoreContext</a> &amp;ctx, const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;alloc, const <a class="el" href="class_p_h_v_1_1_container_group.html">ContainerGroup</a> &amp;group, const <a class="el" href="class_p4_1_1ordered__map.html">ActionSourceCoPackMap</a> &amp;action_hints_map, <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_field_slice.html">PHV::FieldSlice</a> &gt; &amp;allocated, <a class="el" href="struct_p_h_v_1_1v2_1_1_sc_alloc_alignment.html">ScAllocAlignment</a> &amp;hint_enforced_alignments, <a class="el" href="class_p_h_v_1_1v2_1_1_allocator_metrics.html">AllocatorMetrics</a> &amp;alloc_metrics) const</td></tr>
<tr class="separator:a3c4507a5a412176d3195393265cd685d inherit pro_methods_class_p_h_v_1_1v2_1_1_allocator_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed7d89a4550ed4684cc8d65e63f96cc inherit pro_methods_class_p_h_v_1_1v2_1_1_allocator_base" id="r_aaed7d89a4550ed4684cc8d65e63f96cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_p_h_v_1_1v2_1_1_some_cont_scope_alloc_result.html">SomeContScopeAllocResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_h_v_1_1v2_1_1_allocator_base.html#aaed7d89a4550ed4684cc8d65e63f96cc">try_slices_adapter</a> (const <a class="el" href="class_p_h_v_1_1v2_1_1_score_context.html">ScoreContext</a> &amp;ctx, const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;alloc, const <a class="el" href="class_p4_1_1ordered__map.html">FieldSliceAllocStartMap</a> &amp;fs_starts, const <a class="el" href="class_p_h_v_1_1_container_group.html">ContainerGroup</a> &amp;group, std::optional&lt; <a class="el" href="class_p_h_v_1_1_container.html">Container</a> &gt; c, <a class="el" href="class_p_h_v_1_1v2_1_1_allocator_metrics.html">AllocatorMetrics</a> &amp;alloc_metrics) const</td></tr>
<tr class="separator:aaed7d89a4550ed4684cc8d65e63f96cc inherit pro_methods_class_p_h_v_1_1v2_1_1_allocator_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33a6c927f57ff3a2757dc94d4e5491d inherit pro_methods_class_p_h_v_1_1v2_1_1_allocator_base" id="r_aa33a6c927f57ff3a2757dc94d4e5491d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_p_h_v_1_1v2_1_1_cont_scope_alloc_result.html">ContScopeAllocResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_h_v_1_1v2_1_1_allocator_base.html#aa33a6c927f57ff3a2757dc94d4e5491d">try_slices_to_container</a> (const <a class="el" href="class_p_h_v_1_1v2_1_1_score_context.html">ScoreContext</a> &amp;ctx, const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;alloc, const <a class="el" href="class_p4_1_1ordered__map.html">FieldSliceAllocStartMap</a> &amp;fs_starts, const <a class="el" href="class_p_h_v_1_1_container.html">Container</a> &amp;c, <a class="el" href="class_p_h_v_1_1v2_1_1_allocator_metrics.html">AllocatorMetrics</a> &amp;alloc_metrics, const bool skip_mau_checks=false) const</td></tr>
<tr class="separator:aa33a6c927f57ff3a2757dc94d4e5491d inherit pro_methods_class_p_h_v_1_1v2_1_1_allocator_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf7ea3a442d4d717499e510b81fdc460 inherit pro_methods_class_p_h_v_1_1v2_1_1_allocator_base" id="r_adf7ea3a442d4d717499e510b81fdc460"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_p_h_v_1_1v2_1_1_some_cont_scope_alloc_result.html">SomeContScopeAllocResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_h_v_1_1v2_1_1_allocator_base.html#adf7ea3a442d4d717499e510b81fdc460">try_slices_to_container_group</a> (const <a class="el" href="class_p_h_v_1_1v2_1_1_score_context.html">ScoreContext</a> &amp;ctx, const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;alloc, const <a class="el" href="class_p4_1_1ordered__map.html">FieldSliceAllocStartMap</a> &amp;fs_starts, const <a class="el" href="class_p_h_v_1_1_container_group.html">ContainerGroup</a> &amp;group, <a class="el" href="class_p_h_v_1_1v2_1_1_allocator_metrics.html">AllocatorMetrics</a> &amp;alloc_metrics) const</td></tr>
<tr class="separator:adf7ea3a442d4d717499e510b81fdc460 inherit pro_methods_class_p_h_v_1_1v2_1_1_allocator_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fdb425138ff0ee6cfb28bfa83002661 inherit pro_methods_class_p_h_v_1_1v2_1_1_allocator_base" id="r_a8fdb425138ff0ee6cfb28bfa83002661"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_p_h_v_1_1v2_1_1_alloc_result.html">AllocResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_h_v_1_1v2_1_1_allocator_base.html#a8fdb425138ff0ee6cfb28bfa83002661">try_super_cluster_to_container_group</a> (const <a class="el" href="class_p_h_v_1_1v2_1_1_score_context.html">ScoreContext</a> &amp;ctx, const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;alloc, const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *sc, const <a class="el" href="class_p_h_v_1_1_container_group.html">ContainerGroup</a> &amp;group, <a class="el" href="class_p_h_v_1_1v2_1_1_allocator_metrics.html">AllocatorMetrics</a> &amp;alloc_metrics) const</td></tr>
<tr class="separator:a8fdb425138ff0ee6cfb28bfa83002661 inherit pro_methods_class_p_h_v_1_1v2_1_1_allocator_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4b2f42fd2c1837d5ed098a51b2520a inherit pro_methods_class_p_h_v_1_1v2_1_1_allocator_base" id="r_ade4b2f42fd2c1837d5ed098a51b2520a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_p_h_v_1_1v2_1_1_alloc_result.html">AllocResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_h_v_1_1v2_1_1_allocator_base.html#ade4b2f42fd2c1837d5ed098a51b2520a">try_wide_arith_slices_to_container_group</a> (const <a class="el" href="class_p_h_v_1_1v2_1_1_score_context.html">ScoreContext</a> &amp;ctx, const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;alloc, const <a class="el" href="struct_p_h_v_1_1v2_1_1_sc_alloc_alignment.html">ScAllocAlignment</a> &amp;alignment, const SuperCluster::SliceList *lo, const SuperCluster::SliceList *hi, const <a class="el" href="class_p_h_v_1_1_container_group.html">ContainerGroup</a> &amp;group, <a class="el" href="class_p_h_v_1_1v2_1_1_allocator_metrics.html">AllocatorMetrics</a> &amp;alloc_metrics) const</td></tr>
<tr class="separator:ade4b2f42fd2c1837d5ed098a51b2520a inherit pro_methods_class_p_h_v_1_1v2_1_1_allocator_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453ba4a9aa4dca3f9ee6394697a0fc03 inherit pro_methods_class_p_h_v_1_1v2_1_1_allocator_base" id="r_a453ba4a9aa4dca3f9ee6394697a0fc03"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_p_h_v_1_1v2_1_1_alloc_error.html">AllocError</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_h_v_1_1v2_1_1_allocator_base.html#a453ba4a9aa4dca3f9ee6394697a0fc03">verify_can_pack</a> (const <a class="el" href="class_p_h_v_1_1v2_1_1_score_context.html">ScoreContext</a> &amp;ctx, const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;alloc, const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *sc, const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &gt; &amp;candidates, const <a class="el" href="class_p_h_v_1_1_container.html">Container</a> &amp;c, <a class="el" href="class_p4_1_1ordered__map.html">ActionSourceCoPackMap</a> &amp;co_pack_hints) const</td></tr>
<tr class="separator:a453ba4a9aa4dca3f9ee6394697a0fc03 inherit pro_methods_class_p_h_v_1_1v2_1_1_allocator_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_p_h_v_1_1v2_1_1_allocator_base"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_attribs_class_p_h_v_1_1v2_1_1_allocator_base')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_p_h_v_1_1v2_1_1_allocator_base.html">PHV::v2::AllocatorBase</a></td></tr>
<tr class="memitem:acf366ea67a6166f61a4d2477ccf57e52 inherit pro_attribs_class_p_h_v_1_1v2_1_1_allocator_base" id="r_acf366ea67a6166f61a4d2477ccf57e52"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="struct_p_h_v_1_1v2_1_1_phv_kit.html">PhvKit</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>kit_i</b></td></tr>
<tr class="separator:acf366ea67a6166f61a4d2477ccf57e52 inherit pro_attribs_class_p_h_v_1_1v2_1_1_allocator_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>TrivialAllocator allocates PHV fields to an infinite long PHV. It is in two cases: (1) trivial allocation before table placement. (2) check whether all constraints can be satisfied. </p>
</div><hr/><h2 class="groupheader">Class Documentation</h2>
<a name="struct_p_h_v_1_1v2_1_1_trivial_allocator_1_1_pre_slicing_result" id="struct_p_h_v_1_1v2_1_1_trivial_allocator_1_1_pre_slicing_result"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_p_h_v_1_1v2_1_1_trivial_allocator_1_1_pre_slicing_result">&#9670;&#160;</a></span>PHV::v2::TrivialAllocator::PreSlicingResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct PHV::v2::TrivialAllocator::PreSlicingResult</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>result of pre-slicing will always have a set of sliced super cluster. If any sliced super cluster failed to pass can_be_allocated verification, the first one will be saved to invalid. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a9dfb2601f6424cd474d00b0fbd9475b9" name="a9dfb2601f6424cd474d00b0fbd9475b9"></a><a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt; <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *, <a class="el" href="struct_p_h_v_1_1v2_1_1_kind_size_indexed_map.html">KindSizeIndexedMap</a> &gt;</td>
<td class="fieldname">
baseline_cont_req</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a674948c400925a70a320ac59db35013d" name="a674948c400925a70a320ac59db35013d"></a>const <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *</td>
<td class="fieldname">
invalid = nullptr</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="ac2a00e5519e4fcece33377e7cf665730" name="ac2a00e5519e4fcece33377e7cf665730"></a>list&lt; <a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> * &gt;</td>
<td class="fieldname">
sliced</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0e98262aad527bb68bbfc3eb03143483" name="a0e98262aad527bb68bbfc3eb03143483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e98262aad527bb68bbfc3eb03143483">&#9670;&#160;</a></span>can_be_allocated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PHV::v2::TrivialAllocator::can_be_allocated </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>empty_alloc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_super_cluster.html">PHV::SuperCluster</a> *</td>          <td class="paramname"><span class="paramname"><em>sc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p_h_v_1_1v2_1_1_allocator_metrics.html">AllocatorMetrics</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc_metrics</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>max_slicings</em></span><span class="paramdefsep"> = </span><span class="paramdefval">128</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if <code>sc</code> can be allocated to <code>empty_alloc</code>, assuming there are infinite containers. Use this verify whether there is any unsat constraint in <code>sc</code>. </dd></dl>

</div>
</div>
<a id="aebe73f2b63f5cda38a5e6091702297ec" name="aebe73f2b63f5cda38a5e6091702297ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe73f2b63f5cda38a5e6091702297ec">&#9670;&#160;</a></span>pre_slice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#struct_p_h_v_1_1v2_1_1_trivial_allocator_1_1_pre_slicing_result">TrivialAllocator::PreSlicingResult</a> PHV::v2::TrivialAllocator::pre_slice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>empty_alloc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p_h_v_1_1_super_cluster.html">SuperCluster</a> *</td>          <td class="paramname"><span class="paramname"><em>sc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p_h_v_1_1v2_1_1_allocator_metrics.html">AllocatorMetrics</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc_metrics</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>n_max_slicing</em></span><span class="paramdefsep"> = </span><span class="paramdefval">128</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>baseline_mode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>result of sliced cluster from <code>sc</code> with the minimal number of slicing (try to maximize packing). This function will try to ensure that all the returned super clusters can be allocated, without violating any constraints, by calling can_be_allocated to verify before return. However, there can by cases that either we are not lucky enough or there are conflicting constraints, the <code>sc</code> cannot be split to allocatable clusters. In those cases, we will just return the last slicing we found. </dd></dl>

</div>
</div>
<a id="ad376c144c72cd64a835776c74e62196b" name="ad376c144c72cd64a835776c74e62196b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad376c144c72cd64a835776c74e62196b">&#9670;&#160;</a></span>slice_and_allocate_sc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_p_h_v_1_1v2_1_1_trivial_allocator_1_1_partial_alloc_result.html">TrivialAllocator::PartialAllocResult</a> * PHV::v2::TrivialAllocator::slice_and_allocate_sc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>empty_alloc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_super_cluster.html">PHV::SuperCluster</a> *</td>          <td class="paramname"><span class="paramname"><em>sc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p_h_v_1_1v2_1_1_trivial_allocator_1_1_phv_status.html">PhvStatus</a></td>          <td class="paramname"><span class="paramname"><em>phv_status</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerGroupsBySize &amp;</td>          <td class="paramname"><span class="paramname"><em>container_groups</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p_h_v_1_1v2_1_1_allocator_metrics.html">AllocatorMetrics</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc_metrics</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>homogeneous_sizes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>minimal_packing_slicing</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>max_slicings</em></span><span class="paramdefsep"> = </span><span class="paramdefval">128</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *</td>          <td class="paramname"><span class="paramname"><em>history</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a PartialAllocResult that contains alloc_slices of an updated phv status when allocation succeeded. If allocation failed, PartialResult of an error that contains the best effort diagnose result will be returned. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.12.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_p_h_v.html">PHV</a></li><li class="navelem"><b>v2</b></li><li class="navelem"><a class="el" href="class_p_h_v_1_1v2_1_1_trivial_allocator.html">TrivialAllocator</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
