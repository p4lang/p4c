<!-- HTML header for doxygen 1.12.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>P4C: PSA implementation for eBPF backend</title>
<link rel="icon" href="p4-fav.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!--  Add link to paragraphs   -->
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
  DoxygenAwesomeParagraphLink.init()
</script>
<!-- Add copy button to code fragments  -->
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
  DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add dark mode toggle -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
  DoxygenAwesomeDarkModeToggle.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="cards.css" rel="stylesheet" type="text/css"/>
<link href="flow.css" rel="stylesheet" type="text/css"/>
<link href="p4c_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="p4-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">P4C
   </div>
   <div id="projectbrief">The P4 Compiler</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md__2home_2runner_2work_2p4c_2p4c_2backends_2ebpf_2psa_2_r_e_a_d_m_e.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">PSA implementation for eBPF backend</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="psa-implementation-for-ebpf-backend"></a></p>
<p>This directory implements PSA (Portable Switch Architecture) for the eBPF backend.</p>
<h1><a class="anchor" id="prerequisites"></a>
Prerequisites</h1>
<ul>
<li>Refer to the <a href="https://docs.cilium.io/en/latest/bpf/">Cilium docs</a> to learn more about eBPF.</li>
<li>This guide assumes at least basic familiarity with <a href="https://p4.org/p4-spec/docs/PSA.html">the PSA specification</a>.</li>
<li>The PSA implementation inherits some mechanisms (e.g. generation of Parser and Control block) from <code>ebpf_model</code>. Please, get familiar with <a class="el" href="md__2home_2runner_2work_2p4c_2p4c_2docs_2_r_e_a_d_m_e.html">the base eBPF backend</a> first.</li>
</ul>
<h1><a class="anchor" id="design"></a>
Design</h1>
<p>The PSA to eBPF compiler provides two flavors of generated eBPF code: TC-based design and XDP-based design. The TC-based design leverages eBPF TC (Traffic Control) hook and is able to implement any PSA program. The XDP-based design offloads packet processing to eBPF XDP (eXpress Data Path) hook and provides better performance than the TC-based flavor. However, the XDP-based design lacks support for packet recirculation, QoS (no integration with TC qdisc) and CLONE_E2E packet path.</p>
<h2><a class="anchor" id="tc-based-design-default"></a>
TC-based design (default)</h2>
<p><a class="el" href="namespace_p4.html" title="TODO: this is not really specific to BMV2, it should reside somewhere else.">P4</a> packet processing is translated into a set of eBPF programs attached to the TC hook. The eBPF programs implement packet processing defined in a <a class="el" href="namespace_p4.html" title="TODO: this is not really specific to BMV2, it should reside somewhere else.">P4</a> program written according to the PSA model. The TC hook is used as a main engine, because it enables a full implementation of the PSA specification. The XDP-based version of the PSA implementation does not implement the full specification, but provides better performance.</p>
<p>The TC-based design of PSA for eBPF is depicted in Figure below.</p>
<div class="image">
<img src="psa-ebpf-design.png" alt=""/>
<div class="caption">
TC-based PSA-eBPF design</div></div>
    <ul>
<li><code>xdp-helper</code> - the fixed, non-programmable "helper" program attached to the XDP hook. The role of the <code>xdp-helper</code> program is to prepare a packet for further processing in the TC subsystem. Why do we need the XDP helper program? Some eBPF helpers for the TC hook depend on the <code>skb-&gt;protocol</code> type (in particular, IPv4/IPv6 EtherType), which is read by the TC layer before a packet enters the eBPF program. This limitation prevents from using TC as a protocol-independent packet processing engine. If a packet arriving at the XDP level isn't an IPv4 packet, the XDP helper replaces it's original EtherType with IPv4 EtherType. The original EtherType is passed to TC according to the XDP2TC mode specified by a user (see XDP2TC metadata section). The <code>tc-ingress</code> program reads original EtherType and puts it back into the packet. We verified that this workaround enables handling other protocols in the TC layer (e.g., MPLS).</li>
<li><code>tc-ingress</code> - In the TC Ingress, the PSA Ingress pipeline as well as so-called "Traffic Manager" eBPF program is attached. The Ingress pipeline is composed of Parser, Control block and Deparser. The details of Parser, Control block and Deparser implementation will be explained further in this document. The same eBPF program in TC contains also the Traffic Manager. The role of Traffic Manager is to redirect traffic between the Ingress (TC) and Egress (TC). It is also responsible for packet replication via clone sessions or multicast groups and sending packet to CPU.</li>
<li><code>tc-egress</code> - The PSA Egress pipeline (composed of Parser, Control block and Deparser) is attached to the TC Egress hook. As there is no XDP hook in the Egress path, the use of TC is mandatory for the egress processing. <b>Note!</b> If the PSA Egress pipeline is not used (i.e. it is left empty by a developer), the PSA-eBPF compiler will not generate the TC Egress program. This brings a noticeable performance gain, if the egress pipeline is not used.</li>
</ul>
<h2><a class="anchor" id="xdp-based-design"></a>
XDP-based design</h2>
<p>The XDP-based design of PSA for eBPF is depicted in Figure below.</p>
<div class="image">
<img src="psa-ebpf-xdp-design.png" alt=""/>
<div class="caption">
XDP-based PSA-eBPF design</div></div>
    <p><code>xdp-helper</code> does not exist in this design, instead the PSA Ingress pipeline is attached to XDP hook. Since XDP does not provide a hook on the egress path, we mimic the PSA Egress pipeline by using eBPF program attached to <code>BPF_MAP_TYPE_DEVMAP</code>, a special type of BPF map used to perform packet redirection with <code>bpf_redirect_map()</code> helper. Also, XDP hook in the currently supported kernel version (up to 5.13) does not support packet cloning. Therefore, packets to be cloned are passed up to the TC hook, where the Packet Replication Engine is implemented. Once a packet reaches the TC hook, it is further processed by TC exclusively. Thus, the PSA-eBPF compiler generates a TC Egress program, which is a mirror reflection of the PSA Egress pipeline attached to the XDP DEVMAP. The packets to be cloned are passed up to TC with additional metadata. The mechanism used to transfer the metadata depends on the XDP2TC mode, we support <code>cpumap</code> and <code>head</code> modes for XDP-based design (<code>meta</code> mode is not supported).</p>
<p>There is no difference (comparing to TC-based design) in how PSA externs, <a class="el" href="namespace_p4.html" title="TODO: this is not really specific to BMV2, it should reside somewhere else.">P4</a> match kinds and parser primitives are implemented for XDP-based design.</p>
<p>To compile <a class="el" href="namespace_p4.html" title="TODO: this is not really specific to BMV2, it should reside somewhere else.">P4</a> programs for XDP, use <code>--xdp</code> compiler option.</p>
<h2><a class="anchor" id="packet-paths"></a>
Packet paths</h2>
<h3><a class="anchor" id="ntk-normal-packet-to-kernel"></a>
NTK (Normal Packet To Kernel)</h3>
<p><b>WARNING!</b> The NTK packet path is a custom packet path used for the PSA-eBPF only! It is not a standardized PSA packet path.</p>
<p>The NTK packet path allows integrating P4/PSA programs for eBPF with the standard Linux kernel stack. The main use case is handling ICMP/ARP requests and sending packet to the userspace process listening on a socket.</p>
<p>The NTK path is enforced if <code>drop</code> is set to <code>false</code> and <code>egress_port</code> is left unchanged or set to 0 (it's a special implicit port number that forwards packets to the kernel stack). Since packets can be modified in the PSA ingress pipeline before they are sent to the kernel stack, a <a class="el" href="namespace_p4.html" title="TODO: this is not really specific to BMV2, it should reside somewhere else.">P4</a> programmer should make sure that packets use standard headers and are properly formatted. Otherwise, the kernel stack will drop them.</p>
<p><b>NOTE!</b> There is no symmetric packet path <em>from kernel</em> - once a packet enters the kernel network stack, it is further processed exclusively by the kernel. As a consequence, all packets that have not been processed by the PSA Ingress pipeline (e.g., packets sent from userspace application) will not be handled by the PSA Egress pipeline!</p>
<h3><a class="anchor" id="nfp-normal-packet-from-port"></a>
NFP (Normal Packet From Port)</h3>
<p><b>TC-based design</b></p>
<p>Packet arriving on an interface is intercepted in the XDP hook by the <code>xdp-helper</code> program. It performs pre-processing and packet is passed for further processing to the TC ingress. Note that there is no P4-related processing done in the <code>xdp-helper</code> program.</p>
<p>By default, a packet is further passed to the TC subsystem. It is done by <code>XDP_PASS</code> action and packet is further handled by <code>tc-ingress</code> program.</p>
<p><b>XDP-based design</b></p>
<p>No specific processing is done. Packets are just received by the eBPF programm attached to XDP.</p>
<h3><a class="anchor" id="resubmit"></a>
RESUBMIT</h3>
<p>The purpose of <code>RESUBMIT</code> is to transfer packet processing back to the Ingress Parser from Ingress Deparser.</p>
<p>We implement packet resubmission by calling main <code>ingress()</code> function (implementing the PSA Ingress pipeline) in a loop. The <code>MAX_RESUBMIT_DEPTH</code> variable specifies maximum number of resubmit operations (the <code>MAX_RESUBMIT_DEPTH</code> value is currently hardcoded and is set to 4). The <code>resubmit</code> flag defines whether the <code>tc-ingress</code> program should enter next iteration (resubmit) or break the loop. The pseudocode looks as follows:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> i = 0;</div>
<div class="line"><span class="keywordtype">int</span> ret = TC_ACT_UNSPEC;</div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; MAX_RESUBMIT_DEPTH; i++) {</div>
<div class="line">    out_md.resubmit = 0;</div>
<div class="line">    ret = ingress(skb, &amp;out_md);</div>
<div class="line">    <span class="keywordflow">if</span> (out_md.resubmit == 0) {</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The same mechanism for RESUBMIT is used in the TC-based and XDP-based design.</p>
<h3><a class="anchor" id="nu-normal-unicast-nm-normal-multicast-ci2e-clone-ingress-to-egress"></a>
NU (Normal Unicast), NM (Normal Multicast), CI2E (Clone Ingress to Egress)</h3>
<p><b>TC-based design</b></p>
<p>NU, NM and CI2E refer to process of sending packet from the PSA Ingress Pipeline (more specifically from the Traffic Manager) to the PSA Egress pipeline. The NU path is implemented in the eBPF subsystem by invoking the <code>bpf_redirect()</code> helper from the <code>tc-ingress</code> program. This helper sets an output port for a packet and the packet is further intercepted by the TC egress.</p>
<p>Both NM and CI2E require the <code>bpf_clone_redirect()</code> helper to be used. It redirects a packet to an output port, but also clones a packet buffer, so that a packet can be copied and sent to multiple interfaces. From the eBPF program's perspective, <code>bpf_clone_redirect()</code> must be invoked in the loop to send packets to all ports from a clone session/multicast group.</p>
<p>Clone sessions or multicast groups and theirs members are stored as a BPF array map of maps (<code>BPF_MAP_TYPE_ARRAY_OF_MAPS</code>). The P4-eBPF compiler generates two outer BPF maps: <code>multicast_grp_tbl</code> and <code>clone_session_tbl</code>. Both of them store inner maps indexed by the clone session or multicast group identifier, respectively. The clone session/multicast group members (defining <code>egress_port</code>, <code>instance</code> or other parameters used by clone sessions) are stored in the inner hash map.</p>
<p>While performing the packet replication, the eBPF program does a lookup to the outer map based on the clone session/multicast group identifier and, then, does another lookup to the inner map to find all members.</p>
<p><b>XDP-based design</b></p>
<p>The NU path is implemented by calling <code>bpf_redirect_map()</code> after the ingress processing is completed. The NM and CI2E paths are not possible in the XDP layer. Packets marked to be cloned are sent up to the TC hook with additional metadata (e.g., parsed headers) and they are cloned by the eBPF program attached to the TC Ingress by using <code>bpf_clone_redirect()</code>. The clone sessions and multicast groups are implemented exactly like for the TC-based design.</p>
<h3><a class="anchor" id="ce2e-clone-egress-to-egress"></a>
CE2E (Clone Egress to Egress)</h3>
<p><b>TC-based design</b></p>
<p>CE2E refers to process of copying a packet that was handled by the Egress pipeline and resubmitting the cloned packet to the Egress Parser.</p>
<p>CE2E is implemented by invoking <code>bpf_clone_redirect()</code> helper in the Egress path. Output ports are determined based on the <code>clone_session_id</code> and lookup to "clone_session" BPF map, which is shared among TC ingress and egress (eBPF subsystem allows for map sharing between programs).</p>
<p><b>XDP-based design</b></p>
<p>CE2E is not supported by the XDP-based design.</p>
<h3><a class="anchor" id="sending-packet-to-cpu"></a>
Sending packet to CPU</h3>
<p>The PSA implementation for eBPF backend assumes a special interface called <code>PSA_PORT_CPU</code> that is used for communication between a control plane application and data plane. Sending packet to CPU does not differ significantly from normal packet unicast. A control plane application should listen for new packets on the interface identified by <code>PSA_PORT_CPU</code> in a <a class="el" href="namespace_p4.html" title="TODO: this is not really specific to BMV2, it should reside somewhere else.">P4</a> program. By redirecting a packet to <code>PSA_PORT_CPU</code> in the Ingress pipeline the packet is forwarded via Traffic Manager to the Egress pipeline and then, sent to the "CPU" interface.</p>
<p>The mechanism is common for both design options (TC/XDP).</p>
<h3><a class="anchor" id="ntp-normal-packet-to-port"></a>
NTP (Normal packet to port)</h3>
<p><b>TC-based design</b></p>
<p>Packets from <code>tc-egress</code> are sent out to the egress port. The egress port is determined in the Ingress pipeline and is not changed in the Egress pipeline.</p>
<p>Note that before a packet is sent to the output port, it's processed by <code>TC qdisc</code> first. The <code>TC qdisc</code> is the Linux QoS engine. The eBPF programs generated by P4-eBPF compiler sets <code>skb-&gt;priority</code> value based on the PSA <code>class_of_service</code> metadata. The <code>skb-&gt;priority</code> is used to interact between eBPF programs and <code>TC qdisc</code>. A user can configure different QoS behaviors via TC CLI and send a packet from PSA pipeline to a specific QoS class identified by <code>skb-&gt;priority</code>.</p>
<p><b>XDP-based design</b></p>
<p>Packets from the XDP egress program attached to BPF_DEVMAP are directly sent out to the egress port. There is no equivalent of Buffering &amp; Queueing Engine in the XDP-based design.</p>
<h3><a class="anchor" id="recirculate"></a>
RECIRCULATE</h3>
<p><b>TC-based design</b></p>
<p>The purpose of <code>RECIRCULATE</code> is to transfer packet processing back from the Egress Deparser to the Ingress Parser.</p>
<p>In order to implement <code>RECIRCULATE</code> we assume the existence of <code>PSA_PORT_RECIRCULATE</code> ports. Therefore, packet recirculation is simply performed by invoking <code>bpf_redirect()</code> to the <code>PSA_PORT_RECIRCULATE</code> port with <code>BPF_F_INGRESS</code> flag to enforce processing a packet by the Ingress pipeline.</p>
<p><b>XDP-based design</b></p>
<p>The RECIRCULATE path is not supported by the XDP-based design.</p>
<h2><a class="anchor" id="metadata"></a>
Metadata</h2>
<p>There are some global metadata defined for the PSA architecture. For example, <code>packet_path</code> must be shared among different pipelines. To share a global metadata between pipelines we use <code>skb-&gt;cb</code> (control buffer), which gives us 20B that are free to use.</p>
<h2><a class="anchor" id="xdp2tc-mode"></a>
XDP2TC mode</h2>
<p>The XDP2TC mode determines how the metadata (containing original EtherType) is passed from XDP up to TC. By default, PSA-eBPF uses the <code>bpf_xdp_adjust_meta()</code> helper to append the original EtherType to the <code>skb</code>â€™s <code>data_meta</code> field, which is further read by the TC Ingress to restore the original format of the packet. The way of passing metadata is determined by the user-configurable <code>--xdp2tc</code> compiler flag. We have noticed that some NIC drivers does not support the <code>bpf_xdp_adjust_meta()</code> BPF helper and the default mode cannot be used. Therefore, we come up with a more generic mode called <code>head</code>, which uses <code>bpf_xdp_adjust_head()</code> instead to prepend a packet with metadata. In this mode, the helper must be invoked twice - in the XDP helper program to append the metadata and in the TC Ingress to strip the metadata out of a packet. We also introduce the third mode - <code>cpumap</code>, which is an experimental features and should be used carefully. The <code>cpumap</code> assumes that the single CPU core handles a packet in the run-to-completion mode from XDP up to the TC layer (in other words, for a given packet, the CPU core running the TC program is the same as the one for XDP). If the above condition is met, the <code>cpumap</code> mode uses the per-CPU BPF array map to transfer metadata from XDP to TC. Hence, the <code>cpumap</code> mode should only be used, if there is a guarantee that the same CPU core handles the packet in both XDP and TC hooks. Note that the XDP helper program introduces a constant but noticeable per-packet overhead. Though, it is necessary to implement <a class="el" href="namespace_p4.html" title="TODO: this is not really specific to BMV2, it should reside somewhere else.">P4</a> processing in the TC layer.</p>
<p>To sum up, the <code>--xdp2tc</code> compiler flag can take the following values:</p><ul>
<li><code>meta</code> (default) - uses the <code>bpf_xdp_adjust_meta()</code> BPF helper. It's the most efficient way and should be used wherever possible.</li>
<li><code>head</code> - uses the <code>bpf_xdp_adjust_head()</code> BPF helper and should be used if <code>meta</code> is not supported by a NIC driver.</li>
<li><code>cpumap</code> - uses the BPF per-CPU array map. It should rather be used for testing purposes only.</li>
</ul>
<h2><a class="anchor" id="control-plane-api"></a>
Control-plane API</h2>
<p>The PSA-eBPF compiler assumes that any control plane software managing eBPF programs generated by the <a class="el" href="namespace_p4.html" title="TODO: this is not really specific to BMV2, it should reside somewhere else.">P4</a> compiler must be in line with the Control-plane API (a kind of contract or set of instructions that must be followed to make use of PSA-eBPF programs). The Control-plane API is summarized below, but we suggest using the <a href="https://github.com/NIKSS-vSwitch/nikss">NIKSS API</a> that already implements the control-plane API and exposes higher level C API.</p>
<ul>
<li><b>Pipeline initialization</b> - eBPF programs must be first loaded to the eBPF subsystem. The C files generated by the <a class="el" href="namespace_p4.html" title="TODO: this is not really specific to BMV2, it should reside somewhere else.">P4</a> compiler are compatible with <code>libbpf</code> loader and are annotated with BTF. All eBPF objects (programs, maps) must be pinned to the BPF filesystem under <code>/sys/fs/bpf/</code>. Once eBPF objects are loaded and pinned, a control plane application must invoke <code>map_initialize()</code> BPF function - it can be done using <code>bpf_prog_test_run</code>. The <code>map_initialize()</code> function is auto-generated by the PSA-eBPF compiler and configures all initial state, i.e. it initializes default actions, const entries, etc.</li>
<li><b>Table management</b> - a control plane software is responsible for inserting BPF map entries that are in line with types generated by the <a class="el" href="namespace_p4.html" title="TODO: this is not really specific to BMV2, it should reside somewhere else.">P4</a> compiler. The PSA-eBPF compiler generates C <code>struct</code> for BPF map's key and value. (e.g. <code>ingress_tbl_fwd_key</code> and <code>ingress_tbl_fwd_value</code>). The <code>exact</code> match table is implemented as BPF hash map. The <code>lpm</code> match table is implemented as BPF <code>LPM_TRIE</code>. Both key and value fields must be provided in the host byte order.</li>
<li><b>Clone sessions or multicast groups management</b> - Clone sessions or multicast groups are represented as a BPF array map of maps (<code>BPF_MAP_TYPE_ARRAY_OF_MAPS</code>) in the eBPF subsystem. Each entry of an outer map represents a single clone session or multicast group. An inner map is a hash map storing clone session/multicast group members, according to the structure defined by <code>struct list_key_t</code> (BPF map key) and <code>struct element</code> (value). To add a new clone session/mutlicast group, a control plane must add a new element to the outer map (indexed by clone session or multicast group identifier referenced by <code>clone_session_id</code> or <code>multicast_group</code> in a PSA program) and initialize an inner map. To add a new clone session/multicast group member, a con1trol plane must add new element to the inner map.</li>
</ul>
<h2><a class="anchor" id="p4-match-kinds"></a>
P4 match kinds</h2>
<p>The PSA-eBPF compiler currently supports the following <a class="el" href="namespace_p4.html" title="TODO: this is not really specific to BMV2, it should reside somewhere else.">P4</a> match kinds: <code>exact</code>, <code>lpm</code>, <code>ternary</code>.</p>
<h3><a class="anchor" id="exact"></a>
exact</h3>
<p>An <code>exact</code> table is implemented using the BPF hash map. A <a class="el" href="namespace_p4.html" title="TODO: this is not really specific to BMV2, it should reside somewhere else.">P4</a> table is considered an <code>exact</code> table if all its match fields are defined as <code>exact</code>. Then, the PSA-eBPF compiler generates a BPF hash map instance for each <a class="el" href="namespace_p4.html" title="TODO: this is not really specific to BMV2, it should reside somewhere else.">P4</a> table instance. The hash map key as a concatenation of <a class="el" href="namespace_p4.html" title="TODO: this is not really specific to BMV2, it should reside somewhere else.">P4</a> match fields translated to eBPF representation. Each <code>apply()</code> operation is translated into a lookup to the BPF hash map. The value is used to determine an action and its parameters.</p>
<h3><a class="anchor" id="lpm"></a>
lpm</h3>
<p>An <code>lpm</code> table is implemented using the BPF <code>LPM_TRIE</code> map. A <a class="el" href="namespace_p4.html" title="TODO: this is not really specific to BMV2, it should reside somewhere else.">P4</a> table is considered an <code>lpm</code> table if it contains a single <code>lpm</code> field and no <code>ternary</code> fields. The PSA-eBPF compiler generates a BPF <code>LPM_TRIE</code> map instance for each <a class="el" href="namespace_p4.html" title="TODO: this is not really specific to BMV2, it should reside somewhere else.">P4</a> table instance. The hash map key as a concatenation of <a class="el" href="namespace_p4.html" title="TODO: this is not really specific to BMV2, it should reside somewhere else.">P4</a> match fields translated to eBPF representation. Moreover, the PSA-eBPF compiler shuffles the match fields and places the <code>lpm</code> field in the last position. Each <code>apply()</code> operation is translated into a lookup to the <code>LPM_TRIE</code> map. A control plane should populate the <code>LPM_TRIE</code> map with entries composed of a value and prefix.</p>
<h3><a class="anchor" id="ternary"></a>
ternary</h3>
<p>There is no built-in BPF map for ternary (wildcard) matching. Hence, the PSA-eBPF compiler leverages the Tuple Space Search (TSS) algorithm for ternary matching (refer to the <a href="https://dl.acm.org/doi/10.1145/316194.316216">research paper</a> to learn more about the TSS algorithm). A <code>ternary</code> table is implemented using a combination of hash and array BPF maps that realizes the TSS algorithm. A <a class="el" href="namespace_p4.html" title="TODO: this is not really specific to BMV2, it should reside somewhere else.">P4</a> table is considered a <code>ternary</code> table if it contains at least one <code>ternary</code> field (exact and lpm fields are converted to ternary fields with an appropriate mask).</p>
<p><b>Note!</b> The PSA-eBPF compiler requires match keys in a ternary table to be sorted by size in descending order.</p>
<p>The PSA-eBPF compiler generates 2 BPF maps for each ternary table instance (+ the default action map):</p><ul>
<li>the <code>&lt;TBL-NAME&gt;_prefixes</code> map is a BPF hash map that stores all unique ternary masks. The ternary masks are created based on the runtime table entries that are installed by a user.</li>
<li>the <code>&lt;TBL-NAME&gt;_tuples_map</code> map is a BPF array map of maps that stores all "tuples". A single tuple is a BPF hash map that stores all flow rules with the same ternary mask.</li>
</ul>
<p>Note that the <code>nikss-ctl table add</code> CLI command greatly simplifies the process of adding/removing flow rules to ternary tables.</p>
<p>For each <code>apply()</code> operation, the PSA-eBPF compiler generates the piece of code performing lookup to the above maps. The lookup code iterates over the <code>&lt;TBL-NAME&gt;_prefixes</code> map to retrieve a ternary mask. Next, the lookup key (a concatenation of match keys) is masked with the obtained ternary mask and lookup to a corresponding tuple map is performed. If a match is found, the best match with the highest priority is saved, and the algorithm continues to examine other tuples. If an entry with a higher priority is found, the best match is overwritten. The algorithm exists when there is no more tuples left.</p>
<p>The snippet below shows the C code generated by the PSA-eBPF compiler for a lookup into a ternary table. The steps are explained below.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ingress_tbl_ternary_1_key key = {};</div>
<div class="line">key.field0 = hdr-&gt;ipv4.dstAddr;</div>
<div class="line">key.field1 = hdr-&gt;ipv4.diffserv;</div>
<div class="line"><span class="keyword">struct </span>ingress_tbl_ternary_1_value *value = NULL;</div>
<div class="line"><span class="keyword">struct </span>ingress_tbl_ternary_1_key_mask head = {0};</div>
<div class="line"><span class="keyword">struct </span>ingress_tbl_ternary_1_value_mask *val = BPF_MAP_LOOKUP_ELEM(ingress_tbl_ternary_1_prefixes, &amp;head);</div>
<div class="line"><span class="keywordflow">if</span> (val &amp;&amp; val-&gt;has_next != 0) {</div>
<div class="line">    <span class="keyword">struct </span>ingress_tbl_ternary_1_key_mask next = val-&gt;next_tuple_mask;</div>
<div class="line"><span class="preprocessor">    #pragma clang loop unroll(disable)</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; MAX_INGRESS_TBL_TERNARY_1_KEY_MASKS; i++) {  <span class="comment">// (1)</span></div>
<div class="line">        <span class="keyword">struct </span>ingress_tbl_ternary_1_value_mask *v = BPF_MAP_LOOKUP_ELEM(ingress_tbl_ternary_1_prefixes, &amp;next);</div>
<div class="line">        <span class="keywordflow">if</span> (!v) {</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// (2)</span></div>
<div class="line">        <span class="keyword">struct </span>ingress_tbl_ternary_1_key k = {};</div>
<div class="line">        __u32 *chunk = ((__u32 *) &amp;k);</div>
<div class="line">        __u32 *mask = ((__u32 *) &amp;next);</div>
<div class="line"><span class="preprocessor">        #pragma clang loop unroll(disable)</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <span class="keyword">sizeof</span>(<span class="keyword">struct </span>ingress_tbl_ternary_1_key_mask) / 4; i++) {</div>
<div class="line">            chunk[i] = ((__u32 *) &amp;key)[i] &amp; mask[i];</div>
<div class="line">        }</div>
<div class="line">        __u32 tuple_id = v-&gt;tuple_id;</div>
<div class="line">        next = v-&gt;next_tuple_mask;</div>
<div class="line">        <span class="comment">// (3)</span></div>
<div class="line">        <span class="keyword">struct </span><a class="code hl_struct" href="structbpf__elf__map.html">bpf_elf_map</a> *tuple = BPF_MAP_LOOKUP_ELEM(ingress_tbl_ternary_1_tuples_map, &amp;tuple_id);</div>
<div class="line">        <span class="keywordflow">if</span> (!tuple) {</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// (4)</span></div>
<div class="line">        <span class="keyword">struct </span>ingress_tbl_ternary_1_value *tuple_entry = bpf_map_lookup_elem(tuple, &amp;k);</div>
<div class="line">        <span class="keywordflow">if</span> (!tuple_entry) {</div>
<div class="line">            <span class="keywordflow">if</span> (v-&gt;has_next == 0) {</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">continue</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// (5)</span></div>
<div class="line">        <span class="keywordflow">if</span> (value == NULL || tuple_entry-&gt;priority &gt; value-&gt;priority) {</div>
<div class="line">            value = tuple_entry;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (v-&gt;has_next == 0) {</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// (6): go to default action if value == NULL</span></div>
<div class="ttc" id="astructbpf__elf__map_html"><div class="ttname"><a href="structbpf__elf__map.html">bpf_elf_map</a></div><div class="ttdef"><b>Definition</b> ebpf_kernel.h:67</div></div>
</div><!-- fragment --><p>The description of annotated lines:</p><ol type="1">
<li>The algorithm starts to iterate over the ternary masks map. The loop is bounded by the <code>MAX_INGRESS_TBL_TERNARY_1_KEY_MASKS</code> which is configured by <code>--max-ternary-masks</code> compiler option (defaults to 128). Note that the eBPF program complexity (instruction count) depends on this constant, so some more complex <a class="el" href="namespace_p4.html" title="TODO: this is not really specific to BMV2, it should reside somewhere else.">P4</a> program may not compile if the max ternary masks value is too high (see the Limitations section).</li>
<li>A lookup key to a next tuple map is created by masking the concatenation of match keys with the ternary masks retrieved from the <code>&lt;TBL-NAME&gt;_prefixes</code> map. Note that the key is masked in 4-byte chunks.</li>
<li>A lookup to the <code>&lt;TBL-NAME&gt;_tuples_map</code> outer BPF map is done to find a tuple map based on the tuple ID. The lookup returns the inner BPF map, which stores all entries related to a tuple.</li>
<li>Next, a lookup to the inner BPF map (a tuple map) is performed. The returned value stores the action ID, action params and priority.</li>
<li>The priority of an obtained value is compared with a current "best match" entry. An entry that is returned from the ternary classification is the one with the highest priority among different tuples.</li>
</ol>
<p>Note that the TSS algorithm has linear O(n) packet classification complexity, where "n" is a number of unique ternary masks.</p>
<h2><a class="anchor" id="psa-externs"></a>
PSA externs</h2>
<h3><a class="anchor" id="actionprofile"></a>
ActionProfile</h3>
<p><a href="https://p4.org/p4-spec/docs/PSA.html#sec-action-profile">ActionProfile</a> is a table implementation that separates actions (and its parameters) from a <a class="el" href="namespace_p4.html" title="TODO: this is not really specific to BMV2, it should reside somewhere else.">P4</a> table, introducing a level of indirection. The P4-eBPF compiler generates an additional BPF hash map, if the Action Profile is specified for a <a class="el" href="namespace_p4.html" title="TODO: this is not really specific to BMV2, it should reside somewhere else.">P4</a> table. The additional BPF map stores the mapping between the ActionProfile member reference and a <a class="el" href="namespace_p4.html" title="TODO: this is not really specific to BMV2, it should reside somewhere else.">P4</a> action specification. During the lookup to the <a class="el" href="namespace_p4.html" title="TODO: this is not really specific to BMV2, it should reside somewhere else.">P4</a> table with Action Profile, eBPF program first queries the first BPF map using the match key composed from the packet fields and expects the ActionProfile member reference to be returned. Next, the eBPF programs uses the obtained member reference as a lookup key to a second map to retrieve the action specification. Hence, the eBPF program does one additional lookup to the additional BPF map, if the ActionProfile is specified for a <a class="el" href="namespace_p4.html" title="TODO: this is not really specific to BMV2, it should reside somewhere else.">P4</a> table.</p>
<h3><a class="anchor" id="actionselector"></a>
ActionSelector</h3>
<p><a href="https://p4.org/p4-spec/docs/PSA-v1.1.0.html#sec-action-selector">ActionSelector</a> is a table implementation similar to an ActionProfile, but extends its functionality with support for groups of actions. If a table entry contains a member reference, the ActionSelector behaves in the same way as an ActionProfile. In case of group references, the PSA-eBPF compiler generates additional BPF maps. One of additional BPF maps (hash map of maps) maps a group reference ID to an inner map that contains a group of entries. The inner map (might be created at runtime by <code>nikss-ctl</code>) stores a number of all members in a group as the first element of the inner map. The rest of entries contains members of the ActionSelector group. To choose a member from a group, a checksum is calculated from all <code>selector</code> match keys. Next, the obtained member from the group map is used to get and execute an action.</p>
<p>The second compiler-created map contains an action for an empty group. For the ActionSelector, there are two fields stored in a table that uses given ActionSelector instance, one is reference, second is marker whether reference points to group or member.</p>
<p>Before action execution, following source code will be generated (and some additional comments to it) for table lookup, which has implementation <code>ActionSelector</code>: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>ingress_as_value * as_value = NULL;  <span class="comment">// pointer to an action data</span></div>
<div class="line">u32 as_action_ref = value-&gt;ingress_as_ref;  <span class="comment">// value-&gt;ingress_as_ref is entry from table (reference)</span></div>
<div class="line">u8 as_group_state = 0;                      <span class="comment">// which map contains action data</span></div>
<div class="line"><span class="keywordflow">if</span> (value-&gt;ingress_as_is_group_ref != 0) {  <span class="comment">// (1)</span></div>
<div class="line">    bpf_trace_message(<span class="stringliteral">&quot;ActionSelector: group reference %u\n&quot;</span>, as_action_ref);</div>
<div class="line">    <span class="keywordtype">void</span> * as_group_map = BPF_MAP_LOOKUP_ELEM(ingress_as_groups, &amp;as_action_ref);  <span class="comment">// get group map</span></div>
<div class="line">    <span class="keywordflow">if</span> (as_group_map != NULL) {</div>
<div class="line">        u32 * num_of_members = bpf_map_lookup_elem(as_group_map, &amp;ebpf_zero);      <span class="comment">// (2)</span></div>
<div class="line">        <span class="keywordflow">if</span> (num_of_members != NULL) {</div>
<div class="line">            <span class="keywordflow">if</span> (*num_of_members != 0) {</div>
<div class="line">                u32 ingress_as_hash_reg = 0xffffffff;  <span class="comment">// start calculation of hash</span></div>
<div class="line">                {</div>
<div class="line">                    u8 ingress_as_hash_tmp = 0;</div>
<div class="line">                    crc32_update(&amp;ingress_as_hash_reg, (u8 *) &amp;(hdr-&gt;ethernet.etherType), 2, 3988292384);</div>
<div class="line">                    bpf_trace_message(<span class="stringliteral">&quot;CRC: checksum state: %llx\n&quot;</span>, (u64) ingress_as_hash_reg);</div>
<div class="line">                    bpf_trace_message(<span class="stringliteral">&quot;CRC: final checksum: %llx\n&quot;</span>, (u64) crc32_finalize(ingress_as_hash_reg));</div>
<div class="line">                }</div>
<div class="line">                u64 as_checksum_val = crc32_finalize(ingress_as_hash_reg) &amp; 0xffff;     <span class="comment">// (3)</span></div>
<div class="line">                as_action_ref = 1 + (as_checksum_val % (*num_of_members));              <span class="comment">// (4)</span></div>
<div class="line">                bpf_trace_message(<span class="stringliteral">&quot;ActionSelector: selected action %u from group\n&quot;</span>, as_action_ref);</div>
<div class="line">                u32 * as_map_entry = bpf_map_lookup_elem(as_group_map, &amp;as_action_ref); <span class="comment">// (5)</span></div>
<div class="line">                <span class="keywordflow">if</span> (as_map_entry != NULL) {</div>
<div class="line">                    as_action_ref = *as_map_entry;</div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                    <span class="comment">/* Not found, probably bug. Skip further execution of the extern. */</span></div>
<div class="line">                    bpf_trace_message(<span class="stringliteral">&quot;ActionSelector: Entry with action reference was not found, dropping packet. Bug?\n&quot;</span>);</div>
<div class="line">                    <span class="keywordflow">return</span> TC_ACT_SHOT;</div>
<div class="line">                }</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                bpf_trace_message(<span class="stringliteral">&quot;ActionSelector: empty group, going to default action\n&quot;</span>);</div>
<div class="line">                as_group_state = 1;</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            bpf_trace_message(<span class="stringliteral">&quot;ActionSelector: entry with number of elements not found, dropping packet. Bug?\n&quot;</span>);</div>
<div class="line">            <span class="keywordflow">return</span> TC_ACT_SHOT;</div>
<div class="line">        }</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        bpf_trace_message(<span class="stringliteral">&quot;ActionSelector: group map was not found, dropping packet. Bug?\n&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> TC_ACT_SHOT;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span> (as_group_state == 0) {</div>
<div class="line">    bpf_trace_message(<span class="stringliteral">&quot;ActionSelector: member reference %u\n&quot;</span>, as_action_ref);</div>
<div class="line">    as_value = BPF_MAP_LOOKUP_ELEM(ingress_as_actions, &amp;as_action_ref);         <span class="comment">// (6)</span></div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">if</span> (as_group_state == 1) {</div>
<div class="line">    bpf_trace_message(<span class="stringliteral">&quot;ActionSelector: empty group, executing default group action\n&quot;</span>);</div>
<div class="line">    as_value = BPF_MAP_LOOKUP_ELEM(ingress_as_defaultActionGroup, &amp;ebpf_zero);  <span class="comment">// (7)</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> Description of marked lines:</p><ol type="1">
<li>Detect if a reference is a group reference. When the <code>_is_group_ref</code> field is non-zero, the reference is assumed to be a group reference.</li>
<li>Read a first entry in a group. This gives the number of members in a group.</li>
<li>From calculated hash N LSB bits are taken into account. N is obtained from last parameter of constructor of <code>ActionSelector</code>.</li>
<li>The number of members in a group is known (the first entry in a table) and one of them must be dynamically selected. An action ID in a group is chosen based on the calculated hash value. A valid value of an action ID in a group is within the following range: {1, 2, ... number of members}.</li>
<li>This lookup is necessary to translate the action ID in a group into a member reference.</li>
<li>When a member reference is found, action data is read from the <code>_actions</code> map.</li>
<li>For an empty group (without members), action data is read from the <code>_defaultActionGroup</code> table.</li>
</ol>
<p>To manage the ActionSelector instance (do not confuse with a table that uses this implementation), you can use <code>nikss-ctl action-selector</code> command or C API from NIKSS.</p>
<h3><a class="anchor" id="digest"></a>
Digest</h3>
<p><a href="https://p4.org/p4-spec/docs/PSA.html#sec-packet-digest">Digests</a> are intended to carry a small piece of user-defined data from the data plane to a control plane. The PSA-eBPF compiler translates each Digest instance into <code>BPF_MAP_TYPE_QUEUE</code> that implements a FIFO queue. If a deparser triggers the <code>pack()</code> method, an eBPF program inserts data defined for a Digest into the BPF queue map using <code>bpf_map_push_elem</code>. A user space application is responsible for performing periodic queries to this map to read a Digest message. It can use either <code>nikss-ctl digest get pipe</code>, <code>nikss_digest_get_next</code> from NIKSS C API or <code>bpf_map_lookup_and_delete_elem</code> from <code>libbpf</code> API.</p>
<h3><a class="anchor" id="meters"></a>
Meters</h3>
<p><a href="https://p4.org/p4-spec/docs/PSA.html#sec-meters">Meters</a> are a mechanism for "marking" packets that exceed an average packet or bit rate. Meters implement Dual Token Bucket Algorithm with both "color aware" and "color blind" modes. The PSA-eBPF implementation uses a BPF hash map to store a Meter state. The current implementation in eBPF uses BPF spinlocks to make operations on Meters atomic. The <code>bpf_ktime_get_ns()</code> helper is used to get a packet arrival timestamp.</p>
<p>The best way to configure a Meter is to use <code>nikss-ctl meter</code> tool as in the following example: </p><div class="fragment"><div class="line"># 1Mb/s -&gt; 128 000 bytes/s (132 kbytes/s PIR, 128 kbytes/s CIR), let CBS, PBS -&gt; 10 kbytes</div>
<div class="line">$ nikss-ctl meter update pipe &quot;$PIPELINE&quot; DemoIngress_meter index 0 132000:10000 128000:10000</div>
</div><!-- fragment --><p><code>nikss-ctl</code> accepts PIR and CIR values in bytes/s units or packets/s. PBS and CBS in bytes or packets.</p>
<h4><a class="anchor" id="direct-meter"></a>
Direct Meter</h4>
<p><a href="https://p4.org/p4-spec/docs/PSA.html#sec-direct-meters">Direct Meter</a> is always associated with the table entry that matched. The Direct Meter state is stored within the table entry value.</p>
<h3><a class="anchor" id="value_set"></a>
value_set</h3>
<p><a href="https://p4.org/p4-spec/docs/P4-16-v1.2.2.html#sec-value-set">value_set</a> is a <a class="el" href="namespace_p4.html" title="TODO: this is not really specific to BMV2, it should reside somewhere else.">P4</a> lang construct allowing to determine next parser state based on runtime values. The P4-eBPF compiler generates additional hash map for each <code>ValueSet</code> instance. In select case expression each <code>select()</code> on <code>ValueSet</code> is translated into a lookup into the BPF hash map to check if an entry for a given key exists. A value of the BPF map is ignored.</p>
<h3><a class="anchor" id="random"></a>
Random</h3>
<p>The <a href="https://p4.org/p4-spec/docs/PSA.html#sec-random">Random</a> extern is a mean to retrieve a pseudo-random number in a specified range within a <a class="el" href="namespace_p4.html" title="TODO: this is not really specific to BMV2, it should reside somewhere else.">P4</a> program. The PSA-eBPF compiler uses the <code>bpf_get_prandom_u32()</code> BPF helper to get a pseudo-random number. Each <code>read()</code> operation on the Random extern in a <a class="el" href="namespace_p4.html" title="TODO: this is not really specific to BMV2, it should reside somewhere else.">P4</a> program is translated into a call to the BPF helper.</p>
<h1><a class="anchor" id="getting-started-1"></a>
Getting started</h1>
<h2><a class="anchor" id="installation-1"></a>
Installation</h2>
<p>Follow standard steps for the <a class="el" href="namespace_p4.html" title="TODO: this is not really specific to BMV2, it should reside somewhere else.">P4</a> compiler to install the eBPF backend with the PSA support.</p>
<h2><a class="anchor" id="using-psa-ebpf"></a>
Using PSA-eBPF</h2>
<h3><a class="anchor" id="prerequisites-1"></a>
Prerequisites</h3>
<p>The PSA implemented for eBPF backend is verified to work with the kernel version 5.8+ and <code>x86-64</code> CPU architecture. Moreover, make sure that the BPF filesystem is mounted under <code>/sys/fs/bpf</code>.</p>
<p>Also, make sure you have the following packages installed:</p>
<div class="fragment"><div class="line">$ sudo apt install -y clang llvm libelf-dev</div>
</div><!-- fragment --><p>You should also install a static <code>libbpf</code> library. Run the following commands:</p>
<div class="fragment"><div class="line">$ python3 backends/ebpf/build_libbpf</div>
</div><!-- fragment --><h3><a class="anchor" id="compilation-1"></a>
Compilation</h3>
<p>You can compile a P4-16 PSA program for eBPF in a single step using:</p>
<div class="fragment"><div class="line">make -f backends/ebpf/runtime/kernel.mk BPFOBJ=out.o P4FILE=&lt;P4-PROGRAM&gt;.p4 P4C=p4c-ebpf psa</div>
</div><!-- fragment --><p>You can also perform compilation step by step:</p>
<div class="fragment"><div class="line">$ p4c-ebpf --arch psa --target kernel -o out.c &lt;program&gt;.p4</div>
<div class="line">$ clang -Ibackends/ebpf/runtime -Ibackends/ebpf/runtime/usr/include -O2 -g -c -emit-llvm -o out.bc out.c</div>
<div class="line">$ llc -march=bpf -mcpu=generic -filetype=obj -o out.o out.bc</div>
</div><!-- fragment --><p>Note that you can use <code>-mcpu</code> flag to define the eBPF instruction set. Visit <a href="https://pchaigno.github.io/bpf/2021/10/20/ebpf-instruction-sets.html">this blog post</a> to learn more about eBPF instruction sets.</p>
<p>The above steps generate <code>out.o</code> BPF object file that can be loaded to the kernel.</p>
<h4><a class="anchor" id="optional-flags"></a>
Optional flags</h4>
<p>Supposing we want to use a packet recirculation we have to specify the <code>PSA_PORT_RECIRCULATE</code> port. We can use <code>-DPSA_PORT_RECIRCULATE=&lt;RECIRCULATE_PORT_IDX&gt;</code> Clang flag via <code>kernel.mk</code> </p><div class="fragment"><div class="line">make -f backends/ebpf/runtime/kernel.mk BPFOBJ=out.o ARGS=&quot;-DPSA_PORT_RECIRCULATE=&lt;RECIRCULATE_PORT_IDX&gt;&quot; P4FILE=&lt;P4-PROGRAM&gt;.p4 P4C=p4c-ebpf psa</div>
</div><!-- fragment --><p> or directly: <code>clang ... -DPSA_PORT_RECIRCULATE=&lt;RECIRCULATE_PORT_IDX&gt; ...</code>, <br  />
 where <code>RECIRCULATE_PORT_IDX</code> is a number of a <code>psa_recirc</code> interface (this number can be obtained from <code>ip -n switch link</code>).</p>
<p>By default <code>PSA_PORT_RECIRCULATE</code> is set to 0.</p>
<h3><a class="anchor" id="nikss-api-and-nikss-ctl"></a>
NIKSS API and nikss-ctl</h3>
<p>We provide the <code>NIKSS</code> C API and the <code>nikss-ctl</code> CLI tool that can be used to manage eBPF programs generated by P4-eBPF compiler. To install the CLI tool, follow the guide in <a href="https://github.com/NIKSS-vSwitch/nikss">the NIKSS repository</a>. Use <code>nikss-ctl help</code> to get all possible commands.</p>
<p><b>Note!</b> Although eBPF objects can be loaded and managed by other tools (e.g. <code>bpftool</code>), we recommend using <code>nikss-ctl</code>. Some features (e.g., default actions) will only work when using <code>nikss-ctl</code>.</p>
<p>To load eBPF programs generated by P4-eBPF compiler run:</p>
<div class="fragment"><div class="line">nikss-ctl pipeline load id &lt;PIPELINE-ID&gt; out.o</div>
</div><!-- fragment --><p><code>PIPELINE-ID</code> is a user-defined value used to uniquely identify PSA-eBPF pipeline (we are going to support for multiple PSA-eBPF pipelines running in parallel). In the next step, for each interface that should be attached to PSA-eBPF run:</p>
<div class="fragment"><div class="line">nikss-ctl add-port pipe &lt;PIPELINE-ID&gt; dev &lt;INTF&gt;</div>
</div><!-- fragment --><h2><a class="anchor" id="running-ptf-tests"></a>
Running PTF tests</h2>
<p>PSA implementation for eBPF backend is covered by a set of PTF tests that verify a correct behavior of various PSA mechanisms. The test scripts, PTF test cases and test <a class="el" href="namespace_p4.html" title="TODO: this is not really specific to BMV2, it should reside somewhere else.">P4</a> programs are located under <code>backends/ebpf/tests</code>. The tests must be executed from this directory.</p>
<p>To run all PTF tests:</p>
<div class="fragment"><div class="line">sudo ./test.sh</div>
</div><!-- fragment --><p>You can also specify a single PTF test to run:</p>
<div class="fragment"><div class="line">sudo ./test.sh test.BridgedMetadataPSATest</div>
</div><!-- fragment --><p>It might be also useful to enable tracing for troubleshooting with <code>bpftool prog tracelog</code>:</p>
<div class="fragment"><div class="line">sudo ./test.sh --trace=on</div>
</div><!-- fragment --><h2><a class="anchor" id="troubleshooting"></a>
Troubleshooting</h2>
<p>The PSA implementation for eBPF backend generates standard BPF objects that can be inspected using <code>bpftool</code>.</p>
<p>To troubleshoot PSA-eBPF program you will probably need <code>bpftool</code>. Follow the steps below to install it.</p>
<p>You should be able to see <code>bpftool help</code>:</p>
<div class="fragment"><div class="line">$ bpftool help</div>
<div class="line">  Usage: bpftool [OPTIONS] OBJECT { COMMAND | help }</div>
<div class="line">         bpftool batch file FILE</div>
<div class="line">         bpftool version</div>
<div class="line">  </div>
<div class="line">         OBJECT := { prog | map | link | cgroup | perf | net | feature | btf | gen | struct_ops | iter }</div>
<div class="line">         OPTIONS := { {-j|--json} [{-p|--pretty}] | {-f|--bpffs} |</div>
<div class="line">                      {-m|--mapcompat} | {-n|--nomount} }</div>
</div><!-- fragment --><p>Refer to <a href="https://manpages.ubuntu.com/manpages/focal/man8/bpftool-prog.8.html">the bpftool guide</a> for more examples how to use it.</p>
<h1><a class="anchor" id="performance-optimizations"></a>
Performance optimizations</h1>
<h2><a class="anchor" id="table-caching"></a>
Table caching</h2>
<p>Table caching optimizes <a class="el" href="namespace_p4.html" title="TODO: this is not really specific to BMV2, it should reside somewhere else.">P4</a> table lookups by adding a cache with all <code>exact</code> matches for time-consuming lookups including:</p><ul>
<li>table with <code>ternary</code> (and/or lpm, exact) key - skip slow TSS algorithm if the key was matched earlier.</li>
<li>table with <code>lpm</code> (and/or exact) key - skip slow <code>LPM_TRIE</code> map (especially when there is many entries) if the key was matched earlier.</li>
<li><code>ActionSelector</code> member selection from group - skip slow checksum calculation for <code>selector</code> key if it was calculated earlier.</li>
</ul>
<p>The fast exact-match map is added in front of each instance of a table that contains a <code>lpm</code>, <code>ternary</code> or <code>selector</code> match key. The table cache is implemented with <code>BPF_MAP_TYPE_LRU_HASH</code>, which shares its implementation with the BPF hash map. The LRU map provides a good lookup performance, but lower performance on map updates due to a maintenance process. Thus, this optimization fits into use cases, where a value of table key changes infrequently between packets.</p>
<p>This optimization may not improve performance in every case, so it must be explicitly enabled by compiler option. To enable table caching pass <code>--table-caching</code> to the compiler.</p>
<h1><a class="anchor" id="todo--limitations"></a>
TODO / Limitations</h1>
<p>We list the known bugs/limitations below. Refer to the Roadmap section for features planned in the near future.</p>
<ul>
<li>Fields wider than 64 bits must have size multiple of 8 bits, otherwise they may have unexpected value in the LSB byte. These fields may not work with all the externs and not all the operations on them are possible.</li>
<li>We noticed that <code>bpf_xdp_adjust_meta()</code> isn't implemented by some NIC drivers, so the <code>meta</code> XDP2TC mode may not work with some NICs. So far, we have verified the correct behavior with Intel 82599ES. If a NIC doesn't support the <code>meta</code> XDP2TC mode you can use <code>head</code> or <code>cpumap</code> modes.</li>
<li><code>lookahead()</code> with bit fields (e.g., <code>bit&lt;16&gt;</code>) doesn't work.</li>
<li><code>@atomic</code> operation is not supported yet.</li>
<li><code>psa_idle_timeout</code> is not supported yet.</li>
<li>DirectCounter and DirectMeter externs are not supported for <a class="el" href="namespace_p4.html" title="TODO: this is not really specific to BMV2, it should reside somewhere else.">P4</a> tables with implementation (ActionProfile or ActionSelector).</li>
<li>The <code>xdp2tc=head</code> mode works only for packets larger than 34 bytes (the size of Ethernet and IPv4 header).</li>
<li><code>value_set</code> only supports the exact match type and can only match on a single field in the <code>select()</code> expression.</li>
<li>The number of entries in ternary tables are limited by the number of unique ternary masks. If a <a class="el" href="namespace_p4.html" title="TODO: this is not really specific to BMV2, it should reside somewhere else.">P4</a> program uses many ternary tables and the <code>--max-ternary-masks</code> (default: 128) is set to a high value, the <a class="el" href="namespace_p4.html" title="TODO: this is not really specific to BMV2, it should reside somewhere else.">P4</a> program may not load into the BPF subsystem due to the BPF complexity issue (the 1M instruction limit exceeded). This is the limitation of the current implementation of the TSS algorithm that requires iteration over BPF maps. Note that the recent kernel introduced the <a href="https://lwn.net/Articles/846504/">bpf_for_each_map_elem()</a> helper that should simplify the iteration process and help to overcome the current limitation.</li>
<li>Setting a size of ternary tables does not currently work.</li>
<li>DirectMeter cannot be used if a table defines <code>ternary</code> match fields, as <a href="https://patchwork.ozlabs.org/project/netdev/patch/20190124041403.2100609-2-ast@kernel.org/">BPF spinlocks are not allowed in inner maps of map-in-map</a>.</li>
<li>Table cache optimization can't be enabled on tables with DirectCounter or DirectMeter due to two different states of a table entry. Tables with these externs will not have enabled cache optimization even when enabled by compiler option.</li>
<li>When table cache optimization is enabled for a table, the number of cached entries is determined as a half of table size. This would be more configurable or smart during compilation.</li>
<li>Updates to tables or ActionSelector with enabled table cache optimization require cache invalidation. <code>nikss</code> library will remove all cached entries if it detects cache.</li>
</ul>
<h1><a class="anchor" id="roadmap"></a>
Roadmap</h1>
<h2><a class="anchor" id="planned-features"></a>
Planned features</h2>
<p>All the below features are already implemented and will be contributed to the <a class="el" href="namespace_p4.html" title="TODO: this is not really specific to BMV2, it should reside somewhere else.">P4</a> compiler in subsequent pull requests.</p>
<ul>
<li><b>Extended ValueSet support.</b> We plan to extend implementation to support other match kinds and multiple fields in the <code>select()</code> expression.</li>
</ul>
<h2><a class="anchor" id="long-term-goals"></a>
Long-term goals</h2>
<p>The below features are not implemented yet, but they are considered for the future extensions:</p>
<ul>
<li><b>Range matching.</b> P4-eBPF compiler does not support <code>range</code> match kind and there is a further investigation needed on how to implement range matching for eBPF programs.</li>
<li><b>Optional matching.</b> P4-eBPF compiler does not support <code>optional</code> match kind yet. However, it can be implemented based on the same algorithm that is used for ternary matching.</li>
<li><b>Investigate support for PNA.</b> We plan to investigate the PNA implementation for eBPF backend. We believe that the PNA implementation can be significantly based on the PSA implementation.</li>
<li><b>Meet parity with the latest version of Linux kernel.</b> The latest Linux kernel brings a few improvements/extensions to eBPF subsystem. We plan to incorporate them to the P4-eBPF compiler to extend functionalities or improve performance.</li>
<li><b>P4Runtime support.</b> Currently, PSA-eBPF programs can only be managed by <code>NIKSS API</code>. We plan to integrate PSA-eBPF with the P4Runtime software stack (e.g., Stratum, TDI or P4-OvS).</li>
</ul>
<h2><a class="anchor" id="support"></a>
Support</h2>
<p>To report any other kind of problem, feel free to open a GitHub Issue or reach out to the project maintainers on the <a class="el" href="namespace_p4.html" title="TODO: this is not really specific to BMV2, it should reside somewhere else.">P4</a> Community Slack or via email.</p>
<p>Project maintainers:</p>
<ul>
<li>Tomasz OsiÅ„ski (tomasz [at] opennetworking.org / osinstom [at] gmail.com)</li>
<li>Mateusz Kossakowski (mateusz.kossakowski [at] orange.com / mateusz.kossakowski.10 [at] gmail.com)</li>
<li>Jan PalimÄ…ka (jan.palimaka [at] orange.com / jan.palimaka95 [at] gmail.com) </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.12.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
