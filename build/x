# 1 "../frontends/p4/validateParsedProgram.cpp"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 328 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "../frontends/p4/validateParsedProgram.cpp" 2
# 1 "../frontends/p4/validateParsedProgram.h" 1



# 1 "../ir/ir.h" 1



# 1 "/usr/include/gmpxx.h" 1 3 4
# 24 "/usr/include/gmpxx.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/iosfwd" 1 3 4
# 37 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/iosfwd" 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/c++config.h" 1 3
# 184 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/c++config.h" 3
namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;

}
# 426 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/c++config.h" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/os_defines.h" 1 3
# 39 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/os_defines.h" 3
# 1 "/usr/include/features.h" 1 3 4
# 352 "/usr/include/features.h" 3 4
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 353 "/usr/include/features.h" 2 3 4
# 374 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 385 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 386 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 375 "/usr/include/features.h" 2 3 4
# 398 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 399 "/usr/include/features.h" 2 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/os_defines.h" 2 3
# 427 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/c++config.h" 2 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/cpu_defines.h" 1 3
# 430 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/c++config.h" 2 3
# 39 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/iosfwd" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stringfwd.h" 1 3
# 38 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stringfwd.h" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/memoryfwd.h" 1 3
# 47 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/memoryfwd.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{
# 63 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/memoryfwd.h" 3
  template<typename>
    class allocator;

  template<>
    class allocator<void>;


  template<typename, typename>
    struct uses_allocator;




}
# 41 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stringfwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
# 52 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stringfwd.h" 3
  template<class _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;

  template<> struct char_traits<char>;


  typedef basic_string<char> string;


  template<> struct char_traits<wchar_t>;


  typedef basic_string<wchar_t> wstring;





  template<> struct char_traits<char16_t>;
  template<> struct char_traits<char32_t>;


  typedef basic_string<char16_t> u16string;


  typedef basic_string<char32_t> u32string;





}
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/iosfwd" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/postypes.h" 1 3
# 39 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/postypes.h" 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cwchar" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cwchar" 3




# 1 "/usr/include/wchar.h" 1 3 4
# 36 "/usr/include/wchar.h" 3 4
# 1 "/usr/include/stdio.h" 1 3 4
# 44 "/usr/include/stdio.h" 3 4
struct _IO_FILE;



typedef struct _IO_FILE FILE;
# 64 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 37 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/stdarg.h" 1 3 4
# 30 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/stdarg.h" 3 4
typedef __builtin_va_list va_list;
# 50 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 40 "/usr/include/wchar.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
# 42 "/usr/include/wchar.h" 2 3 4
# 51 "/usr/include/wchar.h" 3 4
# 1 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/stddef.h" 1 3 4
# 58 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 141 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/stddef.h" 3 4
typedef unsigned int wint_t;
# 52 "/usr/include/wchar.h" 2 3 4
# 82 "/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;
# 106 "/usr/include/wchar.h" 3 4
typedef __mbstate_t mbstate_t;
# 132 "/usr/include/wchar.h" 3 4
extern "C" {




struct tm;
# 147 "/usr/include/wchar.h" 3 4
extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src) throw ();

extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw ();


extern wchar_t *wcscat (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src) throw ();

extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw ();


extern int wcscmp (const wchar_t *__s1, const wchar_t *__s2)
     throw () __attribute__ ((__pure__));

extern int wcsncmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__));




extern int wcscasecmp (const wchar_t *__s1, const wchar_t *__s2) throw ();


extern int wcsncasecmp (const wchar_t *__s1, const wchar_t *__s2,
   size_t __n) throw ();




# 1 "/usr/include/xlocale.h" 1 3 4
# 27 "/usr/include/xlocale.h" 3 4
typedef struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;


typedef __locale_t locale_t;
# 181 "/usr/include/wchar.h" 2 3 4

extern int wcscasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
    __locale_t __loc) throw ();

extern int wcsncasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
     size_t __n, __locale_t __loc) throw ();





extern int wcscoll (const wchar_t *__s1, const wchar_t *__s2) throw ();



extern size_t wcsxfrm (wchar_t *__restrict __s1,
         const wchar_t *__restrict __s2, size_t __n) throw ();
# 206 "/usr/include/wchar.h" 3 4
extern int wcscoll_l (const wchar_t *__s1, const wchar_t *__s2,
        __locale_t __loc) throw ();




extern size_t wcsxfrm_l (wchar_t *__s1, const wchar_t *__s2,
    size_t __n, __locale_t __loc) throw ();


extern wchar_t *wcsdup (const wchar_t *__s) throw () __attribute__ ((__malloc__));
# 227 "/usr/include/wchar.h" 3 4
extern wchar_t *wcschr (const wchar_t *__wcs, wchar_t __wc)
     throw () __attribute__ ((__pure__));
# 237 "/usr/include/wchar.h" 3 4
extern wchar_t *wcsrchr (const wchar_t *__wcs, wchar_t __wc)
     throw () __attribute__ ((__pure__));






extern wchar_t *wcschrnul (const wchar_t *__s, wchar_t __wc)
     throw () __attribute__ ((__pure__));





extern size_t wcscspn (const wchar_t *__wcs, const wchar_t *__reject)
     throw () __attribute__ ((__pure__));


extern size_t wcsspn (const wchar_t *__wcs, const wchar_t *__accept)
     throw () __attribute__ ((__pure__));
# 266 "/usr/include/wchar.h" 3 4
extern wchar_t *wcspbrk (const wchar_t *__wcs, const wchar_t *__accept)
     throw () __attribute__ ((__pure__));
# 277 "/usr/include/wchar.h" 3 4
extern wchar_t *wcsstr (const wchar_t *__haystack, const wchar_t *__needle)
     throw () __attribute__ ((__pure__));



extern wchar_t *wcstok (wchar_t *__restrict __s,
   const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) throw ();


extern size_t wcslen (const wchar_t *__s) throw () __attribute__ ((__pure__));
# 299 "/usr/include/wchar.h" 3 4
extern wchar_t *wcswcs (const wchar_t *__haystack, const wchar_t *__needle)
     throw () __attribute__ ((__pure__));





extern size_t wcsnlen (const wchar_t *__s, size_t __maxlen)
     throw () __attribute__ ((__pure__));
# 320 "/usr/include/wchar.h" 3 4
extern wchar_t *wmemchr (const wchar_t *__s, wchar_t __c, size_t __n)
     throw () __attribute__ ((__pure__));



extern int wmemcmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__));


extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    const wchar_t *__restrict __s2, size_t __n) throw ();



extern wchar_t *wmemmove (wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw ();


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) throw ();





extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
     const wchar_t *__restrict __s2, size_t __n)
     throw ();






extern wint_t btowc (int __c) throw ();



extern int wctob (wint_t __c) throw ();



extern int mbsinit (const mbstate_t *__ps) throw () __attribute__ ((__pure__));



extern size_t mbrtowc (wchar_t *__restrict __pwc,
         const char *__restrict __s, size_t __n,
         mbstate_t *__restrict __p) throw ();


extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) throw ();


extern size_t __mbrlen (const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) throw ();
extern size_t mbrlen (const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) throw ();
# 408 "/usr/include/wchar.h" 3 4
extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();



extern size_t wcsrtombs (char *__restrict __dst,
    const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();






extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
     const char **__restrict __src, size_t __nmc,
     size_t __len, mbstate_t *__restrict __ps) throw ();



extern size_t wcsnrtombs (char *__restrict __dst,
     const wchar_t **__restrict __src,
     size_t __nwc, size_t __len,
     mbstate_t *__restrict __ps) throw ();






extern int wcwidth (wchar_t __c) throw ();



extern int wcswidth (const wchar_t *__s, size_t __n) throw ();






extern double wcstod (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) throw ();





extern float wcstof (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
extern long double wcstold (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();







extern long int wcstol (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) throw ();



extern unsigned long int wcstoul (const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     throw ();






__extension__
extern long long int wcstoll (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstoull (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr,
     int __base) throw ();






__extension__
extern long long int wcstoq (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstouq (const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __base) throw ();
# 530 "/usr/include/wchar.h" 3 4
extern long int wcstol_l (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __base,
     __locale_t __loc) throw ();

extern unsigned long int wcstoul_l (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr,
        int __base, __locale_t __loc) throw ();

__extension__
extern long long int wcstoll_l (const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr,
    int __base, __locale_t __loc) throw ();

__extension__
extern unsigned long long int wcstoull_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, __locale_t __loc)
     throw ();

extern double wcstod_l (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();

extern float wcstof_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();

extern long double wcstold_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         __locale_t __loc) throw ();






extern wchar_t *wcpcpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src) throw ();



extern wchar_t *wcpncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw ();






extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) throw ();






extern int fwide (__FILE *__fp, int __mode) throw ();






extern int fwprintf (__FILE *__restrict __stream,
       const wchar_t *__restrict __format, ...)
                                                           ;




extern int wprintf (const wchar_t *__restrict __format, ...)
                                                           ;

extern int swprintf (wchar_t *__restrict __s, size_t __n,
       const wchar_t *__restrict __format, ...)
     throw () ;





extern int vfwprintf (__FILE *__restrict __s,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
                                                           ;




extern int vwprintf (const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                           ;


extern int vswprintf (wchar_t *__restrict __s, size_t __n,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     throw () ;






extern int fwscanf (__FILE *__restrict __stream,
      const wchar_t *__restrict __format, ...)
                                                          ;




extern int wscanf (const wchar_t *__restrict __format, ...)
                                                          ;

extern int swscanf (const wchar_t *__restrict __s,
      const wchar_t *__restrict __format, ...)
     throw () ;
# 689 "/usr/include/wchar.h" 3 4
extern int vfwscanf (__FILE *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                          ;




extern int vwscanf (const wchar_t *__restrict __format,
      __gnuc_va_list __arg)
                                                          ;

extern int vswscanf (const wchar_t *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     throw () ;
# 745 "/usr/include/wchar.h" 3 4
extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);





extern int fputws (const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);
# 801 "/usr/include/wchar.h" 3 4
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);







extern wint_t fgetwc_unlocked (__FILE *__stream);







extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
# 827 "/usr/include/wchar.h" 3 4
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);
# 837 "/usr/include/wchar.h" 3 4
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
     __FILE *__restrict __stream);







extern int fputws_unlocked (const wchar_t *__restrict __ws,
       __FILE *__restrict __stream);







extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   const wchar_t *__restrict __format,
   const struct tm *__restrict __tp) throw ();







extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
     const wchar_t *__restrict __format,
     const struct tm *__restrict __tp,
     __locale_t __loc) throw ();
# 891 "/usr/include/wchar.h" 3 4
}
# 45 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cwchar" 2 3
# 62 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cwchar" 3
namespace std
{
  using ::mbstate_t;
}
# 135 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cwchar" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;

  using ::swprintf;

  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;


  using ::vswprintf;


  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;


  inline wchar_t*
  wcschr(wchar_t* __p, wchar_t __c)
  { return wcschr(const_cast<const wchar_t*>(__p), __c); }

  inline wchar_t*
  wcspbrk(wchar_t* __s1, const wchar_t* __s2)
  { return wcspbrk(const_cast<const wchar_t*>(__s1), __s2); }

  inline wchar_t*
  wcsrchr(wchar_t* __p, wchar_t __c)
  { return wcsrchr(const_cast<const wchar_t*>(__p), __c); }

  inline wchar_t*
  wcsstr(wchar_t* __s1, const wchar_t* __s2)
  { return wcsstr(const_cast<const wchar_t*>(__s1), __s2); }

  inline wchar_t*
  wmemchr(wchar_t* __p, wchar_t __c, size_t __n)
  { return wmemchr(const_cast<const wchar_t*>(__p), __c, __n); }



}







namespace __gnu_cxx
{





  using ::wcstold;
# 257 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;

}

namespace std
{
  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;
}
# 277 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cwchar" 3
namespace std
{

  using std::wcstof;


  using std::vfwscanf;


  using std::vswscanf;


  using std::vwscanf;



  using std::wcstold;
  using std::wcstoll;
  using std::wcstoull;

}
# 41 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/postypes.h" 2 3
# 68 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/postypes.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 88 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/postypes.h" 3
  typedef long streamoff;
# 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/postypes.h" 3
  typedef ptrdiff_t streamsize;
# 111 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
# 133 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };






  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;



  typedef fpos<mbstate_t> u16streampos;

  typedef fpos<mbstate_t> u32streampos;



}
# 41 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/iosfwd" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
# 74 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/iosfwd" 3
  class ios_base;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  typedef basic_ios<char> ios;


  typedef basic_streambuf<char> streambuf;


  typedef basic_istream<char> istream;


  typedef basic_ostream<char> ostream;


  typedef basic_iostream<char> iostream;


  typedef basic_stringbuf<char> stringbuf;


  typedef basic_istringstream<char> istringstream;


  typedef basic_ostringstream<char> ostringstream;


  typedef basic_stringstream<char> stringstream;


  typedef basic_filebuf<char> filebuf;


  typedef basic_ifstream<char> ifstream;


  typedef basic_ofstream<char> ofstream;


  typedef basic_fstream<char> fstream;



  typedef basic_ios<wchar_t> wios;


  typedef basic_streambuf<wchar_t> wstreambuf;


  typedef basic_istream<wchar_t> wistream;


  typedef basic_ostream<wchar_t> wostream;


  typedef basic_iostream<wchar_t> wiostream;


  typedef basic_stringbuf<wchar_t> wstringbuf;


  typedef basic_istringstream<wchar_t> wistringstream;


  typedef basic_ostringstream<wchar_t> wostringstream;


  typedef basic_stringstream<wchar_t> wstringstream;


  typedef basic_filebuf<wchar_t> wfilebuf;


  typedef basic_ifstream<wchar_t> wifstream;


  typedef basic_ofstream<wchar_t> wofstream;


  typedef basic_fstream<wchar_t> wfstream;




}
# 25 "/usr/include/gmpxx.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstring" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstring" 3


# 1 "/usr/include/string.h" 1 3 4
# 27 "/usr/include/string.h" 3 4
extern "C" {





# 1 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/stddef.h" 1 3 4
# 33 "/usr/include/string.h" 2 3 4
# 46 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern void *memchr (void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const void *memchr (const void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 94 "/usr/include/string.h" 3 4
}
# 105 "/usr/include/string.h" 3 4
extern "C++" void *rawmemchr (void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *rawmemchr (const void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));







extern "C++" void *memrchr (void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *memrchr (const void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 129 "/usr/include/string.h" 3 4
extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (2)));
# 166 "/usr/include/string.h" 3 4
extern int strcoll_l (const char *__s1, const char *__s2, __locale_t __l)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    __locale_t __l) throw () __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 214 "/usr/include/string.h" 3 4
extern "C++"
{
extern char *strchr (char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strchr (const char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 234 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strrchr (char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strrchr (const char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 261 "/usr/include/string.h" 3 4
}
# 272 "/usr/include/string.h" 3 4
extern "C++" char *strchrnul (char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const char *strchrnul (const char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 285 "/usr/include/string.h" 3 4
extern size_t strcspn (const char *__s, const char *__reject)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern "C++"
{
extern char *strpbrk (char *__s, const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strpbrk (const char *__s, const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 313 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strstr (char *__haystack, const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strstr (const char *__haystack, const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 340 "/usr/include/string.h" 3 4
}







extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));





extern "C++" char *strcasestr (char *__haystack, const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern "C++" const char *strcasestr (const char *__haystack,
         const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 382 "/usr/include/string.h" 3 4
extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern size_t strlen (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (const char *__string, size_t __maxlen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) throw ();
# 438 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) ;





extern char *strerror_l (int __errnum, __locale_t __l) throw ();





extern void __bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));



extern void bcopy (const void *__src, void *__dest, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern char *index (char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *index (const char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 487 "/usr/include/string.h" 3 4
}







extern "C++"
{
extern char *rindex (char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *rindex (const char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 515 "/usr/include/string.h" 3 4
}







extern int ffs (int __i) throw () __attribute__ ((__const__));




extern int ffsl (long int __l) throw () __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     throw () __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));





extern int strcasecmp_l (const char *__s1, const char *__s2,
    __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));





extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) throw ();


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) throw () __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));







extern "C++" char *basename (char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
extern "C++" const char *basename (const char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
# 644 "/usr/include/string.h" 3 4
}
# 43 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstring" 2 3
# 71 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstring" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::memchr;
  using ::memcmp;
  using ::memcpy;
  using ::memmove;
  using ::memset;
  using ::strcat;
  using ::strcmp;
  using ::strcoll;
  using ::strcpy;
  using ::strcspn;
  using ::strerror;
  using ::strlen;
  using ::strncat;
  using ::strncmp;
  using ::strncpy;
  using ::strspn;
  using ::strtok;
  using ::strxfrm;
  using ::strchr;
  using ::strpbrk;
  using ::strrchr;
  using ::strstr;
# 121 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstring" 3
}
# 27 "/usr/include/gmpxx.h" 2 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/limits" 1 3 4
# 41 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/limits" 3
# 147 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/limits" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 191 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/limits" 3
  struct __numeric_limits_base
  {


    static constexpr bool is_specialized = false;




    static constexpr int digits = 0;


    static constexpr int digits10 = 0;




    static constexpr int max_digits10 = 0;



    static constexpr bool is_signed = false;


    static constexpr bool is_integer = false;




    static constexpr bool is_exact = false;



    static constexpr int radix = 0;



    static constexpr int min_exponent = 0;



    static constexpr int min_exponent10 = 0;




    static constexpr int max_exponent = 0;



    static constexpr int max_exponent10 = 0;


    static constexpr bool has_infinity = false;



    static constexpr bool has_quiet_NaN = false;



    static constexpr bool has_signaling_NaN = false;


    static constexpr float_denorm_style has_denorm = denorm_absent;



    static constexpr bool has_denorm_loss = false;



    static constexpr bool is_iec559 = false;




    static constexpr bool is_bounded = false;
# 277 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/limits" 3
    static constexpr bool is_modulo = false;


    static constexpr bool traps = false;


    static constexpr bool tinyness_before = false;




    static constexpr float_round_style round_style =
          round_toward_zero;
  };
# 303 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static constexpr _Tp
      min() noexcept { return _Tp(); }


      static constexpr _Tp
      max() noexcept { return _Tp(); }




      static constexpr _Tp
      lowest() noexcept { return _Tp(); }




      static constexpr _Tp
      epsilon() noexcept { return _Tp(); }


      static constexpr _Tp
      round_error() noexcept { return _Tp(); }


      static constexpr _Tp
      infinity() noexcept { return _Tp(); }



      static constexpr _Tp
      quiet_NaN() noexcept { return _Tp(); }



      static constexpr _Tp
      signaling_NaN() noexcept { return _Tp(); }




      static constexpr _Tp
      denorm_min() noexcept { return _Tp(); }
    };


  template<typename _Tp>
    struct numeric_limits<const _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<volatile _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<const volatile _Tp>
    : public numeric_limits<_Tp> { };






  template<>
    struct numeric_limits<bool>
    {
      static constexpr bool is_specialized = true;

      static constexpr bool
      min() noexcept { return false; }

      static constexpr bool
      max() noexcept { return true; }


      static constexpr bool
      lowest() noexcept { return min(); }

      static constexpr int digits = 1;
      static constexpr int digits10 = 0;

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr bool
      epsilon() noexcept { return false; }

      static constexpr bool
      round_error() noexcept { return false; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr bool
      infinity() noexcept { return false; }

      static constexpr bool
      quiet_NaN() noexcept { return false; }

      static constexpr bool
      signaling_NaN() noexcept { return false; }

      static constexpr bool
      denorm_min() noexcept { return false; }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;




      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static constexpr bool is_specialized = true;

      static constexpr char
      min() noexcept { return (((char)(-1) < 0) ? -(((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0) - 1 : (char)0); }

      static constexpr char
      max() noexcept { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }


      static constexpr char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((char)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char
      epsilon() noexcept { return 0; }

      static constexpr char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr
      char infinity() noexcept { return char(); }

      static constexpr char
      quiet_NaN() noexcept { return char(); }

      static constexpr char
      signaling_NaN() noexcept { return char(); }

      static constexpr char
      denorm_min() noexcept { return static_cast<char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static constexpr bool is_specialized = true;

      static constexpr signed char
      min() noexcept { return -127 - 1; }

      static constexpr signed char
      max() noexcept { return 127; }


      static constexpr signed char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr signed char
      epsilon() noexcept { return 0; }

      static constexpr signed char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr signed char
      infinity() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      quiet_NaN() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      signaling_NaN() noexcept
      { return static_cast<signed char>(0); }

      static constexpr signed char
      denorm_min() noexcept
      { return static_cast<signed char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned char
      min() noexcept { return 0; }

      static constexpr unsigned char
      max() noexcept { return 127 * 2U + 1; }


      static constexpr unsigned char
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned char
      epsilon() noexcept { return 0; }

      static constexpr unsigned char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned char
      infinity() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      quiet_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      signaling_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      denorm_min() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr wchar_t
      min() noexcept { return (((wchar_t)(-1) < 0) ? -(((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0) - 1 : (wchar_t)0); }

      static constexpr wchar_t
      max() noexcept { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }


      static constexpr wchar_t
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((wchar_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr wchar_t
      epsilon() noexcept { return 0; }

      static constexpr wchar_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr wchar_t
      infinity() noexcept { return wchar_t(); }

      static constexpr wchar_t
      quiet_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      signaling_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      denorm_min() noexcept { return wchar_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };



  template<>
    struct numeric_limits<char16_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char16_t
      min() noexcept { return (((char16_t)(-1) < 0) ? -(((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0) - 1 : (char16_t)0); }

      static constexpr char16_t
      max() noexcept { return (((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0); }

      static constexpr char16_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char16_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char16_t
      epsilon() noexcept { return 0; }

      static constexpr char16_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char16_t
      infinity() noexcept { return char16_t(); }

      static constexpr char16_t
      quiet_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      signaling_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      denorm_min() noexcept { return char16_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<char32_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char32_t
      min() noexcept { return (((char32_t)(-1) < 0) ? -(((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0) - 1 : (char32_t)0); }

      static constexpr char32_t
      max() noexcept { return (((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0); }

      static constexpr char32_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char32_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char32_t
      epsilon() noexcept { return 0; }

      static constexpr char32_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char32_t
      infinity() noexcept { return char32_t(); }

      static constexpr char32_t
      quiet_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      signaling_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      denorm_min() noexcept { return char32_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };



  template<>
    struct numeric_limits<short>
    {
      static constexpr bool is_specialized = true;

      static constexpr short
      min() noexcept { return -32767 - 1; }

      static constexpr short
      max() noexcept { return 32767; }


      static constexpr short
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static constexpr int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr short
      epsilon() noexcept { return 0; }

      static constexpr short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr short
      infinity() noexcept { return short(); }

      static constexpr short
      quiet_NaN() noexcept { return short(); }

      static constexpr short
      signaling_NaN() noexcept { return short(); }

      static constexpr short
      denorm_min() noexcept { return short(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned short
      min() noexcept { return 0; }

      static constexpr unsigned short
      max() noexcept { return 32767 * 2U + 1; }


      static constexpr unsigned short
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned short
      epsilon() noexcept { return 0; }

      static constexpr unsigned short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned short
      infinity() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      quiet_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      signaling_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      denorm_min() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static constexpr bool is_specialized = true;

      static constexpr int
      min() noexcept { return -2147483647 - 1; }

      static constexpr int
      max() noexcept { return 2147483647; }


      static constexpr int
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static constexpr int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr int
      epsilon() noexcept { return 0; }

      static constexpr int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr int
      infinity() noexcept { return static_cast<int>(0); }

      static constexpr int
      quiet_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      signaling_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      denorm_min() noexcept { return static_cast<int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned int
      min() noexcept { return 0; }

      static constexpr unsigned int
      max() noexcept { return 2147483647 * 2U + 1; }


      static constexpr unsigned int
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned int
      epsilon() noexcept { return 0; }

      static constexpr unsigned int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned int
      infinity() noexcept { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      quiet_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      signaling_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      denorm_min() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long
      min() noexcept { return -9223372036854775807L - 1; }

      static constexpr long
      max() noexcept { return 9223372036854775807L; }


      static constexpr long
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static constexpr int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long
      epsilon() noexcept { return 0; }

      static constexpr long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long
      infinity() noexcept { return static_cast<long>(0); }

      static constexpr long
      quiet_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      signaling_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      denorm_min() noexcept { return static_cast<long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long
      min() noexcept { return 0; }

      static constexpr unsigned long
      max() noexcept { return 9223372036854775807L * 2UL + 1; }


      static constexpr unsigned long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long
      infinity() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      quiet_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      signaling_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      denorm_min() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long long
      min() noexcept { return -9223372036854775807LL - 1; }

      static constexpr long long
      max() noexcept { return 9223372036854775807LL; }


      static constexpr long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long long
      epsilon() noexcept { return 0; }

      static constexpr long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long long
      infinity() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      quiet_NaN() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      signaling_NaN() noexcept
      { return static_cast<long long>(0); }

      static constexpr long long
      denorm_min() noexcept { return static_cast<long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long long
      min() noexcept { return 0; }

      static constexpr unsigned long long
      max() noexcept { return 9223372036854775807LL * 2ULL + 1; }


      static constexpr unsigned long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long long
      infinity() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      quiet_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      signaling_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      denorm_min() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };
# 1552 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/limits" 3
  template<>
    struct numeric_limits<float>
    {
      static constexpr bool is_specialized = true;

      static constexpr float
      min() noexcept { return 1.17549435e-38F; }

      static constexpr float
      max() noexcept { return 3.40282347e+38F; }


      static constexpr float
      lowest() noexcept { return -3.40282347e+38F; }


      static constexpr int digits = 24;
      static constexpr int digits10 = 6;

      static constexpr int max_digits10
  = (2 + (24) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr float
      epsilon() noexcept { return 1.19209290e-7F; }

      static constexpr float
      round_error() noexcept { return 0.5F; }

      static constexpr int min_exponent = (-125);
      static constexpr int min_exponent10 = (-37);
      static constexpr int max_exponent = 128;
      static constexpr int max_exponent10 = 38;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
       = false;

      static constexpr float
      infinity() noexcept { return __builtin_huge_valf(); }

      static constexpr float
      quiet_NaN() noexcept { return __builtin_nanf(""); }

      static constexpr float
      signaling_NaN() noexcept { return __builtin_nansf(""); }

      static constexpr float
      denorm_min() noexcept { return 1.40129846e-45F; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static constexpr bool is_specialized = true;

      static constexpr double
      min() noexcept { return 2.2250738585072014e-308; }

      static constexpr double
      max() noexcept { return 1.7976931348623157e+308; }


      static constexpr double
      lowest() noexcept { return -1.7976931348623157e+308; }


      static constexpr int digits = 53;
      static constexpr int digits10 = 15;

      static constexpr int max_digits10
  = (2 + (53) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr double
      epsilon() noexcept { return 2.2204460492503131e-16; }

      static constexpr double
      round_error() noexcept { return 0.5; }

      static constexpr int min_exponent = (-1021);
      static constexpr int min_exponent10 = (-307);
      static constexpr int max_exponent = 1024;
      static constexpr int max_exponent10 = 308;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
        = false;

      static constexpr double
      infinity() noexcept { return __builtin_huge_val(); }

      static constexpr double
      quiet_NaN() noexcept { return __builtin_nan(""); }

      static constexpr double
      signaling_NaN() noexcept { return __builtin_nans(""); }

      static constexpr double
      denorm_min() noexcept { return 4.9406564584124654e-324; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static constexpr bool is_specialized = true;

      static constexpr long double
      min() noexcept { return 3.36210314311209350626e-4932L; }

      static constexpr long double
      max() noexcept { return 1.18973149535723176502e+4932L; }


      static constexpr long double
      lowest() noexcept { return -1.18973149535723176502e+4932L; }


      static constexpr int digits = 64;
      static constexpr int digits10 = 18;

      static constexpr int max_digits10
  = (2 + (64) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr long double
      epsilon() noexcept { return 1.08420217248550443401e-19L; }

      static constexpr long double
      round_error() noexcept { return 0.5L; }

      static constexpr int min_exponent = (-16381);
      static constexpr int min_exponent10 = (-4931);
      static constexpr int max_exponent = 16384;
      static constexpr int max_exponent10 = 4932;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
 = false;

      static constexpr long double
      infinity() noexcept { return __builtin_huge_vall(); }

      static constexpr long double
      quiet_NaN() noexcept { return __builtin_nanl(""); }

      static constexpr long double
      signaling_NaN() noexcept { return __builtin_nansl(""); }

      static constexpr long double
      denorm_min() noexcept { return 3.64519953188247460253e-4951L; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before =
      false;
      static constexpr float_round_style round_style =
            round_to_nearest;
    };






}
# 28 "/usr/include/gmpxx.h" 2 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/utility" 1 3 4
# 59 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/utility" 3
# 69 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/utility" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_relops.h" 1 3
# 67 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_relops.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
  namespace rel_ops
  {
# 85 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }
# 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }
# 111 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }
# 124 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }


  }

}
# 70 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/utility" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_pair.h" 1 3
# 59 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_pair.h" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/move.h" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/move.h" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/concept_check.h" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/concept_check.h" 3
# 35 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/move.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Tp>
    inline _Tp*
    __addressof(_Tp& __r) noexcept
    {
      return reinterpret_cast<_Tp*>
 (&const_cast<char&>(reinterpret_cast<const volatile char&>(__r)));
    }


}



# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/type_traits" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/type_traits" 3







namespace std __attribute__ ((__visibility__ ("default")))
{
# 56 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/type_traits" 3
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static constexpr _Tp value = __v;
      typedef _Tp value_type;
      typedef integral_constant<_Tp, __v> type;
      constexpr operator value_type() { return value; }
    };

  template<typename _Tp, _Tp __v>
    constexpr _Tp integral_constant<_Tp, __v>::value;


  typedef integral_constant<bool, true> true_type;


  typedef integral_constant<bool, false> false_type;



  template<bool, typename, typename>
    struct conditional;

  template<typename...>
    struct __or_;

  template<>
    struct __or_<>
    : public false_type
    { };

  template<typename _B1>
    struct __or_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __or_<_B1, _B2>
    : public conditional<_B1::value, _B1, _B2>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __or_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type
    { };

  template<typename...>
    struct __and_;

  template<>
    struct __and_<>
    : public true_type
    { };

  template<typename _B1>
    struct __and_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __and_<_B1, _B2>
    : public conditional<_B1::value, _B2, _B1>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __and_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type
    { };

  template<typename _Pp>
    struct __not_
    : public integral_constant<bool, !_Pp::value>
    { };

  struct __sfinae_types
  {
    typedef char __one;
    typedef struct { char __arr[2]; } __two;
  };






  template<typename _Tp>
    struct __success_type
    { typedef _Tp type; };

  struct __failure_type
  { };



  template<typename>
    struct remove_cv;

  template<typename>
    struct __is_void_helper
    : public false_type { };

  template<>
    struct __is_void_helper<void>
    : public true_type { };


  template<typename _Tp>
    struct is_void
    : public integral_constant<bool, (__is_void_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };

  template<typename>
    struct __is_integral_helper
    : public false_type { };

  template<>
    struct __is_integral_helper<bool>
    : public true_type { };

  template<>
    struct __is_integral_helper<char>
    : public true_type { };

  template<>
    struct __is_integral_helper<signed char>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned char>
    : public true_type { };


  template<>
    struct __is_integral_helper<wchar_t>
    : public true_type { };


  template<>
    struct __is_integral_helper<char16_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<char32_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<short>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned short>
    : public true_type { };

  template<>
    struct __is_integral_helper<int>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned int>
    : public true_type { };

  template<>
    struct __is_integral_helper<long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long>
    : public true_type { };

  template<>
    struct __is_integral_helper<long long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long long>
    : public true_type { };
# 245 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/type_traits" 3
  template<typename _Tp>
    struct is_integral
    : public integral_constant<bool, (__is_integral_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };

  template<typename>
    struct __is_floating_point_helper
    : public false_type { };

  template<>
    struct __is_floating_point_helper<float>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<double>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<long double>
    : public true_type { };
# 274 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/type_traits" 3
  template<typename _Tp>
    struct is_floating_point
    : public integral_constant<bool, (__is_floating_point_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };


  template<typename>
    struct is_array
    : public false_type { };

  template<typename _Tp, std::size_t _Size>
    struct is_array<_Tp[_Size]>
    : public true_type { };

  template<typename _Tp>
    struct is_array<_Tp[]>
    : public true_type { };

  template<typename>
    struct __is_pointer_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_pointer_helper<_Tp*>
    : public true_type { };


  template<typename _Tp>
    struct is_pointer
    : public integral_constant<bool, (__is_pointer_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };


  template<typename>
    struct is_lvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_lvalue_reference<_Tp&>
    : public true_type { };


  template<typename>
    struct is_rvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_rvalue_reference<_Tp&&>
    : public true_type { };

  template<typename>
    struct is_function;

  template<typename>
    struct __is_member_object_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_object_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, !is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_object_pointer
    : public integral_constant<bool, (__is_member_object_pointer_helper<
          typename remove_cv<_Tp>::type>::value)>
    { };

  template<typename>
    struct __is_member_function_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_function_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_function_pointer
    : public integral_constant<bool, (__is_member_function_pointer_helper<
          typename remove_cv<_Tp>::type>::value)>
    { };


  template<typename _Tp>
    struct is_enum
    : public integral_constant<bool, __is_enum(_Tp)>
    { };


  template<typename _Tp>
    struct is_union
    : public integral_constant<bool, __is_union(_Tp)>
    { };


  template<typename _Tp>
    struct is_class
    : public integral_constant<bool, __is_class(_Tp)>
    { };


  template<typename>
    struct is_function
    : public false_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const volatile>
    : public true_type { };

  template<typename>
    struct __is_nullptr_t_helper
    : public false_type { };

  template<>
    struct __is_nullptr_t_helper<std::nullptr_t>
    : public true_type { };


  template<typename _Tp>
    struct __is_nullptr_t
    : public integral_constant<bool, (__is_nullptr_t_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };




  template<typename _Tp>
    struct is_reference
    : public __or_<is_lvalue_reference<_Tp>,
                   is_rvalue_reference<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_arithmetic
    : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_fundamental
    : public __or_<is_arithmetic<_Tp>, is_void<_Tp>, __is_nullptr_t<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_object
    : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>,
                          is_void<_Tp>>>::type
    { };

  template<typename>
    struct is_member_pointer;


  template<typename _Tp>
    struct is_scalar
    : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
                   is_member_pointer<_Tp>, __is_nullptr_t<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_compound
    : public integral_constant<bool, !is_fundamental<_Tp>::value> { };

  template<typename _Tp>
    struct __is_member_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_pointer_helper<_Tp _Cp::*>
    : public true_type { };


  template<typename _Tp>
    struct is_member_pointer
    : public integral_constant<bool, (__is_member_pointer_helper<
          typename remove_cv<_Tp>::type>::value)>
    { };




  template<typename>
    struct is_const
    : public false_type { };

  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };


  template<typename>
    struct is_volatile
    : public false_type { };

  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };


  template<typename _Tp>
    struct is_trivial
    : public integral_constant<bool, __is_trivial(_Tp)>
    { };




  template<typename _Tp>
    struct is_standard_layout
    : public integral_constant<bool, __is_standard_layout(_Tp)>
    { };



  template<typename _Tp>
    struct is_pod
    : public integral_constant<bool, __is_pod(_Tp)>
    { };


  template<typename _Tp>
    struct is_literal_type
    : public integral_constant<bool, __is_literal_type(_Tp)>
    { };


  template<typename _Tp>
    struct is_empty
    : public integral_constant<bool, __is_empty(_Tp)>
    { };


  template<typename _Tp>
    struct is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)>
    { };


  template<typename _Tp>
    struct is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)>
    { };

  template<typename _Tp,
    bool = is_integral<_Tp>::value,
    bool = is_floating_point<_Tp>::value>
    struct __is_signed_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, false, true>
    : public true_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, true, false>
    : public integral_constant<bool, static_cast<bool>(_Tp(-1) < _Tp(0))>
    { };


  template<typename _Tp>
    struct is_signed
    : public integral_constant<bool, __is_signed_helper<_Tp>::value>
    { };


  template<typename _Tp>
    struct is_unsigned
    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>::type
    { };




  template<typename>
    struct add_rvalue_reference;





  template<typename _Tp>
    typename add_rvalue_reference<_Tp>::type declval() noexcept;

  template<typename, unsigned = 0>
    struct extent;

  template<typename>
    struct remove_all_extents;

  template<typename _Tp>
    struct __is_array_known_bounds
    : public integral_constant<bool, (extent<_Tp>::value > 0)>
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds
    : public __and_<is_array<_Tp>, __not_<extent<_Tp>>>::type
    { };






  struct __do_is_destructible_impl
  {
    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_destructible_impl
    : public __do_is_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_destructible_safe;

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, false>
    : public __is_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_destructible
    : public integral_constant<bool, (__is_destructible_safe<_Tp>::value)>
    { };





  struct __do_is_nt_destructible_impl
  {
    template<typename _Tp>
      static integral_constant<bool, noexcept(declval<_Tp&>().~_Tp())>
        __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_nt_destructible_impl
    : public __do_is_nt_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_nt_destructible_safe;

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, false>
    : public __is_nt_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_nothrow_destructible
    : public integral_constant<bool, (__is_nt_destructible_safe<_Tp>::value)>
    { };

  struct __do_is_default_constructible_impl
  {
    template<typename _Tp, typename = decltype(_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_default_constructible_impl
    : public __do_is_default_constructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_default_constructible_atom
    : public __and_<__not_<is_void<_Tp>>,
                    __is_default_constructible_impl<_Tp>>::type
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_default_constructible_safe;






  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>::type
    { };

  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, false>
    : public __is_default_constructible_atom<_Tp>::type
    { };


  template<typename _Tp>
    struct is_default_constructible
    : public integral_constant<bool, (__is_default_constructible_safe<
          _Tp>::value)>
    { };
# 765 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/type_traits" 3
  struct __do_is_static_castable_impl
  {
    template<typename _From, typename _To, typename
             = decltype(static_cast<_To>(declval<_From>()))>
      static true_type __test(int);

    template<typename, typename>
      static false_type __test(...);
  };

  template<typename _From, typename _To>
    struct __is_static_castable_impl
    : public __do_is_static_castable_impl
    {
      typedef decltype(__test<_From, _To>(0)) type;
    };

  template<typename _From, typename _To>
    struct __is_static_castable_safe
    : public __is_static_castable_impl<_From, _To>::type
    { };


  template<typename _From, typename _To>
    struct __is_static_castable
    : public integral_constant<bool, (__is_static_castable_safe<
          _From, _To>::value)>
    { };






  struct __do_is_direct_constructible_impl
  {
    template<typename _Tp, typename _Arg, typename
      = decltype(::new _Tp(declval<_Arg>()))>
      static true_type __test(int);

    template<typename, typename>
      static false_type __test(...);
  };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_impl
    : public __do_is_direct_constructible_impl
    {
      typedef decltype(__test<_Tp, _Arg>(0)) type;
    };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_new_safe
    : public __and_<is_destructible<_Tp>,
                    __is_direct_constructible_impl<_Tp, _Arg>>::type
    { };

  template<typename, typename>
    struct is_same;

  template<typename, typename>
    struct is_base_of;

  template<typename>
    struct remove_reference;

  template<typename _From, typename _To, bool
           = __not_<__or_<is_void<_From>,
                          is_function<_From>>>::value>
    struct __is_base_to_derived_ref;



  template<typename _From, typename _To>
    struct __is_base_to_derived_ref<_From, _To, true>
    {
      typedef typename remove_cv<typename remove_reference<_From
        >::type>::type __src_t;
      typedef typename remove_cv<typename remove_reference<_To
        >::type>::type __dst_t;
      typedef __and_<__not_<is_same<__src_t, __dst_t>>,
       is_base_of<__src_t, __dst_t>> type;
      static constexpr bool value = type::value;
    };

  template<typename _From, typename _To>
    struct __is_base_to_derived_ref<_From, _To, false>
    : public false_type
    { };

  template<typename _From, typename _To, bool
           = __and_<is_lvalue_reference<_From>,
                    is_rvalue_reference<_To>>::value>
    struct __is_lvalue_to_rvalue_ref;



  template<typename _From, typename _To>
    struct __is_lvalue_to_rvalue_ref<_From, _To, true>
    {
      typedef typename remove_cv<typename remove_reference<
        _From>::type>::type __src_t;
      typedef typename remove_cv<typename remove_reference<
        _To>::type>::type __dst_t;
      typedef __and_<__not_<is_function<__src_t>>,
        __or_<is_same<__src_t, __dst_t>,
      is_base_of<__dst_t, __src_t>>> type;
      static constexpr bool value = type::value;
    };

  template<typename _From, typename _To>
    struct __is_lvalue_to_rvalue_ref<_From, _To, false>
    : public false_type
    { };







  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_ref_cast
    : public __and_<__is_static_castable<_Arg, _Tp>,
                    __not_<__or_<__is_base_to_derived_ref<_Arg, _Tp>,
                                 __is_lvalue_to_rvalue_ref<_Arg, _Tp>
                   >>>::type
    { };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_new
    : public conditional<is_reference<_Tp>::value,
    __is_direct_constructible_ref_cast<_Tp, _Arg>,
    __is_direct_constructible_new_safe<_Tp, _Arg>
    >::type
    { };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible
    : public integral_constant<bool, (__is_direct_constructible_new<
          _Tp, _Arg>::value)>
    { };






  struct __do_is_nary_constructible_impl
  {
    template<typename _Tp, typename... _Args, typename
             = decltype(_Tp(declval<_Args>()...))>
      static true_type __test(int);

    template<typename, typename...>
      static false_type __test(...);
  };

  template<typename _Tp, typename... _Args>
    struct __is_nary_constructible_impl
    : public __do_is_nary_constructible_impl
    {
      typedef decltype(__test<_Tp, _Args...>(0)) type;
    };

  template<typename _Tp, typename... _Args>
    struct __is_nary_constructible
    : public __is_nary_constructible_impl<_Tp, _Args...>::type
    {
      static_assert(sizeof...(_Args) > 1,
                    "Only useful for > 1 arguments");
    };

  template<typename _Tp, typename... _Args>
    struct __is_constructible_impl
    : public __is_nary_constructible<_Tp, _Args...>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_constructible_impl<_Tp, _Arg>
    : public __is_direct_constructible<_Tp, _Arg>
    { };

  template<typename _Tp>
    struct __is_constructible_impl<_Tp>
    : public is_default_constructible<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_constructible
    : public integral_constant<bool, (__is_constructible_impl<_Tp,
          _Args...>::value)>
    { };

  template<typename _Tp, bool = is_void<_Tp>::value>
    struct __is_copy_constructible_impl;

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, true>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, false>
    : public is_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_constructible
    : public __is_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = is_void<_Tp>::value>
    struct __is_move_constructible_impl;

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, true>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, false>
    : public is_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_constructible
    : public __is_move_constructible_impl<_Tp>
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_atom
    : public integral_constant<bool, noexcept(_Tp())>
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_nt_default_constructible_impl;

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_nt_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>::type
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, false>
    : public __is_nt_default_constructible_atom<_Tp>
    { };


  template<typename _Tp>
    struct is_nothrow_default_constructible
    : public __and_<is_default_constructible<_Tp>,
                    __is_nt_default_constructible_impl<_Tp>>::type
    { };

  template<typename _Tp, typename... _Args>
    struct __is_nt_constructible_impl
    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_nt_constructible_impl<_Tp, _Arg>
    : public integral_constant<bool,
                               noexcept(static_cast<_Tp>(declval<_Arg>()))>
    { };

  template<typename _Tp>
    struct __is_nt_constructible_impl<_Tp>
    : public is_nothrow_default_constructible<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_nothrow_constructible
    : public __and_<is_constructible<_Tp, _Args...>,
      __is_nt_constructible_impl<_Tp, _Args...>>::type
    { };

  template<typename _Tp, bool = is_void<_Tp>::value>
    struct __is_nothrow_copy_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, true>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, false>
    : public is_nothrow_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_constructible
    : public __is_nothrow_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = is_void<_Tp>::value>
    struct __is_nothrow_move_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, true>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, false>
    : public is_nothrow_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_constructible
    : public __is_nothrow_move_constructible_impl<_Tp>
    { };

  template<typename _Tp, typename _Up>
    class __is_assignable_helper
    : public __sfinae_types
    {
      template<typename _Tp1, typename _Up1>
        static decltype(declval<_Tp1>() = declval<_Up1>(), __one())
 __test(int);

      template<typename, typename>
        static __two __test(...);

    public:
      static constexpr bool value = sizeof(__test<_Tp, _Up>(0)) == 1;
    };


  template<typename _Tp, typename _Up>
    struct is_assignable
    : public integral_constant<bool,
                               __is_assignable_helper<_Tp, _Up>::value>
    { };

  template<typename _Tp, bool = is_void<_Tp>::value>
    struct __is_copy_assignable_impl;

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, true>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, false>
    : public is_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_assignable
    : public __is_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = is_void<_Tp>::value>
    struct __is_move_assignable_impl;

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, true>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, false>
    : public is_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_assignable
    : public __is_move_assignable_impl<_Tp>
    { };

  template<typename _Tp, typename _Up>
    struct __is_nt_assignable_impl
    : public integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())>
    { };


  template<typename _Tp, typename _Up>
    struct is_nothrow_assignable
    : public __and_<is_assignable<_Tp, _Up>,
      __is_nt_assignable_impl<_Tp, _Up>>::type
    { };

  template<typename _Tp, bool = is_void<_Tp>::value>
    struct __is_nt_copy_assignable_impl;

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, true>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, false>
    : public is_nothrow_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_assignable
    : public __is_nt_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = is_void<_Tp>::value>
    struct __is_nt_move_assignable_impl;

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, true>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, false>
    : public is_nothrow_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_assignable
    : public __is_nt_move_assignable_impl<_Tp>
    { };
# 1203 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/type_traits" 3
  template<typename _Tp>
    struct is_trivially_destructible
    : public __and_<is_destructible<_Tp>, integral_constant<bool,
         __has_trivial_destructor(_Tp)>>::type
    { };


  template<typename _Tp>
    struct has_trivial_default_constructor
    : public integral_constant<bool, __has_trivial_constructor(_Tp)>
    { };


  template<typename _Tp>
    struct has_trivial_copy_constructor
    : public integral_constant<bool, __has_trivial_copy(_Tp)>
    { };


  template<typename _Tp>
    struct has_trivial_copy_assign
    : public integral_constant<bool, __has_trivial_assign(_Tp)>
    { };


  template<typename _Tp>
    struct has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)>
    { };





  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, __alignof__(_Tp)> { };


  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };

  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };


  template<typename, unsigned _Uint>
    struct extent
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, unsigned _Uint, std::size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? _Size : extent<_Tp,
          _Uint - 1>::value>
    { };

  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? 0 : extent<_Tp,
             _Uint - 1>::value>
    { };





  template<typename, typename>
    struct is_same
    : public false_type { };

  template<typename _Tp>
    struct is_same<_Tp, _Tp>
    : public true_type { };


  template<typename _Base, typename _Derived>
    struct is_base_of
    : public integral_constant<bool, __is_base_of(_Base, _Derived)>
    { };

  template<typename _From, typename _To,
           bool = __or_<is_void<_From>, is_function<_To>,
                        is_array<_To>>::value>
    struct __is_convertible_helper
    { static constexpr bool value = is_void<_To>::value; };

  template<typename _From, typename _To>
    class __is_convertible_helper<_From, _To, false>
    : public __sfinae_types
    {
      template<typename _To1>
        static void __test_aux(_To1);

      template<typename _From1, typename _To1>
        static decltype(__test_aux<_To1>(std::declval<_From1>()), __one())
 __test(int);

      template<typename, typename>
        static __two __test(...);

    public:
      static constexpr bool value = sizeof(__test<_From, _To>(0)) == 1;
    };


  template<typename _From, typename _To>
    struct is_convertible
    : public integral_constant<bool,
          __is_convertible_helper<_From, _To>::value>
    { };





  template<typename _Tp>
    struct remove_const
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_const<_Tp const>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_volatile
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_cv
    {
      typedef typename
      remove_const<typename remove_volatile<_Tp>::type>::type type;
    };


  template<typename _Tp>
    struct add_const
    { typedef _Tp const type; };


  template<typename _Tp>
    struct add_volatile
    { typedef _Tp volatile type; };


  template<typename _Tp>
    struct add_cv
    {
      typedef typename
      add_const<typename add_volatile<_Tp>::type>::type type;
    };





  template<typename _Tp>
    struct remove_reference
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&&>
    { typedef _Tp type; };

  template<typename _Tp,
    bool = __and_<__not_<is_reference<_Tp>>,
                         __not_<is_void<_Tp>>>::value,
    bool = is_rvalue_reference<_Tp>::value>
    struct __add_lvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, true, false>
    { typedef _Tp& type; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, false, true>
    { typedef typename remove_reference<_Tp>::type& type; };


  template<typename _Tp>
    struct add_lvalue_reference
    : public __add_lvalue_reference_helper<_Tp>
    { };

  template<typename _Tp,
           bool = __and_<__not_<is_reference<_Tp>>,
                         __not_<is_void<_Tp>>>::value>
    struct __add_rvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_rvalue_reference_helper<_Tp, true>
    { typedef _Tp&& type; };


  template<typename _Tp>
    struct add_rvalue_reference
    : public __add_rvalue_reference_helper<_Tp>
    { };





  template<typename _Unqualified, bool _IsConst, bool _IsVol>
    struct __cv_selector;

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, false>
    { typedef _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, true>
    { typedef volatile _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, false>
    { typedef const _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, true>
    { typedef const volatile _Unqualified __type; };

  template<typename _Qualified, typename _Unqualified,
    bool _IsConst = is_const<_Qualified>::value,
    bool _IsVol = is_volatile<_Qualified>::value>
    class __match_cv_qualifiers
    {
      typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;

    public:
      typedef typename __match::__type __type;
    };


  template<typename _Tp>
    struct __make_unsigned
    { typedef _Tp __type; };

  template<>
    struct __make_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __make_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __make_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __make_unsigned<long long>
    { typedef unsigned long long __type; };
# 1492 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_unsigned_selector;

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, true, false>
    {
      typedef __make_unsigned<typename remove_cv<_Tp>::type> __unsignedt;
      typedef typename __unsignedt::__type __unsigned_type;
      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;

    public:
      typedef typename __cv_unsigned::__type __type;
    };

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, false, true>
    {

      typedef unsigned char __smallest;
      static const bool __b0 = sizeof(_Tp) <= sizeof(__smallest);
      static const bool __b1 = sizeof(_Tp) <= sizeof(unsigned short);
      static const bool __b2 = sizeof(_Tp) <= sizeof(unsigned int);
      typedef conditional<__b2, unsigned int, unsigned long> __cond2;
      typedef typename __cond2::type __cond2_type;
      typedef conditional<__b1, unsigned short, __cond2_type> __cond1;
      typedef typename __cond1::type __cond1_type;

    public:
      typedef typename conditional<__b0, __smallest, __cond1_type>::type __type;
    };





  template<typename _Tp>
    struct make_unsigned
    { typedef typename __make_unsigned_selector<_Tp>::__type type; };


  template<>
    struct make_unsigned<bool>;



  template<typename _Tp>
    struct __make_signed
    { typedef _Tp __type; };

  template<>
    struct __make_signed<char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned short>
    { typedef signed short __type; };

  template<>
    struct __make_signed<unsigned int>
    { typedef signed int __type; };

  template<>
    struct __make_signed<unsigned long>
    { typedef signed long __type; };

  template<>
    struct __make_signed<unsigned long long>
    { typedef signed long long __type; };
# 1574 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_signed_selector;

  template<typename _Tp>
    class __make_signed_selector<_Tp, true, false>
    {
      typedef __make_signed<typename remove_cv<_Tp>::type> __signedt;
      typedef typename __signedt::__type __signed_type;
      typedef __match_cv_qualifiers<_Tp, __signed_type> __cv_signed;

    public:
      typedef typename __cv_signed::__type __type;
    };

  template<typename _Tp>
    class __make_signed_selector<_Tp, false, true>
    {

      typedef signed char __smallest;
      static const bool __b0 = sizeof(_Tp) <= sizeof(__smallest);
      static const bool __b1 = sizeof(_Tp) <= sizeof(signed short);
      static const bool __b2 = sizeof(_Tp) <= sizeof(signed int);
      typedef conditional<__b2, signed int, signed long> __cond2;
      typedef typename __cond2::type __cond2_type;
      typedef conditional<__b1, signed short, __cond2_type> __cond1;
      typedef typename __cond1::type __cond1_type;

    public:
      typedef typename conditional<__b0, __smallest, __cond1_type>::type __type;
    };





  template<typename _Tp>
    struct make_signed
    { typedef typename __make_signed_selector<_Tp>::__type type; };


  template<>
    struct make_signed<bool>;





  template<typename _Tp>
    struct remove_extent
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_all_extents
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { typedef typename remove_all_extents<_Tp>::type type; };

  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { typedef typename remove_all_extents<_Tp>::type type; };




  template<typename _Tp, typename>
    struct __remove_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp, typename _Up>
    struct __remove_pointer_helper<_Tp, _Up*>
    { typedef _Up type; };


  template<typename _Tp>
    struct remove_pointer
    : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type>
    { };


  template<typename _Tp>
    struct add_pointer
    { typedef typename remove_reference<_Tp>::type* type; };


  template<std::size_t _Len>
    struct __aligned_storage_msa
    {
      union __type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__)) { } __align;
      };
    };
# 1691 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/type_traits" 3
  template<std::size_t _Len, std::size_t _Align =
    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    struct aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };




  template<typename _Up,
    bool _IsArray = is_array<_Up>::value,
    bool _IsFunction = is_function<_Up>::value>
    struct __decay_selector;


  template<typename _Up>
    struct __decay_selector<_Up, false, false>
    { typedef typename remove_cv<_Up>::type __type; };

  template<typename _Up>
    struct __decay_selector<_Up, true, false>
    { typedef typename remove_extent<_Up>::type* __type; };

  template<typename _Up>
    struct __decay_selector<_Up, false, true>
    { typedef typename add_pointer<_Up>::type __type; };


  template<typename _Tp>
    class decay
    {
      typedef typename remove_reference<_Tp>::type __remove_type;

    public:
      typedef typename __decay_selector<__remove_type>::__type type;
    };

  template<typename _Tp>
    class reference_wrapper;


  template<typename _Tp>
    struct __strip_reference_wrapper
    {
      typedef _Tp __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<const reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };

  template<typename _Tp>
    struct __decay_and_strip
    {
      typedef typename __strip_reference_wrapper<
 typename decay<_Tp>::type>::__type __type;
    };




  template<bool, typename _Tp = void>
    struct enable_if
    { };


  template<typename _Tp>
    struct enable_if<true, _Tp>
    { typedef _Tp type; };

  template<typename... _Cond>
    using _Require = typename enable_if<__and_<_Cond...>::value>::type;



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct conditional
    { typedef _Iftrue type; };


  template<typename _Iftrue, typename _Iffalse>
    struct conditional<false, _Iftrue, _Iffalse>
    { typedef _Iffalse type; };


  template<typename... _Tp>
    struct common_type;



  struct __do_common_type_impl
  {
    template<typename _Tp, typename _Up>
      static __success_type<typename decay<decltype
       (true ? std::declval<_Tp>()
        : std::declval<_Up>())>::type> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp, typename _Up>
    struct __common_type_impl
    : private __do_common_type_impl
    {
      typedef decltype(_S_test<_Tp, _Up>(0)) type;
    };

  struct __do_member_type_wrapper
  {
    template<typename _Tp>
      static __success_type<typename _Tp::type> _S_test(int);

    template<typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp>
    struct __member_type_wrapper
    : private __do_member_type_wrapper
    {
      typedef decltype(_S_test<_Tp>(0)) type;
    };

  template<typename _CTp, typename... _Args>
    struct __expanded_common_type_wrapper
    {
      typedef common_type<typename _CTp::type, _Args...> type;
    };

  template<typename... _Args>
    struct __expanded_common_type_wrapper<__failure_type, _Args...>
    { typedef __failure_type type; };

  template<typename _Tp>
    struct common_type<_Tp>
    { typedef typename decay<_Tp>::type type; };

  template<typename _Tp, typename _Up>
    struct common_type<_Tp, _Up>
    : public __common_type_impl<_Tp, _Up>::type
    { };

  template<typename _Tp, typename _Up, typename... _Vp>
    struct common_type<_Tp, _Up, _Vp...>
    : public __expanded_common_type_wrapper<typename __member_type_wrapper<
               common_type<_Tp, _Up>>::type, _Vp...>::type
    { };


  template<typename _Tp>
    struct underlying_type
    {
      typedef __underlying_type(_Tp) type;
    };

  template<typename _Tp>
    struct __declval_protector
    {
      static const bool __stop = false;
      static typename add_rvalue_reference<_Tp>::type __delegate();
    };

  template<typename _Tp>
    inline typename add_rvalue_reference<_Tp>::type
    declval() noexcept
    {
      static_assert(__declval_protector<_Tp>::__stop,
      "declval() must not be used!");
      return __declval_protector<_Tp>::__delegate();
    }


  template<typename _Signature>
    class result_of;




  struct __result_of_memfun_ref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __success_type<decltype(
      (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)
      )> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_ref
    : private __result_of_memfun_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memfun_deref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __success_type<decltype(
      ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)
      )> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_deref
    : private __result_of_memfun_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memobj_ref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __success_type<decltype(
      std::declval<_Tp1>().*std::declval<_Fp>()
      )> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_ref
    : private __result_of_memobj_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };


  struct __result_of_memobj_deref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __success_type<decltype(
      (*std::declval<_Tp1>()).*std::declval<_Fp>()
      )> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_deref
    : private __result_of_memobj_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj;

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, _Arg>
    {
      typedef typename remove_cv<typename remove_reference<
        _Arg>::type>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memobj_ref<_MemPtr, _Arg>,
        __result_of_memobj_deref<_MemPtr, _Arg>
      >::type::type type;
    };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun;

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>
    {
      typedef typename remove_cv<typename remove_reference<
        _Arg>::type>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
        __result_of_memfun_deref<_MemPtr, _Arg, _Args...>
      >::type::type type;
    };

  template<bool, bool, typename _Functor, typename... _ArgTypes>
    struct __result_of_impl
    {
      typedef __failure_type type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_impl<true, false, _MemPtr, _Arg>
    : public __result_of_memobj<typename decay<_MemPtr>::type, _Arg>
    { };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
    : public __result_of_memfun<typename decay<_MemPtr>::type, _Arg, _Args...>
    { };


  struct __result_of_other_impl
  {
    template<typename _Fn, typename... _Args>
      static __success_type<decltype(
      std::declval<_Fn>()(std::declval<_Args>()...)
      )> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _Functor, typename... _ArgTypes>
    struct __result_of_impl<false, false, _Functor, _ArgTypes...>
    : private __result_of_other_impl
    {
      typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
    };

  template<typename _Functor, typename... _ArgTypes>
    struct result_of<_Functor(_ArgTypes...)>
    : public __result_of_impl<
        is_member_object_pointer<
          typename remove_reference<_Functor>::type
        >::value,
        is_member_function_pointer<
          typename remove_reference<_Functor>::type
        >::value,
     _Functor, _ArgTypes...
      >::type
    { };
# 2070 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/type_traits" 3
}
# 58 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/move.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
# 74 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/move.h" 3
  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Tp&&>(__t); }







  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
    {
      static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
      " substituting _Tp is an lvalue reference type");
      return static_cast<_Tp&&>(__t);
    }






  template<typename _Tp>
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }


  template<typename _Tp>
    struct __move_if_noexcept_cond
    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                    is_copy_constructible<_Tp>>::type { };
# 118 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/move.h" 3
  template<typename _Tp>
    inline constexpr typename
    conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type
    move_if_noexcept(_Tp& __x) noexcept
    { return std::move(__x); }
# 133 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/move.h" 3
  template<typename _Tp>
    inline _Tp*
    addressof(_Tp& __r) noexcept
    { return std::__addressof(__r); }



}
# 149 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/move.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 164 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/move.h" 3
  template<typename _Tp>
    inline void
    swap(_Tp& __a, _Tp& __b)

    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value)

    {



      _Tp __tmp = std::move(__a);
      __a = std::move(__b);
      __b = std::move(__tmp);
    }




  template<typename _Tp, size_t _Nm>
    inline void
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])

    noexcept(noexcept(swap(*__a, *__b)))

    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }



}
# 60 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_pair.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{
# 76 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_pair.h" 3
  struct piecewise_construct_t { };


  constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();


  template<typename...>
    class tuple;

  template<std::size_t...>
    struct _Index_tuple;
# 95 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_pair.h" 3
  template<class _T1, class _T2>
    struct pair
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;





      constexpr pair()
      : first(), second() { }


      constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }







      template<class _U1, class _U2, class = typename
        enable_if<__and_<is_convertible<const _U1&, _T1>,
    is_convertible<const _U2&, _T2>>::value>::type>
 constexpr pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }

      constexpr pair(const pair&) = default;
      constexpr pair(pair&&) = default;


      template<class _U1, class = typename
        enable_if<is_convertible<_U1, _T1>::value>::type>
 constexpr pair(_U1&& __x, const _T2& __y)
 : first(std::forward<_U1>(__x)), second(__y) { }

      template<class _U2, class = typename
        enable_if<is_convertible<_U2, _T2>::value>::type>
 constexpr pair(const _T1& __x, _U2&& __y)
 : first(__x), second(std::forward<_U2>(__y)) { }

      template<class _U1, class _U2, class = typename
        enable_if<__and_<is_convertible<_U1, _T1>,
    is_convertible<_U2, _T2>>::value>::type>
 constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }

      template<class _U1, class _U2, class = typename
        enable_if<__and_<is_convertible<_U1, _T1>,
    is_convertible<_U2, _T2>>::value>::type>
 constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename... _Args1, typename... _Args2>
        pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);

      pair&
      operator=(const pair& __p)
      {
 first = __p.first;
 second = __p.second;
 return *this;
      }

      pair&
      operator=(pair&& __p)
      noexcept(__and_<is_nothrow_move_assignable<_T1>,
               is_nothrow_move_assignable<_T2>>::value)
      {
 first = std::forward<first_type>(__p.first);
 second = std::forward<second_type>(__p.second);
 return *this;
      }

      template<class _U1, class _U2>
 pair&
 operator=(const pair<_U1, _U2>& __p)
 {
   first = __p.first;
   second = __p.second;
   return *this;
 }

      template<class _U1, class _U2>
 pair&
 operator=(pair<_U1, _U2>&& __p)
 {
   first = std::forward<_U1>(__p.first);
   second = std::forward<_U2>(__p.second);
   return *this;
 }

      void
      swap(pair& __p)
      noexcept(noexcept(swap(first, __p.first))
        && noexcept(swap(second, __p.second)))
      {
 using std::swap;
 swap(first, __p.first);
 swap(second, __p.second);
      }

    private:
      template<typename... _Args1, std::size_t... _Indexes1,
               typename... _Args2, std::size_t... _Indexes2>
        pair(tuple<_Args1...>&, tuple<_Args2...>&,
             _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);

    };


  template<class _T1, class _T2>
    inline constexpr bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<class _T1, class _T2>
    inline constexpr bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<class _T1, class _T2>
    inline constexpr bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<class _T1, class _T2>
    inline constexpr bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<class _T1, class _T2>
    inline constexpr bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<class _T1, class _T2>
    inline constexpr bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }





  template<class _T1, class _T2>
    inline void
    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }
# 273 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_pair.h" 3
  template<class _T1, class _T2>
    constexpr pair<typename __decay_and_strip<_T1>::__type,
                   typename __decay_and_strip<_T2>::__type>
    make_pair(_T1&& __x, _T2&& __y)
    {
      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
      typedef pair<__ds_type1, __ds_type2> __pair_type;
      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
# 293 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_pair.h" 3
}
# 71 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/utility" 2 3



# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/initializer_list" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/initializer_list" 3





#pragma GCC visibility push(default)



namespace std
{

  template<class _E>
    class initializer_list
    {
    public:
      typedef _E value_type;
      typedef const _E& reference;
      typedef const _E& const_reference;
      typedef size_t size_type;
      typedef const _E* iterator;
      typedef const _E* const_iterator;

    private:
      iterator _M_array;
      size_type _M_len;


      constexpr initializer_list(const_iterator __a, size_type __l)
      : _M_array(__a), _M_len(__l) { }

    public:
      constexpr initializer_list() noexcept
      : _M_array(0), _M_len(0) { }


      constexpr size_type
      size() const noexcept { return _M_len; }


      constexpr const_iterator
      begin() const noexcept { return _M_array; }


      constexpr const_iterator
      end() const noexcept { return begin() + size(); }
    };






  template<class _Tp>
    constexpr const _Tp*
    begin(initializer_list<_Tp> __ils) noexcept
    { return __ils.begin(); }






  template<class _Tp>
    constexpr const _Tp*
    end(initializer_list<_Tp> __ils) noexcept
    { return __ils.end(); }
}

#pragma GCC visibility pop
# 75 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/utility" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<class _Tp>
    class tuple_size;

  template<std::size_t _Int, class _Tp>
    class tuple_element;


  template<class _Tp1, class _Tp2>
    struct tuple_size<std::pair<_Tp1, _Tp2>>
    : public integral_constant<std::size_t, 2> { };

  template<class _Tp1, class _Tp2>
    struct tuple_element<0, std::pair<_Tp1, _Tp2>>
    { typedef _Tp1 type; };

  template<class _Tp1, class _Tp2>
    struct tuple_element<1, std::pair<_Tp1, _Tp2>>
    { typedef _Tp2 type; };

  template<std::size_t _Int>
    struct __pair_get;

  template<>
    struct __pair_get<0>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp1>(__pair.first); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp1&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }
    };

  template<>
    struct __pair_get<1>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp2>(__pair.second); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp2&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }
    };

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__get(__in); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&&
    get(std::pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__move_get(std::move(__in)); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(const std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__const_get(__in); }


}
# 29 "/usr/include/gmpxx.h" 2 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/algorithm" 1 3 4
# 59 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/algorithm" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algobase.h" 1 3
# 60 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algobase.h" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/functexcept.h" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/functexcept.h" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/exception_defines.h" 1 3
# 41 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/functexcept.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

  void
  __throw_system_error(int) __attribute__((__noreturn__));

  void
  __throw_future_error(int) __attribute__((__noreturn__));


  void
  __throw_bad_function_call() __attribute__((__noreturn__));


}
# 61 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algobase.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/cpp_type_traits.h" 1 3
# 36 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/cpp_type_traits.h" 3
# 68 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/cpp_type_traits.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  template<typename _Iterator, typename _Container>
    class __normal_iterator;


}

namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };




  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_integer<char16_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char32_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_normal_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Iterator, typename _Container>
    struct __is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator,
             _Container> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_fundamental
    : public __traitor<__is_void<_Tp>, __is_arithmetic<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<typename _Iterator>
    class move_iterator;

  template<typename _Iterator>
    struct __is_move_iterator< move_iterator<_Iterator> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



}
# 62 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algobase.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ext/type_traits.h" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ext/type_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }



  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };




  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };

  template<typename _Tp, typename _Up,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type>
    struct __promote_2
    {
      typedef __typeof__(_Tp2() + _Up2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type>
    struct __promote_3
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type,
           typename _Wp2 = typename __promote<_Wp>::__type>
    struct __promote_4
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
    };


}
# 63 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algobase.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ext/numeric_traits.h" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ext/numeric_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{
# 54 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_integer
    {

      static const _Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);
      static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);



      static const bool __is_signed = ((_Value)(-1) < 0);
      static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
# 99 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;

  template<typename _Value>
    struct __numeric_traits
    : public __conditional_type<std::__is_integer<_Value>::__value,
    __numeric_traits_integer<_Value>,
    __numeric_traits_floating<_Value> >::__type
    { };


}
# 64 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algobase.h" 2 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_iterator_base_types.h" 1 3
# 63 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_iterator_base_types.h" 3







namespace std __attribute__ ((__visibility__ ("default")))
{
# 89 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };


  struct output_iterator_tag { };


  struct forward_iterator_tag : public input_iterator_tag { };



  struct bidirectional_iterator_tag : public forward_iterator_tag { };



  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
# 116 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };
# 142 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_iterator_base_types.h" 3
template<typename _Tp> class __has_iterator_category_helper : __sfinae_types { template<typename _Up> struct _Wrap_type { }; template<typename _Up> static __one __test(_Wrap_type<typename _Up::iterator_category>*); template<typename _Up> static __two __test(...); public: static constexpr bool value = sizeof(__test<_Tp>(0)) == 1; }; template<typename _Tp> struct __has_iterator_category : integral_constant<bool, __has_iterator_category_helper <typename remove_cv<_Tp>::type>::value> { };

  template<typename _Iterator,
    bool = __has_iterator_category<_Iterator>::value>
    struct __iterator_traits { };

  template<typename _Iterator>
    struct __iterator_traits<_Iterator, true>
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };

  template<typename _Iterator>
    struct iterator_traits
    : public __iterator_traits<_Iterator> { };
# 174 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_iterator_base_types.h" 3
  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };


  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };





  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }





  template<typename _Iterator, bool _HasBase>
    struct _Iter_base
    {
      typedef _Iterator iterator_type;
      static iterator_type _S_base(_Iterator __it)
      { return __it; }
    };

  template<typename _Iterator>
    struct _Iter_base<_Iterator, true>
    {
      typedef typename _Iterator::iterator_type iterator_type;
      static iterator_type _S_base(_Iterator __it)
      { return __it.base(); }
    };


  template<typename _InIter>
    using _RequireInputIter = typename
      enable_if<is_convertible<typename
  iterator_traits<_InIter>::iterator_category,
          input_iterator_tag>::value>::type;



}
# 66 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algobase.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_iterator_base_funcs.h" 1 3
# 63 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_iterator_base_funcs.h" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/debug/debug.h" 1 3
# 46 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;
}
# 66 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_iterator_base_funcs.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {



      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {



      return __last - __first;
    }
# 112 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {


                                     ;
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {



      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {



      __i += __n;
    }
# 171 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }



  template<typename _ForwardIterator>
    inline _ForwardIterator
    next(_ForwardIterator __x, typename
  iterator_traits<_ForwardIterator>::difference_type __n = 1)
    {
      std::advance(__x, __n);
      return __x;
    }

  template<typename _BidirectionalIterator>
    inline _BidirectionalIterator
    prev(_BidirectionalIterator __x, typename
  iterator_traits<_BidirectionalIterator>::difference_type __n = 1)
    {
      std::advance(__x, -__n);
      return __x;
    }




}
# 67 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algobase.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_iterator.h" 1 3
# 67 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_iterator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 95 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::pointer pointer;
      typedef typename __traits_type::reference reference;







      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      iterator_type
      base() const
      { return current; }
# 159 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_iterator.h" 3
      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      pointer
      operator->() const
      { return &(operator*()); }






      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }







      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }







      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
# 289 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline typename reverse_iterator<_Iterator>::difference_type
    operator-(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() - __x.base(); }

  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _IteratorL, typename _IteratorR>


    inline auto
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    -> decltype(__y.base() - __x.base())





    { return __y.base() - __x.base(); }
# 401 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x) : container(&__x) { }
# 435 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_back(__value);
 return *this;
      }

      back_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_back(std::move(__value));
 return *this;
      }



      back_insert_iterator&
      operator*()
      { return *this; }


      back_insert_iterator&
      operator++()
      { return *this; }


      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 477 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 492 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x) : container(&__x) { }
# 525 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_front(__value);
 return *this;
      }

      front_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_front(std::move(__value));
 return *this;
      }



      front_insert_iterator&
      operator*()
      { return *this; }


      front_insert_iterator&
      operator++()
      { return *this; }


      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 567 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 586 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(&__x), iter(__i) {}
# 637 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }

      insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 iter = container->insert(iter, std::move(__value));
 ++iter;
 return *this;
      }



      insert_iterator&
      operator*()
      { return *this; }


      insert_iterator&
      operator++()
      { return *this; }


      insert_iterator&
      operator++(int)
      { return *this; }
    };
# 681 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }




}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{
# 705 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_iterator.h" 3
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;

      constexpr __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }


      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i)
        : _M_current(__i.base()) { }


      reference
      operator*() const
      { return *_M_current; }

      pointer
      operator->() const
      { return _M_current; }

      __normal_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      __normal_iterator
      operator++(int)
      { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      __normal_iterator
      operator--(int)
      { return __normal_iterator(_M_current--); }


      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const
      { return _M_current; }
    };
# 803 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>


    inline auto
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    -> decltype(__lhs.base() - __rhs.base())





    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }


}



namespace std __attribute__ ((__visibility__ ("default")))
{
# 929 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class move_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;

      typedef _Iterator pointer;
      typedef value_type&& reference;

      move_iterator()
      : _M_current() { }

      explicit
      move_iterator(iterator_type __i)
      : _M_current(__i) { }

      template<typename _Iter>
 move_iterator(const move_iterator<_Iter>& __i)
 : _M_current(__i.base()) { }

      iterator_type
      base() const
      { return _M_current; }

      reference
      operator*() const
      { return std::move(*_M_current); }

      pointer
      operator->() const
      { return _M_current; }

      move_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      move_iterator
      operator++(int)
      {
 move_iterator __tmp = *this;
 ++_M_current;
 return __tmp;
      }

      move_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      move_iterator
      operator--(int)
      {
 move_iterator __tmp = *this;
 --_M_current;
 return __tmp;
      }

      move_iterator
      operator+(difference_type __n) const
      { return move_iterator(_M_current + __n); }

      move_iterator&
      operator+=(difference_type __n)
      {
 _M_current += __n;
 return *this;
      }

      move_iterator
      operator-(difference_type __n) const
      { return move_iterator(_M_current - __n); }

      move_iterator&
      operator-=(difference_type __n)
      {
 _M_current -= __n;
 return *this;
      }

      reference
      operator[](difference_type __n) const
      { return std::move(_M_current[__n]); }
    };




  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator==(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator!=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __x.base() < __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __x.base() < __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator<=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator>(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline bool
    operator>=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x < __y); }


  template<typename _IteratorL, typename _IteratorR>
    inline auto
    operator-(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    inline auto
    operator-(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    operator+(typename move_iterator<_Iterator>::difference_type __n,
       const move_iterator<_Iterator>& __x)
    { return __x + __n; }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    make_move_iterator(_Iterator __i)
    { return move_iterator<_Iterator>(__i); }

  template<typename _Iterator, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond
      <typename iterator_traits<_Iterator>::value_type>::value,
                _Iterator, move_iterator<_Iterator>>::type>
    inline _ReturnType
    __make_move_if_noexcept_iterator(_Iterator __i)
    { return _ReturnType(__i); }




}
# 68 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algobase.h" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{
# 117 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {
# 147 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algobase.h" 3
      swap(*__a, *__b);

    }
# 163 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {





                                                       ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 191 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {



      if (__b < __a)
 return __b;
      return __a;
    }
# 214 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {



      if (__a < __b)
 return __b;
      return __a;
    }
# 237 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 258 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }



  template<typename _Iterator>
    struct _Niter_base
    : _Iter_base<_Iterator, __is_normal_iterator<_Iterator>::__value>
    { };

  template<typename _Iterator>
    inline typename _Niter_base<_Iterator>::iterator_type
    __niter_base(_Iterator __it)
    { return std::_Niter_base<_Iterator>::_S_base(__it); }


  template<typename _Iterator>
    struct _Miter_base
    : _Iter_base<_Iterator, __is_move_iterator<_Iterator>::__value>
    { };

  template<typename _Iterator>
    inline typename _Miter_base<_Iterator>::iterator_type
    __miter_base(_Iterator __it)
    { return std::_Miter_base<_Iterator>::_S_base(__it); }







  template<bool, bool, typename>
    struct __copy_move
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, ++__first)
     *__result = *__first;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move<true, false, _Category>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, ++__first)
     *__result = std::move(*__first);
   return __result;
 }
    };


  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<>
    struct __copy_move<true, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = std::move(*__first);
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   return __result + _Num;
 }
    };

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueTypeI)
                      && __is_pointer<_II>::__value
                      && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);

      return std::__copy_move<_IsMove, __simple,
                       _Category>::__copy_m(__first, __last, __result);
    }



  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }
# 448 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {




                                                     ;

      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 481 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    move(_II __first, _II __last, _OI __result)
    {




                                                     ;

      return std::__copy_move_a2<true>(std::__miter_base(__first),
           std::__miter_base(__last), __result);
    }






  template<bool, bool, typename>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move_backward<true, false, _Category>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<true, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueType1)
                      && __is_pointer<_BI1>::__value
                      && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__copy_move_backward<_IsMove, __simple,
                                _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      return _BI2(std::__copy_move_backward_a<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }
# 617 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {






                                                     ;

      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 653 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {






                                                     ;

      return std::__copy_move_backward_a2<true>(std::__miter_base(__first),
      std::__miter_base(__last),
      __result);
    }






  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
      __builtin_memset(__first, static_cast<unsigned char>(__tmp),
         __last - __first);
    }
# 719 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {



                                                     ;

      std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),
      __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
    {
      std::__fill_a(__first, __first + __n, __c);
      return __first + __n;
    }
# 779 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {



      return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
        static bool
        equal(_II1 __first1, _II1 __last1, _II2 __first2)
        {
   for (; __first1 != __last1; ++__first1, ++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>
        static bool
        equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
        {
   return !__builtin_memcmp(__first1, __first2, sizeof(_Tp)
       * (__last1 - __first1));
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple = ((__is_integer<_ValueType1>::__value
         || __is_pointer<_ValueType1>::__value)
                      && __is_pointer<_II1>::__value
                      && __is_pointer<_II2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }


  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
        static _II1
        __newlast1(_II1, _II1 __last1, _II2, _II2)
        { return __last1; }

      template<typename _II>
        static bool
        __cnd2(_II __first, _II __last)
        { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
        static _RAI1
        __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
        {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
        static bool
        __cnd2(_RAI, _RAI)
        { return true; }
    };

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
        static bool __lc(_II1, _II1, _II2, _II2);
    };

  template<bool _BoolType>
    template<typename _II1, typename _II2>
      bool
      __lexicographical_compare<_BoolType>::
      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
      {
 typedef typename iterator_traits<_II1>::iterator_category _Category1;
 typedef typename iterator_traits<_II2>::iterator_category _Category2;
 typedef std::__lc_rai<_Category1, _Category2> __rai_type;

 __last1 = __rai_type::__newlast1(__first1, __last1,
      __first2, __last2);
 for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
      ++__first1, ++__first2)
   {
     if (*__first1 < *__first2)
       return true;
     if (*__first2 < *__first1)
       return false;
   }
 return __first1 == __last1 && __first2 != __last2;
      }

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
        static bool
        __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   const int __result = __builtin_memcmp(__first1, __first2,
      std::min(__len1, __len2));
   return __result != 0 ? __result < 0 : __len1 < __len2;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
  && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
  && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value);

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }
# 941 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {




      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;




                                                                  ;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }



  inline constexpr int
  __lg(int __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr unsigned
  __lg(unsigned __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr long
  __lg(long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr unsigned long
  __lg(unsigned long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr long long
  __lg(long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }

  inline constexpr unsigned long long
  __lg(unsigned long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }
# 1019 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {






                                                       ;

      return std::__equal_aux(std::__niter_base(__first1),
         std::__niter_base(__last1),
         std::__niter_base(__first2));
    }
# 1051 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {



                                                       ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }
# 1082 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {
# 1096 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algobase.h" 3
                                                       ;
                                                       ;

      return std::__lexicographical_compare_aux(std::__niter_base(__first1),
      std::__niter_base(__last1),
      std::__niter_base(__first2),
      std::__niter_base(__last2));
    }
# 1118 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
    bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;




                                                       ;
                                                       ;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, ++__first2)
 {
   if (__comp(*__first1, *__first2))
     return true;
   if (__comp(*__first2, *__first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }
# 1158 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {






                                                       ;

      while (__first1 != __last1 && *__first1 == *__first2)
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1195 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {



                                                       ;

      while (__first1 != __last1 && bool(__binary_pred(*__first1, *__first2)))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }


}
# 62 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/algorithm" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 1 3
# 59 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstdlib" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstdlib" 3
# 72 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstdlib" 3
# 1 "/usr/include/stdlib.h" 1 3 4
# 32 "/usr/include/stdlib.h" 3 4
# 1 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/stddef.h" 1 3 4
# 33 "/usr/include/stdlib.h" 2 3 4

extern "C" {







# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 50 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3 4
typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
# 42 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 64 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 36 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 2 3 4
# 60 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;







typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
# 121 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 122 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;
# 28 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4






# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap-16.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4
# 61 "/usr/include/endian.h" 2 3 4
# 65 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 2 3 4

union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };
# 43 "/usr/include/stdlib.h" 2 3 4
# 97 "/usr/include/stdlib.h" 3 4
typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 139 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) throw () ;




extern double atof (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));





extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) throw () __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));





extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));





__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));
# 239 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     __locale_t __loc) throw () __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));
# 305 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) throw () ;


extern long int a64l (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
extern "C" {





typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;






typedef __off64_t off64_t;




typedef __pid_t pid_t;





typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 132 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
# 59 "/usr/include/time.h" 3 4
typedef __clock_t clock_t;
# 75 "/usr/include/time.h" 3 4
typedef __time_t time_t;
# 91 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
# 103 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
# 133 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;






# 1 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/stddef.h" 1 3 4
# 147 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 194 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 219 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/select.h" 2 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



typedef __sigset_t sigset_t;






# 1 "/usr/include/time.h" 1 3 4
# 120 "/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    __syscall_slong_t tv_nsec;
  };
# 44 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 46 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4








typedef long int __fd_mask;
# 64 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 96 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern "C" {
# 106 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 118 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 131 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
}
# 220 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4
extern "C" {

__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     throw () __attribute__ ((__const__));
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     throw () __attribute__ ((__const__));
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     throw () __attribute__ ((__const__));
# 58 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4
}
# 223 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 262 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;






# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4
# 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;





typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
# 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;

    unsigned int __nusers;



    int __kind;

    short __spins;
    short __elision;
    __pthread_list_t __list;
# 124 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
  } __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{

  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
    int __writer;
    int __shared;
    unsigned long int __pad1;
    unsigned long int __pad2;


    unsigned int __flags;

  } __data;
# 211 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 271 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


}
# 315 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) throw ();


extern void srandom (unsigned int __seed) throw ();





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) throw () __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) throw () __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     throw () __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) throw ();

extern void srand (unsigned int __seed) throw ();




extern int rand_r (unsigned int *__seed) throw ();







extern double drand48 (void) throw ();
extern double erand48 (unsigned short int __xsubi[3]) throw () __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) throw ();
extern long int nrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) throw ();
extern long int jrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) throw ();
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     throw () __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) throw () __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (1, 2)));
# 466 "/usr/include/stdlib.h" 3 4
extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     throw () __attribute__ ((__malloc__)) ;
# 480 "/usr/include/stdlib.h" 3 4
extern void *realloc (void *__ptr, size_t __size)
     throw () __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) throw ();




extern void cfree (void *__ptr) throw ();




# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) throw ();





}
# 493 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     throw () __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     throw () __attribute__ ((__malloc__)) ;




extern void abort (void) throw () __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) throw () __attribute__ ((__nonnull__ (1)));




extern "C++" int at_quick_exit (void (*__func) (void))
     throw () __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));
# 535 "/usr/include/stdlib.h" 3 4
extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     throw () __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) throw () __attribute__ ((__noreturn__));





extern void quick_exit (int __status) throw () __attribute__ ((__noreturn__));







extern void _Exit (int __status) throw () __attribute__ ((__noreturn__));






extern char *getenv (const char *__name) throw () __attribute__ ((__nonnull__ (1))) ;





extern char *secure_getenv (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) throw () __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     throw () __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) throw () __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) throw ();
# 606 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) throw () __attribute__ ((__nonnull__ (1)));
# 620 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 630 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 642 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 652 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 663 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
# 674 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 684 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 694 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 706 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 717 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) ;






extern char *canonicalize_file_name (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 734 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) throw () ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);





extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) throw () __attribute__ ((__const__)) ;
extern long int labs (long int __x) throw () __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     throw () __attribute__ ((__const__)) ;







extern div_t div (int __numer, int __denom)
     throw () __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     throw () __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     throw () __attribute__ ((__const__)) ;
# 812 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));






extern int mblen (const char *__s, size_t __n) throw ();


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) throw ();


extern int wctomb (char *__s, wchar_t __wchar) throw ();



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) throw ();

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     throw ();
# 888 "/usr/include/stdlib.h" 3 4
extern int rpmatch (const char *__response) throw () __attribute__ ((__nonnull__ (1))) ;
# 899 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     throw () __attribute__ ((__nonnull__ (1, 2, 3))) ;





extern void setkey (const char *__key) throw () __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) throw ();



extern int unlockpt (int __fd) throw ();




extern char *ptsname (int __fd) throw () ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     throw () __attribute__ ((__nonnull__ (1)));



# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 956 "/usr/include/stdlib.h" 2 3 4
# 968 "/usr/include/stdlib.h" 3 4
}
# 73 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstdlib" 2 3
# 114 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstdlib" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;
  using ::abs;
  using ::atexit;


  using ::at_quick_exit;


  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;


  using ::quick_exit;


  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;



  inline long
  abs(long __i) { return __builtin_labs(__i); }

  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }



  inline long long
  abs(long long __x) { return __builtin_llabs (__x); }
# 183 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstdlib" 3
}
# 196 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstdlib" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  using ::lldiv_t;





  using ::_Exit;



  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 228 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


}

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}
# 60 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/algorithmfwd.h" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/algorithmfwd.h" 3








namespace std __attribute__ ((__visibility__ ("default")))
{
# 194 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/algorithmfwd.h" 3
  template<typename _IIter, typename _Predicate>
    bool
    all_of(_IIter, _IIter, _Predicate);

  template<typename _IIter, typename _Predicate>
    bool
    any_of(_IIter, _IIter, _Predicate);


  template<typename _FIter, typename _Tp>
    bool
    binary_search(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    bool
    binary_search(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _IIter, typename _OIter>
    _OIter
    copy(_IIter, _IIter, _OIter);

  template<typename _BIter1, typename _BIter2>
    _BIter2
    copy_backward(_BIter1, _BIter1, _BIter2);


  template<typename _IIter, typename _OIter, typename _Predicate>
    _OIter
    copy_if(_IIter, _IIter, _OIter, _Predicate);

  template<typename _IIter, typename _Size, typename _OIter>
    _OIter
    copy_n(_IIter, _Size, _OIter);





  template<typename _FIter, typename _Tp>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _FIter, typename _Tp>
    void
    fill(_FIter, _FIter, const _Tp&);

  template<typename _OIter, typename _Size, typename _Tp>
    _OIter
    fill_n(_OIter, _Size, const _Tp&);



  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);





  template<typename _IIter, typename _Predicate>
    _IIter
    find_if_not(_IIter, _IIter, _Predicate);






  template<typename _IIter1, typename _IIter2>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _BIter>
    void
    inplace_merge(_BIter, _BIter, _BIter);

  template<typename _BIter, typename _Compare>
    void
    inplace_merge(_BIter, _BIter, _BIter, _Compare);


  template<typename _RAIter>
    bool
    is_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    bool
    is_heap(_RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    _RAIter
    is_heap_until(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    _RAIter
    is_heap_until(_RAIter, _RAIter, _Compare);

  template<typename _IIter, typename _Predicate>
    bool
    is_partitioned(_IIter, _IIter, _Predicate);

  template<typename _FIter1, typename _FIter2>
    bool
    is_permutation(_FIter1, _FIter1, _FIter2);

  template<typename _FIter1, typename _FIter2,
    typename _BinaryPredicate>
    bool
    is_permutation(_FIter1, _FIter1, _FIter2, _BinaryPredicate);

  template<typename _FIter>
    bool
    is_sorted(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    bool
    is_sorted(_FIter, _FIter, _Compare);

  template<typename _FIter>
    _FIter
    is_sorted_until(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    _FIter
    is_sorted_until(_FIter, _FIter, _Compare);


  template<typename _FIter1, typename _FIter2>
    void
    iter_swap(_FIter1, _FIter2);

  template<typename _FIter, typename _Tp>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _RAIter>
    void
    make_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    make_heap(_RAIter, _RAIter, _Compare);

  template<typename _Tp>
    const _Tp&
    max(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    const _Tp&
    max(const _Tp&, const _Tp&, _Compare);




  template<typename _Tp>
    const _Tp&
    min(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    const _Tp&
    min(const _Tp&, const _Tp&, _Compare);




  template<typename _Tp>
    pair<const _Tp&, const _Tp&>
    minmax(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    pair<const _Tp&, const _Tp&>
    minmax(const _Tp&, const _Tp&, _Compare);

  template<typename _FIter>
    pair<_FIter, _FIter>
    minmax_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    pair<_FIter, _FIter>
    minmax_element(_FIter, _FIter, _Compare);

  template<typename _Tp>
    _Tp
    min(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    _Tp
    min(initializer_list<_Tp>, _Compare);

  template<typename _Tp>
    _Tp
    max(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    _Tp
    max(initializer_list<_Tp>, _Compare);

  template<typename _Tp>
    pair<_Tp, _Tp>
    minmax(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    pair<_Tp, _Tp>
    minmax(initializer_list<_Tp>, _Compare);




  template<typename _BIter>
    bool
    next_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool
    next_permutation(_BIter, _BIter, _Compare);


  template<typename _IIter, typename _Predicate>
    bool
    none_of(_IIter, _IIter, _Predicate);





  template<typename _IIter, typename _RAIter>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter);

  template<typename _IIter, typename _RAIter, typename _Compare>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter, _Compare);




  template<typename _IIter, typename _OIter1,
    typename _OIter2, typename _Predicate>
    pair<_OIter1, _OIter2>
    partition_copy(_IIter, _IIter, _OIter1, _OIter2, _Predicate);

  template<typename _FIter, typename _Predicate>
    _FIter
    partition_point(_FIter, _FIter, _Predicate);


  template<typename _RAIter>
    void
    pop_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    pop_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter>
    bool
    prev_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool
    prev_permutation(_BIter, _BIter, _Compare);

  template<typename _RAIter>
    void
    push_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    push_heap(_RAIter, _RAIter, _Compare);



  template<typename _FIter, typename _Tp>
    _FIter
    remove(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Predicate>
    _FIter
    remove_if(_FIter, _FIter, _Predicate);

  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    remove_copy(_IIter, _IIter, _OIter, const _Tp&);

  template<typename _IIter, typename _OIter, typename _Predicate>
    _OIter
    remove_copy_if(_IIter, _IIter, _OIter, _Predicate);



  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    replace_copy(_IIter, _IIter, _OIter, const _Tp&, const _Tp&);

  template<typename _Iter, typename _OIter, typename _Predicate, typename _Tp>
    _OIter
    replace_copy_if(_Iter, _Iter, _OIter, _Predicate, const _Tp&);



  template<typename _BIter>
    void
    reverse(_BIter, _BIter);

  template<typename _BIter, typename _OIter>
    _OIter
    reverse_copy(_BIter, _BIter, _OIter);

  template<typename _FIter>
    void
    rotate(_FIter, _FIter, _FIter);

  template<typename _FIter, typename _OIter>
    _OIter
    rotate_copy(_FIter, _FIter, _FIter, _OIter);
# 535 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/algorithmfwd.h" 3
  template<typename _RAIter, typename _UGenerator>
    void
    shuffle(_RAIter, _RAIter, _UGenerator&&);


  template<typename _RAIter>
    void
    sort_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    sort_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    stable_partition(_BIter, _BIter, _Predicate);

  template<typename _Tp>
    void
    swap(_Tp&, _Tp&)

    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value)

    ;

  template<typename _Tp, size_t _Nm>
    void
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])

    noexcept(noexcept(swap(*__a, *__b)))

    ;

  template<typename _FIter1, typename _FIter2>
    _FIter2
    swap_ranges(_FIter1, _FIter1, _FIter2);



  template<typename _FIter>
    _FIter
    unique(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    unique(_FIter, _FIter, _BinaryPredicate);



  template<typename _FIter, typename _Tp>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&, _Compare);





  template<typename _FIter>
    _FIter
    adjacent_find(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    adjacent_find(_FIter, _FIter, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    typename iterator_traits<_IIter>::difference_type
    count(_IIter, _IIter, const _Tp&);

  template<typename _IIter, typename _Predicate>
    typename iterator_traits<_IIter>::difference_type
    count_if(_IIter, _IIter, _Predicate);

  template<typename _IIter1, typename _IIter2>
    bool
    equal(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    bool
    equal(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    _IIter
    find(_IIter, _IIter, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _IIter, typename _Predicate>
    _IIter
    find_if(_IIter, _IIter, _Predicate);

  template<typename _IIter, typename _Funct>
    _Funct
    for_each(_IIter, _IIter, _Funct);

  template<typename _FIter, typename _Generator>
    void
    generate(_FIter, _FIter, _Generator);

  template<typename _OIter, typename _Size, typename _Generator>
    _OIter
    generate_n(_OIter, _Size, _Generator);

  template<typename _IIter1, typename _IIter2>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _FIter>
    _FIter
    max_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    _FIter
    max_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _FIter>
    _FIter
    min_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    _FIter
    min_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _RAIter>
    void
    nth_element(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    nth_element(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    partial_sort(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    partial_sort(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    partition(_BIter, _BIter, _Predicate);

  template<typename _RAIter>
    void
    random_shuffle(_RAIter, _RAIter);

  template<typename _RAIter, typename _Generator>
    void
    random_shuffle(_RAIter, _RAIter,

     _Generator&&);




  template<typename _FIter, typename _Tp>
    void
    replace(_FIter, _FIter, const _Tp&, const _Tp&);

  template<typename _FIter, typename _Predicate, typename _Tp>
    void
    replace_if(_FIter, _FIter, _Predicate, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _FIter, typename _Size, typename _Tp>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&);

  template<typename _FIter, typename _Size, typename _Tp,
    typename _BinaryPredicate>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&, _BinaryPredicate);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2,
        _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _RAIter>
    void
    sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    sort(_RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    stable_sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    stable_sort(_RAIter, _RAIter, _Compare);

  template<typename _IIter, typename _OIter, typename _UnaryOperation>
    _OIter
    transform(_IIter, _IIter, _OIter, _UnaryOperation);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _BinaryOperation>
    _OIter
    transform(_IIter1, _IIter1, _IIter2, _OIter, _BinaryOperation);

  template<typename _IIter, typename _OIter>
    _OIter
    unique_copy(_IIter, _IIter, _OIter);

  template<typename _IIter, typename _OIter, typename _BinaryPredicate>
    _OIter
    unique_copy(_IIter, _IIter, _OIter, _BinaryPredicate);


}
# 61 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_heap.h" 1 3
# 61 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_heap.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _RandomAccessIterator, typename _Distance>
    _Distance
    __is_heap_until(_RandomAccessIterator __first, _Distance __n)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__first[__parent] < __first[__child])
     return __child;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return __n;
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    _Distance
    __is_heap_until(_RandomAccessIterator __first, _Distance __n,
      _Compare __comp)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__comp(__first[__parent], __first[__child]))
     return __child;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return __n;
    }



  template<typename _RandomAccessIterator, typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Distance __n)
    { return std::__is_heap_until(__first, __n) == __n; }

  template<typename _RandomAccessIterator, typename _Compare,
    typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Compare __comp, _Distance __n)
    { return std::__is_heap_until(__first, __n, __comp) == __n; }

  template<typename _RandomAccessIterator>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::__is_heap(__first, std::distance(__first, __last)); }

  template<typename _RandomAccessIterator, typename _Compare>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    { return std::__is_heap(__first, __comp, std::distance(__first, __last)); }




  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __push_heap(_RandomAccessIterator __first,
  _Distance __holeIndex, _Distance __topIndex, _Tp __value)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex && *(__first + __parent) < __value)
 {
   *(__first + __holeIndex) = std::move(*(__first + __parent));
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = std::move(__value);
    }
# 154 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;





                                                     ;
                                                  ;

      _ValueType __value = std::move(*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), std::move(__value));
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Tp,
    typename _Compare>
    void
    __push_heap(_RandomAccessIterator __first, _Distance __holeIndex,
  _Distance __topIndex, _Tp __value, _Compare __comp)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex
      && __comp(*(__first + __parent), __value))
 {
   *(__first + __holeIndex) = std::move(*(__first + __parent));
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = std::move(__value);
    }
# 204 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;




                                                     ;
                                                               ;

      _ValueType __value = std::move(*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), std::move(__value), __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = __holeIndex;
      while (__secondChild < (__len - 1) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   if (*(__first + __secondChild) < *(__first + (__secondChild - 1)))
     __secondChild--;
   *(__first + __holeIndex) = std::move(*(__first + __secondChild));
   __holeIndex = __secondChild;
 }
      if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   *(__first + __holeIndex) = std::move(*(__first + (__secondChild - 1)));

   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex,
         std::move(__value));
    }

  template<typename _RandomAccessIterator>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      _ValueType __value = std::move(*__result);
      *__result = std::move(*__first);
      std::__adjust_heap(__first, _DistanceType(0),
    _DistanceType(__last - __first),
    std::move(__value));
    }
# 279 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;





                                                         ;
                                                     ;
                                              ;

      if (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last);
 }
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Tp, typename _Compare>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value, _Compare __comp)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = __holeIndex;
      while (__secondChild < (__len - 1) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   if (__comp(*(__first + __secondChild),
       *(__first + (__secondChild - 1))))
     __secondChild--;
   *(__first + __holeIndex) = std::move(*(__first + __secondChild));
   __holeIndex = __secondChild;
 }
      if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   *(__first + __holeIndex) = std::move(*(__first + (__secondChild - 1)));

   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex,
         std::move(__value), __comp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      _ValueType __value = std::move(*__result);
      *__result = std::move(*__first);
      std::__adjust_heap(__first, _DistanceType(0),
    _DistanceType(__last - __first),
    std::move(__value), __comp);
    }
# 357 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    pop_heap(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {



                                                     ;
                                                         ;
                                                           ;

      if (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last, __comp);
 }
    }
# 384 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;





                                                     ;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   _ValueType __value = std::move(*(__first + __parent));
   std::__adjust_heap(__first, __parent, __len, std::move(__value));
   if (__parent == 0)
     return;
   __parent--;
 }
    }
# 424 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;




                                                     ;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   _ValueType __value = std::move(*(__first + __parent));
   std::__adjust_heap(__first, __parent, __len, std::move(__value),
        __comp);
   if (__parent == 0)
     return;
   __parent--;
 }
    }
# 463 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {





                                                     ;
                                              ;

      while (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last);
 }
    }
# 492 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {



                                                     ;
                                                           ;

      while (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last, __comp);
 }
    }
# 521 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline _RandomAccessIterator
    is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {





                                                     ;

      return __first + std::__is_heap_until(__first, std::distance(__first,
           __last));
    }
# 547 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline _RandomAccessIterator
    is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {



                                                     ;

      return __first + std::__is_heap_until(__first, std::distance(__first,
           __last),
         __comp);
    }
# 569 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline bool
    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::is_heap_until(__first, __last) == __last; }
# 582 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline bool
    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _Compare __comp)
    { return std::is_heap_until(__first, __last, __comp) == __last; }



}
# 62 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_tempbuf.h" 1 3
# 60 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_tempbuf.h" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_construct.h" 1 3
# 59 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_construct.h" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/new" 1 3
# 38 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/new" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/exception" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/exception" 3

#pragma GCC visibility push(default)



# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/atomic_lockfree_defines.h" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/atomic_lockfree_defines.h" 3
# 39 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/exception" 2 3

extern "C++" {

namespace std
{
# 60 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/exception" 3
  class exception
  {
  public:
    exception() noexcept { }
    virtual ~exception() noexcept;



    virtual const char* what() const noexcept;
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() noexcept { }



    virtual ~bad_exception() noexcept;


    virtual const char* what() const noexcept;
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) noexcept;



  void terminate() noexcept __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) noexcept;



  void unexpected() __attribute__ ((__noreturn__));
# 117 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/exception" 3
  bool uncaught_exception() noexcept __attribute__ ((__pure__));


}

namespace __gnu_cxx
{
# 142 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/exception" 3
  void __verbose_terminate_handler();


}

}

#pragma GCC visibility pop



# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/exception_ptr.h" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/exception_ptr.h" 3
#pragma GCC visibility push(default)








extern "C++" {

namespace std
{
  class type_info;





  namespace __exception_ptr
  {
    class exception_ptr;
  }

  using __exception_ptr::exception_ptr;





  exception_ptr current_exception() noexcept;


  void rethrow_exception(exception_ptr) __attribute__ ((__noreturn__));

  namespace __exception_ptr
  {




    class exception_ptr
    {
      void* _M_exception_object;

      explicit exception_ptr(void* __e) noexcept;

      void _M_addref() noexcept;
      void _M_release() noexcept;

      void *_M_get() const noexcept __attribute__ ((__pure__));

      friend exception_ptr std::current_exception() noexcept;
      friend void std::rethrow_exception(exception_ptr);

    public:
      exception_ptr() noexcept;

      exception_ptr(const exception_ptr&) noexcept;


      exception_ptr(nullptr_t) noexcept
      : _M_exception_object(0)
      { }

      exception_ptr(exception_ptr&& __o) noexcept
      : _M_exception_object(__o._M_exception_object)
      { __o._M_exception_object = 0; }
# 111 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/exception_ptr.h" 3
      exception_ptr&
      operator=(const exception_ptr&) noexcept;


      exception_ptr&
      operator=(exception_ptr&& __o) noexcept
      {
        exception_ptr(static_cast<exception_ptr&&>(__o)).swap(*this);
        return *this;
      }


      ~exception_ptr() noexcept;

      void
      swap(exception_ptr&) noexcept;
# 138 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/exception_ptr.h" 3
      explicit operator bool() const
      { return _M_exception_object; }


      friend bool
      operator==(const exception_ptr&, const exception_ptr&)
 noexcept __attribute__ ((__pure__));

      const class std::type_info*
      __cxa_exception_type() const noexcept
 __attribute__ ((__pure__));
    };

    bool
    operator==(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    bool
    operator!=(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    inline void
    swap(exception_ptr& __lhs, exception_ptr& __rhs)
    { __lhs.swap(__rhs); }

  }



  template<typename _Ex>
    exception_ptr
    copy_exception(_Ex __ex) noexcept
    {
      try
 {

   throw __ex;

 }
      catch(...)
 {
   return current_exception();
 }
    }




  template<typename _Ex>
    exception_ptr
    make_exception_ptr(_Ex __ex) noexcept
    { return std::copy_exception<_Ex>(__ex); }


}

}

#pragma GCC visibility pop
# 153 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/exception" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/nested_exception.h" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/nested_exception.h" 3
#pragma GCC visibility push(default)
# 45 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/nested_exception.h" 3
extern "C++" {

namespace std
{






  class nested_exception
  {
    exception_ptr _M_ptr;

  public:
    nested_exception() noexcept : _M_ptr(current_exception()) { }

    nested_exception(const nested_exception&) = default;

    nested_exception& operator=(const nested_exception&) = default;

    virtual ~nested_exception() noexcept;

    void
    rethrow_nested() const __attribute__ ((__noreturn__))
    { rethrow_exception(_M_ptr); }

    exception_ptr
    nested_ptr() const
    { return _M_ptr; }
  };

  template<typename _Except>
    struct _Nested_exception : public _Except, public nested_exception
    {
      explicit _Nested_exception(_Except&& __ex)
      : _Except(static_cast<_Except&&>(__ex))
      { }
    };

  template<typename _Ex>
    struct __get_nested_helper
    {
      static const nested_exception*
      _S_get(const _Ex& __ex)
      { return dynamic_cast<const nested_exception*>(&__ex); }
    };

  template<typename _Ex>
    struct __get_nested_helper<_Ex*>
    {
      static const nested_exception*
      _S_get(const _Ex* __ex)
      { return dynamic_cast<const nested_exception*>(__ex); }
    };

  template<typename _Ex>
    inline const nested_exception*
    __get_nested_exception(const _Ex& __ex)
    { return __get_nested_helper<_Ex>::_S_get(__ex); }

  template<typename _Ex>
    void
    __throw_with_nested(_Ex&&, const nested_exception* = 0)
    __attribute__ ((__noreturn__));

  template<typename _Ex>
    void
    __throw_with_nested(_Ex&&, ...) __attribute__ ((__noreturn__));




  template<typename _Ex>
    inline void
    __throw_with_nested(_Ex&& __ex, const nested_exception*)
    { throw __ex; }

  template<typename _Ex>
    inline void
    __throw_with_nested(_Ex&& __ex, ...)
    { throw _Nested_exception<_Ex>(static_cast<_Ex&&>(__ex)); }

  template<typename _Ex>
    void
    throw_with_nested(_Ex __ex) __attribute__ ((__noreturn__));



  template<typename _Ex>
    inline void
    throw_with_nested(_Ex __ex)
    {
      if (__get_nested_exception(__ex))
        throw __ex;
      __throw_with_nested(static_cast<_Ex&&>(__ex), &__ex);
    }


  template<typename _Ex>
    inline void
    rethrow_if_nested(const _Ex& __ex)
    {
      if (const nested_exception* __nested = __get_nested_exception(__ex))
        __nested->rethrow_nested();
    }


  inline void
  rethrow_if_nested(const nested_exception& __ex)
  { __ex.rethrow_nested(); }


}

}



#pragma GCC visibility pop
# 154 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/exception" 2 3
# 41 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/new" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }



    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };

  struct nothrow_t { };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();
}
# 91 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/new" 3
void* operator new(std::size_t)
  __attribute__((__externally_visible__));
void* operator new[](std::size_t)
  __attribute__((__externally_visible__));
void operator delete(void*) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*) noexcept
  __attribute__((__externally_visible__));
void* operator new(std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void* operator new[](std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete(void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));


inline void* operator new(std::size_t, void* __p) noexcept
{ return __p; }
inline void* operator new[](std::size_t, void* __p) noexcept
{ return __p; }


inline void operator delete (void*, void*) noexcept { }
inline void operator delete[](void*, void*) noexcept { }

}

#pragma GCC visibility pop
# 60 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_construct.h" 2 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ext/alloc_traits.h" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ext/alloc_traits.h" 3



# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/alloc_traits.h" 1 3
# 36 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/alloc_traits.h" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/ptr_traits.h" 1 3
# 37 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/ptr_traits.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


template<typename _Tp> class __has_element_type_helper : __sfinae_types { template<typename _Up> struct _Wrap_type { }; template<typename _Up> static __one __test(_Wrap_type<typename _Up::element_type>*); template<typename _Up> static __two __test(...); public: static constexpr bool value = sizeof(__test<_Tp>(0)) == 1; }; template<typename _Tp> struct __has_element_type : integral_constant<bool, __has_element_type_helper <typename remove_cv<_Tp>::type>::value> { };
template<typename _Tp> class __has_difference_type_helper : __sfinae_types { template<typename _Up> struct _Wrap_type { }; template<typename _Up> static __one __test(_Wrap_type<typename _Up::difference_type>*); template<typename _Up> static __two __test(...); public: static constexpr bool value = sizeof(__test<_Tp>(0)) == 1; }; template<typename _Tp> struct __has_difference_type : integral_constant<bool, __has_difference_type_helper <typename remove_cv<_Tp>::type>::value> { };

  template<typename _Tp, bool = __has_element_type<_Tp>::value>
    struct __ptrtr_elt_type;

  template<typename _Tp>
    struct __ptrtr_elt_type<_Tp, true>
    {
      typedef typename _Tp::element_type __type;
    };

  template<template<typename, typename...> class _SomePtr, typename _Tp,
            typename... _Args>
    struct __ptrtr_elt_type<_SomePtr<_Tp, _Args...>, false>
    {
      typedef _Tp __type;
    };

  template<typename _Tp, bool = __has_difference_type<_Tp>::value>
    struct __ptrtr_diff_type
    {
      typedef typename _Tp::difference_type __type;
    };

  template<typename _Tp>
    struct __ptrtr_diff_type<_Tp, false>
    {
      typedef ptrdiff_t __type;
    };

  template<typename _Ptr, typename _Up>
    class __ptrtr_rebind_helper
    {
      template<typename _Ptr2, typename _Up2>
 static constexpr bool
        _S_chk(typename _Ptr2::template rebind<_Up2>*)
        { return true; }

      template<typename, typename>
        static constexpr bool
        _S_chk(...)
        { return false; }

    public:
      static const bool __value = _S_chk<_Ptr, _Up>(nullptr);
    };

  template<typename _Ptr, typename _Up>
    const bool __ptrtr_rebind_helper<_Ptr, _Up>::__value;

  template<typename _Tp, typename _Up,
           bool = __ptrtr_rebind_helper<_Tp, _Up>::__value>
    struct __ptrtr_rebind;

  template<typename _Tp, typename _Up>
    struct __ptrtr_rebind<_Tp, _Up, true>
    {
      typedef typename _Tp::template rebind<_Up> __type;
    };

  template<template<typename, typename...> class _SomePtr, typename _Up,
            typename _Tp, typename... _Args>
    struct __ptrtr_rebind<_SomePtr<_Tp, _Args...>, _Up, false>
    {
      typedef _SomePtr<_Up, _Args...> __type;
    };

  template<typename _Tp, typename = typename remove_cv<_Tp>::type>
    struct __ptrtr_not_void
    {
      typedef _Tp __type;
    };

  template<typename _Tp>
    struct __ptrtr_not_void<_Tp, void>
    {
      struct __type { };
    };

  template<typename _Ptr>
    class __ptrtr_pointer_to
    {
      typedef typename __ptrtr_elt_type<_Ptr>::__type __orig_type;
      typedef typename __ptrtr_not_void<__orig_type>::__type __element_type;

    public:
      static _Ptr pointer_to(__element_type& __e)
      { return _Ptr::pointer_to(__e); }
    };





  template<typename _Ptr>
    struct pointer_traits : __ptrtr_pointer_to<_Ptr>
    {

      typedef _Ptr pointer;

      typedef typename __ptrtr_elt_type<_Ptr>::__type element_type;

      typedef typename __ptrtr_diff_type<_Ptr>::__type difference_type;

      template<typename _Up>
        using rebind = typename __ptrtr_rebind<_Ptr, _Up>::__type;
    };





  template<typename _Tp>
    struct pointer_traits<_Tp*>
    {

      typedef _Tp* pointer;

      typedef _Tp element_type;

      typedef ptrdiff_t difference_type;

      template<typename _Up>
        using rebind = _Up*;






      static pointer
      pointer_to(typename __ptrtr_not_void<element_type>::__type& __r) noexcept
      { return std::addressof(__r); }
    };


}
# 37 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/alloc_traits.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Alloc, typename _Tp>
    class __alloctr_rebind_helper
    {
      template<typename _Alloc2, typename _Tp2>
 static constexpr bool
        _S_chk(typename _Alloc2::template rebind<_Tp2>::other*)
 { return true; }

      template<typename, typename>
        static constexpr bool
        _S_chk(...)
        { return false; }

    public:
      static const bool __value = _S_chk<_Alloc, _Tp>(nullptr);
    };

  template<typename _Alloc, typename _Tp>
    const bool __alloctr_rebind_helper<_Alloc, _Tp>::__value;

  template<typename _Alloc, typename _Tp,
           bool = __alloctr_rebind_helper<_Alloc, _Tp>::__value>
    struct __alloctr_rebind;

  template<typename _Alloc, typename _Tp>
    struct __alloctr_rebind<_Alloc, _Tp, true>
    {
      typedef typename _Alloc::template rebind<_Tp>::other __type;
    };

  template<template<typename, typename...> class _Alloc, typename _Tp,
            typename _Up, typename... _Args>
    struct __alloctr_rebind<_Alloc<_Up, _Args...>, _Tp, false>
    {
      typedef _Alloc<_Tp, _Args...> __type;
    };





  template<typename _Alloc>
    struct allocator_traits
    {

      typedef _Alloc allocator_type;

      typedef typename _Alloc::value_type value_type;
# 100 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/alloc_traits.h" 3
private: template<typename _Tp> static typename _Tp::pointer _S_pointer_helper(_Tp*); static value_type* _S_pointer_helper(...); typedef decltype(_S_pointer_helper((_Alloc*)0)) __pointer; public:






      typedef __pointer pointer;

private: template<typename _Tp> static typename _Tp::const_pointer _S_const_pointer_helper(_Tp*); static typename pointer_traits<pointer>::template rebind<const value_type> _S_const_pointer_helper(...); typedef decltype(_S_const_pointer_helper((_Alloc*)0)) __const_pointer; public:
# 118 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/alloc_traits.h" 3
      typedef __const_pointer const_pointer;

private: template<typename _Tp> static typename _Tp::void_pointer _S_void_pointer_helper(_Tp*); static typename pointer_traits<pointer>::template rebind<void> _S_void_pointer_helper(...); typedef decltype(_S_void_pointer_helper((_Alloc*)0)) __void_pointer; public:
# 129 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/alloc_traits.h" 3
      typedef __void_pointer void_pointer;

private: template<typename _Tp> static typename _Tp::const_void_pointer _S_const_void_pointer_helper(_Tp*); static typename pointer_traits<pointer>::template rebind<const void> _S_const_void_pointer_helper(...); typedef decltype(_S_const_void_pointer_helper((_Alloc*)0)) __const_void_pointer; public:
# 140 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/alloc_traits.h" 3
      typedef __const_void_pointer const_void_pointer;

private: template<typename _Tp> static typename _Tp::difference_type _S_difference_type_helper(_Tp*); static typename pointer_traits<pointer>::difference_type _S_difference_type_helper(...); typedef decltype(_S_difference_type_helper((_Alloc*)0)) __difference_type; public:
# 151 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/alloc_traits.h" 3
      typedef __difference_type difference_type;

private: template<typename _Tp> static typename _Tp::size_type _S_size_type_helper(_Tp*); static typename make_unsigned<difference_type>::type _S_size_type_helper(...); typedef decltype(_S_size_type_helper((_Alloc*)0)) __size_type; public:
# 162 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/alloc_traits.h" 3
      typedef __size_type size_type;

private: template<typename _Tp> static typename _Tp::propagate_on_container_copy_assignment _S_propagate_on_container_copy_assignment_helper(_Tp*); static false_type _S_propagate_on_container_copy_assignment_helper(...); typedef decltype(_S_propagate_on_container_copy_assignment_helper((_Alloc*)0)) __propagate_on_container_copy_assignment; public:
# 173 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/alloc_traits.h" 3
      typedef __propagate_on_container_copy_assignment
        propagate_on_container_copy_assignment;

private: template<typename _Tp> static typename _Tp::propagate_on_container_move_assignment _S_propagate_on_container_move_assignment_helper(_Tp*); static false_type _S_propagate_on_container_move_assignment_helper(...); typedef decltype(_S_propagate_on_container_move_assignment_helper((_Alloc*)0)) __propagate_on_container_move_assignment; public:
# 185 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/alloc_traits.h" 3
      typedef __propagate_on_container_move_assignment
        propagate_on_container_move_assignment;

private: template<typename _Tp> static typename _Tp::propagate_on_container_swap _S_propagate_on_container_swap_helper(_Tp*); static false_type _S_propagate_on_container_swap_helper(...); typedef decltype(_S_propagate_on_container_swap_helper((_Alloc*)0)) __propagate_on_container_swap; public:
# 197 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/alloc_traits.h" 3
      typedef __propagate_on_container_swap propagate_on_container_swap;



      template<typename _Tp>
        using rebind_alloc = typename __alloctr_rebind<_Alloc, _Tp>::__type;
      template<typename _Tp>
        using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;

    private:
      template<typename _Alloc2>
 struct __allocate_helper
 {
   template<typename _Alloc3,
     typename = decltype(std::declval<_Alloc3*>()->allocate(
    std::declval<size_type>(),
    std::declval<const_void_pointer>()))>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   typedef decltype(__test<_Alloc>(0)) type;
   static const bool value = type::value;
 };

      template<typename _Alloc2>
 static typename
        enable_if<__allocate_helper<_Alloc2>::value, pointer>::type
        _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer __hint)
 { return __a.allocate(__n, __hint); }

      template<typename _Alloc2>
 static typename
        enable_if<!__allocate_helper<_Alloc2>::value, pointer>::type
        _S_allocate(_Alloc2& __a, size_type __n, ...)
 { return __a.allocate(__n); }

      template<typename _Tp, typename... _Args>
 struct __construct_helper
 {
   template<typename _Alloc2,
     typename = decltype(std::declval<_Alloc2*>()->construct(
    std::declval<_Tp*>(), std::declval<_Args>()...))>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   typedef decltype(__test<_Alloc>(0)) type;
   static const bool value = type::value;
 };

      template<typename _Tp, typename... _Args>
 static typename
        enable_if<__construct_helper<_Tp, _Args...>::value, void>::type
        _S_construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 { __a.construct(__p, std::forward<_Args>(__args)...); }

      template<typename _Tp, typename... _Args>
 static typename
 enable_if<__and_<__not_<__construct_helper<_Tp, _Args...>>,
    is_constructible<_Tp, _Args...>>::value, void>::type
        _S_construct(_Alloc&, _Tp* __p, _Args&&... __args)
 { ::new((void*)__p) _Tp(std::forward<_Args>(__args)...); }

      template<typename _Tp>
 struct __destroy_helper
 {
   template<typename _Alloc2,
     typename = decltype(std::declval<_Alloc2*>()->destroy(
    std::declval<_Tp*>()))>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   typedef decltype(__test<_Alloc>(0)) type;
   static const bool value = type::value;
 };

      template<typename _Tp>
 static typename enable_if<__destroy_helper<_Tp>::value, void>::type
        _S_destroy(_Alloc& __a, _Tp* __p)
 { __a.destroy(__p); }

      template<typename _Tp>
 static typename enable_if<!__destroy_helper<_Tp>::value, void>::type
        _S_destroy(_Alloc&, _Tp* __p)
 { __p->~_Tp(); }

      template<typename _Alloc2>
 struct __maxsize_helper
 {
   template<typename _Alloc3,
     typename = decltype(std::declval<_Alloc3*>()->max_size())>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   typedef decltype(__test<_Alloc2>(0)) type;
   static const bool value = type::value;
 };

      template<typename _Alloc2>
 static typename
        enable_if<__maxsize_helper<_Alloc2>::value, size_type>::type
        _S_max_size(_Alloc2& __a)
 { return __a.max_size(); }

      template<typename _Alloc2>
 static typename
        enable_if<!__maxsize_helper<_Alloc2>::value, size_type>::type
 _S_max_size(_Alloc2&)
 { return __gnu_cxx::__numeric_traits<size_type>::__max; }

      template<typename _Alloc2>
 struct __select_helper
 {
   template<typename _Alloc3, typename
     = decltype(std::declval<_Alloc3*>()
  ->select_on_container_copy_construction())>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   typedef decltype(__test<_Alloc2>(0)) type;
   static const bool value = type::value;
 };
      template<typename _Alloc2>
 static typename
        enable_if<__select_helper<_Alloc2>::value, _Alloc2>::type
        _S_select(_Alloc2& __a)
 { return __a.select_on_container_copy_construction(); }

      template<typename _Alloc2>
 static typename
        enable_if<!__select_helper<_Alloc2>::value, _Alloc2>::type
        _S_select(_Alloc2& __a)
 { return __a; }

    public:
# 349 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/alloc_traits.h" 3
      static pointer
      allocate(_Alloc& __a, size_type __n)
      { return __a.allocate(__n); }
# 364 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/alloc_traits.h" 3
      static pointer
      allocate(_Alloc& __a, size_type __n, const_void_pointer __hint)
      { return _S_allocate(__a, __n, __hint); }
# 376 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/alloc_traits.h" 3
      static void deallocate(_Alloc& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 390 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/alloc_traits.h" 3
      template<typename _Tp, typename... _Args>
 static auto construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 -> decltype(_S_construct(__a, __p, std::forward<_Args>(__args)...))
 { _S_construct(__a, __p, std::forward<_Args>(__args)...); }
# 403 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/alloc_traits.h" 3
      template <class _Tp>
 static void destroy(_Alloc& __a, _Tp* __p)
 { _S_destroy(__a, __p); }
# 415 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/alloc_traits.h" 3
      static size_type max_size(const _Alloc& __a)
      { return _S_max_size(__a); }
# 426 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/alloc_traits.h" 3
      static _Alloc
      select_on_container_copy_construction(const _Alloc& __rhs)
      { return _S_select(__rhs); }
    };

  template<typename _Alloc>
  template<typename _Alloc2>
    const bool allocator_traits<_Alloc>::__allocate_helper<_Alloc2>::value;

  template<typename _Alloc>
  template<typename _Tp, typename... _Args>
    const bool
    allocator_traits<_Alloc>::__construct_helper<_Tp, _Args...>::value;

  template<typename _Alloc>
  template<typename _Tp>
    const bool allocator_traits<_Alloc>::__destroy_helper<_Tp>::value;

  template<typename _Alloc>
  template<typename _Alloc2>
    const bool allocator_traits<_Alloc>::__maxsize_helper<_Alloc2>::value;

  template<typename _Alloc>
  template<typename _Alloc2>
    const bool allocator_traits<_Alloc>::__select_helper<_Alloc2>::value;

  template<typename _Alloc>
    inline void
    __do_alloc_on_copy(_Alloc& __one, const _Alloc& __two, true_type)
    { __one = __two; }

  template<typename _Alloc>
    inline void
    __do_alloc_on_copy(_Alloc&, const _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_copy(_Alloc& __one, const _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_copy_assignment __pocca;
      __do_alloc_on_copy(__one, __two, __pocca());
    }

  template<typename _Alloc>
    inline _Alloc __alloc_on_copy(const _Alloc& __a)
    {
      typedef allocator_traits<_Alloc> __traits;
      return __traits::select_on_container_copy_construction(__a);
    }

  template<typename _Alloc>
    inline void __do_alloc_on_move(_Alloc& __one, _Alloc& __two, true_type)
    { __one = std::move(__two); }

  template<typename _Alloc>
    inline void __do_alloc_on_move(_Alloc&, _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_move(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_move_assignment __pocma;
      __do_alloc_on_move(__one, __two, __pocma());
    }

  template<typename _Alloc>
    inline void __do_alloc_on_swap(_Alloc& __one, _Alloc& __two, true_type)
    {
      using std::swap;
      swap(__one, __two);
    }

  template<typename _Alloc>
    inline void __do_alloc_on_swap(_Alloc&, _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_swap(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_swap __pocs;
      __do_alloc_on_swap(__one, __two, __pocs());
    }

  template<typename _Alloc>
    class __is_copy_insertable_impl
    {
      typedef allocator_traits<_Alloc> _Traits;

      template<typename _Up, typename
        = decltype(_Traits::construct(std::declval<_Alloc&>(),
          std::declval<_Up*>(),
          std::declval<const _Up&>()))>
 static true_type
 _M_select(int);

      template<typename _Up>
 static false_type
 _M_select(...);

    public:
      typedef decltype(_M_select<typename _Alloc::value_type>(0)) type;
    };


  template<typename _Alloc>
    struct __is_copy_insertable
    : __is_copy_insertable_impl<_Alloc>::type
    { };


  template<typename _Tp>
    struct __is_copy_insertable<allocator<_Tp>>
    : is_copy_constructible<_Tp>
    { };


  template<bool> struct __allow_copy_cons { };


  template<>
    struct __allow_copy_cons<false>
    {
      __allow_copy_cons() = default;
      __allow_copy_cons(const __allow_copy_cons&) = delete;
      __allow_copy_cons(__allow_copy_cons&&) = default;
      __allow_copy_cons& operator=(const __allow_copy_cons&) = default;
      __allow_copy_cons& operator=(__allow_copy_cons&&) = default;
    };

  template<typename _Alloc>
    using __check_copy_constructible
      = __allow_copy_cons<__is_copy_insertable<_Alloc>::value>;


}
# 37 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ext/alloc_traits.h" 2 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<typename _Alloc>
    struct __allocator_always_compares_equal
    { static const bool value = false; };

  template<typename _Alloc>
    const bool __allocator_always_compares_equal<_Alloc>::value;

  template<typename _Tp>
    struct __allocator_always_compares_equal<std::allocator<_Tp>>
    { static const bool value = true; };

  template<typename _Tp>
    const bool __allocator_always_compares_equal<std::allocator<_Tp>>::value;

  template<typename, typename> struct array_allocator;

  template<typename _Tp, typename _Array>
    struct __allocator_always_compares_equal<array_allocator<_Tp, _Array>>
    { static const bool value = true; };

  template<typename _Tp, typename _Array>
    const bool
    __allocator_always_compares_equal<array_allocator<_Tp, _Array>>::value;

  template<typename> struct bitmap_allocator;

  template<typename _Tp>
    struct __allocator_always_compares_equal<bitmap_allocator<_Tp>>
    { static const bool value = true; };

  template<typename _Tp>
    const bool __allocator_always_compares_equal<bitmap_allocator<_Tp>>::value;

  template<typename> struct malloc_allocator;

  template<typename _Tp>
    struct __allocator_always_compares_equal<malloc_allocator<_Tp>>
    { static const bool value = true; };

  template<typename _Tp>
    const bool __allocator_always_compares_equal<malloc_allocator<_Tp>>::value;

  template<typename> struct mt_allocator;

  template<typename _Tp>
    struct __allocator_always_compares_equal<mt_allocator<_Tp>>
    { static const bool value = true; };

  template<typename _Tp>
    const bool __allocator_always_compares_equal<mt_allocator<_Tp>>::value;

  template<typename> struct new_allocator;

  template<typename _Tp>
    struct __allocator_always_compares_equal<new_allocator<_Tp>>
    { static const bool value = true; };

  template<typename _Tp>
    const bool __allocator_always_compares_equal<new_allocator<_Tp>>::value;

  template<typename> struct pool_allocator;

  template<typename _Tp>
    struct __allocator_always_compares_equal<pool_allocator<_Tp>>
    { static const bool value = true; };

  template<typename _Tp>
    const bool __allocator_always_compares_equal<pool_allocator<_Tp>>::value;






template<typename _Alloc>
  struct __alloc_traits

  : std::allocator_traits<_Alloc>

  {
    typedef _Alloc allocator_type;

    typedef std::allocator_traits<_Alloc> _Base_type;
    typedef typename _Base_type::value_type value_type;
    typedef typename _Base_type::pointer pointer;
    typedef typename _Base_type::const_pointer const_pointer;
    typedef typename _Base_type::size_type size_type;
    typedef typename _Base_type::difference_type difference_type;

    typedef value_type& reference;
    typedef const value_type& const_reference;
    using _Base_type::allocate;
    using _Base_type::deallocate;
    using _Base_type::construct;
    using _Base_type::destroy;
    using _Base_type::max_size;

  private:
    template<typename _Ptr>
      struct __is_custom_pointer
      : std::integral_constant<bool, std::is_same<pointer, _Ptr>::value
                                     && !std::is_pointer<_Ptr>::value>
      { };

  public:

    template<typename _Ptr, typename... _Args>
      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
      construct(_Alloc& __a, _Ptr __p, _Args&&... __args)
      {
 _Base_type::construct(__a, std::addressof(*__p),
         std::forward<_Args>(__args)...);
      }


    template<typename _Ptr>
      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
      destroy(_Alloc& __a, _Ptr __p)
      { _Base_type::destroy(__a, std::addressof(*__p)); }

    static _Alloc _S_select_on_copy(const _Alloc& __a)
    { return _Base_type::select_on_container_copy_construction(__a); }

    static void _S_on_swap(_Alloc& __a, _Alloc& __b)
    { std::__alloc_on_swap(__a, __b); }

    static constexpr bool _S_propagate_on_copy_assign()
    { return _Base_type::propagate_on_container_copy_assignment::value; }

    static constexpr bool _S_propagate_on_move_assign()
    { return _Base_type::propagate_on_container_move_assignment::value; }

    static constexpr bool _S_propagate_on_swap()
    { return _Base_type::propagate_on_container_swap::value; }

    static constexpr bool _S_always_equal()
    { return __allocator_always_compares_equal<_Alloc>::value; }

    static constexpr bool _S_nothrow_move()
    { return _S_propagate_on_move_assign() || _S_always_equal(); }

    static constexpr bool _S_nothrow_swap()
    {
      using std::swap;
      return !_S_propagate_on_swap()
        || noexcept(swap(std::declval<_Alloc&>(), std::declval<_Alloc&>()));
    }

    template<typename _Tp>
      struct rebind
      { typedef typename _Base_type::template rebind_alloc<_Tp> other; };
# 237 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ext/alloc_traits.h" 3
  };


}
# 62 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_construct.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _T1, typename... _Args>
    inline void
    _Construct(_T1* __p, _Args&&... __args)
    { ::new(static_cast<void*>(__p)) _T1(std::forward<_Args>(__args)...); }
# 90 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_construct.h" 3
  template<typename _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }

  template<bool>
    struct _Destroy_aux
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator __first, _ForwardIterator __last)
 {
   for (; __first != __last; ++__first)
     std::_Destroy(std::__addressof(*__first));
 }
    };

  template<>
    struct _Destroy_aux<true>
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator, _ForwardIterator) { }
    };






  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;
      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
 __destroy(__first, __last);
    }







  template<typename _ForwardIterator, typename _Allocator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator& __alloc)
    {
      typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
      for (; __first != __last; ++__first)
 __traits::destroy(__alloc, std::__addressof(*__first));
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>&)
    {
      _Destroy(__first, __last);
    }


}
# 61 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_tempbuf.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
# 83 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    pair<_Tp*, ptrdiff_t>
    get_temporary_buffer(ptrdiff_t __len) noexcept
    {
      const ptrdiff_t __max =
 __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
      if (__len > __max)
 __len = __max;

      while (__len > 0)
 {
   _Tp* __tmp = static_cast<_Tp*>(::operator new(__len * sizeof(_Tp),
       std::nothrow));
   if (__tmp != 0)
     return std::pair<_Tp*, ptrdiff_t>(__tmp, __len);
   __len /= 2;
 }
      return std::pair<_Tp*, ptrdiff_t>(static_cast<_Tp*>(0), 0);
    }
# 110 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    inline void
    return_temporary_buffer(_Tp* __p)
    { ::operator delete(__p, std::nothrow); }







  template<typename _ForwardIterator, typename _Tp>
    class _Temporary_buffer
    {



    public:
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef pointer iterator;
      typedef ptrdiff_t size_type;

    protected:
      size_type _M_original_len;
      size_type _M_len;
      pointer _M_buffer;

    public:

      size_type
      size() const
      { return _M_len; }


      size_type
      requested_size() const
      { return _M_original_len; }


      iterator
      begin()
      { return _M_buffer; }


      iterator
      end()
      { return _M_buffer + _M_len; }





      _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last);

      ~_Temporary_buffer()
      {
 std::_Destroy(_M_buffer, _M_buffer + _M_len);
 std::return_temporary_buffer(_M_buffer);
      }

    private:

      _Temporary_buffer(const _Temporary_buffer&);

      void
      operator=(const _Temporary_buffer&);
    };


  template<bool>
    struct __uninitialized_construct_buf_dispatch
    {
      template<typename _Pointer, typename _ForwardIterator>
        static void
        __ucr(_Pointer __first, _Pointer __last,
       _ForwardIterator __seed)
        {
   if(__first == __last)
     return;

   _Pointer __cur = __first;
   try
     {
       std::_Construct(std::__addressof(*__first),
         std::move(*__seed));
       _Pointer __prev = __cur;
       ++__cur;
       for(; __cur != __last; ++__cur, ++__prev)
  std::_Construct(std::__addressof(*__cur),
    std::move(*__prev));
       *__seed = std::move(*__prev);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_construct_buf_dispatch<true>
    {
      template<typename _Pointer, typename _ForwardIterator>
        static void
        __ucr(_Pointer, _Pointer, _ForwardIterator) { }
    };
# 229 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_tempbuf.h" 3
  template<typename _Pointer, typename _ForwardIterator>
    inline void
    __uninitialized_construct_buf(_Pointer __first, _Pointer __last,
      _ForwardIterator __seed)
    {
      typedef typename std::iterator_traits<_Pointer>::value_type
 _ValueType;

      std::__uninitialized_construct_buf_dispatch<
        __has_trivial_constructor(_ValueType)>::
   __ucr(__first, __last, __seed);
    }

  template<typename _ForwardIterator, typename _Tp>
    _Temporary_buffer<_ForwardIterator, _Tp>::
    _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
    : _M_original_len(std::distance(__first, __last)),
      _M_len(0), _M_buffer(0)
    {
      try
 {
   std::pair<pointer, size_type> __p(std::get_temporary_buffer<
         value_type>(_M_original_len));
   _M_buffer = __p.first;
   _M_len = __p.second;
   if (_M_buffer)
     std::__uninitialized_construct_buf(_M_buffer, _M_buffer + _M_len,
            __first);
 }
      catch(...)
 {
   std::return_temporary_buffer(_M_buffer);
   _M_buffer = 0;
   _M_len = 0;
   throw;
 }
    }


}
# 63 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 2 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/random" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/random" 3





# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cmath" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cmath" 3




# 1 "/usr/include/math.h" 1 3 4
# 28 "/usr/include/math.h" 3 4
extern "C" {




# 1 "/usr/include/x86_64-linux-gnu/bits/huge_val.h" 1 3 4
# 33 "/usr/include/math.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/huge_valf.h" 1 3 4
# 35 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/huge_vall.h" 1 3 4
# 36 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/inf.h" 1 3 4
# 39 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/nan.h" 1 3 4
# 42 "/usr/include/math.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/mathdef.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/mathdef.h" 3 4
typedef float float_t;
typedef double double_t;
# 46 "/usr/include/math.h" 2 3 4
# 69 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 54 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern double acos (double __x) throw (); extern double __acos (double __x) throw ();

extern double asin (double __x) throw (); extern double __asin (double __x) throw ();

extern double atan (double __x) throw (); extern double __atan (double __x) throw ();

extern double atan2 (double __y, double __x) throw (); extern double __atan2 (double __y, double __x) throw ();


extern double cos (double __x) throw (); extern double __cos (double __x) throw ();

extern double sin (double __x) throw (); extern double __sin (double __x) throw ();

extern double tan (double __x) throw (); extern double __tan (double __x) throw ();




extern double cosh (double __x) throw (); extern double __cosh (double __x) throw ();

extern double sinh (double __x) throw (); extern double __sinh (double __x) throw ();

extern double tanh (double __x) throw (); extern double __tanh (double __x) throw ();




extern void sincos (double __x, double *__sinx, double *__cosx) throw (); extern void __sincos (double __x, double *__sinx, double *__cosx) throw ();






extern double acosh (double __x) throw (); extern double __acosh (double __x) throw ();

extern double asinh (double __x) throw (); extern double __asinh (double __x) throw ();

extern double atanh (double __x) throw (); extern double __atanh (double __x) throw ();







extern double exp (double __x) throw (); extern double __exp (double __x) throw ();


extern double frexp (double __x, int *__exponent) throw (); extern double __frexp (double __x, int *__exponent) throw ();


extern double ldexp (double __x, int __exponent) throw (); extern double __ldexp (double __x, int __exponent) throw ();


extern double log (double __x) throw (); extern double __log (double __x) throw ();


extern double log10 (double __x) throw (); extern double __log10 (double __x) throw ();


extern double modf (double __x, double *__iptr) throw (); extern double __modf (double __x, double *__iptr) throw () __attribute__ ((__nonnull__ (2)));




extern double exp10 (double __x) throw (); extern double __exp10 (double __x) throw ();

extern double pow10 (double __x) throw (); extern double __pow10 (double __x) throw ();





extern double expm1 (double __x) throw (); extern double __expm1 (double __x) throw ();


extern double log1p (double __x) throw (); extern double __log1p (double __x) throw ();


extern double logb (double __x) throw (); extern double __logb (double __x) throw ();






extern double exp2 (double __x) throw (); extern double __exp2 (double __x) throw ();


extern double log2 (double __x) throw (); extern double __log2 (double __x) throw ();
# 153 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern double pow (double __x, double __y) throw (); extern double __pow (double __x, double __y) throw ();


extern double sqrt (double __x) throw (); extern double __sqrt (double __x) throw ();





extern double hypot (double __x, double __y) throw (); extern double __hypot (double __x, double __y) throw ();






extern double cbrt (double __x) throw (); extern double __cbrt (double __x) throw ();
# 178 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern double ceil (double __x) throw () __attribute__ ((__const__)); extern double __ceil (double __x) throw () __attribute__ ((__const__));


extern double fabs (double __x) throw () __attribute__ ((__const__)); extern double __fabs (double __x) throw () __attribute__ ((__const__));


extern double floor (double __x) throw () __attribute__ ((__const__)); extern double __floor (double __x) throw () __attribute__ ((__const__));


extern double fmod (double __x, double __y) throw (); extern double __fmod (double __x, double __y) throw ();




extern int __isinf (double __value) throw () __attribute__ ((__const__));


extern int __finite (double __value) throw () __attribute__ ((__const__));





extern int isinf (double __value) throw () __attribute__ ((__const__));


extern int finite (double __value) throw () __attribute__ ((__const__));


extern double drem (double __x, double __y) throw (); extern double __drem (double __x, double __y) throw ();



extern double significand (double __x) throw (); extern double __significand (double __x) throw ();





extern double copysign (double __x, double __y) throw () __attribute__ ((__const__)); extern double __copysign (double __x, double __y) throw () __attribute__ ((__const__));






extern double nan (const char *__tagb) throw () __attribute__ ((__const__)); extern double __nan (const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnan (double __value) throw () __attribute__ ((__const__));



extern int isnan (double __value) throw () __attribute__ ((__const__));


extern double j0 (double) throw (); extern double __j0 (double) throw ();
extern double j1 (double) throw (); extern double __j1 (double) throw ();
extern double jn (int, double) throw (); extern double __jn (int, double) throw ();
extern double y0 (double) throw (); extern double __y0 (double) throw ();
extern double y1 (double) throw (); extern double __y1 (double) throw ();
extern double yn (int, double) throw (); extern double __yn (int, double) throw ();






extern double erf (double) throw (); extern double __erf (double) throw ();
extern double erfc (double) throw (); extern double __erfc (double) throw ();
extern double lgamma (double) throw (); extern double __lgamma (double) throw ();






extern double tgamma (double) throw (); extern double __tgamma (double) throw ();





extern double gamma (double) throw (); extern double __gamma (double) throw ();






extern double lgamma_r (double, int *__signgamp) throw (); extern double __lgamma_r (double, int *__signgamp) throw ();







extern double rint (double __x) throw (); extern double __rint (double __x) throw ();


extern double nextafter (double __x, double __y) throw () __attribute__ ((__const__)); extern double __nextafter (double __x, double __y) throw () __attribute__ ((__const__));

extern double nexttoward (double __x, long double __y) throw () __attribute__ ((__const__)); extern double __nexttoward (double __x, long double __y) throw () __attribute__ ((__const__));



extern double remainder (double __x, double __y) throw (); extern double __remainder (double __x, double __y) throw ();



extern double scalbn (double __x, int __n) throw (); extern double __scalbn (double __x, int __n) throw ();



extern int ilogb (double __x) throw (); extern int __ilogb (double __x) throw ();




extern double scalbln (double __x, long int __n) throw (); extern double __scalbln (double __x, long int __n) throw ();



extern double nearbyint (double __x) throw (); extern double __nearbyint (double __x) throw ();



extern double round (double __x) throw () __attribute__ ((__const__)); extern double __round (double __x) throw () __attribute__ ((__const__));



extern double trunc (double __x) throw () __attribute__ ((__const__)); extern double __trunc (double __x) throw () __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) throw (); extern double __remquo (double __x, double __y, int *__quo) throw ();






extern long int lrint (double __x) throw (); extern long int __lrint (double __x) throw ();
__extension__
extern long long int llrint (double __x) throw (); extern long long int __llrint (double __x) throw ();



extern long int lround (double __x) throw (); extern long int __lround (double __x) throw ();
__extension__
extern long long int llround (double __x) throw (); extern long long int __llround (double __x) throw ();



extern double fdim (double __x, double __y) throw (); extern double __fdim (double __x, double __y) throw ();


extern double fmax (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmax (double __x, double __y) throw () __attribute__ ((__const__));


extern double fmin (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmin (double __x, double __y) throw () __attribute__ ((__const__));



extern int __fpclassify (double __value) throw ()
     __attribute__ ((__const__));


extern int __signbit (double __value) throw ()
     __attribute__ ((__const__));



extern double fma (double __x, double __y, double __z) throw (); extern double __fma (double __x, double __y, double __z) throw ();
# 365 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int __issignaling (double __value) throw ()
     __attribute__ ((__const__));




extern double scalb (double __x, double __n) throw (); extern double __scalb (double __x, double __n) throw ();
# 70 "/usr/include/math.h" 2 3 4
# 88 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 54 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern float acosf (float __x) throw (); extern float __acosf (float __x) throw ();

extern float asinf (float __x) throw (); extern float __asinf (float __x) throw ();

extern float atanf (float __x) throw (); extern float __atanf (float __x) throw ();

extern float atan2f (float __y, float __x) throw (); extern float __atan2f (float __y, float __x) throw ();


extern float cosf (float __x) throw (); extern float __cosf (float __x) throw ();

extern float sinf (float __x) throw (); extern float __sinf (float __x) throw ();

extern float tanf (float __x) throw (); extern float __tanf (float __x) throw ();




extern float coshf (float __x) throw (); extern float __coshf (float __x) throw ();

extern float sinhf (float __x) throw (); extern float __sinhf (float __x) throw ();

extern float tanhf (float __x) throw (); extern float __tanhf (float __x) throw ();




extern void sincosf (float __x, float *__sinx, float *__cosx) throw (); extern void __sincosf (float __x, float *__sinx, float *__cosx) throw ();






extern float acoshf (float __x) throw (); extern float __acoshf (float __x) throw ();

extern float asinhf (float __x) throw (); extern float __asinhf (float __x) throw ();

extern float atanhf (float __x) throw (); extern float __atanhf (float __x) throw ();







extern float expf (float __x) throw (); extern float __expf (float __x) throw ();


extern float frexpf (float __x, int *__exponent) throw (); extern float __frexpf (float __x, int *__exponent) throw ();


extern float ldexpf (float __x, int __exponent) throw (); extern float __ldexpf (float __x, int __exponent) throw ();


extern float logf (float __x) throw (); extern float __logf (float __x) throw ();


extern float log10f (float __x) throw (); extern float __log10f (float __x) throw ();


extern float modff (float __x, float *__iptr) throw (); extern float __modff (float __x, float *__iptr) throw () __attribute__ ((__nonnull__ (2)));




extern float exp10f (float __x) throw (); extern float __exp10f (float __x) throw ();

extern float pow10f (float __x) throw (); extern float __pow10f (float __x) throw ();





extern float expm1f (float __x) throw (); extern float __expm1f (float __x) throw ();


extern float log1pf (float __x) throw (); extern float __log1pf (float __x) throw ();


extern float logbf (float __x) throw (); extern float __logbf (float __x) throw ();






extern float exp2f (float __x) throw (); extern float __exp2f (float __x) throw ();


extern float log2f (float __x) throw (); extern float __log2f (float __x) throw ();
# 153 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern float powf (float __x, float __y) throw (); extern float __powf (float __x, float __y) throw ();


extern float sqrtf (float __x) throw (); extern float __sqrtf (float __x) throw ();





extern float hypotf (float __x, float __y) throw (); extern float __hypotf (float __x, float __y) throw ();






extern float cbrtf (float __x) throw (); extern float __cbrtf (float __x) throw ();
# 178 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern float ceilf (float __x) throw () __attribute__ ((__const__)); extern float __ceilf (float __x) throw () __attribute__ ((__const__));


extern float fabsf (float __x) throw () __attribute__ ((__const__)); extern float __fabsf (float __x) throw () __attribute__ ((__const__));


extern float floorf (float __x) throw () __attribute__ ((__const__)); extern float __floorf (float __x) throw () __attribute__ ((__const__));


extern float fmodf (float __x, float __y) throw (); extern float __fmodf (float __x, float __y) throw ();




extern int __isinff (float __value) throw () __attribute__ ((__const__));


extern int __finitef (float __value) throw () __attribute__ ((__const__));





extern int isinff (float __value) throw () __attribute__ ((__const__));


extern int finitef (float __value) throw () __attribute__ ((__const__));


extern float dremf (float __x, float __y) throw (); extern float __dremf (float __x, float __y) throw ();



extern float significandf (float __x) throw (); extern float __significandf (float __x) throw ();





extern float copysignf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) throw () __attribute__ ((__const__));






extern float nanf (const char *__tagb) throw () __attribute__ ((__const__)); extern float __nanf (const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanf (float __value) throw () __attribute__ ((__const__));



extern int isnanf (float __value) throw () __attribute__ ((__const__));


extern float j0f (float) throw (); extern float __j0f (float) throw ();
extern float j1f (float) throw (); extern float __j1f (float) throw ();
extern float jnf (int, float) throw (); extern float __jnf (int, float) throw ();
extern float y0f (float) throw (); extern float __y0f (float) throw ();
extern float y1f (float) throw (); extern float __y1f (float) throw ();
extern float ynf (int, float) throw (); extern float __ynf (int, float) throw ();






extern float erff (float) throw (); extern float __erff (float) throw ();
extern float erfcf (float) throw (); extern float __erfcf (float) throw ();
extern float lgammaf (float) throw (); extern float __lgammaf (float) throw ();






extern float tgammaf (float) throw (); extern float __tgammaf (float) throw ();





extern float gammaf (float) throw (); extern float __gammaf (float) throw ();






extern float lgammaf_r (float, int *__signgamp) throw (); extern float __lgammaf_r (float, int *__signgamp) throw ();







extern float rintf (float __x) throw (); extern float __rintf (float __x) throw ();


extern float nextafterf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __nextafterf (float __x, float __y) throw () __attribute__ ((__const__));

extern float nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__)); extern float __nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__));



extern float remainderf (float __x, float __y) throw (); extern float __remainderf (float __x, float __y) throw ();



extern float scalbnf (float __x, int __n) throw (); extern float __scalbnf (float __x, int __n) throw ();



extern int ilogbf (float __x) throw (); extern int __ilogbf (float __x) throw ();




extern float scalblnf (float __x, long int __n) throw (); extern float __scalblnf (float __x, long int __n) throw ();



extern float nearbyintf (float __x) throw (); extern float __nearbyintf (float __x) throw ();



extern float roundf (float __x) throw () __attribute__ ((__const__)); extern float __roundf (float __x) throw () __attribute__ ((__const__));



extern float truncf (float __x) throw () __attribute__ ((__const__)); extern float __truncf (float __x) throw () __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) throw (); extern float __remquof (float __x, float __y, int *__quo) throw ();






extern long int lrintf (float __x) throw (); extern long int __lrintf (float __x) throw ();
__extension__
extern long long int llrintf (float __x) throw (); extern long long int __llrintf (float __x) throw ();



extern long int lroundf (float __x) throw (); extern long int __lroundf (float __x) throw ();
__extension__
extern long long int llroundf (float __x) throw (); extern long long int __llroundf (float __x) throw ();



extern float fdimf (float __x, float __y) throw (); extern float __fdimf (float __x, float __y) throw ();


extern float fmaxf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fmaxf (float __x, float __y) throw () __attribute__ ((__const__));


extern float fminf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fminf (float __x, float __y) throw () __attribute__ ((__const__));



extern int __fpclassifyf (float __value) throw ()
     __attribute__ ((__const__));


extern int __signbitf (float __value) throw ()
     __attribute__ ((__const__));



extern float fmaf (float __x, float __y, float __z) throw (); extern float __fmaf (float __x, float __y, float __z) throw ();
# 365 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int __issignalingf (float __value) throw ()
     __attribute__ ((__const__));




extern float scalbf (float __x, float __n) throw (); extern float __scalbf (float __x, float __n) throw ();
# 89 "/usr/include/math.h" 2 3 4
# 132 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 54 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern long double acosl (long double __x) throw (); extern long double __acosl (long double __x) throw ();

extern long double asinl (long double __x) throw (); extern long double __asinl (long double __x) throw ();

extern long double atanl (long double __x) throw (); extern long double __atanl (long double __x) throw ();

extern long double atan2l (long double __y, long double __x) throw (); extern long double __atan2l (long double __y, long double __x) throw ();


extern long double cosl (long double __x) throw (); extern long double __cosl (long double __x) throw ();

extern long double sinl (long double __x) throw (); extern long double __sinl (long double __x) throw ();

extern long double tanl (long double __x) throw (); extern long double __tanl (long double __x) throw ();




extern long double coshl (long double __x) throw (); extern long double __coshl (long double __x) throw ();

extern long double sinhl (long double __x) throw (); extern long double __sinhl (long double __x) throw ();

extern long double tanhl (long double __x) throw (); extern long double __tanhl (long double __x) throw ();




extern void sincosl (long double __x, long double *__sinx, long double *__cosx) throw (); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) throw ();






extern long double acoshl (long double __x) throw (); extern long double __acoshl (long double __x) throw ();

extern long double asinhl (long double __x) throw (); extern long double __asinhl (long double __x) throw ();

extern long double atanhl (long double __x) throw (); extern long double __atanhl (long double __x) throw ();







extern long double expl (long double __x) throw (); extern long double __expl (long double __x) throw ();


extern long double frexpl (long double __x, int *__exponent) throw (); extern long double __frexpl (long double __x, int *__exponent) throw ();


extern long double ldexpl (long double __x, int __exponent) throw (); extern long double __ldexpl (long double __x, int __exponent) throw ();


extern long double logl (long double __x) throw (); extern long double __logl (long double __x) throw ();


extern long double log10l (long double __x) throw (); extern long double __log10l (long double __x) throw ();


extern long double modfl (long double __x, long double *__iptr) throw (); extern long double __modfl (long double __x, long double *__iptr) throw () __attribute__ ((__nonnull__ (2)));




extern long double exp10l (long double __x) throw (); extern long double __exp10l (long double __x) throw ();

extern long double pow10l (long double __x) throw (); extern long double __pow10l (long double __x) throw ();





extern long double expm1l (long double __x) throw (); extern long double __expm1l (long double __x) throw ();


extern long double log1pl (long double __x) throw (); extern long double __log1pl (long double __x) throw ();


extern long double logbl (long double __x) throw (); extern long double __logbl (long double __x) throw ();






extern long double exp2l (long double __x) throw (); extern long double __exp2l (long double __x) throw ();


extern long double log2l (long double __x) throw (); extern long double __log2l (long double __x) throw ();
# 153 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern long double powl (long double __x, long double __y) throw (); extern long double __powl (long double __x, long double __y) throw ();


extern long double sqrtl (long double __x) throw (); extern long double __sqrtl (long double __x) throw ();





extern long double hypotl (long double __x, long double __y) throw (); extern long double __hypotl (long double __x, long double __y) throw ();






extern long double cbrtl (long double __x) throw (); extern long double __cbrtl (long double __x) throw ();
# 178 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern long double ceill (long double __x) throw () __attribute__ ((__const__)); extern long double __ceill (long double __x) throw () __attribute__ ((__const__));


extern long double fabsl (long double __x) throw () __attribute__ ((__const__)); extern long double __fabsl (long double __x) throw () __attribute__ ((__const__));


extern long double floorl (long double __x) throw () __attribute__ ((__const__)); extern long double __floorl (long double __x) throw () __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) throw (); extern long double __fmodl (long double __x, long double __y) throw ();




extern int __isinfl (long double __value) throw () __attribute__ ((__const__));


extern int __finitel (long double __value) throw () __attribute__ ((__const__));





extern int isinfl (long double __value) throw () __attribute__ ((__const__));


extern int finitel (long double __value) throw () __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) throw (); extern long double __dreml (long double __x, long double __y) throw ();



extern long double significandl (long double __x) throw (); extern long double __significandl (long double __x) throw ();





extern long double copysignl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) throw () __attribute__ ((__const__));






extern long double nanl (const char *__tagb) throw () __attribute__ ((__const__)); extern long double __nanl (const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanl (long double __value) throw () __attribute__ ((__const__));



extern int isnanl (long double __value) throw () __attribute__ ((__const__));


extern long double j0l (long double) throw (); extern long double __j0l (long double) throw ();
extern long double j1l (long double) throw (); extern long double __j1l (long double) throw ();
extern long double jnl (int, long double) throw (); extern long double __jnl (int, long double) throw ();
extern long double y0l (long double) throw (); extern long double __y0l (long double) throw ();
extern long double y1l (long double) throw (); extern long double __y1l (long double) throw ();
extern long double ynl (int, long double) throw (); extern long double __ynl (int, long double) throw ();






extern long double erfl (long double) throw (); extern long double __erfl (long double) throw ();
extern long double erfcl (long double) throw (); extern long double __erfcl (long double) throw ();
extern long double lgammal (long double) throw (); extern long double __lgammal (long double) throw ();






extern long double tgammal (long double) throw (); extern long double __tgammal (long double) throw ();





extern long double gammal (long double) throw (); extern long double __gammal (long double) throw ();






extern long double lgammal_r (long double, int *__signgamp) throw (); extern long double __lgammal_r (long double, int *__signgamp) throw ();







extern long double rintl (long double __x) throw (); extern long double __rintl (long double __x) throw ();


extern long double nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__));

extern long double nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__));



extern long double remainderl (long double __x, long double __y) throw (); extern long double __remainderl (long double __x, long double __y) throw ();



extern long double scalbnl (long double __x, int __n) throw (); extern long double __scalbnl (long double __x, int __n) throw ();



extern int ilogbl (long double __x) throw (); extern int __ilogbl (long double __x) throw ();




extern long double scalblnl (long double __x, long int __n) throw (); extern long double __scalblnl (long double __x, long int __n) throw ();



extern long double nearbyintl (long double __x) throw (); extern long double __nearbyintl (long double __x) throw ();



extern long double roundl (long double __x) throw () __attribute__ ((__const__)); extern long double __roundl (long double __x) throw () __attribute__ ((__const__));



extern long double truncl (long double __x) throw () __attribute__ ((__const__)); extern long double __truncl (long double __x) throw () __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) throw (); extern long double __remquol (long double __x, long double __y, int *__quo) throw ();






extern long int lrintl (long double __x) throw (); extern long int __lrintl (long double __x) throw ();
__extension__
extern long long int llrintl (long double __x) throw (); extern long long int __llrintl (long double __x) throw ();



extern long int lroundl (long double __x) throw (); extern long int __lroundl (long double __x) throw ();
__extension__
extern long long int llroundl (long double __x) throw (); extern long long int __llroundl (long double __x) throw ();



extern long double fdiml (long double __x, long double __y) throw (); extern long double __fdiml (long double __x, long double __y) throw ();


extern long double fmaxl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fmaxl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern long double fminl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fminl (long double __x, long double __y) throw () __attribute__ ((__const__));



extern int __fpclassifyl (long double __value) throw ()
     __attribute__ ((__const__));


extern int __signbitl (long double __value) throw ()
     __attribute__ ((__const__));



extern long double fmal (long double __x, long double __y, long double __z) throw (); extern long double __fmal (long double __x, long double __y, long double __z) throw ();
# 365 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int __issignalingl (long double __value) throw ()
     __attribute__ ((__const__));




extern long double scalbl (long double __x, long double __n) throw (); extern long double __scalbl (long double __x, long double __n) throw ();
# 133 "/usr/include/math.h" 2 3 4
# 148 "/usr/include/math.h" 3 4
extern int signgam;
# 189 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN =

      0,
    FP_INFINITE =

      1,
    FP_ZERO =

      2,
    FP_SUBNORMAL =

      3,
    FP_NORMAL =

      4
  };
# 301 "/usr/include/math.h" 3 4
typedef enum
{
  _IEEE_ = -1,
  _SVID_,
  _XOPEN_,
  _POSIX_,
  _ISOC_
} _LIB_VERSION_TYPE;




extern _LIB_VERSION_TYPE _LIB_VERSION;
# 324 "/usr/include/math.h" 3 4
struct __exception



  {
    int type;
    char *name;
    double arg1;
    double arg2;
    double retval;
  };


extern int matherr (struct __exception *__exc) throw ();
# 488 "/usr/include/math.h" 3 4
}
# 45 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cmath" 2 3
# 75 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cmath" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  inline constexpr double
  abs(double __x)
  { return __builtin_fabs(__x); }



  inline constexpr float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    abs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::acos;


  inline constexpr float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline constexpr long double
  acos(long double __x)
  { return __builtin_acosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;


  inline constexpr float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline constexpr long double
  asin(long double __x)
  { return __builtin_asinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;


  inline constexpr float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline constexpr long double
  atan(long double __x)
  { return __builtin_atanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;


  inline constexpr float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline constexpr long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  using ::ceil;


  inline constexpr float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline constexpr long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;


  inline constexpr float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline constexpr long double
  cos(long double __x)
  { return __builtin_cosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;


  inline constexpr float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline constexpr long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;


  inline constexpr float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline constexpr long double
  exp(long double __x)
  { return __builtin_expl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;


  inline constexpr float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;


  inline constexpr float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline constexpr long double
  floor(long double __x)
  { return __builtin_floorl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;


  inline constexpr float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline constexpr long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmod(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmod(__type(__x), __type(__y));
    }

  using ::frexp;


  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;


  inline constexpr float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline constexpr long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ldexp(_Tp __x, int __exp)
    { return __builtin_ldexp(__x, __exp); }

  using ::log;


  inline constexpr float
  log(float __x)
  { return __builtin_logf(__x); }

  inline constexpr long double
  log(long double __x)
  { return __builtin_logl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;


  inline constexpr float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline constexpr long double
  log10(long double __x)
  { return __builtin_log10l(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;


  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }


  using ::pow;


  inline constexpr float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline constexpr long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }
# 431 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cmath" 3
  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }

  using ::sin;


  inline constexpr float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline constexpr long double
  sin(long double __x)
  { return __builtin_sinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;


  inline constexpr float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline constexpr long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;


  inline constexpr float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline constexpr long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;


  inline constexpr float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline constexpr long double
  tan(long double __x)
  { return __builtin_tanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;


  inline constexpr float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline constexpr long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }


}
# 555 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cmath" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  constexpr int
  fpclassify(float __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(long double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              int>::__type
    fpclassify(_Tp __x)
    { return __x != 0 ? 4 : 2; }

  constexpr bool
  isfinite(float __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(double __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(long double __x)
  { return __builtin_isfinite(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isfinite(_Tp __x)
    { return true; }

  constexpr bool
  isinf(float __x)
  { return __builtin_isinf(__x); }

  constexpr bool
  isinf(double __x)
  { return __builtin_isinf(__x); }

  constexpr bool
  isinf(long double __x)
  { return __builtin_isinf(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isinf(_Tp __x)
    { return false; }

  constexpr bool
  isnan(float __x)
  { return __builtin_isnan(__x); }

  constexpr bool
  isnan(double __x)
  { return __builtin_isnan(__x); }

  constexpr bool
  isnan(long double __x)
  { return __builtin_isnan(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnan(_Tp __x)
    { return false; }

  constexpr bool
  isnormal(float __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(double __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(long double __x)
  { return __builtin_isnormal(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnormal(_Tp __x)
    { return __x != 0 ? true : false; }

  constexpr bool
  signbit(float __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(double __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(long double __x)
  { return __builtin_signbit(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    signbit(_Tp __x)
    { return __x < 0 ? true : false; }

  constexpr bool
  isgreater(float __x, float __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(double __x, double __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(long double __x, long double __y)
  { return __builtin_isgreater(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreater(__type(__x), __type(__y));
    }

  constexpr bool
  isgreaterequal(float __x, float __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(double __x, double __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(long double __x, long double __y)
  { return __builtin_isgreaterequal(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreaterequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreaterequal(__type(__x), __type(__y));
    }

  constexpr bool
  isless(float __x, float __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(double __x, double __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(long double __x, long double __y)
  { return __builtin_isless(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isless(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isless(__type(__x), __type(__y));
    }

  constexpr bool
  islessequal(float __x, float __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(double __x, double __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(long double __x, long double __y)
  { return __builtin_islessequal(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessequal(__type(__x), __type(__y));
    }

  constexpr bool
  islessgreater(float __x, float __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(double __x, double __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(long double __x, long double __y)
  { return __builtin_islessgreater(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessgreater(__type(__x), __type(__y));
    }

  constexpr bool
  isunordered(float __x, float __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(double __x, double __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(long double __x, long double __y)
  { return __builtin_isunordered(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isunordered(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isunordered(__type(__x), __type(__y));
    }
# 917 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cmath" 3
}
# 1032 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cmath" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  using ::double_t;
  using ::float_t;


  using ::acosh;
  using ::acoshf;
  using ::acoshl;

  using ::asinh;
  using ::asinhf;
  using ::asinhl;

  using ::atanh;
  using ::atanhf;
  using ::atanhl;

  using ::cbrt;
  using ::cbrtf;
  using ::cbrtl;

  using ::copysign;
  using ::copysignf;
  using ::copysignl;

  using ::erf;
  using ::erff;
  using ::erfl;

  using ::erfc;
  using ::erfcf;
  using ::erfcl;

  using ::exp2;
  using ::exp2f;
  using ::exp2l;

  using ::expm1;
  using ::expm1f;
  using ::expm1l;

  using ::fdim;
  using ::fdimf;
  using ::fdiml;

  using ::fma;
  using ::fmaf;
  using ::fmal;

  using ::fmax;
  using ::fmaxf;
  using ::fmaxl;

  using ::fmin;
  using ::fminf;
  using ::fminl;

  using ::hypot;
  using ::hypotf;
  using ::hypotl;

  using ::ilogb;
  using ::ilogbf;
  using ::ilogbl;

  using ::lgamma;
  using ::lgammaf;
  using ::lgammal;

  using ::llrint;
  using ::llrintf;
  using ::llrintl;

  using ::llround;
  using ::llroundf;
  using ::llroundl;

  using ::log1p;
  using ::log1pf;
  using ::log1pl;

  using ::log2;
  using ::log2f;
  using ::log2l;

  using ::logb;
  using ::logbf;
  using ::logbl;

  using ::lrint;
  using ::lrintf;
  using ::lrintl;

  using ::lround;
  using ::lroundf;
  using ::lroundl;

  using ::nan;
  using ::nanf;
  using ::nanl;

  using ::nearbyint;
  using ::nearbyintf;
  using ::nearbyintl;

  using ::nextafter;
  using ::nextafterf;
  using ::nextafterl;

  using ::nexttoward;
  using ::nexttowardf;
  using ::nexttowardl;

  using ::remainder;
  using ::remainderf;
  using ::remainderl;

  using ::remquo;
  using ::remquof;
  using ::remquol;

  using ::rint;
  using ::rintf;
  using ::rintl;

  using ::round;
  using ::roundf;
  using ::roundl;

  using ::scalbln;
  using ::scalblnf;
  using ::scalblnl;

  using ::scalbn;
  using ::scalbnf;
  using ::scalbnl;

  using ::tgamma;
  using ::tgammaf;
  using ::tgammal;

  using ::trunc;
  using ::truncf;
  using ::truncl;


  constexpr float
  acosh(float __x)
  { return __builtin_acoshf(__x); }

  constexpr long double
  acosh(long double __x)
  { return __builtin_acoshl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    acosh(_Tp __x)
    { return __builtin_acosh(__x); }

  constexpr float
  asinh(float __x)
  { return __builtin_asinhf(__x); }

  constexpr long double
  asinh(long double __x)
  { return __builtin_asinhl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    asinh(_Tp __x)
    { return __builtin_asinh(__x); }

  constexpr float
  atanh(float __x)
  { return __builtin_atanhf(__x); }

  constexpr long double
  atanh(long double __x)
  { return __builtin_atanhl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    atanh(_Tp __x)
    { return __builtin_atanh(__x); }

  constexpr float
  cbrt(float __x)
  { return __builtin_cbrtf(__x); }

  constexpr long double
  cbrt(long double __x)
  { return __builtin_cbrtl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    cbrt(_Tp __x)
    { return __builtin_cbrt(__x); }

  constexpr float
  copysign(float __x, float __y)
  { return __builtin_copysignf(__x, __y); }

  constexpr long double
  copysign(long double __x, long double __y)
  { return __builtin_copysignl(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    copysign(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return copysign(__type(__x), __type(__y));
    }

  constexpr float
  erf(float __x)
  { return __builtin_erff(__x); }

  constexpr long double
  erf(long double __x)
  { return __builtin_erfl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erf(_Tp __x)
    { return __builtin_erf(__x); }

  constexpr float
  erfc(float __x)
  { return __builtin_erfcf(__x); }

  constexpr long double
  erfc(long double __x)
  { return __builtin_erfcl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erfc(_Tp __x)
    { return __builtin_erfc(__x); }

  constexpr float
  exp2(float __x)
  { return __builtin_exp2f(__x); }

  constexpr long double
  exp2(long double __x)
  { return __builtin_exp2l(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    exp2(_Tp __x)
    { return __builtin_exp2(__x); }

  constexpr float
  expm1(float __x)
  { return __builtin_expm1f(__x); }

  constexpr long double
  expm1(long double __x)
  { return __builtin_expm1l(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    expm1(_Tp __x)
    { return __builtin_expm1(__x); }

  constexpr float
  fdim(float __x, float __y)
  { return __builtin_fdimf(__x, __y); }

  constexpr long double
  fdim(long double __x, long double __y)
  { return __builtin_fdiml(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fdim(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fdim(__type(__x), __type(__y));
    }

  constexpr float
  fma(float __x, float __y, float __z)
  { return __builtin_fmaf(__x, __y, __z); }

  constexpr long double
  fma(long double __x, long double __y, long double __z)
  { return __builtin_fmal(__x, __y, __z); }

  template<typename _Tp, typename _Up, typename _Vp>
    constexpr typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
    fma(_Tp __x, _Up __y, _Vp __z)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
      return fma(__type(__x), __type(__y), __type(__z));
    }

  constexpr float
  fmax(float __x, float __y)
  { return __builtin_fmaxf(__x, __y); }

  constexpr long double
  fmax(long double __x, long double __y)
  { return __builtin_fmaxl(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmax(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmax(__type(__x), __type(__y));
    }

  constexpr float
  fmin(float __x, float __y)
  { return __builtin_fminf(__x, __y); }

  constexpr long double
  fmin(long double __x, long double __y)
  { return __builtin_fminl(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmin(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmin(__type(__x), __type(__y));
    }

  constexpr float
  hypot(float __x, float __y)
  { return __builtin_hypotf(__x, __y); }

  constexpr long double
  hypot(long double __x, long double __y)
  { return __builtin_hypotl(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    hypot(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return hypot(__type(__x), __type(__y));
    }

  constexpr int
  ilogb(float __x)
  { return __builtin_ilogbf(__x); }

  constexpr int
  ilogb(long double __x)
  { return __builtin_ilogbl(__x); }

  template<typename _Tp>
    constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    int>::__type
    ilogb(_Tp __x)
    { return __builtin_ilogb(__x); }

  constexpr float
  lgamma(float __x)
  { return __builtin_lgammaf(__x); }

  constexpr long double
  lgamma(long double __x)
  { return __builtin_lgammal(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    lgamma(_Tp __x)
    { return __builtin_lgamma(__x); }

  constexpr long long
  llrint(float __x)
  { return __builtin_llrintf(__x); }

  constexpr long long
  llrint(long double __x)
  { return __builtin_llrintl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llrint(_Tp __x)
    { return __builtin_llrint(__x); }

  constexpr long long
  llround(float __x)
  { return __builtin_llroundf(__x); }

  constexpr long long
  llround(long double __x)
  { return __builtin_llroundl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llround(_Tp __x)
    { return __builtin_llround(__x); }

  constexpr float
  log1p(float __x)
  { return __builtin_log1pf(__x); }

  constexpr long double
  log1p(long double __x)
  { return __builtin_log1pl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log1p(_Tp __x)
    { return __builtin_log1p(__x); }


  constexpr float
  log2(float __x)
  { return __builtin_log2f(__x); }

  constexpr long double
  log2(long double __x)
  { return __builtin_log2l(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log2(_Tp __x)
    { return __builtin_log2(__x); }

  constexpr float
  logb(float __x)
  { return __builtin_logbf(__x); }

  constexpr long double
  logb(long double __x)
  { return __builtin_logbl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    logb(_Tp __x)
    { return __builtin_logb(__x); }

  constexpr long
  lrint(float __x)
  { return __builtin_lrintf(__x); }

  constexpr long
  lrint(long double __x)
  { return __builtin_lrintl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lrint(_Tp __x)
    { return __builtin_lrint(__x); }

  constexpr long
  lround(float __x)
  { return __builtin_lroundf(__x); }

  constexpr long
  lround(long double __x)
  { return __builtin_lroundl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lround(_Tp __x)
    { return __builtin_lround(__x); }

  constexpr float
  nearbyint(float __x)
  { return __builtin_nearbyintf(__x); }

  constexpr long double
  nearbyint(long double __x)
  { return __builtin_nearbyintl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nearbyint(_Tp __x)
    { return __builtin_nearbyint(__x); }

  constexpr float
  nextafter(float __x, float __y)
  { return __builtin_nextafterf(__x, __y); }

  constexpr long double
  nextafter(long double __x, long double __y)
  { return __builtin_nextafterl(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    nextafter(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return nextafter(__type(__x), __type(__y));
    }

  constexpr float
  nexttoward(float __x, long double __y)
  { return __builtin_nexttowardf(__x, __y); }

  constexpr long double
  nexttoward(long double __x, long double __y)
  { return __builtin_nexttowardl(__x, __y); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nexttoward(_Tp __x, long double __y)
    { return __builtin_nexttoward(__x, __y); }

  constexpr float
  remainder(float __x, float __y)
  { return __builtin_remainderf(__x, __y); }

  constexpr long double
  remainder(long double __x, long double __y)
  { return __builtin_remainderl(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remainder(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remainder(__type(__x), __type(__y));
    }

  inline float
  remquo(float __x, float __y, int* __pquo)
  { return __builtin_remquof(__x, __y, __pquo); }

  inline long double
  remquo(long double __x, long double __y, int* __pquo)
  { return __builtin_remquol(__x, __y, __pquo); }

  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remquo(_Tp __x, _Up __y, int* __pquo)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remquo(__type(__x), __type(__y), __pquo);
    }

  constexpr float
  rint(float __x)
  { return __builtin_rintf(__x); }

  constexpr long double
  rint(long double __x)
  { return __builtin_rintl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    rint(_Tp __x)
    { return __builtin_rint(__x); }

  constexpr float
  round(float __x)
  { return __builtin_roundf(__x); }

  constexpr long double
  round(long double __x)
  { return __builtin_roundl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    round(_Tp __x)
    { return __builtin_round(__x); }

  constexpr float
  scalbln(float __x, long __ex)
  { return __builtin_scalblnf(__x, __ex); }

  constexpr long double
  scalbln(long double __x, long __ex)
  { return __builtin_scalblnl(__x, __ex); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbln(_Tp __x, long __ex)
    { return __builtin_scalbln(__x, __ex); }

  constexpr float
  scalbn(float __x, int __ex)
  { return __builtin_scalbnf(__x, __ex); }

  constexpr long double
  scalbn(long double __x, int __ex)
  { return __builtin_scalbnl(__x, __ex); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbn(_Tp __x, int __ex)
    { return __builtin_scalbn(__x, __ex); }

  constexpr float
  tgamma(float __x)
  { return __builtin_tgammaf(__x); }

  constexpr long double
  tgamma(long double __x)
  { return __builtin_tgammal(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    tgamma(_Tp __x)
    { return __builtin_tgamma(__x); }

  constexpr float
  trunc(float __x)
  { return __builtin_truncf(__x); }

  constexpr long double
  trunc(long double __x)
  { return __builtin_truncl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    trunc(_Tp __x)
    { return __builtin_trunc(__x); }


}
# 39 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/random" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstdio" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstdio" 3


# 1 "/usr/include/stdio.h" 1 3 4
# 29 "/usr/include/stdio.h" 3 4
extern "C" {




# 1 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/stddef.h" 1 3 4
# 34 "/usr/include/stdio.h" 2 3 4
# 74 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
# 31 "/usr/include/libio.h" 3 4
# 1 "/usr/include/_G_config.h" 1 3 4
# 15 "/usr/include/_G_config.h" 3 4
# 1 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/stddef.h" 1 3 4
# 16 "/usr/include/_G_config.h" 2 3 4




# 1 "/usr/include/wchar.h" 1 3 4
# 21 "/usr/include/_G_config.h" 2 3 4
typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 32 "/usr/include/libio.h" 2 3 4
# 144 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;
# 154 "/usr/include/libio.h" 3 4
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 177 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 245 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 293 "/usr/include/libio.h" 3 4
  __off64_t _offset;
# 302 "/usr/include/libio.h" 3 4
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};





struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 338 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);




extern "C" {


extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 434 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) throw ();
extern int _IO_ferror (_IO_FILE *__fp) throw ();

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) throw ();
extern void _IO_funlockfile (_IO_FILE *) throw ();
extern int _IO_ftrylockfile (_IO_FILE *) throw ();
# 464 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) throw ();
# 526 "/usr/include/libio.h" 3 4
}
# 75 "/usr/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
# 110 "/usr/include/stdio.h" 3 4
typedef _G_fpos_t fpos_t;





typedef _G_fpos64_t fpos64_t;
# 164 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 165 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (const char *__filename) throw ();

extern int rename (const char *__old, const char *__new) throw ();




extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) throw ();
# 195 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile (void) ;
# 205 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) throw () ;





extern char *tmpnam_r (char *__s) throw () ;
# 227 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     throw () __attribute__ ((__malloc__)) ;
# 237 "/usr/include/stdio.h" 3 4
extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);
# 252 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 262 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);
# 272 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 297 "/usr/include/stdio.h" 3 4
extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) throw () ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) throw () ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  throw () ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) throw () ;






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) throw ();



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) throw ();





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) throw ();


extern void setlinebuf (FILE *__stream) throw ();
# 356 "/usr/include/stdio.h" 3 4
extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) throw ();





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) throw ();





extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 3, 0)));






extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));
# 425 "/usr/include/stdio.h" 3 4
extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) throw ();
# 471 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__scanf__, 2, 0)));
# 531 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);
# 550 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 561 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 573 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 594 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);
# 622 "/usr/include/stdio.h" 3 4
extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
          ;
# 638 "/usr/include/stdio.h" 3 4
extern char *gets (char *__s) __attribute__ ((__deprecated__));
# 649 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
# 665 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;
# 689 "/usr/include/stdio.h" 3 4
extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 726 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 737 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);
# 749 "/usr/include/stdio.h" 3 4
extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);
# 773 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 798 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 818 "/usr/include/stdio.h" 3 4
extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);




extern void clearerr (FILE *__stream) throw ();

extern int feof (FILE *__stream) throw () ;

extern int ferror (FILE *__stream) throw () ;




extern void clearerr_unlocked (FILE *__stream) throw ();
extern int feof_unlocked (FILE *__stream) throw () ;
extern int ferror_unlocked (FILE *__stream) throw () ;
# 846 "/usr/include/stdio.h" 3 4
extern void perror (const char *__s);







# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];


extern int _sys_nerr;
extern const char *const _sys_errlist[];
# 854 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) throw () ;




extern int fileno_unlocked (FILE *__stream) throw () ;
# 873 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) throw ();





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     throw () __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) throw ();



extern int ftrylockfile (FILE *__stream) throw () ;


extern void funlockfile (FILE *__stream) throw ();
# 943 "/usr/include/stdio.h" 3 4
}
# 43 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstdio" 2 3
# 94 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstdio" 3
namespace std
{
  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;
  using ::gets;
  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;
  using ::tmpnam;
  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
}
# 150 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstdio" 3
namespace __gnu_cxx
{
# 168 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;

}

namespace std
{
  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;
}
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/random" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstdlib" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstdlib" 3
# 41 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/random" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/string" 1 3
# 37 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/string" 3



# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/char_traits.h" 1 3
# 38 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/char_traits.h" 3



# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cwchar" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cwchar" 3




# 1 "/usr/include/wchar.h" 1 3 4
# 45 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cwchar" 2 3
# 42 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/char_traits.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{
# 57 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/char_traits.h" 3
  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
# 82 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static std::size_t
      length(const char_type* __s);

      static const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static constexpr char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static constexpr int_type
      eof()
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
    std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,
          __n * sizeof(char_type)));
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {

      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {

      std::fill_n(__s, __n, __a);
      return __s;
    }


}

namespace std __attribute__ ((__visibility__ ("default")))
{
# 226 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return __builtin_memcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return __builtin_strlen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n)); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n)); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n)); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return static_cast<char_type*>(__builtin_memset(__s, __a, __n)); }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return static_cast<char_type>(__c); }



      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return wcslen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return wmemchr(__s, __a, __n); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemmove(__s1, __s2, __n); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcpy(__s1, __s2, __n); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return wmemset(__s, __a, __n); }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>((0xffffffffu)); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };



}





# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstdint" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstdint" 3








# 1 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/stdint.h" 1 3
# 61 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/stdint.h" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdint.h" 1 3 4








# 1 "/usr/include/stdint.h" 1 3 4
# 27 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/stdint.h" 2 3 4
# 48 "/usr/include/stdint.h" 3 4
typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;

typedef unsigned int uint32_t;



typedef unsigned long int uint64_t;
# 65 "/usr/include/stdint.h" 3 4
typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;

typedef long int int_least64_t;






typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;

typedef unsigned long int uint_least64_t;
# 90 "/usr/include/stdint.h" 3 4
typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 103 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 119 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 134 "/usr/include/stdint.h" 3 4
typedef long int intmax_t;
typedef unsigned long int uintmax_t;
# 10 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdint.h" 2 3 4
# 62 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/stdint.h" 2 3
# 42 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstdint" 2 3




namespace std
{
  using ::int8_t;
  using ::int16_t;
  using ::int32_t;
  using ::int64_t;

  using ::int_fast8_t;
  using ::int_fast16_t;
  using ::int_fast32_t;
  using ::int_fast64_t;

  using ::int_least8_t;
  using ::int_least16_t;
  using ::int_least32_t;
  using ::int_least64_t;

  using ::intmax_t;
  using ::intptr_t;

  using ::uint8_t;
  using ::uint16_t;
  using ::uint32_t;
  using ::uint64_t;

  using ::uint_fast8_t;
  using ::uint_fast16_t;
  using ::uint_fast32_t;
  using ::uint_fast64_t;

  using ::uint_least8_t;
  using ::uint_least16_t;
  using ::uint_least32_t;
  using ::uint_least64_t;

  using ::uintmax_t;
  using ::uintptr_t;
}
# 377 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/char_traits.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<>
    struct char_traits<char16_t>
    {
      typedef char16_t char_type;
      typedef uint_least16_t int_type;
      typedef streamoff off_type;
      typedef u16streampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };

  template<>
    struct char_traits<char32_t>
    {
      typedef char32_t char_type;
      typedef uint_least32_t int_type;
      typedef streamoff off_type;
      typedef u32streampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };


}
# 41 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/string" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/allocator.h" 1 3
# 46 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/allocator.h" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/c++allocator.h" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/c++allocator.h" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ext/new_allocator.h" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ext/new_allocator.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  using std::size_t;
  using std::ptrdiff_t;
# 57 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };




      typedef std::true_type propagate_on_container_move_assignment;


      new_allocator() noexcept { }

      new_allocator(const new_allocator&) noexcept { }

      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) noexcept { }

      ~new_allocator() noexcept { }

      pointer
      address(reference __x) const noexcept
      { return std::__addressof(__x); }

      const_pointer
      address(const_reference __x) const noexcept
      { return std::__addressof(__x); }



      pointer
      allocate(size_type __n, const void* = 0)
      {
 if (__n > this->max_size())
   std::__throw_bad_alloc();

 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }

      size_type
      max_size() const noexcept
      { return size_t(-1) / sizeof(_Tp); }


      template<typename _Up, typename... _Args>
        void
        construct(_Up* __p, _Args&&... __args)
 { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }

      template<typename _Up>
        void
        destroy(_Up* __p) { __p->~_Up(); }
# 135 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ext/new_allocator.h" 3
    };

  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }


}
# 34 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/c++allocator.h" 2 3


namespace std
{
# 47 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/c++allocator.h" 3
  template<typename _Tp>
    using __allocator_base = __gnu_cxx::new_allocator<_Tp>;
}
# 47 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/allocator.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{
# 62 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/allocator.h" 3
  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };




      typedef true_type propagate_on_container_move_assignment;

    };
# 91 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/allocator.h" 3
  template<typename _Tp>
    class allocator: public __allocator_base<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };




      typedef true_type propagate_on_container_move_assignment;


      allocator() throw() { }

      allocator(const allocator& __a) throw()
      : __allocator_base<_Tp>(__a) { }

      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }

      ~allocator() throw() { }


    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator==(const allocator<_Tp>&, const allocator<_Tp>&)
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    { return false; }

  template<typename _Tp>
    inline bool
    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
    { return false; }






  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two)
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };


  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };

  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };


  template<typename _Tp, bool
    = __or_<is_copy_constructible<typename _Tp::value_type>,
            is_nothrow_move_constructible<typename _Tp::value_type>>::value>
    struct __shrink_to_fit_aux
    { static bool _S_do_it(_Tp&) { return false; } };

  template<typename _Tp>
    struct __shrink_to_fit_aux<_Tp, true>
    {
      static bool
      _S_do_it(_Tp& __c)
      {
 try
   {
     _Tp(__make_move_if_noexcept_iterator(__c.begin()),
  __make_move_if_noexcept_iterator(__c.end()),
  __c.get_allocator()).swap(__c);
     return true;
   }
 catch(...)
   { return false; }
      }
    };



}
# 42 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/string" 2 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/localefwd.h" 1 3
# 38 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/localefwd.h" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/c++locale.h" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/c++locale.h" 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/clocale" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/clocale" 3


# 1 "/usr/include/locale.h" 1 3 4
# 28 "/usr/include/locale.h" 3 4
# 1 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/stddef.h" 1 3 4
# 29 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/locale.h" 1 3 4
# 30 "/usr/include/locale.h" 2 3 4

extern "C" {
# 53 "/usr/include/locale.h" 3 4
struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
# 120 "/usr/include/locale.h" 3 4
};



extern char *setlocale (int __category, const char *__locale) throw ();


extern struct lconv *localeconv (void) throw ();
# 151 "/usr/include/locale.h" 3 4
extern __locale_t newlocale (int __category_mask, const char *__locale,
        __locale_t __base) throw ();
# 186 "/usr/include/locale.h" 3 4
extern __locale_t duplocale (__locale_t __dataset) throw ();



extern void freelocale (__locale_t __dataset) throw ();






extern __locale_t uselocale (__locale_t __dataset) throw ();







}
# 43 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/clocale" 2 3








namespace std
{
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}
# 42 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/c++locale.h" 2 3






namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  extern "C" __typeof(uselocale) __uselocale;


}


namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef __locale_t __c_locale;





  inline int
  __convert_from_v(const __c_locale& __cloc __attribute__ ((__unused__)),
     char* __out,
     const int __size __attribute__ ((__unused__)),
     const char* __fmt, ...)
  {

    __c_locale __old = __gnu_cxx::__uselocale(__cloc);
# 88 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/c++locale.h" 3
    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);


    const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);




    __builtin_va_end(__args);


    __gnu_cxx::__uselocale(__old);







    return __ret;
  }


}
# 41 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/localefwd.h" 2 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cctype" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cctype" 3


# 1 "/usr/include/ctype.h" 1 3 4
# 28 "/usr/include/ctype.h" 3 4
extern "C" {
# 46 "/usr/include/ctype.h" 3 4
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 79 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     throw () __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     throw () __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     throw () __attribute__ ((__const__));
# 110 "/usr/include/ctype.h" 3 4
extern int isalnum (int) throw ();
extern int isalpha (int) throw ();
extern int iscntrl (int) throw ();
extern int isdigit (int) throw ();
extern int islower (int) throw ();
extern int isgraph (int) throw ();
extern int isprint (int) throw ();
extern int ispunct (int) throw ();
extern int isspace (int) throw ();
extern int isupper (int) throw ();
extern int isxdigit (int) throw ();



extern int tolower (int __c) throw ();


extern int toupper (int __c) throw ();
# 136 "/usr/include/ctype.h" 3 4
extern int isblank (int) throw ();






extern int isctype (int __c, int __mask) throw ();






extern int isascii (int __c) throw ();



extern int toascii (int __c) throw ();



extern int _toupper (int) throw ();
extern int _tolower (int) throw ();
# 271 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, __locale_t) throw ();
extern int isalpha_l (int, __locale_t) throw ();
extern int iscntrl_l (int, __locale_t) throw ();
extern int isdigit_l (int, __locale_t) throw ();
extern int islower_l (int, __locale_t) throw ();
extern int isgraph_l (int, __locale_t) throw ();
extern int isprint_l (int, __locale_t) throw ();
extern int ispunct_l (int, __locale_t) throw ();
extern int isspace_l (int, __locale_t) throw ();
extern int isupper_l (int, __locale_t) throw ();
extern int isxdigit_l (int, __locale_t) throw ();

extern int isblank_l (int, __locale_t) throw ();



extern int __tolower_l (int __c, __locale_t __l) throw ();
extern int tolower_l (int __c, __locale_t __l) throw ();


extern int __toupper_l (int __c, __locale_t __l) throw ();
extern int toupper_l (int __c, __locale_t __l) throw ();
# 347 "/usr/include/ctype.h" 3 4
}
# 43 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cctype" 2 3
# 62 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cctype" 3
namespace std
{
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
}







namespace std
{
  using ::isblank;
}
# 43 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/localefwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
# 55 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/localefwd.h" 3
  class locale;

  template<typename _Facet>
    bool
    has_facet(const locale&) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale&);


  template<typename _CharT>
    bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    bool
    isgraph(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;

  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;



  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;

  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;


  template<typename _CharT>
    class collate;
  template<typename _CharT> class
    collate_byname;


  class time_base;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;

  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;

  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;


  class messages_base;
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;


}
# 44 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/string" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/ostream_insert.h" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/ostream_insert.h" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/cxxabi_forced.h" 1 3
# 35 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/cxxabi_forced.h" 3

#pragma GCC visibility push(default)


namespace __cxxabiv1
{







  class __forced_unwind
  {
    virtual ~__forced_unwind() throw();


    virtual void __pure_dummy() = 0;
  };
}


#pragma GCC visibility pop
# 37 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/ostream_insert.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }




  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);


  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);




}
# 45 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/string" 2 3



# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_function.h" 1 3
# 59 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_function.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 100 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    struct unary_function
    {

      typedef _Arg argument_type;


      typedef _Result result_type;
    };




  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {

      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;


      typedef _Result result_type;
    };
# 139 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_function.h" 3
  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };
# 203 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_function.h" 3
  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };
# 267 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_function.h" 3
  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };




  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };
# 350 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_function.h" 3
  template<typename _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template<typename _Predicate>
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template<typename _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template<typename _Predicate>
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
# 421 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template<typename _Arg, typename _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template<typename _Arg1, typename _Arg2, typename _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template<typename _Tp>
    struct _Identity
    : public unary_function<_Tp,_Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };

  template<typename _Pair>
    struct _Select1st
    : public unary_function<_Pair, typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }


      template<typename _Pair2>
        typename _Pair2::first_type&
        operator()(_Pair2& __x) const
        { return __x.first; }

      template<typename _Pair2>
        const typename _Pair2::first_type&
        operator()(const _Pair2& __x) const
        { return __x.first; }

    };

  template<typename _Pair>
    struct _Select2nd
    : public unary_function<_Pair, typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
# 541 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_function.h" 3
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
  };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }




}



# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/backward/binders.h" 1 3
# 59 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/backward/binders.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 103 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/backward/binders.h" 3
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } ;


  template<typename _Operation, typename _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } ;


  template<typename _Operation, typename _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }



}
# 732 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_function.h" 2 3
# 49 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/string" 2 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/range_access.h" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/range_access.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{







  template<class _Container>
    inline auto
    begin(_Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<class _Container>
    inline auto
    begin(const _Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<class _Container>
    inline auto
    end(_Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }






  template<class _Container>
    inline auto
    end(const _Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }





  template<class _Tp, size_t _Nm>
    inline _Tp*
    begin(_Tp (&__arr)[_Nm])
    { return __arr; }






  template<class _Tp, size_t _Nm>
    inline _Tp*
    end(_Tp (&__arr)[_Nm])
    { return __arr + _Nm; }


}
# 52 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/string" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 1 3
# 38 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ext/atomicity.h" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ext/atomicity.h" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/gthr.h" 1 3
# 30 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/gthr.h" 3
#pragma GCC visibility push(default)
# 148 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/gthr.h" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/gthr-default.h" 1 3
# 35 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/gthr-default.h" 3
# 1 "/usr/include/pthread.h" 1 3 4
# 23 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/sched.h" 1 3 4
# 28 "/usr/include/sched.h" 3 4
# 1 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/stddef.h" 1 3 4
# 29 "/usr/include/sched.h" 2 3 4



# 1 "/usr/include/time.h" 1 3 4
# 33 "/usr/include/sched.h" 2 3 4








# 1 "/usr/include/x86_64-linux-gnu/bits/sched.h" 1 3 4
# 72 "/usr/include/x86_64-linux-gnu/bits/sched.h" 3 4
struct sched_param
  {
    int __sched_priority;
  };

extern "C" {



extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) throw ();


extern int unshare (int __flags) throw ();


extern int sched_getcpu (void) throw ();


extern int setns (int __fd, int __nstype) throw ();



}







struct __sched_param
  {
    int __sched_priority;
  };
# 118 "/usr/include/x86_64-linux-gnu/bits/sched.h" 3 4
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
# 201 "/usr/include/x86_64-linux-gnu/bits/sched.h" 3 4
extern "C" {

extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
  throw ();
extern cpu_set_t *__sched_cpualloc (size_t __count) throw () ;
extern void __sched_cpufree (cpu_set_t *__set) throw ();

}
# 42 "/usr/include/sched.h" 2 3 4




extern "C" {


extern int sched_setparam (__pid_t __pid, const struct sched_param *__param)
     throw ();


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) throw ();


extern int sched_setscheduler (__pid_t __pid, int __policy,
          const struct sched_param *__param) throw ();


extern int sched_getscheduler (__pid_t __pid) throw ();


extern int sched_yield (void) throw ();


extern int sched_get_priority_max (int __algorithm) throw ();


extern int sched_get_priority_min (int __algorithm) throw ();


extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) throw ();
# 116 "/usr/include/sched.h" 3 4
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         const cpu_set_t *__cpuset) throw ();


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) throw ();


}
# 24 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4
extern "C" {








# 1 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/stddef.h" 1 3 4
# 38 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 86 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timex.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/timex.h" 3 4
struct timex
{
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;
};
# 87 "/usr/include/x86_64-linux-gnu/bits/time.h" 2 3 4

extern "C" {


extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) throw ();

}
# 42 "/usr/include/time.h" 2 3 4
# 133 "/usr/include/time.h" 3 4
struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};
# 161 "/usr/include/time.h" 3 4
struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;
# 189 "/usr/include/time.h" 3 4
extern clock_t clock (void) throw ();


extern time_t time (time_t *__timer) throw ();


extern double difftime (time_t __time1, time_t __time0)
     throw () __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) throw ();





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) throw ();





extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     throw ();







extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     __locale_t __loc) throw ();



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    __locale_t __loc) throw ();






extern struct tm *gmtime (const time_t *__timer) throw ();



extern struct tm *localtime (const time_t *__timer) throw ();





extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) throw ();



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) throw ();





extern char *asctime (const struct tm *__tp) throw ();


extern char *ctime (const time_t *__timer) throw ();







extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) throw ();


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) throw ();




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) throw ();



extern int daylight;
extern long int timezone;





extern int stime (const time_t *__when) throw ();
# 319 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) throw ();


extern time_t timelocal (struct tm *__tp) throw ();


extern int dysize (int __year) throw () __attribute__ ((__const__));
# 334 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) throw ();


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) throw ();


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     throw ();






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) throw ();




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) throw ();


extern int timer_delete (timer_t __timerid) throw ();


extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) throw ();


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     throw ();


extern int timer_getoverrun (timer_t __timerid) throw ();





extern int timespec_get (struct timespec *__ts, int __base)
     throw () __attribute__ ((__nonnull__ (1)));
# 403 "/usr/include/time.h" 3 4
extern int getdate_err;
# 412 "/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
# 426 "/usr/include/time.h" 3 4
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);


}
# 25 "/usr/include/pthread.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 2 3 4




typedef long int __jmp_buf[8];
# 28 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/pthread.h" 2 3 4



enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};




enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
# 125 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
# 166 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
# 201 "/usr/include/pthread.h" 3 4
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
# 239 "/usr/include/pthread.h" 3 4
extern "C" {




extern int pthread_create (pthread_t *__restrict __newthread,
      const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) throw () __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);




extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) throw ();







extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     const struct timespec *__abstime);






extern int pthread_detach (pthread_t __th) throw ();



extern pthread_t pthread_self (void) throw () __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2)
  throw () __attribute__ ((__const__));







extern int pthread_attr_init (pthread_attr_t *__attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,
     int *__detachstate)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (const pthread_attr_t *__attr,
          size_t *__guardsize)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (const pthread_attr_t *__restrict __attr,
           struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           const struct sched_param *__restrict
           __param) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_attr_getaffinity_np (const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));


extern int pthread_getattr_default_np (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_setattr_default_np (const pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));




extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (2)));







extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      const struct sched_param *__param)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     throw ();




extern int pthread_getname_np (pthread_t __target_thread, char *__buf,
          size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int pthread_setname_np (pthread_t __target_thread, const char *__name)
     throw () __attribute__ ((__nonnull__ (2)));





extern int pthread_getconcurrency (void) throw ();


extern int pthread_setconcurrency (int __level) throw ();







extern int pthread_yield (void) throw ();




extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));
# 505 "/usr/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
# 517 "/usr/include/pthread.h" 3 4
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




typedef struct
{
  struct
  {
    __jmp_buf __cancel_jmp_buf;
    int __mask_was_saved;
  } __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
# 551 "/usr/include/pthread.h" 3 4
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};




class __pthread_cleanup_class
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;

 public:
  __pthread_cleanup_class (void (*__fct) (void *), void *__arg)
    : __cancel_routine (__fct), __cancel_arg (__arg), __do_it (1) { }
  ~__pthread_cleanup_class () { if (__do_it) __cancel_routine (__cancel_arg); }
  void __setdoit (int __newval) { __do_it = __newval; }
  void __defer () { pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED,
        &__cancel_type); }
  void __restore () const { pthread_setcanceltype (__cancel_type, 0); }
};
# 753 "/usr/include/pthread.h" 3 4
struct __jmp_buf_tag;
extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) throw ();





extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          const pthread_mutexattr_t *__mutexattr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        const struct timespec *__restrict
        __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_getprioceiling (const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     throw () __attribute__ ((__nonnull__ (1, 3)));




extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));
# 817 "/usr/include/pthread.h" 3 4
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getprotocol (const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getrobust (const pthread_mutexattr_t *__attr,
     int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern int pthread_mutexattr_getrobust_np (const pthread_mutexattr_t *__attr,
        int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
        int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));
# 899 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    const pthread_rwlockattr_t *__restrict
    __attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) throw () __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         const pthread_condattr_t *__restrict __cond_attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
# 1011 "/usr/include/pthread.h" 3 4
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_condattr_init (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     throw () __attribute__ ((__nonnull__ (1)));
# 1055 "/usr/include/pthread.h" 3 4
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
        int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));
# 1122 "/usr/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) throw ();


extern void *pthread_getspecific (pthread_key_t __key) throw ();


extern int pthread_setspecific (pthread_key_t __key,
    const void *__pointer) throw () ;




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     throw () __attribute__ ((__nonnull__ (2)));
# 1156 "/usr/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) throw ();
# 1170 "/usr/include/pthread.h" 3 4
}
# 36 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/gthr-default.h" 2 3
# 47 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/gthr-default.h" 3
typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;
# 101 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/gthr-default.h" 3
static __typeof(pthread_once) __gthrw_pthread_once __attribute__ ((__weakref__("pthread_once")));
static __typeof(pthread_getspecific) __gthrw_pthread_getspecific __attribute__ ((__weakref__("pthread_getspecific")));
static __typeof(pthread_setspecific) __gthrw_pthread_setspecific __attribute__ ((__weakref__("pthread_setspecific")));

static __typeof(pthread_create) __gthrw_pthread_create __attribute__ ((__weakref__("pthread_create")));
static __typeof(pthread_join) __gthrw_pthread_join __attribute__ ((__weakref__("pthread_join")));
static __typeof(pthread_equal) __gthrw_pthread_equal __attribute__ ((__weakref__("pthread_equal")));
static __typeof(pthread_self) __gthrw_pthread_self __attribute__ ((__weakref__("pthread_self")));
static __typeof(pthread_detach) __gthrw_pthread_detach __attribute__ ((__weakref__("pthread_detach")));

static __typeof(pthread_cancel) __gthrw_pthread_cancel __attribute__ ((__weakref__("pthread_cancel")));

static __typeof(sched_yield) __gthrw_sched_yield __attribute__ ((__weakref__("sched_yield")));

static __typeof(pthread_mutex_lock) __gthrw_pthread_mutex_lock __attribute__ ((__weakref__("pthread_mutex_lock")));
static __typeof(pthread_mutex_trylock) __gthrw_pthread_mutex_trylock __attribute__ ((__weakref__("pthread_mutex_trylock")));

static __typeof(pthread_mutex_timedlock) __gthrw_pthread_mutex_timedlock __attribute__ ((__weakref__("pthread_mutex_timedlock")));

static __typeof(pthread_mutex_unlock) __gthrw_pthread_mutex_unlock __attribute__ ((__weakref__("pthread_mutex_unlock")));
static __typeof(pthread_mutex_init) __gthrw_pthread_mutex_init __attribute__ ((__weakref__("pthread_mutex_init")));
static __typeof(pthread_mutex_destroy) __gthrw_pthread_mutex_destroy __attribute__ ((__weakref__("pthread_mutex_destroy")));

static __typeof(pthread_cond_init) __gthrw_pthread_cond_init __attribute__ ((__weakref__("pthread_cond_init")));
static __typeof(pthread_cond_broadcast) __gthrw_pthread_cond_broadcast __attribute__ ((__weakref__("pthread_cond_broadcast")));
static __typeof(pthread_cond_signal) __gthrw_pthread_cond_signal __attribute__ ((__weakref__("pthread_cond_signal")));
static __typeof(pthread_cond_wait) __gthrw_pthread_cond_wait __attribute__ ((__weakref__("pthread_cond_wait")));
static __typeof(pthread_cond_timedwait) __gthrw_pthread_cond_timedwait __attribute__ ((__weakref__("pthread_cond_timedwait")));
static __typeof(pthread_cond_destroy) __gthrw_pthread_cond_destroy __attribute__ ((__weakref__("pthread_cond_destroy")));

static __typeof(pthread_key_create) __gthrw_pthread_key_create __attribute__ ((__weakref__("pthread_key_create")));
static __typeof(pthread_key_delete) __gthrw_pthread_key_delete __attribute__ ((__weakref__("pthread_key_delete")));
static __typeof(pthread_mutexattr_init) __gthrw_pthread_mutexattr_init __attribute__ ((__weakref__("pthread_mutexattr_init")));
static __typeof(pthread_mutexattr_settype) __gthrw_pthread_mutexattr_settype __attribute__ ((__weakref__("pthread_mutexattr_settype")));
static __typeof(pthread_mutexattr_destroy) __gthrw_pthread_mutexattr_destroy __attribute__ ((__weakref__("pthread_mutexattr_destroy")));
# 236 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/gthr-default.h" 3
static __typeof(pthread_key_create) __gthrw___pthread_key_create __attribute__ ((__weakref__("__pthread_key_create")));
# 246 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{
  static void *const __gthread_active_ptr
    = __extension__ (void *) &__gthrw___pthread_key_create;
  return __gthread_active_ptr != 0;
}
# 658 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/gthr-default.h" 3
static inline int
__gthread_create (__gthread_t *__threadid, void *(*__func) (void*),
    void *__args)
{
  return __gthrw_pthread_create (__threadid, __null, __func, __args);
}

static inline int
__gthread_join (__gthread_t __threadid, void **__value_ptr)
{
  return __gthrw_pthread_join (__threadid, __value_ptr);
}

static inline int
__gthread_detach (__gthread_t __threadid)
{
  return __gthrw_pthread_detach (__threadid);
}

static inline int
__gthread_equal (__gthread_t __t1, __gthread_t __t2)
{
  return __gthrw_pthread_equal (__t1, __t2);
}

static inline __gthread_t
__gthread_self (void)
{
  return __gthrw_pthread_self ();
}

static inline int
__gthread_yield (void)
{
  return __gthrw_sched_yield ();
}

static inline int
__gthread_once (__gthread_once_t *__once, void (*__func) (void))
{
  if (__gthread_active_p ())
    return __gthrw_pthread_once (__once, __func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))
{
  return __gthrw_pthread_key_create (__key, __dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t __key)
{
  return __gthrw_pthread_key_delete (__key);
}

static inline void *
__gthread_getspecific (__gthread_key_t __key)
{
  return __gthrw_pthread_getspecific (__key);
}

static inline int
__gthread_setspecific (__gthread_key_t __key, const void *__ptr)
{
  return __gthrw_pthread_setspecific (__key, __ptr);
}

static inline void
__gthread_mutex_init_function (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    __gthrw_pthread_mutex_init (__mutex, __null);
}

static inline int
__gthread_mutex_destroy (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_destroy (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_lock (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_trylock (__mutex);
  else
    return 0;
}


static inline int
__gthread_mutex_timedlock (__gthread_mutex_t *__mutex,
      const __gthread_time_t *__abs_timeout)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_timedlock (__mutex, __abs_timeout);
  else
    return 0;
}


static inline int
__gthread_mutex_unlock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_unlock (__mutex);
  else
    return 0;
}
# 807 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/gthr-default.h" 3
static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_lock (__mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_trylock (__mutex);
}


static inline int
__gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *__mutex,
         const __gthread_time_t *__abs_timeout)
{
  return __gthread_mutex_timedlock (__mutex, __abs_timeout);
}


static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_unlock (__mutex);
}

static inline int
__gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_destroy (__mutex);
}
# 849 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/gthr-default.h" 3
static inline int
__gthread_cond_broadcast (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_broadcast (__cond);
}

static inline int
__gthread_cond_signal (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_signal (__cond);
}

static inline int
__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)
{
  return __gthrw_pthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
     const __gthread_time_t *__abs_timeout)
{
  return __gthrw_pthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_wait_recursive (__gthread_cond_t *__cond,
          __gthread_recursive_mutex_t *__mutex)
{
  return __gthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_destroy (__gthread_cond_t* __cond)
{
  return __gthrw_pthread_cond_destroy (__cond);
}
# 149 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/gthr.h" 2 3


#pragma GCC visibility pop
# 36 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ext/atomicity.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/atomic_word.h" 1 3
# 32 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/atomic_word.h" 3
typedef int _Atomic_word;
# 37 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ext/atomicity.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{







  static inline _Atomic_word
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, 4); }

  static inline void
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __atomic_fetch_add(__mem, __val, 4); }
# 64 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ext/atomicity.h" 3
  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  static inline void
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);



  }

  static inline void
  __attribute__ ((__unused__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      __atomic_add(__mem, __val);
    else
      __atomic_add_single(__mem, __val);



  }


}
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{
# 111 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;


    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Alloc allocator_type;
      typedef typename _CharT_alloc_type::size_type size_type;
      typedef typename _CharT_alloc_type::difference_type difference_type;
      typedef typename _CharT_alloc_type::reference reference;
      typedef typename _CharT_alloc_type::const_reference const_reference;
      typedef typename _CharT_alloc_type::pointer pointer;
      typedef typename _CharT_alloc_type::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                                                            const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;

    private:
# 148 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      struct _Rep_base
      {
 size_type _M_length;
 size_type _M_capacity;
 _Atomic_word _M_refcount;
      };

      struct _Rep : _Rep_base
      {

 typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;
# 173 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
 static const size_type _S_max_size;
 static const _CharT _S_terminal;



        static size_type _S_empty_rep_storage[];

        static _Rep&
        _S_empty_rep()
        {



   void* __p = reinterpret_cast<void*>(&_S_empty_rep_storage);
   return *reinterpret_cast<_Rep*>(__p);
 }

        bool
 _M_is_leaked() const
        { return this->_M_refcount < 0; }

        bool
 _M_is_shared() const
        { return this->_M_refcount > 0; }

        void
 _M_set_leaked()
        { this->_M_refcount = -1; }

        void
 _M_set_sharable()
        { this->_M_refcount = 0; }

 void
 _M_set_length_and_sharable(size_type __n)
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     {
       this->_M_set_sharable();
       this->_M_length = __n;
       traits_type::assign(this->_M_refdata()[__n], _S_terminal);


     }
 }

 _CharT*
 _M_refdata() throw()
 { return reinterpret_cast<_CharT*>(this + 1); }

 _CharT*
 _M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)
 {
   return (!_M_is_leaked() && __alloc1 == __alloc2)
           ? _M_refcopy() : _M_clone(__alloc1);
 }


 static _Rep*
 _S_create(size_type, size_type, const _Alloc&);

 void
 _M_dispose(const _Alloc& __a)
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     {

                                                                  ;
       if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
        -1) <= 0)
  {
                                                              ;
    _M_destroy(__a);
  }
     }
 }

 void
 _M_destroy(const _Alloc&) throw();

 _CharT*
 _M_refcopy() throw()
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
   return _M_refdata();
 }

 _CharT*
 _M_clone(const _Alloc&, size_type __res = 0);
      };


      struct _Alloc_hider : _Alloc
      {
 _Alloc_hider(_CharT* __dat, const _Alloc& __a)
 : _Alloc(__a), _M_p(__dat) { }

 _CharT* _M_p;
      };

    public:




      static const size_type npos = static_cast<size_type>(-1);

    private:

      mutable _Alloc_hider _M_dataplus;

      _CharT*
      _M_data() const
      { return _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p)
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }



      iterator
      _M_ibegin() const
      { return iterator(_M_data()); }

      iterator
      _M_iend() const
      { return iterator(_M_data() + this->size()); }

      void
      _M_leak()
      {
 if (!_M_rep()->_M_is_leaked())
   _M_leak_hard();
      }

      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range((__s));
 return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }


      size_type
      _M_limit(size_type __pos, size_type __off) const
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }


      bool
      _M_disjunct(const _CharT* __s) const
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }



      static void
      _M_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }

      static void
      _M_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }

      static void
      _M_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, ++__p)
     traits_type::assign(*__p, *__k1);
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2)
      {
 const difference_type __d = difference_type(__n1 - __n2);

 if (__d > __gnu_cxx::__numeric_traits<int>::__max)
   return __gnu_cxx::__numeric_traits<int>::__max;
 else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
   return __gnu_cxx::__numeric_traits<int>::__min;
 else
   return int(__d);
      }

      void
      _M_mutate(size_type __pos, size_type __len1, size_type __len2);

      void
      _M_leak_hard();

      static _Rep&
      _S_empty_rep()
      { return _Rep::_S_empty_rep(); }

    public:







      basic_string()

      : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }







      explicit
      basic_string(const _Alloc& __a);






      basic_string(const basic_string& __str);






      basic_string(const basic_string& __str, size_type __pos,
     size_type __n = npos);







      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a);
# 483 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc());





      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());






      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());
# 507 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      basic_string(basic_string&& __str) noexcept
      : _M_dataplus(__str._M_dataplus)
      {

 __str._M_data(_S_empty_rep()._M_refdata());



      }






      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc());
# 531 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc());




      ~basic_string() noexcept
      { _M_rep()->_M_dispose(this->get_allocator()); }





      basic_string&
      operator=(const basic_string& __str)
      { return this->assign(__str); }





      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
# 564 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }
# 579 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      operator=(basic_string&& __str)
      {

 this->swap(__str);
 return *this;
      }





      basic_string&
      operator=(initializer_list<_CharT> __l)
      {
 this->assign(__l.begin(), __l.size());
 return *this;
      }







      iterator
      begin() noexcept
      {
 _M_leak();
 return iterator(_M_data());
      }





      const_iterator
      begin() const noexcept
      { return const_iterator(_M_data()); }





      iterator
      end() noexcept
      {
 _M_leak();
 return iterator(_M_data() + this->size());
      }





      const_iterator
      end() const noexcept
      { return const_iterator(_M_data() + this->size()); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(this->end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(this->begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(this->begin()); }






      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_data()); }





      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_data() + this->size()); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(this->begin()); }


    public:



      size_type
      size() const noexcept
      { return _M_rep()->_M_length; }



      size_type
      length() const noexcept
      { return _M_rep()->_M_length; }


      size_type
      max_size() const noexcept
      { return _Rep::_S_max_size; }
# 739 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      void
      resize(size_type __n, _CharT __c);
# 752 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }



      void
      shrink_to_fit()
      {
 if (capacity() > size())
   {
     try
       { reserve(0); }
     catch(...)
       { }
   }
      }






      size_type
      capacity() const noexcept
      { return _M_rep()->_M_capacity; }
# 796 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      void
      reserve(size_type __res_arg = 0);




      void
      clear() noexcept
      { _M_mutate(0, this->size(), 0); }





      bool
      empty() const noexcept
      { return this->size() == 0; }
# 825 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      const_reference
      operator[] (size_type __pos) const
      {
                                       ;
 return _M_data()[__pos];
      }
# 842 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      reference
      operator[](size_type __pos)
      {

                                       ;

                                         ;
 _M_leak();
 return _M_data()[__pos];
      }
# 863 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("basic_string::at"));
 return _M_data()[__n];
      }
# 882 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range(("basic_string::at"));
 _M_leak();
 return _M_data()[__n];
      }






      reference
      front()
      { return operator[](0); }





      const_reference
      front() const
      { return operator[](0); }





      reference
      back()
      { return operator[](this->size() - 1); }





      const_reference
      back() const
      { return operator[](this->size() - 1); }
# 931 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }






      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }






      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }







      basic_string&
      operator+=(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }







      basic_string&
      append(const basic_string& __str);
# 988 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n);







      basic_string&
      append(const _CharT* __s, size_type __n);






      basic_string&
      append(const _CharT* __s)
      {
                               ;
 return this->append(__s, traits_type::length(__s));
      }
# 1020 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      append(size_type __n, _CharT __c);







      basic_string&
      append(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }
# 1042 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_iend(), _M_iend(), __first, __last); }





      void
      push_back(_CharT __c)
      {
 const size_type __len = 1 + this->size();
 if (__len > this->capacity() || _M_rep()->_M_is_shared())
   this->reserve(__len);
 traits_type::assign(_M_data()[this->size()], __c);
 _M_rep()->_M_set_length_and_sharable(__len);
      }






      basic_string&
      assign(const basic_string& __str);
# 1078 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      assign(basic_string&& __str)
      {
 this->swap(__str);
 return *this;
      }
# 1099 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n)
      { return this->assign(__str._M_data()
       + __str._M_check(__pos, "basic_string::assign"),
       __str._M_limit(__pos, __n)); }
# 1115 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s, size_type __n);
# 1127 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s)
      {
                               ;
 return this->assign(__s, traits_type::length(__s));
      }
# 1143 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
# 1155 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }







      basic_string&
      assign(initializer_list<_CharT> __l)
      { return this->assign(__l.begin(), __l.size()); }
# 1184 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      void
      insert(iterator __p, size_type __n, _CharT __c)
      { this->replace(__p, __p, __n, __c); }
# 1200 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      template<class _InputIterator>
        void
        insert(iterator __p, _InputIterator __beg, _InputIterator __end)
        { this->replace(__p, __p, __beg, __end); }
# 1212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      void
      insert(iterator __p, initializer_list<_CharT> __l)
      {
                                                                 ;
 this->insert(__p - _M_ibegin(), __l.begin(), __l.size());
      }
# 1232 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->insert(__pos1, __str, size_type(0), __str.size()); }
# 1254 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n)
      { return this->insert(__pos1, __str._M_data()
       + __str._M_check(__pos2, "basic_string::insert"),
       __str._M_limit(__pos2, __n)); }
# 1277 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n);
# 1295 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
                               ;
 return this->insert(__pos, __s, traits_type::length(__s));
      }
# 1318 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
# 1336 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      iterator
      insert(iterator __p, _CharT __c)
      {
                                                                 ;
 const size_type __pos = __p - _M_ibegin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
# 1361 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 _M_mutate(_M_check(__pos, "basic_string::erase"),
    _M_limit(__pos, __n), size_type(0));
 return *this;
      }
# 1377 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      iterator
      erase(iterator __position)
      {

                               ;
 const size_type __pos = __position - _M_ibegin();
 _M_mutate(__pos, size_type(1), size_type(0));
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
# 1397 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      iterator
      erase(iterator __first, iterator __last);







      void
      pop_back()
      { erase(size()-1, 1); }
# 1428 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
# 1450 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
# 1475 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2);
# 1495 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
                               ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
# 1519 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
# 1537 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
# 1556 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)
      {

                          ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);
      }
# 1577 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s)
      {
                               ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
# 1598 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)
      {

                          ;
 return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);
      }
# 1621 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        replace(iterator __i1, iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {

                            ;
                                             ;
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
 }



      basic_string&
      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)
      {

                          ;
                                           ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {

                          ;
                                           ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)
      {

                          ;
                                           ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {

                          ;
                                           ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
# 1692 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      basic_string& replace(iterator __i1, iterator __i2,
       initializer_list<_CharT> __l)
      { return this->replace(__i1, __i2, __l.begin(), __l.end()); }


    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,
       _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
       _InputIterator __k2, __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);

      basic_string&
      _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
        size_type __n2);



      template<class _InIterator>
        static _CharT*
        _S_construct_aux(_InIterator __beg, _InIterator __end,
    const _Alloc& __a, __false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          return _S_construct(__beg, __end, __a, _Tag());
 }



      template<class _Integer>
        static _CharT*
        _S_construct_aux(_Integer __beg, _Integer __end,
    const _Alloc& __a, __true_type)
        { return _S_construct_aux_2(static_cast<size_type>(__beg),
        __end, __a); }

      static _CharT*
      _S_construct_aux_2(size_type __req, _CharT __c, const _Alloc& __a)
      { return _S_construct(__req, __c, __a); }

      template<class _InIterator>
        static _CharT*
        _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   return _S_construct_aux(__beg, __end, __a, _Integral());
        }


      template<class _InIterator>
        static _CharT*
         _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
        input_iterator_tag);



      template<class _FwdIterator>
        static _CharT*
        _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc& __a,
       forward_iterator_tag);

      static _CharT*
      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);

    public:
# 1779 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
# 1789 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      void
      swap(basic_string& __s);
# 1799 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      const _CharT*
      c_str() const noexcept
      { return _M_data(); }







      const _CharT*
      data() const noexcept
      { return _M_data(); }




      allocator_type
      get_allocator() const noexcept
      { return _M_dataplus; }
# 1832 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const;
# 1845 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
 noexcept
      { return this->find(__str.data(), __pos, __str.size()); }
# 1860 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos = 0) const
      {
                               ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
# 1877 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      size_type
      find(_CharT __c, size_type __pos = 0) const noexcept;
# 1890 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
 noexcept
      { return this->rfind(__str.data(), __pos, __str.size()); }
# 1907 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const;
# 1920 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
                               ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
# 1937 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      size_type
      rfind(_CharT __c, size_type __pos = npos) const noexcept;
# 1951 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
 noexcept
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
# 1968 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 1981 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      {
                               ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
# 2000 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const noexcept
      { return this->find(__c, __pos); }
# 2015 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
 noexcept
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
# 2032 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 2045 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      {
                               ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
# 2064 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const noexcept
      { return this->rfind(__c, __pos); }
# 2078 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
 noexcept
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
# 2095 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const;
# 2109 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      {
                               ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
# 2126 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const
 noexcept;
# 2141 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
 noexcept
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
# 2158 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const;
# 2172 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      {
                               ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
# 2189 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const
 noexcept;
# 2205 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
# 2224 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }
# 2256 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
# 2282 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2) const;
# 2300 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      int
      compare(const _CharT* __s) const;
# 2324 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
# 2351 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;
  };
# 2363 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
      const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    {
      const auto __size = __lhs.size() + __rhs.size();
      const bool __cond = (__size > __lhs.capacity()
      && __size <= __rhs.capacity());
      return __cond ? std::move(__rhs.insert(0, __lhs))
             : std::move(__lhs.append(__rhs));
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, 1, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const _CharT* __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       _CharT __rhs)
    { return std::move(__lhs.append(1, __rhs)); }
# 2484 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT>
    inline
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
        const basic_string<_CharT>& __rhs)
    { return (__lhs.size() == __rhs.size()
       && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
          __lhs.size())); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
# 2530 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return !(__lhs == __rhs); }
# 2567 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
# 2604 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
# 2641 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
# 2678 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
# 2715 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { __lhs.swap(__rhs); }
# 2733 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
# 2751 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {


      return __ostream_insert(__os, __str.data(), __str.size());
    }
# 2774 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
# 2791 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return getline(__is, __str, __is.widen('\n')); }

  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);


  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);



}





# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ext/string_conversions.h" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ext/string_conversions.h" 3








# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstdlib" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstdlib" 3
# 42 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ext/string_conversions.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cwchar" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cwchar" 3




# 1 "/usr/include/wchar.h" 1 3 4
# 45 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cwchar" 2 3
# 43 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ext/string_conversions.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstdio" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstdio" 3
# 44 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ext/string_conversions.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cerrno" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cerrno" 3

# 1 "/usr/include/errno.h" 1 3 4
# 31 "/usr/include/errno.h" 3 4
extern "C" {




# 1 "/usr/include/x86_64-linux-gnu/bits/errno.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4



# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 5 "/usr/include/asm-generic/errno.h" 2 3 4
# 2 "/usr/include/x86_64-linux-gnu/asm/errno.h" 2 3 4
# 2 "/usr/include/linux/errno.h" 2 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/errno.h" 2 3 4
# 50 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
extern int *__errno_location (void) throw () __attribute__ ((__const__));
# 36 "/usr/include/errno.h" 2 3 4
# 54 "/usr/include/errno.h" 3 4
extern char *program_invocation_name, *program_invocation_short_name;



}
# 68 "/usr/include/errno.h" 3 4
typedef int error_t;
# 42 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cerrno" 2 3
# 45 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ext/string_conversions.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<typename _TRet, typename _Ret = _TRet, typename _CharT,
    typename... _Base>
    _Ret
    __stoa(_TRet (*__convf) (const _CharT*, _CharT**, _Base...),
    const char* __name, const _CharT* __str, std::size_t* __idx,
    _Base... __base)
    {
      _Ret __ret;

      _CharT* __endptr;
      (*__errno_location ()) = 0;
      const _TRet __tmp = __convf(__str, &__endptr, __base...);

      if (__endptr == __str)
 std::__throw_invalid_argument(__name);
      else if ((*__errno_location ()) == 34
        || (std::__are_same<_Ret, int>::__value
     && (__tmp < __numeric_traits<int>::__min
         || __tmp > __numeric_traits<int>::__max)))
 std::__throw_out_of_range(__name);
      else
 __ret = __tmp;

      if (__idx)
 *__idx = __endptr - __str;

      return __ret;
    }


  template<typename _String, typename _CharT = typename _String::value_type>
    _String
    __to_xstring(int (*__convf) (_CharT*, std::size_t, const _CharT*,
     __builtin_va_list), std::size_t __n,
   const _CharT* __fmt, ...)
    {


      _CharT* __s = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
         * __n));

      __builtin_va_list __args;
      __builtin_va_start(__args, __fmt);

      const int __len = __convf(__s, __n, __fmt, __args);

      __builtin_va_end(__args);

      return _String(__s, __s + __len);
    }


}
# 2816 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  inline int
  stoi(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::strtol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx); }




  inline string
  to_string(int __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(int),
        "%d", __val); }

  inline string
  to_string(unsigned __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned),
        "%u", __val); }

  inline string
  to_string(long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(long),
        "%ld", __val); }

  inline string
  to_string(unsigned long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned long),
        "%lu", __val); }

  inline string
  to_string(long long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(long long),
        "%lld", __val); }

  inline string
  to_string(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned long long),
        "%llu", __val); }

  inline string
  to_string(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%Lf", __val);
  }


  inline int
  stoi(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::wcstol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx); }


  inline wstring
  to_wstring(int __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(int),
         L"%d", __val); }

  inline wstring
  to_wstring(unsigned __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned),
         L"%u", __val); }

  inline wstring
  to_wstring(long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(long),
         L"%ld", __val); }

  inline wstring
  to_wstring(unsigned long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long),
         L"%lu", __val); }

  inline wstring
  to_wstring(long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(long long),
         L"%lld", __val); }

  inline wstring
  to_wstring(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long long),
         L"%llu", __val); }

  inline wstring
  to_wstring(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%Lf", __val);
  }



}






# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/functional_hash.h" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/functional_hash.h" 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/hash_bytes.h" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/hash_bytes.h" 3



namespace std
{







  size_t
  _Hash_bytes(const void* __ptr, size_t __len, size_t __seed);





  size_t
  _Fnv_hash_bytes(const void* __ptr, size_t __len, size_t __seed);


}
# 36 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/functional_hash.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
# 49 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/functional_hash.h" 3
  template<typename _Result, typename _Arg>
    struct __hash_base
    {
      typedef _Result result_type;
      typedef _Arg argument_type;
    };


  template<typename _Tp>
    struct hash;


  template<typename _Tp>
    struct hash<_Tp*> : public __hash_base<size_t, _Tp*>
    {
      size_t
      operator()(_Tp* __p) const noexcept
      { return reinterpret_cast<size_t>(__p); }
    };
# 80 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/functional_hash.h" 3
  template<> struct hash<bool> : public __hash_base<size_t, bool> { size_t operator()(bool __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char> : public __hash_base<size_t, char> { size_t operator()(char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<signed char> : public __hash_base<size_t, signed char> { size_t operator()(signed char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned char> : public __hash_base<size_t, unsigned char> { size_t operator()(unsigned char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<wchar_t> : public __hash_base<size_t, wchar_t> { size_t operator()(wchar_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char16_t> : public __hash_base<size_t, char16_t> { size_t operator()(char16_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char32_t> : public __hash_base<size_t, char32_t> { size_t operator()(char32_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<short> : public __hash_base<size_t, short> { size_t operator()(short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<int> : public __hash_base<size_t, int> { size_t operator()(int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long> : public __hash_base<size_t, long> { size_t operator()(long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long long> : public __hash_base<size_t, long long> { size_t operator()(long long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned short> : public __hash_base<size_t, unsigned short> { size_t operator()(unsigned short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned int> : public __hash_base<size_t, unsigned int> { size_t operator()(unsigned int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long> : public __hash_base<size_t, unsigned long> { size_t operator()(unsigned long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long long> : public __hash_base<size_t, unsigned long long> { size_t operator()(unsigned long long __val) const noexcept { return static_cast<size_t>(__val); } };



  struct _Hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(0xc70f6907UL))
    { return _Hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };

  struct _Fnv_hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(2166136261UL))
    { return _Fnv_hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };


  template<>
    struct hash<float> : public __hash_base<size_t, float>
    {
      size_t
      operator()(float __val) const noexcept
      {

 return __val != 0.0f ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<double> : public __hash_base<size_t, double>
    {
      size_t
      operator()(double __val) const noexcept
      {

 return __val != 0.0 ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<long double>
    : public __hash_base<size_t, long double>
    {
      __attribute__ ((__pure__)) size_t
      operator()(long double __val) const noexcept;
    };







  template<typename _Hash>
    struct __is_fast_hash : public std::true_type
    { };

  template<>
    struct __is_fast_hash<hash<long double>> : public std::false_type
    { };


}
# 3034 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{






  template<>
    struct hash<string>
    : public __hash_base<size_t, string>
    {
      size_t
      operator()(const string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(), __s.length()); }
    };

  template<>
    struct __is_fast_hash<hash<string>> : std::false_type
    { };



  template<>
    struct hash<wstring>
    : public __hash_base<size_t, wstring>
    {
      size_t
      operator()(const wstring& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(wchar_t)); }
    };

  template<>
    struct __is_fast_hash<hash<wstring>> : std::false_type
    { };





  template<>
    struct hash<u16string>
    : public __hash_base<size_t, u16string>
    {
      size_t
      operator()(const u16string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char16_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u16string>> : std::false_type
    { };


  template<>
    struct hash<u32string>
    : public __hash_base<size_t, u32string>
    {
      size_t
      operator()(const u32string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char32_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u32string>> : std::false_type
    { };



}
# 53 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/string" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.tcc" 1 3
# 41 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_max_size = (((npos - sizeof(_Rep_base))/sizeof(_CharT)) - 1) / 4;

  template<typename _CharT, typename _Traits, typename _Alloc>
    const _CharT
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_terminal = _CharT();

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;



  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage[
    (sizeof(_Rep_base) + sizeof(_CharT) + sizeof(size_type) - 1) /
      sizeof(size_type)];





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     input_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 _CharT __buf[128];
 size_type __len = 0;
 while (__beg != __end && __len < sizeof(__buf) / sizeof(_CharT))
   {
     __buf[__len++] = *__beg;
     ++__beg;
   }
 _Rep* __r = _Rep::_S_create(__len, size_type(0), __a);
 _M_copy(__r->_M_refdata(), __buf, __len);
 try
   {
     while (__beg != __end)
       {
  if (__len == __r->_M_capacity)
    {

      _Rep* __another = _Rep::_S_create(__len + 1, __len, __a);
      _M_copy(__another->_M_refdata(), __r->_M_refdata(), __len);
      __r->_M_destroy(__a);
      __r = __another;
    }
  __r->_M_refdata()[__len++] = *__beg;
  ++__beg;
       }
   }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__len);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template <typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     forward_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
   __throw_logic_error(("basic_string::_S_construct null not valid"));

 const size_type __dnew = static_cast<size_type>(std::distance(__beg,
              __end));

 _Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);
 try
   { _S_copy_chars(__r->_M_refdata(), __beg, __end); }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__dnew);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::
    _S_construct(size_type __n, _CharT __c, const _Alloc& __a)
    {

      if (__n == 0 && __a == _Alloc())
 return _S_empty_rep()._M_refdata();


      _Rep* __r = _Rep::_S_create(__n, size_type(0), __a);
      if (__n)
 _M_assign(__r->_M_refdata(), __n, __c);

      __r->_M_set_length_and_sharable(__n);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str)
    : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(__str.get_allocator()),
       __str.get_allocator()),
    __str.get_allocator())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _Alloc& __a)
    : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos, size_type __n)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, _Alloc()), _Alloc())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos,
   size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) :
          __s + npos, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(size_type __n, _CharT __c, const _Alloc& __a)
    : _M_dataplus(_S_construct(__n, __c, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc& __a)
    : _M_dataplus(_S_construct(__beg, __end, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(initializer_list<_CharT> __l, const _Alloc& __a)
    : _M_dataplus(_S_construct(__l.begin(), __l.end(), __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const basic_string& __str)
    {
      if (_M_rep() != __str._M_rep())
 {

   const allocator_type __a = this->get_allocator();
   _CharT* __tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const _CharT* __s, size_type __n)
    {
                                             ;
      _M_check_length(this->size(), __n, "basic_string::assign");
      if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
 return _M_replace_safe(size_type(0), this->size(), __s, __n);
      else
 {

   const size_type __pos = __s - _M_data();
   if (__pos >= __n)
     _M_copy(_M_data(), __s, __n);
   else if (__pos)
     _M_move(_M_data(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__n);
   return *this;
 }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(size_type __n, _CharT __c)
    {
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_assign(_M_data() + this->size(), __n, __c);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const _CharT* __s, size_type __n)
    {
                                             ;
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     {
       if (_M_disjunct(__s))
  this->reserve(__len);
       else
  {
    const size_type __off = __s - _M_data();
    this->reserve(__len);
    __s = _M_data() + __off;
  }
     }
   _M_copy(_M_data() + this->size(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str)
    {
      const size_type __size = __str.size();
      if (__size)
 {
   const size_type __len = __size + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data(), __size);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str, size_type __pos, size_type __n)
    {
      __str._M_check(__pos, "basic_string::append");
      __n = __str._M_limit(__pos, __n);
      if (__n)
 {
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data() + __pos, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     insert(size_type __pos, const _CharT* __s, size_type __n)
     {
                                              ;
       _M_check(__pos, "basic_string::insert");
       _M_check_length(size_type(0), __n, "basic_string::insert");
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, size_type(0), __s, __n);
       else
         {

           const size_type __off = __s - _M_data();
           _M_mutate(__pos, 0, __n);
           __s = _M_data() + __off;
           _CharT* __p = _M_data() + __pos;
           if (__s + __n <= __p)
             _M_copy(__p, __s, __n);
           else if (__s >= __p)
             _M_copy(__p, __s + __n, __n);
           else
             {
        const size_type __nleft = __p - __s;
               _M_copy(__p, __s, __nleft);
               _M_copy(__p + __nleft, __p + __n, __n - __nleft);
             }
           return *this;
         }
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     typename basic_string<_CharT, _Traits, _Alloc>::iterator
     basic_string<_CharT, _Traits, _Alloc>::
     erase(iterator __first, iterator __last)
     {

                           ;




       const size_type __size = __last - __first;
       if (__size)
  {
    const size_type __pos = __first - _M_ibegin();
    _M_mutate(__pos, __size, size_type(0));
    _M_rep()->_M_set_leaked();
    return iterator(_M_data() + __pos);
  }
       else
  return __first;
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     replace(size_type __pos, size_type __n1, const _CharT* __s,
      size_type __n2)
     {
                                               ;
       _M_check(__pos, "basic_string::replace");
       __n1 = _M_limit(__pos, __n1);
       _M_check_length(__n1, __n2, "basic_string::replace");
       bool __left;
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, __n1, __s, __n2);
       else if ((__left = __s + __n2 <= _M_data() + __pos)
  || _M_data() + __pos + __n1 <= __s)
  {

    size_type __off = __s - _M_data();
    __left ? __off : (__off += __n2 - __n1);
    _M_mutate(__pos, __n1, __n2);
    _M_copy(_M_data() + __pos, _M_data() + __off, __n2);
    return *this;
  }
       else
  {

    const basic_string __tmp(__s, __n2);
    return _M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);
  }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_destroy(const _Alloc& __a) throw ()
    {
      const size_type __size = sizeof(_Rep_base) +
                        (this->_M_capacity + 1) * sizeof(_CharT);
      _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char*>(this), __size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_leak_hard()
    {

      if (_M_rep() == &_S_empty_rep())
 return;

      if (_M_rep()->_M_is_shared())
 _M_mutate(0, 0, 0);
      _M_rep()->_M_set_leaked();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, size_type __len2)
    {
      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;
      const size_type __how_much = __old_size - __pos - __len1;

      if (__new_size > this->capacity() || _M_rep()->_M_is_shared())
 {

   const allocator_type __a = get_allocator();
   _Rep* __r = _Rep::_S_create(__new_size, this->capacity(), __a);

   if (__pos)
     _M_copy(__r->_M_refdata(), _M_data(), __pos);
   if (__how_much)
     _M_copy(__r->_M_refdata() + __pos + __len2,
      _M_data() + __pos + __len1, __how_much);

   _M_rep()->_M_dispose(__a);
   _M_data(__r->_M_refdata());
 }
      else if (__how_much && __len1 != __len2)
 {

   _M_move(_M_data() + __pos + __len2,
    _M_data() + __pos + __len1, __how_much);
 }
      _M_rep()->_M_set_length_and_sharable(__new_size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {
      if (__res != this->capacity() || _M_rep()->_M_is_shared())
        {

   if (__res < this->size())
     __res = this->size();
   const allocator_type __a = get_allocator();
   _CharT* __tmp = _M_rep()->_M_clone(__a, __res - this->size());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
        }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s)
    {
      if (_M_rep()->_M_is_leaked())
 _M_rep()->_M_set_sharable();
      if (__s._M_rep()->_M_is_leaked())
 __s._M_rep()->_M_set_sharable();
      if (this->get_allocator() == __s.get_allocator())
 {
   _CharT* __tmp = _M_data();
   _M_data(__s._M_data());
   __s._M_data(__tmp);
 }

      else
 {
   const basic_string __tmp1(_M_ibegin(), _M_iend(),
        __s.get_allocator());
   const basic_string __tmp2(__s._M_ibegin(), __s._M_iend(),
        this->get_allocator());
   *this = __tmp2;
   __s = __tmp1;
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::_Rep*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _S_create(size_type __capacity, size_type __old_capacity,
       const _Alloc& __alloc)
    {


      if (__capacity > _S_max_size)
 __throw_length_error(("basic_string::_S_create"));
# 577 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_string.tcc" 3
      const size_type __pagesize = 4096;
      const size_type __malloc_header_size = 4 * sizeof(void*);







      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 __capacity = 2 * __old_capacity;




      size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);

      const size_type __adj_size = __size + __malloc_header_size;
      if (__adj_size > __pagesize && __capacity > __old_capacity)
 {
   const size_type __extra = __pagesize - __adj_size % __pagesize;
   __capacity += __extra / sizeof(_CharT);

   if (__capacity > _S_max_size)
     __capacity = _S_max_size;
   __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
 }



      void* __place = _Raw_bytes_alloc(__alloc).allocate(__size);
      _Rep *__p = new (__place) _Rep;
      __p->_M_capacity = __capacity;







      __p->_M_set_sharable();
      return __p;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_clone(const _Alloc& __alloc, size_type __res)
    {

      const size_type __requested_cap = this->_M_length + __res;
      _Rep* __r = _Rep::_S_create(__requested_cap, this->_M_capacity,
      __alloc);
      if (this->_M_length)
 _M_copy(__r->_M_refdata(), _M_refdata(), this->_M_length);

      __r->_M_set_length_and_sharable(this->_M_length);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      _M_check_length(__size, __n, "basic_string::resize");
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->erase(__n);

    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
     _InputIterator __k2, __false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 _M_check_length(__n1, __s.size(), "basic_string::_M_replace_dispatch");
 return _M_replace_safe(__i1 - _M_ibegin(), __n1, __s._M_data(),
          __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_assign(_M_data() + __pos1, __n2, __c);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
      size_type __n2)
    {
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_copy(_M_data() + __pos1, __s, __n2);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
                                      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
                                             ;
      if (__n)
 _M_copy(__s, _M_data() + __pos, __n);

      return __n;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      const size_type __size = this->size();
      const _CharT* __data = _M_data();

      if (__n == 0)
 return __pos <= __size ? __pos : npos;

      if (__n <= __size)
 {
   for (; __pos <= __size - __n; ++__pos)
     if (traits_type::eq(__data[__pos], __s[0])
  && traits_type::compare(__data + __pos + 1,
     __s + 1, __n - 1) == 0)
       return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const noexcept
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const noexcept
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = _S_compare(__n, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const
    {
                                    ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = _S_compare(__size, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
                                    ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
                                              ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
      typedef ctype<_CharT> __ctype_type;
      typedef typename __ctype_type::ctype_base __ctype_base;

      __size_type __extracted = 0;
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(__ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   try
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __in.rdbuf()->sbumpc();
  }
       else
  __err |= __ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }




  extern template class basic_string<char>;
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);


  extern template class basic_string<wchar_t>;
  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);




}
# 54 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/string" 2 3
# 42 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/random" 2 3








# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/vector" 1 3
# 59 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/vector" 3




# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_uninitialized.h" 1 3
# 59 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_uninitialized.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<bool _TrivialValueTypes>
    struct __uninitialized_copy
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        {
   _ForwardIterator __cur = __result;
   try
     {
       for (; __first != __last; ++__first, ++__cur)
  std::_Construct(std::__addressof(*__cur), *__first);
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__result, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_copy<true>
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        { return std::copy(__first, __last, __result); }
    };
# 105 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType2;

      return std::__uninitialized_copy<(__is_trivial(_ValueType1)
     && __is_trivial(_ValueType2))>::
 __uninit_copy(__first, __last, __result);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        { std::fill(__first, __last, __x); }
    };
# 162 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
         const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_fill<__is_trivial(_ValueType)>::
 __uninit_fill(__first, __last, __x);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill_n
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static void
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill_n<true>
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static void
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        { std::fill_n(__first, __n, __x); }
    };
# 216 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline void
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_fill_n<__is_trivial(_ValueType)>::
 __uninit_fill_n(__first, __n, __x);
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __result;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __first != __last; ++__first, ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur, __alloc);
   throw;
 }
    }

  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, allocator<_Tp>&)
    { return std::uninitialized_copy(__first, __last, __result); }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a(std::make_move_iterator(__first),
      std::make_move_iterator(__last),
      __result, __alloc);
    }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_if_noexcept_a(_InputIterator __first,
           _InputIterator __last,
           _ForwardIterator __result,
           _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a
 (std::__make_move_if_noexcept_iterator(__first),
  std::__make_move_if_noexcept_iterator(__last), __result, __alloc);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
    void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
    inline void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Allocator>
    void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Tp2>
    inline void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill_n(__first, __n, __x); }
# 346 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_uninitialized.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_copy_move(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }





  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_copy(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,
         const _Tp& __x, _InputIterator __first,
         _InputIterator __last, _Allocator& __alloc)
    {
      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
      try
 {
   return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
    typename _Allocator>
    inline void
    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp& __x,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,
           __first2,
           __alloc);
      try
 {
   std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__first2, __mid2, __alloc);
   throw;
 }
    }





  template<bool _TrivialValueType>
    struct __uninitialized_default_1
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur));
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_1<true>
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
        {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;

   std::fill(__first, __last, _ValueType());
 }
    };

  template<bool _TrivialValueType>
    struct __uninitialized_default_n_1
    {
      template<typename _ForwardIterator, typename _Size>
        static void
        __uninit_default_n(_ForwardIterator __first, _Size __n)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, ++__cur)
  std::_Construct(std::__addressof(*__cur));
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_n_1<true>
    {
      template<typename _ForwardIterator, typename _Size>
        static void
        __uninit_default_n(_ForwardIterator __first, _Size __n)
        {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;

   std::fill_n(__first, __n, _ValueType());
 }
    };




  template<typename _ForwardIterator>
    inline void
    __uninitialized_default(_ForwardIterator __first,
       _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_default_1<__is_trivial(_ValueType)>::
 __uninit_default(__first, __last);
    }



  template<typename _ForwardIterator, typename _Size>
    inline void
    __uninitialized_default_n(_ForwardIterator __first, _Size __n)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_default_n_1<__is_trivial(_ValueType)>::
 __uninit_default_n(__first, __n);
    }





  template<typename _ForwardIterator, typename _Allocator>
    void
    __uninitialized_default_a(_ForwardIterator __first,
         _ForwardIterator __last,
         _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur));
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    __uninitialized_default_a(_ForwardIterator __first,
         _ForwardIterator __last,
         allocator<_Tp>&)
    { std::__uninitialized_default(__first, __last); }





  template<typename _ForwardIterator, typename _Size, typename _Allocator>
    void
    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,
    _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur));
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline void
    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,
    allocator<_Tp>&)
    { std::__uninitialized_default_n(__first, __n); }


  template<typename _InputIterator, typename _Size,
    typename _ForwardIterator>
    _ForwardIterator
    __uninitialized_copy_n(_InputIterator __first, _Size __n,
      _ForwardIterator __result, input_iterator_tag)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __n > 0; --__n, ++__first, ++__cur)
     std::_Construct(std::__addressof(*__cur), *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur);
   throw;
 }
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_n(_RandomAccessIterator __first, _Size __n,
      _ForwardIterator __result,
      random_access_iterator_tag)
    { return std::uninitialized_copy(__first, __first + __n, __result); }
# 645 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy_n(_InputIterator __first, _Size __n,
    _ForwardIterator __result)
    { return std::__uninitialized_copy_n(__first, __n, __result,
      std::__iterator_category(__first)); }



}
# 64 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/vector" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h" 1 3
# 66 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp, typename _Alloc>
    struct _Vector_base
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
        rebind<_Tp>::other _Tp_alloc_type;
      typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer
        pointer;

      struct _Vector_impl
      : public _Tp_alloc_type
      {
 pointer _M_start;
 pointer _M_finish;
 pointer _M_end_of_storage;

 _Vector_impl()
 : _Tp_alloc_type(), _M_start(0), _M_finish(0), _M_end_of_storage(0)
 { }

 _Vector_impl(_Tp_alloc_type const& __a)
 : _Tp_alloc_type(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)
 { }


 _Vector_impl(_Tp_alloc_type&& __a)
 : _Tp_alloc_type(std::move(__a)),
   _M_start(0), _M_finish(0), _M_end_of_storage(0)
 { }


 void _M_swap_data(_Vector_impl& __x)
 {
   std::swap(_M_start, __x._M_start);
   std::swap(_M_finish, __x._M_finish);
   std::swap(_M_end_of_storage, __x._M_end_of_storage);
 }
      };

    public:
      typedef _Alloc allocator_type;

      _Tp_alloc_type&
      _M_get_Tp_allocator() noexcept
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const noexcept
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Tp_allocator()); }

      _Vector_base()
      : _M_impl() { }

      _Vector_base(const allocator_type& __a)
      : _M_impl(__a) { }

      _Vector_base(size_t __n)
      : _M_impl()
      { _M_create_storage(__n); }

      _Vector_base(size_t __n, const allocator_type& __a)
      : _M_impl(__a)
      { _M_create_storage(__n); }


      _Vector_base(_Tp_alloc_type&& __a)
      : _M_impl(std::move(__a)) { }

      _Vector_base(_Vector_base&& __x)
      : _M_impl(std::move(__x._M_get_Tp_allocator()))
      { this->_M_impl._M_swap_data(__x._M_impl); }

      _Vector_base(_Vector_base&& __x, const allocator_type& __a)
      : _M_impl(__a)
      {
 if (__x.get_allocator() == __a)
   this->_M_impl._M_swap_data(__x._M_impl);
 else
   {
     size_t __n = __x._M_impl._M_finish - __x._M_impl._M_start;
     _M_create_storage(__n);
   }
      }


      ~_Vector_base()
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
        - this->_M_impl._M_start); }

    public:
      _Vector_impl _M_impl;

      pointer
      _M_allocate(size_t __n)
      { return __n != 0 ? _M_impl.allocate(__n) : 0; }

      void
      _M_deallocate(pointer __p, size_t __n)
      {
 if (__p)
   _M_impl.deallocate(__p, __n);
      }

    private:
      void
      _M_create_storage(size_t __n)
      {
 this->_M_impl._M_start = this->_M_allocate(__n);
 this->_M_impl._M_finish = this->_M_impl._M_start;
 this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }
    };
# 209 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;



      typedef _Vector_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Alloc_traits;

    public:
      typedef _Tp value_type;
      typedef typename _Base::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
      const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_M_impl;
      using _Base::_M_get_Tp_allocator;

    public:





      vector()
      : _Base() { }





      explicit
      vector(const allocator_type& __a)
      : _Base(__a) { }
# 268 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h" 3
      explicit
      vector(size_type __n, const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { _M_default_initialize(__n); }
# 281 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h" 3
      vector(size_type __n, const value_type& __value,
      const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { _M_fill_initialize(__n, __value); }
# 310 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h" 3
      vector(const vector& __x)
      : _Base(__x.size(),
        _Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
      { this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }
# 327 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h" 3
      vector(vector&& __x) noexcept
      : _Base(std::move(__x)) { }


      vector(const vector& __x, const allocator_type& __a)
      : _Base(__x.size(), __a)
      { this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }


      vector(vector&& __rv, const allocator_type& __m)
      : _Base(std::move(__rv), __m)
      {
 if (__rv.get_allocator() != __m)
   {
     this->_M_impl._M_finish =
       std::__uninitialized_move_a(__rv.begin(), __rv.end(),
       this->_M_impl._M_start,
       _M_get_Tp_allocator());
     __rv.clear();
   }
      }
# 364 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h" 3
      vector(initializer_list<value_type> __l,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 _M_range_initialize(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }
# 390 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
        { _M_initialize_dispatch(__first, __last, __false_type()); }
# 414 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h" 3
      ~vector() noexcept
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator()); }
# 426 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h" 3
      vector&
      operator=(const vector& __x);
# 438 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h" 3
      vector&
      operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
      {
        constexpr bool __move_storage =
          _Alloc_traits::_S_propagate_on_move_assign()
          || _Alloc_traits::_S_always_equal();
        _M_move_assign(std::move(__x),
                       integral_constant<bool, __move_storage>());
 return *this;
      }
# 460 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h" 3
      vector&
      operator=(initializer_list<value_type> __l)
      {
 this->assign(__l.begin(), __l.end());
 return *this;
      }
# 478 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 495 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        void
        assign(_InputIterator __first, _InputIterator __last)
        { _M_assign_dispatch(__first, __last, __false_type()); }
# 523 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h" 3
      void
      assign(initializer_list<value_type> __l)
      { this->assign(__l.begin(), __l.end()); }



      using _Base::get_allocator;







      iterator
      begin() noexcept
      { return iterator(this->_M_impl._M_start); }






      const_iterator
      begin() const noexcept
      { return const_iterator(this->_M_impl._M_start); }






      iterator
      end() noexcept
      { return iterator(this->_M_impl._M_finish); }






      const_iterator
      end() const noexcept
      { return const_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }







      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_impl._M_start); }






      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_impl._M_finish); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }




      size_type
      size() const noexcept
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }


      size_type
      max_size() const noexcept
      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }
# 663 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h" 3
      void
      resize(size_type __new_size)
      {
 if (__new_size > size())
   _M_default_append(__new_size - size());
 else if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
# 683 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h" 3
      void
      resize(size_type __new_size, const value_type& __x)
      {
 if (__new_size > size())
   insert(end(), __new_size - size(), __x);
 else if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
# 715 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h" 3
      void
      shrink_to_fit()
      { _M_shrink_to_fit(); }






      size_type
      capacity() const noexcept
      { return size_type(this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start); }





      bool
      empty() const noexcept
      { return begin() == end(); }
# 754 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h" 3
      void
      reserve(size_type __n);
# 769 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h" 3
      reference
      operator[](size_type __n)
      { return *(this->_M_impl._M_start + __n); }
# 784 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h" 3
      const_reference
      operator[](size_type __n) const
      { return *(this->_M_impl._M_start + __n); }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("vector::_M_range_check"));
      }

    public:
# 809 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 827 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front()
      { return *begin(); }





      const_reference
      front() const
      { return *begin(); }





      reference
      back()
      { return *(end() - 1); }





      const_reference
      back() const
      { return *(end() - 1); }
# 874 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h" 3
      _Tp*



      data() noexcept
      { return std::__addressof(front()); }


      const _Tp*



      data() const noexcept
      { return std::__addressof(front()); }
# 900 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                              __x);
     ++this->_M_impl._M_finish;
   }
 else

   _M_emplace_back_aux(__x);



      }


      void
      push_back(value_type&& __x)
      { emplace_back(std::move(__x)); }

      template<typename... _Args>
        void
        emplace_back(_Args&&... __args);
# 936 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h" 3
      void
      pop_back()
      {
 --this->_M_impl._M_finish;
 _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
      }
# 956 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h" 3
      template<typename... _Args>
        iterator
        emplace(iterator __position, _Args&&... __args);
# 972 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
# 987 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h" 3
      iterator
      insert(iterator __position, value_type&& __x)
      { return emplace(__position, std::move(__x)); }
# 1004 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h" 3
      void
      insert(iterator __position, initializer_list<value_type> __l)
      { this->insert(__position, __l.begin(), __l.end()); }
# 1022 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      { _M_fill_insert(__position, __n, __x); }
# 1041 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        { _M_insert_dispatch(__position, __first, __last, __false_type()); }
# 1074 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h" 3
      iterator
      erase(iterator __position);
# 1095 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h" 3
      iterator
      erase(iterator __first, iterator __last);
# 1107 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h" 3
      void
      swap(vector& __x)

   noexcept(_Alloc_traits::_S_nothrow_swap())

      {
 this->_M_impl._M_swap_data(__x._M_impl);
 _Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
                           __x._M_get_Tp_allocator());
      }







      void
      clear() noexcept
      { _M_erase_at_end(this->_M_impl._M_start); }

    protected:




      template<typename _ForwardIterator>
        pointer
        _M_allocate_and_copy(size_type __n,
        _ForwardIterator __first, _ForwardIterator __last)
        {
   pointer __result = this->_M_allocate(__n);
   try
     {
       std::__uninitialized_copy_a(__first, __last, __result,
       _M_get_Tp_allocator());
       return __result;
     }
   catch(...)
     {
       _M_deallocate(__result, __n);
       throw;
     }
 }
# 1159 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
        {
   this->_M_impl._M_start = _M_allocate(static_cast<size_type>(__n));
   this->_M_impl._M_end_of_storage =
     this->_M_impl._M_start + static_cast<size_type>(__n);
   _M_fill_initialize(static_cast<size_type>(__n), __value);
 }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first,
       _InputIterator __last, std::input_iterator_tag)
        {
   for (; __first != __last; ++__first)

     emplace_back(*__first);



 }


      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first,
       _ForwardIterator __last, std::forward_iterator_tag)
        {
   const size_type __n = std::distance(__first, __last);
   this->_M_impl._M_start = this->_M_allocate(__n);
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   this->_M_impl._M_finish =
     std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_start,
     _M_get_Tp_allocator());
 }



      void
      _M_fill_initialize(size_type __n, const value_type& __value)
      {
 std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
          _M_get_Tp_allocator());
 this->_M_impl._M_finish = this->_M_impl._M_end_of_storage;
      }



      void
      _M_default_initialize(size_type __n)
      {
 std::__uninitialized_default_n_a(this->_M_impl._M_start, __n,
      _M_get_Tp_allocator());
 this->_M_impl._M_finish = this->_M_impl._M_end_of_storage;
      }
# 1237 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_assign_aux(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag);



      void
      _M_fill_assign(size_type __n, const value_type& __val);
# 1277 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
      __true_type)
        { _M_fill_insert(__pos, __n, __val); }


      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos, _InputIterator __first,
      _InputIterator __last, __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_insert(__pos, __first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_insert(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_insert(iterator __pos, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);



      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);



      void
      _M_default_append(size_type __n);

      bool
      _M_shrink_to_fit();







      template<typename... _Args>
        void
        _M_insert_aux(iterator __position, _Args&&... __args);

      template<typename... _Args>
        void
        _M_emplace_back_aux(_Args&&... __args);



      size_type
      _M_check_len(size_type __n, const char* __s) const
      {
 if (max_size() - size() < __n)
   __throw_length_error((__s));

 const size_type __len = size() + std::max(size(), __n);
 return (__len < size() || __len > max_size()) ? max_size() : __len;
      }





      void
      _M_erase_at_end(pointer __pos)
      {
 std::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());
 this->_M_impl._M_finish = __pos;
      }


    private:



      void
      _M_move_assign(vector&& __x, std::true_type) noexcept
      {
 vector __tmp(get_allocator());
 this->_M_impl._M_swap_data(__tmp._M_impl);
 this->_M_impl._M_swap_data(__x._M_impl);
 if (_Alloc_traits::_S_propagate_on_move_assign())
   std::__alloc_on_move(_M_get_Tp_allocator(),
          __x._M_get_Tp_allocator());
      }



      void
      _M_move_assign(vector&& __x, std::false_type)
      {
 if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
   _M_move_assign(std::move(__x), std::true_type());
 else
   {


     this->assign(std::__make_move_if_noexcept_iterator(__x.begin()),
    std::__make_move_if_noexcept_iterator(__x.end()));
     __x.clear();
   }
      }

    };
# 1402 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return (__x.size() == __y.size()
       && std::equal(__x.begin(), __x.end(), __y.begin())); }
# 1419 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
    { __x.swap(__y); }


}
# 65 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/vector" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_bvector.h" 1 3
# 63 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_bvector.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef unsigned long _Bit_type;
  enum { _S_word_bit = int(8 * sizeof(_Bit_type)) };

  struct _Bit_reference
  {
    _Bit_type * _M_p;
    _Bit_type _M_mask;

    _Bit_reference(_Bit_type * __x, _Bit_type __y)
    : _M_p(__x), _M_mask(__y) { }

    _Bit_reference() noexcept : _M_p(0), _M_mask(0) { }

    operator bool() const noexcept
    { return !!(*_M_p & _M_mask); }

    _Bit_reference&
    operator=(bool __x) noexcept
    {
      if (__x)
 *_M_p |= _M_mask;
      else
 *_M_p &= ~_M_mask;
      return *this;
    }

    _Bit_reference&
    operator=(const _Bit_reference& __x) noexcept
    { return *this = bool(__x); }

    bool
    operator==(const _Bit_reference& __x) const
    { return bool(*this) == bool(__x); }

    bool
    operator<(const _Bit_reference& __x) const
    { return !bool(*this) && bool(__x); }

    void
    flip() noexcept
    { *_M_p ^= _M_mask; }
  };


  inline void
  swap(_Bit_reference __x, _Bit_reference __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }

  inline void
  swap(_Bit_reference __x, bool& __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }

  inline void
  swap(bool& __x, _Bit_reference __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }


  struct _Bit_iterator_base
  : public std::iterator<std::random_access_iterator_tag, bool>
  {
    _Bit_type * _M_p;
    unsigned int _M_offset;

    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
    : _M_p(__x), _M_offset(__y) { }

    void
    _M_bump_up()
    {
      if (_M_offset++ == int(_S_word_bit) - 1)
 {
   _M_offset = 0;
   ++_M_p;
 }
    }

    void
    _M_bump_down()
    {
      if (_M_offset-- == 0)
 {
   _M_offset = int(_S_word_bit) - 1;
   --_M_p;
 }
    }

    void
    _M_incr(ptrdiff_t __i)
    {
      difference_type __n = __i + _M_offset;
      _M_p += __n / int(_S_word_bit);
      __n = __n % int(_S_word_bit);
      if (__n < 0)
 {
   __n += int(_S_word_bit);
   --_M_p;
 }
      _M_offset = static_cast<unsigned int>(__n);
    }

    bool
    operator==(const _Bit_iterator_base& __i) const
    { return _M_p == __i._M_p && _M_offset == __i._M_offset; }

    bool
    operator<(const _Bit_iterator_base& __i) const
    {
      return _M_p < __i._M_p
      || (_M_p == __i._M_p && _M_offset < __i._M_offset);
    }

    bool
    operator!=(const _Bit_iterator_base& __i) const
    { return !(*this == __i); }

    bool
    operator>(const _Bit_iterator_base& __i) const
    { return __i < *this; }

    bool
    operator<=(const _Bit_iterator_base& __i) const
    { return !(__i < *this); }

    bool
    operator>=(const _Bit_iterator_base& __i) const
    { return !(*this < __i); }
  };

  inline ptrdiff_t
  operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
  {
    return (int(_S_word_bit) * (__x._M_p - __y._M_p)
     + __x._M_offset - __y._M_offset);
  }

  struct _Bit_iterator : public _Bit_iterator_base
  {
    typedef _Bit_reference reference;
    typedef _Bit_reference* pointer;
    typedef _Bit_iterator iterator;

    _Bit_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    reference
    operator*() const
    { return reference(_M_p, 1UL << _M_offset); }

    iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    iterator
    operator++(int)
    {
      iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    iterator
    operator--(int)
    {
      iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    iterator
    operator+(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp += __i;
    }

    iterator
    operator-(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp -= __i;
    }

    reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_iterator
  operator+(ptrdiff_t __n, const _Bit_iterator& __x)
  { return __x + __n; }

  struct _Bit_const_iterator : public _Bit_iterator_base
  {
    typedef bool reference;
    typedef bool const_reference;
    typedef const bool* pointer;
    typedef _Bit_const_iterator const_iterator;

    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    _Bit_const_iterator(const _Bit_iterator& __x)
    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }

    const_reference
    operator*() const
    { return _Bit_reference(_M_p, 1UL << _M_offset); }

    const_iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    const_iterator
    operator++(int)
    {
      const_iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    const_iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    const_iterator
    operator--(int)
    {
      const_iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    const_iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    const_iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    const_iterator
    operator+(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp += __i;
    }

    const_iterator
    operator-(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp -= __i;
    }

    const_reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_const_iterator
  operator+(ptrdiff_t __n, const _Bit_const_iterator& __x)
  { return __x + __n; }

  inline void
  __fill_bvector(_Bit_iterator __first, _Bit_iterator __last, bool __x)
  {
    for (; __first != __last; ++__first)
      *__first = __x;
  }

  inline void
  fill(_Bit_iterator __first, _Bit_iterator __last, const bool& __x)
  {
    if (__first._M_p != __last._M_p)
      {
 std::fill(__first._M_p + 1, __last._M_p, __x ? ~0 : 0);
 __fill_bvector(__first, _Bit_iterator(__first._M_p + 1, 0), __x);
 __fill_bvector(_Bit_iterator(__last._M_p, 0), __last, __x);
      }
    else
      __fill_bvector(__first, __last, __x);
  }

  template<typename _Alloc>
    struct _Bvector_base
    {
      typedef typename _Alloc::template rebind<_Bit_type>::other
        _Bit_alloc_type;

      struct _Bvector_impl
      : public _Bit_alloc_type
      {
 _Bit_iterator _M_start;
 _Bit_iterator _M_finish;
 _Bit_type* _M_end_of_storage;

 _Bvector_impl()
 : _Bit_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage(0)
 { }

 _Bvector_impl(const _Bit_alloc_type& __a)
 : _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage(0)
 { }


 _Bvector_impl(_Bit_alloc_type&& __a)
 : _Bit_alloc_type(std::move(__a)), _M_start(), _M_finish(),
   _M_end_of_storage(0)
 { }

      };

    public:
      typedef _Alloc allocator_type;

      _Bit_alloc_type&
      _M_get_Bit_allocator() noexcept
      { return *static_cast<_Bit_alloc_type*>(&this->_M_impl); }

      const _Bit_alloc_type&
      _M_get_Bit_allocator() const noexcept
      { return *static_cast<const _Bit_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Bit_allocator()); }

      _Bvector_base()
      : _M_impl() { }

      _Bvector_base(const allocator_type& __a)
      : _M_impl(__a) { }


      _Bvector_base(_Bvector_base&& __x) noexcept
      : _M_impl(std::move(__x._M_get_Bit_allocator()))
      {
 this->_M_impl._M_start = __x._M_impl._M_start;
 this->_M_impl._M_finish = __x._M_impl._M_finish;
 this->_M_impl._M_end_of_storage = __x._M_impl._M_end_of_storage;
 __x._M_impl._M_start = _Bit_iterator();
 __x._M_impl._M_finish = _Bit_iterator();
 __x._M_impl._M_end_of_storage = 0;
      }


      ~_Bvector_base()
      { this->_M_deallocate(); }

    protected:
      _Bvector_impl _M_impl;

      _Bit_type*
      _M_allocate(size_t __n)
      { return _M_impl.allocate(_S_nword(__n)); }

      void
      _M_deallocate()
      {
 if (_M_impl._M_start._M_p)
   _M_impl.deallocate(_M_impl._M_start._M_p,
        _M_impl._M_end_of_storage - _M_impl._M_start._M_p);
      }

      static size_t
      _S_nword(size_t __n)
      { return (__n + int(_S_word_bit) - 1) / int(_S_word_bit); }
    };


}




namespace std __attribute__ ((__visibility__ ("default")))
{
# 517 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_bvector.h" 3
template<typename _Alloc>
  class vector<bool, _Alloc> : protected _Bvector_base<_Alloc>
  {
    typedef _Bvector_base<_Alloc> _Base;


    template<typename> friend struct hash;


  public:
    typedef bool value_type;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Bit_reference reference;
    typedef bool const_reference;
    typedef _Bit_reference* pointer;
    typedef const bool* const_pointer;
    typedef _Bit_iterator iterator;
    typedef _Bit_const_iterator const_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef _Alloc allocator_type;

    allocator_type get_allocator() const
    { return _Base::get_allocator(); }

  protected:
    using _Base::_M_allocate;
    using _Base::_M_deallocate;
    using _Base::_S_nword;
    using _Base::_M_get_Bit_allocator;

  public:
    vector()
    : _Base() { }

    explicit
    vector(const allocator_type& __a)
    : _Base(__a) { }


    explicit
    vector(size_type __n, const allocator_type& __a = allocator_type())
    : vector(__n, false, __a)
    { }

    vector(size_type __n, const bool& __value,
    const allocator_type& __a = allocator_type())
    : _Base(__a)
    {
      _M_initialize(__n);
      std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_of_storage,
  __value ? ~0 : 0);
    }
# 583 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_bvector.h" 3
    vector(const vector& __x)
    : _Base(__x._M_get_Bit_allocator())
    {
      _M_initialize(__x.size());
      _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
    }


    vector(vector&& __x) noexcept
    : _Base(std::move(__x)) { }

    vector(initializer_list<bool> __l,
    const allocator_type& __a = allocator_type())
    : _Base(__a)
    {
      _M_initialize_range(__l.begin(), __l.end(),
     random_access_iterator_tag());
    }



    template<typename _InputIterator,
      typename = std::_RequireInputIter<_InputIterator>>
      vector(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      { _M_initialize_dispatch(__first, __last, __false_type()); }
# 621 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_bvector.h" 3
    ~vector() noexcept { }

    vector&
    operator=(const vector& __x)
    {
      if (&__x == this)
 return *this;
      if (__x.size() > capacity())
 {
   this->_M_deallocate();
   _M_initialize(__x.size());
 }
      this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
      begin());
      return *this;
    }


    vector&
    operator=(vector&& __x)
    {


      this->clear();
      this->swap(__x);
      return *this;
    }

    vector&
    operator=(initializer_list<bool> __l)
    {
      this->assign (__l.begin(), __l.end());
      return *this;
    }






    void
    assign(size_type __n, const bool& __x)
    { _M_fill_assign(__n, __x); }


    template<typename _InputIterator,
      typename = std::_RequireInputIter<_InputIterator>>
      void
      assign(_InputIterator __first, _InputIterator __last)
      { _M_assign_dispatch(__first, __last, __false_type()); }
# 682 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_bvector.h" 3
    void
    assign(initializer_list<bool> __l)
    { this->assign(__l.begin(), __l.end()); }


    iterator
    begin() noexcept
    { return this->_M_impl._M_start; }

    const_iterator
    begin() const noexcept
    { return this->_M_impl._M_start; }

    iterator
    end() noexcept
    { return this->_M_impl._M_finish; }

    const_iterator
    end() const noexcept
    { return this->_M_impl._M_finish; }

    reverse_iterator
    rbegin() noexcept
    { return reverse_iterator(end()); }

    const_reverse_iterator
    rbegin() const noexcept
    { return const_reverse_iterator(end()); }

    reverse_iterator
    rend() noexcept
    { return reverse_iterator(begin()); }

    const_reverse_iterator
    rend() const noexcept
    { return const_reverse_iterator(begin()); }


    const_iterator
    cbegin() const noexcept
    { return this->_M_impl._M_start; }

    const_iterator
    cend() const noexcept
    { return this->_M_impl._M_finish; }

    const_reverse_iterator
    crbegin() const noexcept
    { return const_reverse_iterator(end()); }

    const_reverse_iterator
    crend() const noexcept
    { return const_reverse_iterator(begin()); }


    size_type
    size() const noexcept
    { return size_type(end() - begin()); }

    size_type
    max_size() const noexcept
    {
      const size_type __isize =
 __gnu_cxx::__numeric_traits<difference_type>::__max
 - int(_S_word_bit) + 1;
      const size_type __asize = _M_get_Bit_allocator().max_size();
      return (__asize <= __isize / int(_S_word_bit)
       ? __asize * int(_S_word_bit) : __isize);
    }

    size_type
    capacity() const noexcept
    { return size_type(const_iterator(this->_M_impl._M_end_of_storage, 0)
         - begin()); }

    bool
    empty() const noexcept
    { return begin() == end(); }

    reference
    operator[](size_type __n)
    {
      return *iterator(this->_M_impl._M_start._M_p
         + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

    const_reference
    operator[](size_type __n) const
    {
      return *const_iterator(this->_M_impl._M_start._M_p
        + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

  protected:
    void
    _M_range_check(size_type __n) const
    {
      if (__n >= this->size())
        __throw_out_of_range(("vector<bool>::_M_range_check"));
    }

  public:
    reference
    at(size_type __n)
    { _M_range_check(__n); return (*this)[__n]; }

    const_reference
    at(size_type __n) const
    { _M_range_check(__n); return (*this)[__n]; }

    void
    reserve(size_type __n)
    {
      if (__n > max_size())
 __throw_length_error(("vector::reserve"));
      if (capacity() < __n)
 _M_reallocate(__n);
    }

    reference
    front()
    { return *begin(); }

    const_reference
    front() const
    { return *begin(); }

    reference
    back()
    { return *(end() - 1); }

    const_reference
    back() const
    { return *(end() - 1); }






    void
    data() noexcept { }

    void
    push_back(bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(end(), __x);
    }

    void
    swap(vector& __x)
    {
      std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
      std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
      std::swap(this->_M_impl._M_end_of_storage,
  __x._M_impl._M_end_of_storage);



      std::__alloc_swap<typename _Base::_Bit_alloc_type>::
 _S_do_it(_M_get_Bit_allocator(), __x._M_get_Bit_allocator());
    }


    static void
    swap(reference __x, reference __y) noexcept
    {
      bool __tmp = __x;
      __x = __y;
      __y = __tmp;
    }

    iterator
    insert(iterator __position, const bool& __x = bool())
    {
      const difference_type __n = __position - begin();
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage
   && __position == end())
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(__position, __x);
      return begin() + __n;
    }


    template<typename _InputIterator,
      typename = std::_RequireInputIter<_InputIterator>>
      void
      insert(iterator __position,
      _InputIterator __first, _InputIterator __last)
      { _M_insert_dispatch(__position, __first, __last, __false_type()); }
# 887 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_bvector.h" 3
    void
    insert(iterator __position, size_type __n, const bool& __x)
    { _M_fill_insert(__position, __n, __x); }


    void insert(iterator __p, initializer_list<bool> __l)
    { this->insert(__p, __l.begin(), __l.end()); }


    void
    pop_back()
    { --this->_M_impl._M_finish; }

    iterator
    erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      return __position;
    }

    iterator
    erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 _M_erase_at_end(std::copy(__last, end(), __first));
      return __first;
    }

    void
    resize(size_type __new_size, bool __x = bool())
    {
      if (__new_size < size())
        _M_erase_at_end(begin() + difference_type(__new_size));
      else
        insert(end(), __new_size - size(), __x);
    }


    void
    shrink_to_fit()
    { _M_shrink_to_fit(); }


    void
    flip() noexcept
    {
      for (_Bit_type * __p = this->_M_impl._M_start._M_p;
    __p != this->_M_impl._M_end_of_storage; ++__p)
        *__p = ~*__p;
    }

    void
    clear() noexcept
    { _M_erase_at_end(begin()); }


  protected:

    iterator
    _M_copy_aligned(const_iterator __first, const_iterator __last,
      iterator __result)
    {
      _Bit_type* __q = std::copy(__first._M_p, __last._M_p, __result._M_p);
      return std::copy(const_iterator(__last._M_p, 0), __last,
         iterator(__q, 0));
    }

    void
    _M_initialize(size_type __n)
    {
      _Bit_type* __q = this->_M_allocate(__n);
      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
      this->_M_impl._M_start = iterator(__q, 0);
      this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);
    }

    void
    _M_reallocate(size_type __n);


    bool
    _M_shrink_to_fit();






    template<typename _Integer>
      void
      _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
      {
 _M_initialize(static_cast<size_type>(__n));
 std::fill(this->_M_impl._M_start._M_p,
    this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
      }

    template<typename _InputIterator>
      void
      _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
        __false_type)
      { _M_initialize_range(__first, __last,
       std::__iterator_category(__first)); }

    template<typename _InputIterator>
      void
      _M_initialize_range(_InputIterator __first, _InputIterator __last,
     std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   push_back(*__first);
      }

    template<typename _ForwardIterator>
      void
      _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
     std::forward_iterator_tag)
      {
 const size_type __n = std::distance(__first, __last);
 _M_initialize(__n);
 std::copy(__first, __last, this->_M_impl._M_start);
      }



    template<typename _Integer>
      void
      _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
      { _M_fill_assign(__n, __val); }

    template<class _InputIterator>
      void
      _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }

    void
    _M_fill_assign(size_t __n, bool __x)
    {
      if (__n > size())
 {
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
   insert(end(), __n - size(), __x);
 }
      else
 {
   _M_erase_at_end(begin() + __n);
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
 }
    }

    template<typename _InputIterator>
      void
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 iterator __cur = begin();
 for (; __first != __last && __cur != end(); ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

    template<typename _ForwardIterator>
      void
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);
 if (__len < size())
   _M_erase_at_end(std::copy(__first, __last, begin()));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, begin());
     insert(end(), __mid, __last);
   }
      }





    template<typename _Integer>
      void
      _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
    __true_type)
      { _M_fill_insert(__pos, __n, __x); }

    template<typename _InputIterator>
      void
      _M_insert_dispatch(iterator __pos,
    _InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_insert_range(__pos, __first, __last,
   std::__iterator_category(__first)); }

    void
    _M_fill_insert(iterator __position, size_type __n, bool __x);

    template<typename _InputIterator>
      void
      _M_insert_range(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

    template<typename _ForwardIterator>
      void
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag);

    void
    _M_insert_aux(iterator __position, bool __x);

    size_type
    _M_check_len(size_type __n, const char* __s) const
    {
      if (max_size() - size() < __n)
 __throw_length_error((__s));

      const size_type __len = size() + std::max(size(), __n);
      return (__len < size() || __len > max_size()) ? max_size() : __len;
    }

    void
    _M_erase_at_end(iterator __pos)
    { this->_M_impl._M_finish = __pos; }
  };


}





namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _Alloc>
    struct hash<std::vector<bool, _Alloc>>
    : public __hash_base<size_t, std::vector<bool, _Alloc>>
    {
      size_t
      operator()(const std::vector<bool, _Alloc>&) const noexcept;
    };


}
# 66 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/vector" 2 3



# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/vector.tcc" 1 3
# 59 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/vector.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   const size_type __old_size = size();
   pointer __tmp = _M_allocate_and_copy(__n,
     std::__make_move_if_noexcept_iterator(this->_M_impl._M_start),
     std::__make_move_if_noexcept_iterator(this->_M_impl._M_finish));
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __tmp;
   this->_M_impl._M_finish = __tmp + __old_size;
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
 }
    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         std::forward<_Args>(__args)...);
     ++this->_M_impl._M_finish;
   }
 else
   _M_emplace_back_aux(std::forward<_Args>(__args)...);
      }


  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      const size_type __n = __position - begin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
   && __position == end())
 {
   _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, __x);
   ++this->_M_impl._M_finish;
 }
      else
 {

   if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
     {
       _Tp __x_copy = __x;
       _M_insert_aux(__position, std::move(__x_copy));
     }
   else

     _M_insert_aux(__position, __x);
 }
      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    erase(iterator __position)
    {
      if (__position + 1 != end())
 std::move(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
      return __position;
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 {
   if (__last != end())
     std::move(__last, end(), __first);
   _M_erase_at_end(__first.base() + (end() - __last));
 }
      return __first;
    }

  template<typename _Tp, typename _Alloc>
    vector<_Tp, _Alloc>&
    vector<_Tp, _Alloc>::
    operator=(const vector<_Tp, _Alloc>& __x)
    {
      if (&__x != this)
 {

   if (_Alloc_traits::_S_propagate_on_copy_assign())
     {
       if (!_Alloc_traits::_S_always_equal()
           && _M_get_Tp_allocator() != __x._M_get_Tp_allocator())
         {

    this->clear();
    _M_deallocate(this->_M_impl._M_start,
    this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start);
    this->_M_impl._M_start = nullptr;
    this->_M_impl._M_finish = nullptr;
    this->_M_impl._M_end_of_storage = nullptr;
  }
       std::__alloc_on_copy(_M_get_Tp_allocator(),
       __x._M_get_Tp_allocator());
     }

   const size_type __xlen = __x.size();
   if (__xlen > capacity())
     {
       pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
         __x.end());
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __tmp;
       this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
     }
   else if (size() >= __xlen)
     {
       std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
       end(), _M_get_Tp_allocator());
     }
   else
     {
       std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
   this->_M_impl._M_start);
       std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
       __x._M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     }
   this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_assign(size_t __n, const value_type& __val)
    {
      if (__n > capacity())
 {
   vector __tmp(__n, __val, _M_get_Tp_allocator());
   __tmp.swap(*this);
 }
      else if (__n > size())
 {
   std::fill(begin(), end(), __val);
   std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
     __n - size(), __val,
     _M_get_Tp_allocator());
   this->_M_impl._M_finish += __n - size();
 }
      else
        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 pointer __cur(this->_M_impl._M_start);
 for (; __first != __last && __cur != this->_M_impl._M_finish;
      ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);

 if (__len > capacity())
   {
     pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
     std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     _M_deallocate(this->_M_impl._M_start,
     this->_M_impl._M_end_of_storage
     - this->_M_impl._M_start);
     this->_M_impl._M_start = __tmp;
     this->_M_impl._M_finish = this->_M_impl._M_start + __len;
     this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
   }
 else if (size() >= __len)
   _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, this->_M_impl._M_start);
     this->_M_impl._M_finish =
       std::__uninitialized_copy_a(__mid, __last,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
   }
      }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      typename vector<_Tp, _Alloc>::iterator
      vector<_Tp, _Alloc>::
      emplace(iterator __position, _Args&&... __args)
      {
 const size_type __n = __position - begin();
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
     && __position == end())
   {
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         std::forward<_Args>(__args)...);
     ++this->_M_impl._M_finish;
   }
 else
   _M_insert_aux(__position, std::forward<_Args>(__args)...);
 return iterator(this->_M_impl._M_start + __n);
      }

  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      _M_insert_aux(iterator __position, _Args&&... __args)






    {
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 {
   _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
              std::move(*(this->_M_impl._M_finish - 1)));

   ++this->_M_impl._M_finish;



   std::move_backward(__position.base(), this->_M_impl._M_finish - 2, this->_M_impl._M_finish - 1);





   *__position = _Tp(std::forward<_Args>(__args)...);

 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector::_M_insert_aux");
   const size_type __elems_before = __position - begin();
   pointer __new_start(this->_M_allocate(__len));
   pointer __new_finish(__new_start);
   try
     {




       _Alloc_traits::construct(this->_M_impl,
                         __new_start + __elems_before,

           std::forward<_Args>(__args)...);



       __new_finish = 0;

       __new_finish
  = std::__uninitialized_move_if_noexcept_a
  (this->_M_impl._M_start, __position.base(),
   __new_start, _M_get_Tp_allocator());

       ++__new_finish;

       __new_finish
  = std::__uninitialized_move_if_noexcept_a
  (__position.base(), this->_M_impl._M_finish,
   __new_finish, _M_get_Tp_allocator());
     }
          catch(...)
     {
       if (!__new_finish)
  _Alloc_traits::destroy(this->_M_impl,
                         __new_start + __elems_before);
       else
  std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
       _M_deallocate(__new_start, __len);
       throw;
     }
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __new_start;
   this->_M_impl._M_finish = __new_finish;
   this->_M_impl._M_end_of_storage = __new_start + __len;
 }
    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      _M_emplace_back_aux(_Args&&... __args)
      {
 const size_type __len =
   _M_check_len(size_type(1), "vector::_M_emplace_back_aux");
 pointer __new_start(this->_M_allocate(__len));
 pointer __new_finish(__new_start);
 try
   {
     _Alloc_traits::construct(this->_M_impl, __new_start + size(),
         std::forward<_Args>(__args)...);
     __new_finish = 0;

     __new_finish
       = std::__uninitialized_move_if_noexcept_a
       (this->_M_impl._M_start, this->_M_impl._M_finish,
        __new_start, _M_get_Tp_allocator());

     ++__new_finish;
   }
 catch(...)
   {
     if (!__new_finish)
       _Alloc_traits::destroy(this->_M_impl, __new_start + size());
     else
       std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
     _M_deallocate(__new_start, __len);
     throw;
   }
 std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator());
 _M_deallocate(this->_M_impl._M_start,
        this->_M_impl._M_end_of_storage
        - this->_M_impl._M_start);
 this->_M_impl._M_start = __new_start;
 this->_M_impl._M_finish = __new_finish;
 this->_M_impl._M_end_of_storage = __new_start + __len;
      }


  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {
       value_type __x_copy = __x;
       const size_type __elems_after = end() - __position;
       pointer __old_finish(this->_M_impl._M_finish);
       if (__elems_after > __n)
  {
    std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n;
    std::move_backward(__position.base(), __old_finish - __n, __old_finish);

    std::fill(__position.base(), __position.base() + __n,
       __x_copy);
  }
       else
  {
    std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
      __n - __elems_after,
      __x_copy,
      _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n - __elems_after;
    std::__uninitialized_move_a(__position.base(), __old_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __elems_after;
    std::fill(__position.base(), __old_finish, __x_copy);
  }
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_fill_insert");
       const size_type __elems_before = __position - begin();
       pointer __new_start(this->_M_allocate(__len));
       pointer __new_finish(__new_start);
       try
  {

    std::__uninitialized_fill_n_a(__new_start + __elems_before,
      __n, __x,
      _M_get_Tp_allocator());
    __new_finish = 0;

    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (this->_M_impl._M_start, __position.base(),
       __new_start, _M_get_Tp_allocator());

    __new_finish += __n;

    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (__position.base(), this->_M_impl._M_finish,
       __new_finish, _M_get_Tp_allocator());
  }
       catch(...)
  {
    if (!__new_finish)
      std::_Destroy(__new_start + __elems_before,
      __new_start + __elems_before + __n,
      _M_get_Tp_allocator());
    else
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    throw;
  }
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_finish;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }


  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_default_append(size_type __n)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {
       std::__uninitialized_default_n_a(this->_M_impl._M_finish,
            __n, _M_get_Tp_allocator());
       this->_M_impl._M_finish += __n;
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_default_append");
       const size_type __old_size = this->size();
       pointer __new_start(this->_M_allocate(__len));
       pointer __new_finish(__new_start);
       try
  {
    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (this->_M_impl._M_start, this->_M_impl._M_finish,
       __new_start, _M_get_Tp_allocator());
    std::__uninitialized_default_n_a(__new_finish, __n,
         _M_get_Tp_allocator());
    __new_finish += __n;
  }
       catch(...)
  {
    std::_Destroy(__new_start, __new_finish,
    _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    throw;
  }
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_finish;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }

  template<typename _Tp, typename _Alloc>
    bool
    vector<_Tp, _Alloc>::
    _M_shrink_to_fit()
    {
      if (capacity() == size())
 return false;
      return std::__shrink_to_fit_aux<vector>::_S_do_it(*this);
    }


  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     const size_type __n = std::distance(__first, __last);
     if (size_type(this->_M_impl._M_end_of_storage
     - this->_M_impl._M_finish) >= __n)
       {
  const size_type __elems_after = end() - __position;
  pointer __old_finish(this->_M_impl._M_finish);
  if (__elems_after > __n)
    {
      std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
      this->_M_impl._M_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n;
      std::move_backward(__position.base(), __old_finish - __n, __old_finish);

      std::copy(__first, __last, __position);
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, __elems_after);
      std::__uninitialized_copy_a(__mid, __last,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n - __elems_after;
      std::__uninitialized_move_a(__position.base(),
      __old_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __elems_after;
      std::copy(__first, __mid, __position);
    }
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector::_M_range_insert");
  pointer __new_start(this->_M_allocate(__len));
  pointer __new_finish(__new_start);
  try
    {
      __new_finish
        = std::__uninitialized_move_if_noexcept_a
        (this->_M_impl._M_start, __position.base(),
         __new_start, _M_get_Tp_allocator());
      __new_finish
        = std::__uninitialized_copy_a(__first, __last,
          __new_finish,
          _M_get_Tp_allocator());
      __new_finish
        = std::__uninitialized_move_if_noexcept_a
        (__position.base(), this->_M_impl._M_finish,
         __new_finish, _M_get_Tp_allocator());
    }
  catch(...)
    {
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
      _M_deallocate(__new_start, __len);
      throw;
    }
  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  _M_deallocate(this->_M_impl._M_start,
         this->_M_impl._M_end_of_storage
         - this->_M_impl._M_start);
  this->_M_impl._M_start = __new_start;
  this->_M_impl._M_finish = __new_finish;
  this->_M_impl._M_end_of_storage = __new_start + __len;
       }
   }
      }



  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_reallocate(size_type __n)
    {
      _Bit_type* __q = this->_M_allocate(__n);
      this->_M_impl._M_finish = _M_copy_aligned(begin(), end(),
      iterator(__q, 0));
      this->_M_deallocate();
      this->_M_impl._M_start = iterator(__q, 0);
      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
    }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, bool __x)
    {
      if (__n == 0)
 return;
      if (capacity() - size() >= __n)
 {
   std::copy_backward(__position, end(),
        this->_M_impl._M_finish + difference_type(__n));
   std::fill(__position, __position + difference_type(__n), __x);
   this->_M_impl._M_finish += difference_type(__n);
 }
      else
 {
   const size_type __len =
     _M_check_len(__n, "vector<bool>::_M_fill_insert");
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = _M_copy_aligned(begin(), __position,
      iterator(__q, 0));
   std::fill(__i, __i + difference_type(__n), __x);
   this->_M_impl._M_finish = std::copy(__position, end(),
           __i + difference_type(__n));
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }

  template<typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<bool, _Alloc>::
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     size_type __n = std::distance(__first, __last);
     if (capacity() - size() >= __n)
       {
  std::copy_backward(__position, end(),
       this->_M_impl._M_finish
       + difference_type(__n));
  std::copy(__first, __last, __position);
  this->_M_impl._M_finish += difference_type(__n);
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector<bool>::_M_insert_range");
  _Bit_type * __q = this->_M_allocate(__len);
  iterator __i = _M_copy_aligned(begin(), __position,
            iterator(__q, 0));
  __i = std::copy(__first, __last, __i);
  this->_M_impl._M_finish = std::copy(__position, end(), __i);
  this->_M_deallocate();
  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
  this->_M_impl._M_start = iterator(__q, 0);
       }
   }
      }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_insert_aux(iterator __position, bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
 {
   std::copy_backward(__position, this->_M_impl._M_finish,
        this->_M_impl._M_finish + 1);
   *__position = __x;
   ++this->_M_impl._M_finish;
 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = _M_copy_aligned(begin(), __position,
      iterator(__q, 0));
   *__i++ = __x;
   this->_M_impl._M_finish = std::copy(__position, end(), __i);
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }


  template<typename _Alloc>
    bool
    vector<bool, _Alloc>::
    _M_shrink_to_fit()
    {
      if (capacity() - size() < int(_S_word_bit))
 return false;
      try
 {
   _M_reallocate(size());
   return true;
 }
      catch(...)
 { return false; }
    }



}



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Alloc>
    size_t
    hash<std::vector<bool, _Alloc>>::
    operator()(const std::vector<bool, _Alloc>& __b) const noexcept
    {
      size_t __hash = 0;
      using std::_S_word_bit;
      using std::_Bit_type;

      const size_t __words = __b.size() / _S_word_bit;
      if (__words)
 {
   const size_t __clength = __words * sizeof(_Bit_type);
   __hash = std::_Hash_impl::hash(__b._M_impl._M_start._M_p, __clength);
 }

      const size_t __extrabits = __b.size() % _S_word_bit;
      if (__extrabits)
 {
   _Bit_type __hiword = *__b._M_impl._M_finish._M_p;
   __hiword &= ~((~static_cast<_Bit_type>(0)) << __extrabits);

   const size_t __clength
     = (__extrabits + 8 - 1) / 8;
   if (__words)
     __hash = std::_Hash_impl::hash(&__hiword, __clength, __hash);
   else
     __hash = std::_Hash_impl::hash(&__hiword, __clength);
 }

      return __hash;
    }


}
# 70 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/vector" 2 3
# 35 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
# 55 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _RealType, size_t __bits,
    typename _UniformRandomNumberGenerator>
    _RealType
    generate_canonical(_UniformRandomNumberGenerator& __g);






  namespace __detail
  {


    template<typename _UIntType, size_t __w,
      bool = __w < static_cast<size_t>
     (std::numeric_limits<_UIntType>::digits)>
      struct _Shift
      { static const _UIntType __value = 0; };

    template<typename _UIntType, size_t __w>
      struct _Shift<_UIntType, __w, true>
      { static const _UIntType __value = _UIntType(1) << __w; };

    template<int __s,
      int __which = ((__s <= 8 * sizeof (int))
       + (__s <= 8 * sizeof (long))
       + (__s <= 8 * sizeof (long long))

       + (__s <= 128))>
      struct _Select_uint_least_t
      {
 static_assert(__which < 0,
        "sorry, would be too much trouble for a slow result");
      };

    template<int __s>
      struct _Select_uint_least_t<__s, 4>
      { typedef unsigned int type; };

    template<int __s>
      struct _Select_uint_least_t<__s, 3>
      { typedef unsigned long type; };

    template<int __s>
      struct _Select_uint_least_t<__s, 2>
      { typedef unsigned long long type; };


    template<int __s>
      struct _Select_uint_least_t<__s, 1>
      { typedef unsigned __int128 type; };



    template<typename _Tp, _Tp __m, _Tp __a, _Tp __c,
      bool __big_enough = (!(__m & (__m - 1))
      || (_Tp(-1) - __c) / __a >= __m - 1),
             bool __schrage_ok = __m % __a < __m / __a>
      struct _Mod
      {
 typedef typename _Select_uint_least_t<std::__lg(__a)
           + std::__lg(__m) + 2>::type _Tp2;
 static _Tp
 __calc(_Tp __x)
 { return static_cast<_Tp>((_Tp2(__a) * __x + __c) % __m); }
      };


    template<typename _Tp, _Tp __m, _Tp __a, _Tp __c>
      struct _Mod<_Tp, __m, __a, __c, false, true>
      {
 static _Tp
 __calc(_Tp __x);
      };




    template<typename _Tp, _Tp __m, _Tp __a, _Tp __c, bool __s>
      struct _Mod<_Tp, __m, __a, __c, true, __s>
      {
 static _Tp
 __calc(_Tp __x)
 {
   _Tp __res = __a * __x + __c;
   if (__m)
     __res %= __m;
   return __res;
 }
      };

    template<typename _Tp, _Tp __m, _Tp __a = 1, _Tp __c = 0>
      inline _Tp
      __mod(_Tp __x)
      { return _Mod<_Tp, __m, __a, __c>::__calc(__x); }


    template<typename _Tp>
      inline bool
      _Power_of_2(_Tp __x)
      {
 return ((__x - 1) & __x) == 0;
      };





    template<typename _Engine, typename _DInputType>
      struct _Adaptor
      {

      public:
 _Adaptor(_Engine& __g)
 : _M_g(__g) { }

 _DInputType
 min() const
 { return _DInputType(0); }

 _DInputType
 max() const
 { return _DInputType(1); }






 _DInputType
 operator()()
 {
   return std::generate_canonical<_DInputType,
                             std::numeric_limits<_DInputType>::digits,
                             _Engine>(_M_g);
 }

      private:
 _Engine& _M_g;
      };


  }
# 240 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
    class linear_congruential_engine
    {
      static_assert(std::is_unsigned<_UIntType>::value, "template argument "
      "substituting _UIntType not an unsigned integral type");
      static_assert(__m == 0u || (__a < __m && __c < __m),
      "template argument substituting __m out of bounds");

    public:

      typedef _UIntType result_type;


      static constexpr result_type multiplier = __a;

      static constexpr result_type increment = __c;

      static constexpr result_type modulus = __m;
      static constexpr result_type default_seed = 1u;
# 267 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      explicit
      linear_congruential_engine(result_type __s = default_seed)
      { seed(__s); }







      template<typename _Sseq, typename = typename
 std::enable_if<!std::is_same<_Sseq, linear_congruential_engine>::value>
        ::type>
        explicit
        linear_congruential_engine(_Sseq& __q)
        { seed(__q); }







      void
      seed(result_type __s = default_seed);
# 300 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      template<typename _Sseq>
        typename std::enable_if<std::is_class<_Sseq>::value>::type
        seed(_Sseq& __q);







      static constexpr result_type
      min()
      { return __c == 0u ? 1u : 0u; }




      static constexpr result_type
      max()
      { return __m - 1u; }




      void
      discard(unsigned long long __z)
      {
 for (; __z != 0ULL; --__z)
   (*this)();
      }




      result_type
      operator()()
      {
 _M_x = __detail::__mod<_UIntType, __m, __a, __c>(_M_x);
 return _M_x;
      }
# 352 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      friend bool
      operator==(const linear_congruential_engine& __lhs,
   const linear_congruential_engine& __rhs)
      { return __lhs._M_x == __rhs._M_x; }
# 365 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      template<typename _UIntType1, _UIntType1 __a1, _UIntType1 __c1,
        _UIntType1 __m1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::linear_congruential_engine<_UIntType1,
     __a1, __c1, __m1>& __lcr);
# 385 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      template<typename _UIntType1, _UIntType1 __a1, _UIntType1 __c1,
        _UIntType1 __m1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::linear_congruential_engine<_UIntType1, __a1,
     __c1, __m1>& __lcr);

    private:
      _UIntType _M_x;
    };
# 407 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
    inline bool
    operator!=(const std::linear_congruential_engine<_UIntType, __a,
        __c, __m>& __lhs,
        const std::linear_congruential_engine<_UIntType, __a,
        __c, __m>& __rhs)
    { return !(__lhs == __rhs); }
# 444 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _UIntType, size_t __w,
    size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t,
    _UIntType __c, size_t __l, _UIntType __f>
    class mersenne_twister_engine
    {
      static_assert(std::is_unsigned<_UIntType>::value, "template argument "
      "substituting _UIntType not an unsigned integral type");
      static_assert(1u <= __m && __m <= __n,
      "template argument substituting __m out of bounds");
      static_assert(__r <= __w, "template argument substituting "
      "__r out of bound");
      static_assert(__u <= __w, "template argument substituting "
      "__u out of bound");
      static_assert(__s <= __w, "template argument substituting "
      "__s out of bound");
      static_assert(__t <= __w, "template argument substituting "
      "__t out of bound");
      static_assert(__l <= __w, "template argument substituting "
      "__l out of bound");
      static_assert(__w <= std::numeric_limits<_UIntType>::digits,
      "template argument substituting __w out of bound");
      static_assert(__a <= (__detail::_Shift<_UIntType, __w>::__value - 1),
      "template argument substituting __a out of bound");
      static_assert(__b <= (__detail::_Shift<_UIntType, __w>::__value - 1),
      "template argument substituting __b out of bound");
      static_assert(__c <= (__detail::_Shift<_UIntType, __w>::__value - 1),
      "template argument substituting __c out of bound");
      static_assert(__d <= (__detail::_Shift<_UIntType, __w>::__value - 1),
      "template argument substituting __d out of bound");
      static_assert(__f <= (__detail::_Shift<_UIntType, __w>::__value - 1),
      "template argument substituting __f out of bound");

    public:

      typedef _UIntType result_type;


      static constexpr size_t word_size = __w;
      static constexpr size_t state_size = __n;
      static constexpr size_t shift_size = __m;
      static constexpr size_t mask_bits = __r;
      static constexpr result_type xor_mask = __a;
      static constexpr size_t tempering_u = __u;
      static constexpr result_type tempering_d = __d;
      static constexpr size_t tempering_s = __s;
      static constexpr result_type tempering_b = __b;
      static constexpr size_t tempering_t = __t;
      static constexpr result_type tempering_c = __c;
      static constexpr size_t tempering_l = __l;
      static constexpr result_type initialization_multiplier = __f;
      static constexpr result_type default_seed = 5489u;


      explicit
      mersenne_twister_engine(result_type __sd = default_seed)
      { seed(__sd); }







      template<typename _Sseq, typename = typename
        std::enable_if<!std::is_same<_Sseq, mersenne_twister_engine>::value>
        ::type>
        explicit
        mersenne_twister_engine(_Sseq& __q)
        { seed(__q); }

      void
      seed(result_type __sd = default_seed);

      template<typename _Sseq>
 typename std::enable_if<std::is_class<_Sseq>::value>::type
        seed(_Sseq& __q);




      static constexpr result_type
      min()
      { return 0; };




      static constexpr result_type
      max()
      { return __detail::_Shift<_UIntType, __w>::__value - 1; }




      void
      discard(unsigned long long __z);

      result_type
      operator()();
# 558 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      friend bool
      operator==(const mersenne_twister_engine& __lhs,
   const mersenne_twister_engine& __rhs)
      { return (std::equal(__lhs._M_x, __lhs._M_x + state_size, __rhs._M_x)
  && __lhs._M_p == __rhs._M_p); }
# 576 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      template<typename _UIntType1,
        size_t __w1, size_t __n1,
        size_t __m1, size_t __r1,
        _UIntType1 __a1, size_t __u1,
        _UIntType1 __d1, size_t __s1,
        _UIntType1 __b1, size_t __t1,
        _UIntType1 __c1, size_t __l1, _UIntType1 __f1,
        typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::mersenne_twister_engine<_UIntType1, __w1, __n1,
     __m1, __r1, __a1, __u1, __d1, __s1, __b1, __t1, __c1,
     __l1, __f1>& __x);
# 602 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      template<typename _UIntType1,
        size_t __w1, size_t __n1,
        size_t __m1, size_t __r1,
        _UIntType1 __a1, size_t __u1,
        _UIntType1 __d1, size_t __s1,
        _UIntType1 __b1, size_t __t1,
        _UIntType1 __c1, size_t __l1, _UIntType1 __f1,
        typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::mersenne_twister_engine<_UIntType1, __w1, __n1, __m1,
     __r1, __a1, __u1, __d1, __s1, __b1, __t1, __c1,
     __l1, __f1>& __x);

    private:
      void _M_gen_rand();

      _UIntType _M_x[state_size];
      size_t _M_p;
    };
# 635 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _UIntType, size_t __w,
    size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t,
    _UIntType __c, size_t __l, _UIntType __f>
    inline bool
    operator!=(const std::mersenne_twister_engine<_UIntType, __w, __n, __m,
        __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>& __lhs,
        const std::mersenne_twister_engine<_UIntType, __w, __n, __m,
        __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>& __rhs)
    { return !(__lhs == __rhs); }
# 667 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
    class subtract_with_carry_engine
    {
      static_assert(std::is_unsigned<_UIntType>::value, "template argument "
      "substituting _UIntType not an unsigned integral type");
      static_assert(0u < __s && __s < __r,
      "template argument substituting __s out of bounds");
      static_assert(0u < __w && __w <= std::numeric_limits<_UIntType>::digits,
      "template argument substituting __w out of bounds");

    public:

      typedef _UIntType result_type;


      static constexpr size_t word_size = __w;
      static constexpr size_t short_lag = __s;
      static constexpr size_t long_lag = __r;
      static constexpr result_type default_seed = 19780503u;





      explicit
      subtract_with_carry_engine(result_type __sd = default_seed)
      { seed(__sd); }







      template<typename _Sseq, typename = typename
        std::enable_if<!std::is_same<_Sseq, subtract_with_carry_engine>::value>
        ::type>
        explicit
        subtract_with_carry_engine(_Sseq& __q)
        { seed(__q); }
# 720 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      void
      seed(result_type __sd = default_seed);





      template<typename _Sseq>
 typename std::enable_if<std::is_class<_Sseq>::value>::type
        seed(_Sseq& __q);





      static constexpr result_type
      min()
      { return 0; }





      static constexpr result_type
      max()
      { return __detail::_Shift<_UIntType, __w>::__value - 1; }




      void
      discard(unsigned long long __z)
      {
 for (; __z != 0ULL; --__z)
   (*this)();
      }




      result_type
      operator()();
# 775 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      friend bool
      operator==(const subtract_with_carry_engine& __lhs,
   const subtract_with_carry_engine& __rhs)
      { return (std::equal(__lhs._M_x, __lhs._M_x + long_lag, __rhs._M_x)
  && __lhs._M_carry == __rhs._M_carry
  && __lhs._M_p == __rhs._M_p); }
# 794 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      template<typename _UIntType1, size_t __w1, size_t __s1, size_t __r1,
        typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>&,
     const std::subtract_with_carry_engine<_UIntType1, __w1,
     __s1, __r1>&);
# 813 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      template<typename _UIntType1, size_t __w1, size_t __s1, size_t __r1,
        typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>&,
     std::subtract_with_carry_engine<_UIntType1, __w1,
     __s1, __r1>&);

    private:
      _UIntType _M_x[long_lag];
      _UIntType _M_carry;
      size_t _M_p;
    };
# 838 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
    inline bool
    operator!=(const std::subtract_with_carry_engine<_UIntType, __w,
        __s, __r>& __lhs,
        const std::subtract_with_carry_engine<_UIntType, __w,
        __s, __r>& __rhs)
    { return !(__lhs == __rhs); }
# 853 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _RandomNumberEngine, size_t __p, size_t __r>
    class discard_block_engine
    {
      static_assert(1 <= __r && __r <= __p,
      "template argument substituting __r out of bounds");

    public:

      typedef typename _RandomNumberEngine::result_type result_type;


      static constexpr size_t block_size = __p;
      static constexpr size_t used_block = __r;






      discard_block_engine()
      : _M_b(), _M_n(0) { }







      explicit
      discard_block_engine(const _RandomNumberEngine& __rng)
      : _M_b(__rng), _M_n(0) { }







      explicit
      discard_block_engine(_RandomNumberEngine&& __rng)
      : _M_b(std::move(__rng)), _M_n(0) { }







      explicit
      discard_block_engine(result_type __s)
      : _M_b(__s), _M_n(0) { }






      template<typename _Sseq, typename = typename
 std::enable_if<!std::is_same<_Sseq, discard_block_engine>::value
         && !std::is_same<_Sseq, _RandomNumberEngine>::value>
        ::type>
        explicit
        discard_block_engine(_Sseq& __q)
 : _M_b(__q), _M_n(0)
        { }





      void
      seed()
      {
 _M_b.seed();
 _M_n = 0;
      }





      void
      seed(result_type __s)
      {
 _M_b.seed(__s);
 _M_n = 0;
      }






      template<typename _Sseq>
        void
        seed(_Sseq& __q)
        {
   _M_b.seed(__q);
   _M_n = 0;
 }





      const _RandomNumberEngine&
      base() const noexcept
      { return _M_b; }




      static constexpr result_type
      min()
      { return _RandomNumberEngine::min(); }




      static constexpr result_type
      max()
      { return _RandomNumberEngine::max(); }




      void
      discard(unsigned long long __z)
      {
 for (; __z != 0ULL; --__z)
   (*this)();
      }




      result_type
      operator()();
# 1003 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      friend bool
      operator==(const discard_block_engine& __lhs,
   const discard_block_engine& __rhs)
      { return __lhs._M_b == __rhs._M_b && __lhs._M_n == __rhs._M_n; }
# 1019 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      template<typename _RandomNumberEngine1, size_t __p1, size_t __r1,
        typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::discard_block_engine<_RandomNumberEngine1,
     __p1, __r1>& __x);
# 1037 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      template<typename _RandomNumberEngine1, size_t __p1, size_t __r1,
        typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::discard_block_engine<_RandomNumberEngine1,
     __p1, __r1>& __x);

    private:
      _RandomNumberEngine _M_b;
      size_t _M_n;
    };
# 1060 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _RandomNumberEngine, size_t __p, size_t __r>
    inline bool
    operator!=(const std::discard_block_engine<_RandomNumberEngine, __p,
        __r>& __lhs,
        const std::discard_block_engine<_RandomNumberEngine, __p,
        __r>& __rhs)
    { return !(__lhs == __rhs); }






  template<typename _RandomNumberEngine, size_t __w, typename _UIntType>
    class independent_bits_engine
    {
      static_assert(std::is_unsigned<_UIntType>::value, "template argument "
      "substituting _UIntType not an unsigned integral type");
      static_assert(0u < __w && __w <= std::numeric_limits<_UIntType>::digits,
      "template argument substituting __w out of bounds");

    public:

      typedef _UIntType result_type;






      independent_bits_engine()
      : _M_b() { }







      explicit
      independent_bits_engine(const _RandomNumberEngine& __rng)
      : _M_b(__rng) { }







      explicit
      independent_bits_engine(_RandomNumberEngine&& __rng)
      : _M_b(std::move(__rng)) { }







      explicit
      independent_bits_engine(result_type __s)
      : _M_b(__s) { }






      template<typename _Sseq, typename = typename
 std::enable_if<!std::is_same<_Sseq, independent_bits_engine>::value
         && !std::is_same<_Sseq, _RandomNumberEngine>::value>
               ::type>
        explicit
        independent_bits_engine(_Sseq& __q)
        : _M_b(__q)
        { }





      void
      seed()
      { _M_b.seed(); }





      void
      seed(result_type __s)
      { _M_b.seed(__s); }






      template<typename _Sseq>
        void
        seed(_Sseq& __q)
        { _M_b.seed(__q); }





      const _RandomNumberEngine&
      base() const noexcept
      { return _M_b; }




      static constexpr result_type
      min()
      { return 0U; }




      static constexpr result_type
      max()
      { return __detail::_Shift<_UIntType, __w>::__value - 1; }




      void
      discard(unsigned long long __z)
      {
 for (; __z != 0ULL; --__z)
   (*this)();
      }




      result_type
      operator()();
# 1213 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      friend bool
      operator==(const independent_bits_engine& __lhs,
   const independent_bits_engine& __rhs)
      { return __lhs._M_b == __rhs._M_b; }
# 1230 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      template<typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::independent_bits_engine<_RandomNumberEngine,
     __w, _UIntType>& __x)
 {
   __is >> __x._M_b;
   return __is;
 }

    private:
      _RandomNumberEngine _M_b;
    };
# 1256 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _RandomNumberEngine, size_t __w, typename _UIntType>
    inline bool
    operator!=(const std::independent_bits_engine<_RandomNumberEngine, __w,
        _UIntType>& __lhs,
        const std::independent_bits_engine<_RandomNumberEngine, __w,
        _UIntType>& __rhs)
    { return !(__lhs == __rhs); }
# 1274 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _RandomNumberEngine, size_t __w, typename _UIntType,
    typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const std::independent_bits_engine<_RandomNumberEngine,
        __w, _UIntType>& __x)
    {
      __os << __x.base();
      return __os;
    }







  template<typename _RandomNumberEngine, size_t __k>
    class shuffle_order_engine
    {
      static_assert(1u <= __k, "template argument substituting "
      "__k out of bound");

    public:

      typedef typename _RandomNumberEngine::result_type result_type;

      static constexpr size_t table_size = __k;






      shuffle_order_engine()
      : _M_b()
      { _M_initialize(); }







      explicit
      shuffle_order_engine(const _RandomNumberEngine& __rng)
      : _M_b(__rng)
      { _M_initialize(); }







      explicit
      shuffle_order_engine(_RandomNumberEngine&& __rng)
      : _M_b(std::move(__rng))
      { _M_initialize(); }







      explicit
      shuffle_order_engine(result_type __s)
      : _M_b(__s)
      { _M_initialize(); }






      template<typename _Sseq, typename = typename
 std::enable_if<!std::is_same<_Sseq, shuffle_order_engine>::value
         && !std::is_same<_Sseq, _RandomNumberEngine>::value>
        ::type>
        explicit
        shuffle_order_engine(_Sseq& __q)
        : _M_b(__q)
        { _M_initialize(); }





      void
      seed()
      {
 _M_b.seed();
 _M_initialize();
      }





      void
      seed(result_type __s)
      {
 _M_b.seed(__s);
 _M_initialize();
      }






      template<typename _Sseq>
        void
        seed(_Sseq& __q)
        {
   _M_b.seed(__q);
   _M_initialize();
 }




      const _RandomNumberEngine&
      base() const noexcept
      { return _M_b; }




      static constexpr result_type
      min()
      { return _RandomNumberEngine::min(); }




      static constexpr result_type
      max()
      { return _RandomNumberEngine::max(); }




      void
      discard(unsigned long long __z)
      {
 for (; __z != 0ULL; --__z)
   (*this)();
      }




      result_type
      operator()();
# 1442 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      friend bool
      operator==(const shuffle_order_engine& __lhs,
   const shuffle_order_engine& __rhs)
      { return (__lhs._M_b == __rhs._M_b
  && std::equal(__lhs._M_v, __lhs._M_v + __k, __rhs._M_v)
  && __lhs._M_y == __rhs._M_y); }
# 1460 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      template<typename _RandomNumberEngine1, size_t __k1,
        typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::shuffle_order_engine<_RandomNumberEngine1,
     __k1>& __x);
# 1478 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      template<typename _RandomNumberEngine1, size_t __k1,
        typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::shuffle_order_engine<_RandomNumberEngine1, __k1>& __x);

    private:
      void _M_initialize()
      {
 for (size_t __i = 0; __i < __k; ++__i)
   _M_v[__i] = _M_b();
 _M_y = _M_b();
      }

      _RandomNumberEngine _M_b;
      result_type _M_v[__k];
      result_type _M_y;
    };
# 1508 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _RandomNumberEngine, size_t __k>
    inline bool
    operator!=(const std::shuffle_order_engine<_RandomNumberEngine,
        __k>& __lhs,
        const std::shuffle_order_engine<_RandomNumberEngine,
        __k>& __rhs)
    { return !(__lhs == __rhs); }





  typedef linear_congruential_engine<uint_fast32_t, 16807UL, 0UL, 2147483647UL>
  minstd_rand0;




  typedef linear_congruential_engine<uint_fast32_t, 48271UL, 0UL, 2147483647UL>
  minstd_rand;
# 1537 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  typedef mersenne_twister_engine<
    uint_fast32_t,
    32, 624, 397, 31,
    0x9908b0dfUL, 11,
    0xffffffffUL, 7,
    0x9d2c5680UL, 15,
    0xefc60000UL, 18, 1812433253UL> mt19937;




  typedef mersenne_twister_engine<
    uint_fast64_t,
    64, 312, 156, 31,
    0xb5026f5aa96619e9ULL, 29,
    0x5555555555555555ULL, 17,
    0x71d67fffeda60000ULL, 37,
    0xfff7eee000000000ULL, 43,
    6364136223846793005ULL> mt19937_64;

  typedef subtract_with_carry_engine<uint_fast32_t, 24, 10, 24>
    ranlux24_base;

  typedef subtract_with_carry_engine<uint_fast64_t, 48, 5, 12>
    ranlux48_base;

  typedef discard_block_engine<ranlux24_base, 223, 23> ranlux24;

  typedef discard_block_engine<ranlux48_base, 389, 11> ranlux48;

  typedef shuffle_order_engine<minstd_rand0, 256> knuth_b;

  typedef minstd_rand0 default_random_engine;





  class random_device
  {
  public:

    typedef unsigned int result_type;





    explicit
    random_device(const std::string& __token = "default")
    {
      _M_init(__token);
    }

    ~random_device()
    { _M_fini(); }
# 1604 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
    static constexpr result_type
    min()
    { return std::numeric_limits<result_type>::min(); }

    static constexpr result_type
    max()
    { return std::numeric_limits<result_type>::max(); }

    double
    entropy() const noexcept
    { return 0.0; }

    result_type
    operator()()
    {

      return this->_M_getval();



    }


    random_device(const random_device&) = delete;
    void operator=(const random_device&) = delete;

  private:

    void _M_init(const std::string& __token);
    void _M_init_pretr1(const std::string& __token);
    void _M_fini();

    result_type _M_getval();
    result_type _M_getval_pretr1();

    union
    {
    FILE* _M_file;
    mt19937 _M_mt;
  };
  };
# 1665 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _IntType = int>
    class uniform_int_distribution
    {
      static_assert(std::is_integral<_IntType>::value,
      "template argument not an integral type");

    public:

      typedef _IntType result_type;

      struct param_type
      {
 typedef uniform_int_distribution<_IntType> distribution_type;

 explicit
 param_type(_IntType __a = 0,
     _IntType __b = std::numeric_limits<_IntType>::max())
 : _M_a(__a), _M_b(__b)
 {
                                      ;
 }

 result_type
 a() const
 { return _M_a; }

 result_type
 b() const
 { return _M_b; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b; }

      private:
 _IntType _M_a;
 _IntType _M_b;
      };

    public:



      explicit
      uniform_int_distribution(_IntType __a = 0,
      _IntType __b = std::numeric_limits<_IntType>::max())
      : _M_param(__a, __b)
      { }

      explicit
      uniform_int_distribution(const param_type& __p)
      : _M_param(__p)
      { }






      void
      reset() { }

      result_type
      a() const
      { return _M_param.a(); }

      result_type
      b() const
      { return _M_param.b(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return this->a(); }




      result_type
      max() const
      { return this->b(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
        { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }





      friend bool
      operator==(const uniform_int_distribution& __d1,
   const uniform_int_distribution& __d2)
      { return __d1._M_param == __d2._M_param; }

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;
    };





  template<typename _IntType>
    inline bool
    operator!=(const std::uniform_int_distribution<_IntType>& __d1,
        const std::uniform_int_distribution<_IntType>& __d2)
    { return !(__d1 == __d2); }
# 1839 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _IntType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>&,
        const std::uniform_int_distribution<_IntType>&);
# 1853 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _IntType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>&,
        std::uniform_int_distribution<_IntType>&);
# 1866 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _RealType = double>
    class uniform_real_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");

    public:

      typedef _RealType result_type;

      struct param_type
      {
 typedef uniform_real_distribution<_RealType> distribution_type;

 explicit
 param_type(_RealType __a = _RealType(0),
     _RealType __b = _RealType(1))
 : _M_a(__a), _M_b(__b)
 {
                                      ;
 }

 result_type
 a() const
 { return _M_a; }

 result_type
 b() const
 { return _M_b; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b; }

      private:
 _RealType _M_a;
 _RealType _M_b;
      };

    public:






      explicit
      uniform_real_distribution(_RealType __a = _RealType(0),
    _RealType __b = _RealType(1))
      : _M_param(__a, __b)
      { }

      explicit
      uniform_real_distribution(const param_type& __p)
      : _M_param(__p)
      { }






      void
      reset() { }

      result_type
      a() const
      { return _M_param.a(); }

      result_type
      b() const
      { return _M_param.b(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return this->a(); }




      result_type
      max() const
      { return this->b(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
        { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 {
   __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
     __aurng(__urng);
   return (__aurng() * (__p.b() - __p.a())) + __p.a();
 }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }





      friend bool
      operator==(const uniform_real_distribution& __d1,
   const uniform_real_distribution& __d2)
      { return __d1._M_param == __d2._M_param; }

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;
    };





  template<typename _IntType>
    inline bool
    operator!=(const std::uniform_real_distribution<_IntType>& __d1,
        const std::uniform_real_distribution<_IntType>& __d2)
    { return !(__d1 == __d2); }
# 2048 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>&,
        const std::uniform_real_distribution<_RealType>&);
# 2062 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>&,
        std::uniform_real_distribution<_RealType>&);
# 2084 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _RealType = double>
    class normal_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");

    public:

      typedef _RealType result_type;

      struct param_type
      {
 typedef normal_distribution<_RealType> distribution_type;

 explicit
 param_type(_RealType __mean = _RealType(0),
     _RealType __stddev = _RealType(1))
 : _M_mean(__mean), _M_stddev(__stddev)
 {
                                                  ;
 }

 _RealType
 mean() const
 { return _M_mean; }

 _RealType
 stddev() const
 { return _M_stddev; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return (__p1._M_mean == __p2._M_mean
    && __p1._M_stddev == __p2._M_stddev); }

      private:
 _RealType _M_mean;
 _RealType _M_stddev;
      };

    public:




      explicit
      normal_distribution(result_type __mean = result_type(0),
     result_type __stddev = result_type(1))
      : _M_param(__mean, __stddev), _M_saved_available(false)
      { }

      explicit
      normal_distribution(const param_type& __p)
      : _M_param(__p), _M_saved_available(false)
      { }




      void
      reset()
      { _M_saved_available = false; }




      _RealType
      mean() const
      { return _M_param.mean(); }




      _RealType
      stddev() const
      { return _M_param.stddev(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return std::numeric_limits<result_type>::lowest(); }




      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }






      template<typename _RealType1>
 friend bool
        operator==(const std::normal_distribution<_RealType1>& __d1,
     const std::normal_distribution<_RealType1>& __d2);
# 2245 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::normal_distribution<_RealType1>& __x);
# 2260 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::normal_distribution<_RealType1>& __x);

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;
      result_type _M_saved;
      bool _M_saved_available;
    };




  template<typename _RealType>
    inline bool
    operator!=(const std::normal_distribution<_RealType>& __d1,
        const std::normal_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
# 2297 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _RealType = double>
    class lognormal_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");

    public:

      typedef _RealType result_type;

      struct param_type
      {
 typedef lognormal_distribution<_RealType> distribution_type;

 explicit
 param_type(_RealType __m = _RealType(0),
     _RealType __s = _RealType(1))
 : _M_m(__m), _M_s(__s)
 { }

 _RealType
 m() const
 { return _M_m; }

 _RealType
 s() const
 { return _M_s; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_m == __p2._M_m && __p1._M_s == __p2._M_s; }

      private:
 _RealType _M_m;
 _RealType _M_s;
      };

      explicit
      lognormal_distribution(_RealType __m = _RealType(0),
        _RealType __s = _RealType(1))
      : _M_param(__m, __s), _M_nd()
      { }

      explicit
      lognormal_distribution(const param_type& __p)
      : _M_param(__p), _M_nd()
      { }




      void
      reset()
      { _M_nd.reset(); }




      _RealType
      m() const
      { return _M_param.m(); }

      _RealType
      s() const
      { return _M_param.s(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return result_type(0); }




      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
        { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p)
        { return std::exp(__p.s() * _M_nd(__urng) + __p.m()); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }






      friend bool
      operator==(const lognormal_distribution& __d1,
   const lognormal_distribution& __d2)
      { return (__d1._M_param == __d2._M_param
  && __d1._M_nd == __d2._M_nd); }
# 2449 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::lognormal_distribution<_RealType1>& __x);
# 2464 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::lognormal_distribution<_RealType1>& __x);

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;

      std::normal_distribution<result_type> _M_nd;
    };




  template<typename _RealType>
    inline bool
    operator!=(const std::lognormal_distribution<_RealType>& __d1,
        const std::lognormal_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
# 2501 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _RealType = double>
    class gamma_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");

    public:

      typedef _RealType result_type;

      struct param_type
      {
 typedef gamma_distribution<_RealType> distribution_type;
 friend class gamma_distribution<_RealType>;

 explicit
 param_type(_RealType __alpha_val = _RealType(1),
     _RealType __beta_val = _RealType(1))
 : _M_alpha(__alpha_val), _M_beta(__beta_val)
 {
                                                 ;
   _M_initialize();
 }

 _RealType
 alpha() const
 { return _M_alpha; }

 _RealType
 beta() const
 { return _M_beta; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return (__p1._M_alpha == __p2._M_alpha
    && __p1._M_beta == __p2._M_beta); }

      private:
 void
 _M_initialize();

 _RealType _M_alpha;
 _RealType _M_beta;

 _RealType _M_malpha, _M_a2;
      };

    public:




      explicit
      gamma_distribution(_RealType __alpha_val = _RealType(1),
    _RealType __beta_val = _RealType(1))
      : _M_param(__alpha_val, __beta_val), _M_nd()
      { }

      explicit
      gamma_distribution(const param_type& __p)
      : _M_param(__p), _M_nd()
      { }




      void
      reset()
      { _M_nd.reset(); }




      _RealType
      alpha() const
      { return _M_param.alpha(); }




      _RealType
      beta() const
      { return _M_param.beta(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return result_type(0); }




      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }






      friend bool
      operator==(const gamma_distribution& __d1,
   const gamma_distribution& __d2)
      { return (__d1._M_param == __d2._M_param
  && __d1._M_nd == __d2._M_nd); }
# 2670 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::gamma_distribution<_RealType1>& __x);
# 2684 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::gamma_distribution<_RealType1>& __x);

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;

      std::normal_distribution<result_type> _M_nd;
    };




   template<typename _RealType>
     inline bool
     operator!=(const std::gamma_distribution<_RealType>& __d1,
  const std::gamma_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
# 2718 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _RealType = double>
    class chi_squared_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");

    public:

      typedef _RealType result_type;

      struct param_type
      {
 typedef chi_squared_distribution<_RealType> distribution_type;

 explicit
 param_type(_RealType __n = _RealType(1))
 : _M_n(__n)
 { }

 _RealType
 n() const
 { return _M_n; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_n == __p2._M_n; }

      private:
 _RealType _M_n;
      };

      explicit
      chi_squared_distribution(_RealType __n = _RealType(1))
      : _M_param(__n), _M_gd(__n / 2)
      { }

      explicit
      chi_squared_distribution(const param_type& __p)
      : _M_param(__p), _M_gd(__p.n() / 2)
      { }




      void
      reset()
      { _M_gd.reset(); }




      _RealType
      n() const
      { return _M_param.n(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return result_type(0); }




      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return 2 * _M_gd(__urng); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p)
        {
   typedef typename std::gamma_distribution<result_type>::param_type
     param_type;
   return 2 * _M_gd(__urng, param_type(__p.n() / 2));
 }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
        { this->__generate_impl(__f, __t, __urng); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { typename std::gamma_distribution<result_type>::param_type
     __p2(__p.n() / 2);
   this->__generate_impl(__f, __t, __urng, __p2); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng)
        { this->__generate_impl(__f, __t, __urng); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { typename std::gamma_distribution<result_type>::param_type
     __p2(__p.n() / 2);
   this->__generate_impl(__f, __t, __urng, __p2); }






      friend bool
      operator==(const chi_squared_distribution& __d1,
   const chi_squared_distribution& __d2)
      { return __d1._M_param == __d2._M_param && __d1._M_gd == __d2._M_gd; }
# 2872 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::chi_squared_distribution<_RealType1>& __x);
# 2887 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::chi_squared_distribution<_RealType1>& __x);

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng);

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const typename
   std::gamma_distribution<result_type>::param_type& __p);

      param_type _M_param;

      std::gamma_distribution<result_type> _M_gd;
    };




  template<typename _RealType>
    inline bool
    operator!=(const std::chi_squared_distribution<_RealType>& __d1,
        const std::chi_squared_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
# 2928 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _RealType = double>
    class cauchy_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");

    public:

      typedef _RealType result_type;

      struct param_type
      {
 typedef cauchy_distribution<_RealType> distribution_type;

 explicit
 param_type(_RealType __a = _RealType(0),
     _RealType __b = _RealType(1))
 : _M_a(__a), _M_b(__b)
 { }

 _RealType
 a() const
 { return _M_a; }

 _RealType
 b() const
 { return _M_b; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b; }

      private:
 _RealType _M_a;
 _RealType _M_b;
      };

      explicit
      cauchy_distribution(_RealType __a = _RealType(0),
     _RealType __b = _RealType(1))
      : _M_param(__a, __b)
      { }

      explicit
      cauchy_distribution(const param_type& __p)
      : _M_param(__p)
      { }




      void
      reset()
      { }




      _RealType
      a() const
      { return _M_param.a(); }

      _RealType
      b() const
      { return _M_param.b(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return std::numeric_limits<result_type>::lowest(); }




      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }





      friend bool
      operator==(const cauchy_distribution& __d1,
   const cauchy_distribution& __d2)
      { return __d1._M_param == __d2._M_param; }

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;
    };





  template<typename _RealType>
    inline bool
    operator!=(const std::cauchy_distribution<_RealType>& __d1,
        const std::cauchy_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
# 3098 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const std::cauchy_distribution<_RealType>& __x);
# 3113 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        std::cauchy_distribution<_RealType>& __x);
# 3129 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _RealType = double>
    class fisher_f_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");

    public:

      typedef _RealType result_type;

      struct param_type
      {
 typedef fisher_f_distribution<_RealType> distribution_type;

 explicit
 param_type(_RealType __m = _RealType(1),
     _RealType __n = _RealType(1))
 : _M_m(__m), _M_n(__n)
 { }

 _RealType
 m() const
 { return _M_m; }

 _RealType
 n() const
 { return _M_n; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_m == __p2._M_m && __p1._M_n == __p2._M_n; }

      private:
 _RealType _M_m;
 _RealType _M_n;
      };

      explicit
      fisher_f_distribution(_RealType __m = _RealType(1),
       _RealType __n = _RealType(1))
      : _M_param(__m, __n), _M_gd_x(__m / 2), _M_gd_y(__n / 2)
      { }

      explicit
      fisher_f_distribution(const param_type& __p)
      : _M_param(__p), _M_gd_x(__p.m() / 2), _M_gd_y(__p.n() / 2)
      { }




      void
      reset()
      {
 _M_gd_x.reset();
 _M_gd_y.reset();
      }




      _RealType
      m() const
      { return _M_param.m(); }

      _RealType
      n() const
      { return _M_param.n(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return result_type(0); }




      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return (_M_gd_x(__urng) * n()) / (_M_gd_y(__urng) * m()); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p)
        {
   typedef typename std::gamma_distribution<result_type>::param_type
     param_type;
   return ((_M_gd_x(__urng, param_type(__p.m() / 2)) * n())
    / (_M_gd_y(__urng, param_type(__p.n() / 2)) * m()));
 }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate_impl(__f, __t, __urng); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate_impl(__f, __t, __urng); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }






      friend bool
      operator==(const fisher_f_distribution& __d1,
   const fisher_f_distribution& __d2)
      { return (__d1._M_param == __d2._M_param
  && __d1._M_gd_x == __d2._M_gd_x
  && __d1._M_gd_y == __d2._M_gd_y); }
# 3296 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::fisher_f_distribution<_RealType1>& __x);
# 3311 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::fisher_f_distribution<_RealType1>& __x);

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng);

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;

      std::gamma_distribution<result_type> _M_gd_x, _M_gd_y;
    };




  template<typename _RealType>
    inline bool
    operator!=(const std::fisher_f_distribution<_RealType>& __d1,
        const std::fisher_f_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
# 3353 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _RealType = double>
    class student_t_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");

    public:

      typedef _RealType result_type;

      struct param_type
      {
 typedef student_t_distribution<_RealType> distribution_type;

 explicit
 param_type(_RealType __n = _RealType(1))
 : _M_n(__n)
 { }

 _RealType
 n() const
 { return _M_n; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_n == __p2._M_n; }

      private:
 _RealType _M_n;
      };

      explicit
      student_t_distribution(_RealType __n = _RealType(1))
      : _M_param(__n), _M_nd(), _M_gd(__n / 2, 2)
      { }

      explicit
      student_t_distribution(const param_type& __p)
      : _M_param(__p), _M_nd(), _M_gd(__p.n() / 2, 2)
      { }




      void
      reset()
      {
 _M_nd.reset();
 _M_gd.reset();
      }




      _RealType
      n() const
      { return _M_param.n(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return std::numeric_limits<result_type>::lowest(); }




      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
        operator()(_UniformRandomNumberGenerator& __urng)
        { return _M_nd(__urng) * std::sqrt(n() / _M_gd(__urng)); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p)
        {
   typedef typename std::gamma_distribution<result_type>::param_type
     param_type;

   const result_type __g = _M_gd(__urng, param_type(__p.n() / 2, 2));
   return _M_nd(__urng) * std::sqrt(__p.n() / __g);
        }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate_impl(__f, __t, __urng); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate_impl(__f, __t, __urng); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }






      friend bool
      operator==(const student_t_distribution& __d1,
   const student_t_distribution& __d2)
      { return (__d1._M_param == __d2._M_param
  && __d1._M_nd == __d2._M_nd && __d1._M_gd == __d2._M_gd); }
# 3509 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::student_t_distribution<_RealType1>& __x);
# 3524 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::student_t_distribution<_RealType1>& __x);

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng);
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;

      std::normal_distribution<result_type> _M_nd;
      std::gamma_distribution<result_type> _M_gd;
    };




  template<typename _RealType>
    inline bool
    operator!=(const std::student_t_distribution<_RealType>& __d1,
        const std::student_t_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
# 3572 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  class bernoulli_distribution
  {
  public:

    typedef bool result_type;

    struct param_type
    {
      typedef bernoulli_distribution distribution_type;

      explicit
      param_type(double __p = 0.5)
      : _M_p(__p)
      {
                                                      ;
      }

      double
      p() const
      { return _M_p; }

      friend bool
      operator==(const param_type& __p1, const param_type& __p2)
      { return __p1._M_p == __p2._M_p; }

    private:
      double _M_p;
    };

  public:






    explicit
    bernoulli_distribution(double __p = 0.5)
    : _M_param(__p)
    { }

    explicit
    bernoulli_distribution(const param_type& __p)
    : _M_param(__p)
    { }






    void
    reset() { }




    double
    p() const
    { return _M_param.p(); }




    param_type
    param() const
    { return _M_param; }





    void
    param(const param_type& __param)
    { _M_param = __param; }




    result_type
    min() const
    { return std::numeric_limits<result_type>::min(); }




    result_type
    max() const
    { return std::numeric_limits<result_type>::max(); }




    template<typename _UniformRandomNumberGenerator>
      result_type
      operator()(_UniformRandomNumberGenerator& __urng)
      { return this->operator()(__urng, _M_param); }

    template<typename _UniformRandomNumberGenerator>
      result_type
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __p)
      {
 __detail::_Adaptor<_UniformRandomNumberGenerator, double>
   __aurng(__urng);
 if ((__aurng() - __aurng.min())
      < __p.p() * (__aurng.max() - __aurng.min()))
   return true;
 return false;
      }

    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      __generate(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng)
      { this->__generate(__f, __t, __urng, _M_param); }

    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      __generate(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng, const param_type& __p)
      { this->__generate_impl(__f, __t, __urng, __p); }

    template<typename _UniformRandomNumberGenerator>
      void
      __generate(result_type* __f, result_type* __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p)
      { this->__generate_impl(__f, __t, __urng, __p); }





    friend bool
    operator==(const bernoulli_distribution& __d1,
        const bernoulli_distribution& __d2)
    { return __d1._M_param == __d2._M_param; }

  private:
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __p);

    param_type _M_param;
  };





  inline bool
  operator!=(const std::bernoulli_distribution& __d1,
      const std::bernoulli_distribution& __d2)
  { return !(__d1 == __d2); }
# 3743 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const std::bernoulli_distribution& __x);
# 3757 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        std::bernoulli_distribution& __x)
    {
      double __p;
      __is >> __p;
      __x.param(bernoulli_distribution::param_type(__p));
      return __is;
    }
# 3776 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _IntType = int>
    class binomial_distribution
    {
      static_assert(std::is_integral<_IntType>::value,
      "template argument not an integral type");

    public:

      typedef _IntType result_type;

      struct param_type
      {
 typedef binomial_distribution<_IntType> distribution_type;
 friend class binomial_distribution<_IntType>;

 explicit
 param_type(_IntType __t = _IntType(1), double __p = 0.5)
 : _M_t(__t), _M_p(__p)
 {


                     ;
   _M_initialize();
 }

 _IntType
 t() const
 { return _M_t; }

 double
 p() const
 { return _M_p; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_t == __p2._M_t && __p1._M_p == __p2._M_p; }

      private:
 void
 _M_initialize();

 _IntType _M_t;
 double _M_p;

 double _M_q;

 double _M_d1, _M_d2, _M_s1, _M_s2, _M_c,
        _M_a1, _M_a123, _M_s, _M_lf, _M_lp1p;

 bool _M_easy;
      };


      explicit
      binomial_distribution(_IntType __t = _IntType(1),
       double __p = 0.5)
      : _M_param(__t, __p), _M_nd()
      { }

      explicit
      binomial_distribution(const param_type& __p)
      : _M_param(__p), _M_nd()
      { }




      void
      reset()
      { _M_nd.reset(); }




      _IntType
      t() const
      { return _M_param.t(); }




      double
      p() const
      { return _M_param.p(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return 0; }




      result_type
      max() const
      { return _M_param.t(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }






 friend bool
        operator==(const binomial_distribution& __d1,
     const binomial_distribution& __d2)

 { return __d1._M_param == __d2._M_param && __d1._M_nd == __d2._M_nd; }
# 3949 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      template<typename _IntType1,
        typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::binomial_distribution<_IntType1>& __x);
# 3965 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      template<typename _IntType1,
        typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::binomial_distribution<_IntType1>& __x);

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      template<typename _UniformRandomNumberGenerator>
 result_type
 _M_waiting(_UniformRandomNumberGenerator& __urng,
     _IntType __t, double __q);

      param_type _M_param;


      std::normal_distribution<double> _M_nd;
    };




  template<typename _IntType>
    inline bool
    operator!=(const std::binomial_distribution<_IntType>& __d1,
        const std::binomial_distribution<_IntType>& __d2)
    { return !(__d1 == __d2); }
# 4007 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _IntType = int>
    class geometric_distribution
    {
      static_assert(std::is_integral<_IntType>::value,
      "template argument not an integral type");

    public:

      typedef _IntType result_type;

      struct param_type
      {
 typedef geometric_distribution<_IntType> distribution_type;
 friend class geometric_distribution<_IntType>;

 explicit
 param_type(double __p = 0.5)
 : _M_p(__p)
 {
                                                      ;
   _M_initialize();
 }

 double
 p() const
 { return _M_p; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_p == __p2._M_p; }

      private:
 void
 _M_initialize()
 { _M_log_1_p = std::log(1.0 - _M_p); }

 double _M_p;

 double _M_log_1_p;
      };


      explicit
      geometric_distribution(double __p = 0.5)
      : _M_param(__p)
      { }

      explicit
      geometric_distribution(const param_type& __p)
      : _M_param(__p)
      { }






      void
      reset() { }




      double
      p() const
      { return _M_param.p(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return 0; }




      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }





      friend bool
      operator==(const geometric_distribution& __d1,
   const geometric_distribution& __d2)
      { return __d1._M_param == __d2._M_param; }

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;
    };





  template<typename _IntType>
    inline bool
    operator!=(const std::geometric_distribution<_IntType>& __d1,
        const std::geometric_distribution<_IntType>& __d2)
    { return !(__d1 == __d2); }
# 4178 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _IntType,
    typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const std::geometric_distribution<_IntType>& __x);
# 4193 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _IntType,
    typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        std::geometric_distribution<_IntType>& __x);
# 4207 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _IntType = int>
    class negative_binomial_distribution
    {
      static_assert(std::is_integral<_IntType>::value,
      "template argument not an integral type");

    public:

      typedef _IntType result_type;

      struct param_type
      {
 typedef negative_binomial_distribution<_IntType> distribution_type;

 explicit
 param_type(_IntType __k = 1, double __p = 0.5)
 : _M_k(__k), _M_p(__p)
 {
                                                                     ;
 }

 _IntType
 k() const
 { return _M_k; }

 double
 p() const
 { return _M_p; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_k == __p2._M_k && __p1._M_p == __p2._M_p; }

      private:
 _IntType _M_k;
 double _M_p;
      };

      explicit
      negative_binomial_distribution(_IntType __k = 1, double __p = 0.5)
      : _M_param(__k, __p), _M_gd(__k, (1.0 - __p) / __p)
      { }

      explicit
      negative_binomial_distribution(const param_type& __p)
      : _M_param(__p), _M_gd(__p.k(), (1.0 - __p.p()) / __p.p())
      { }




      void
      reset()
      { _M_gd.reset(); }




      _IntType
      k() const
      { return _M_param.k(); }




      double
      p() const
      { return _M_param.p(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return result_type(0); }




      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
        operator()(_UniformRandomNumberGenerator& __urng);

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate_impl(__f, __t, __urng); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate_impl(__f, __t, __urng); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }






      friend bool
      operator==(const negative_binomial_distribution& __d1,
   const negative_binomial_distribution& __d2)
      { return __d1._M_param == __d2._M_param && __d1._M_gd == __d2._M_gd; }
# 4366 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      template<typename _IntType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::negative_binomial_distribution<_IntType1>& __x);
# 4381 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      template<typename _IntType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::negative_binomial_distribution<_IntType1>& __x);

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng);
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;

      std::gamma_distribution<double> _M_gd;
    };




  template<typename _IntType>
    inline bool
    operator!=(const std::negative_binomial_distribution<_IntType>& __d1,
        const std::negative_binomial_distribution<_IntType>& __d2)
    { return !(__d1 == __d2); }
# 4429 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _IntType = int>
    class poisson_distribution
    {
      static_assert(std::is_integral<_IntType>::value,
      "template argument not an integral type");

    public:

      typedef _IntType result_type;

      struct param_type
      {
 typedef poisson_distribution<_IntType> distribution_type;
 friend class poisson_distribution<_IntType>;

 explicit
 param_type(double __mean = 1.0)
 : _M_mean(__mean)
 {
                                       ;
   _M_initialize();
 }

 double
 mean() const
 { return _M_mean; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_mean == __p2._M_mean; }

      private:

 void
 _M_initialize();

 double _M_mean;

 double _M_lm_thr;

 double _M_lfm, _M_sm, _M_d, _M_scx, _M_1cx, _M_c2b, _M_cb;

      };


      explicit
      poisson_distribution(double __mean = 1.0)
      : _M_param(__mean), _M_nd()
      { }

      explicit
      poisson_distribution(const param_type& __p)
      : _M_param(__p), _M_nd()
      { }




      void
      reset()
      { _M_nd.reset(); }




      double
      mean() const
      { return _M_param.mean(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return 0; }




      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }






      friend bool
      operator==(const poisson_distribution& __d1,
   const poisson_distribution& __d2)

      { return __d1._M_param == __d2._M_param && __d1._M_nd == __d2._M_nd; }
# 4586 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      template<typename _IntType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::poisson_distribution<_IntType1>& __x);
# 4601 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      template<typename _IntType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::poisson_distribution<_IntType1>& __x);

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;


      std::normal_distribution<double> _M_nd;
    };




  template<typename _IntType>
    inline bool
    operator!=(const std::poisson_distribution<_IntType>& __d1,
        const std::poisson_distribution<_IntType>& __d2)
    { return !(__d1 == __d2); }
# 4645 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _RealType = double>
    class exponential_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");

    public:

      typedef _RealType result_type;

      struct param_type
      {
 typedef exponential_distribution<_RealType> distribution_type;

 explicit
 param_type(_RealType __lambda = _RealType(1))
 : _M_lambda(__lambda)
 {
                                                  ;
 }

 _RealType
 lambda() const
 { return _M_lambda; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_lambda == __p2._M_lambda; }

      private:
 _RealType _M_lambda;
      };

    public:




      explicit
      exponential_distribution(const result_type& __lambda = result_type(1))
      : _M_param(__lambda)
      { }

      explicit
      exponential_distribution(const param_type& __p)
      : _M_param(__p)
      { }






      void
      reset() { }




      _RealType
      lambda() const
      { return _M_param.lambda(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return result_type(0); }




      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
        { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 {
   __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
     __aurng(__urng);
   return -std::log(result_type(1) - __aurng()) / __p.lambda();
 }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }





      friend bool
      operator==(const exponential_distribution& __d1,
   const exponential_distribution& __d2)
      { return __d1._M_param == __d2._M_param; }

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;
    };





  template<typename _RealType>
    inline bool
    operator!=(const std::exponential_distribution<_RealType>& __d1,
        const std::exponential_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
# 4817 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const std::exponential_distribution<_RealType>& __x);
# 4832 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        std::exponential_distribution<_RealType>& __x);
# 4847 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _RealType = double>
    class weibull_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");

    public:

      typedef _RealType result_type;

      struct param_type
      {
 typedef weibull_distribution<_RealType> distribution_type;

 explicit
 param_type(_RealType __a = _RealType(1),
     _RealType __b = _RealType(1))
 : _M_a(__a), _M_b(__b)
 { }

 _RealType
 a() const
 { return _M_a; }

 _RealType
 b() const
 { return _M_b; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b; }

      private:
 _RealType _M_a;
 _RealType _M_b;
      };

      explicit
      weibull_distribution(_RealType __a = _RealType(1),
      _RealType __b = _RealType(1))
      : _M_param(__a, __b)
      { }

      explicit
      weibull_distribution(const param_type& __p)
      : _M_param(__p)
      { }




      void
      reset()
      { }




      _RealType
      a() const
      { return _M_param.a(); }




      _RealType
      b() const
      { return _M_param.b(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return result_type(0); }




      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }





      friend bool
      operator==(const weibull_distribution& __d1,
   const weibull_distribution& __d2)
      { return __d1._M_param == __d2._M_param; }

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;
    };





  template<typename _RealType>
    inline bool
    operator!=(const std::weibull_distribution<_RealType>& __d1,
        const std::weibull_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
# 5020 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const std::weibull_distribution<_RealType>& __x);
# 5035 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        std::weibull_distribution<_RealType>& __x);
# 5050 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _RealType = double>
    class extreme_value_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");

    public:

      typedef _RealType result_type;

      struct param_type
      {
 typedef extreme_value_distribution<_RealType> distribution_type;

 explicit
 param_type(_RealType __a = _RealType(0),
     _RealType __b = _RealType(1))
 : _M_a(__a), _M_b(__b)
 { }

 _RealType
 a() const
 { return _M_a; }

 _RealType
 b() const
 { return _M_b; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b; }

      private:
 _RealType _M_a;
 _RealType _M_b;
      };

      explicit
      extreme_value_distribution(_RealType __a = _RealType(0),
     _RealType __b = _RealType(1))
      : _M_param(__a, __b)
      { }

      explicit
      extreme_value_distribution(const param_type& __p)
      : _M_param(__p)
      { }




      void
      reset()
      { }




      _RealType
      a() const
      { return _M_param.a(); }




      _RealType
      b() const
      { return _M_param.b(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return std::numeric_limits<result_type>::lowest(); }




      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }





      friend bool
      operator==(const extreme_value_distribution& __d1,
   const extreme_value_distribution& __d2)
      { return __d1._M_param == __d2._M_param; }

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;
    };





  template<typename _RealType>
    inline bool
    operator!=(const std::extreme_value_distribution<_RealType>& __d1,
        const std::extreme_value_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
# 5223 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const std::extreme_value_distribution<_RealType>& __x);
# 5238 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        std::extreme_value_distribution<_RealType>& __x);
# 5250 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _IntType = int>
    class discrete_distribution
    {
      static_assert(std::is_integral<_IntType>::value,
      "template argument not an integral type");

    public:

      typedef _IntType result_type;

      struct param_type
      {
 typedef discrete_distribution<_IntType> distribution_type;
 friend class discrete_distribution<_IntType>;

 param_type()
 : _M_prob(), _M_cp()
 { }

 template<typename _InputIterator>
   param_type(_InputIterator __wbegin,
       _InputIterator __wend)
   : _M_prob(__wbegin, __wend), _M_cp()
   { _M_initialize(); }

 param_type(initializer_list<double> __wil)
 : _M_prob(__wil.begin(), __wil.end()), _M_cp()
 { _M_initialize(); }

 template<typename _Func>
   param_type(size_t __nw, double __xmin, double __xmax,
       _Func __fw);


 param_type(const param_type&) = default;
 param_type& operator=(const param_type&) = default;

 std::vector<double>
 probabilities() const
 { return _M_prob.empty() ? std::vector<double>(1, 1.0) : _M_prob; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_prob == __p2._M_prob; }

      private:
 void
 _M_initialize();

 std::vector<double> _M_prob;
 std::vector<double> _M_cp;
      };

      discrete_distribution()
      : _M_param()
      { }

      template<typename _InputIterator>
 discrete_distribution(_InputIterator __wbegin,
         _InputIterator __wend)
 : _M_param(__wbegin, __wend)
 { }

      discrete_distribution(initializer_list<double> __wl)
      : _M_param(__wl)
      { }

      template<typename _Func>
 discrete_distribution(size_t __nw, double __xmin, double __xmax,
         _Func __fw)
 : _M_param(__nw, __xmin, __xmax, __fw)
 { }

      explicit
      discrete_distribution(const param_type& __p)
      : _M_param(__p)
      { }




      void
      reset()
      { }




      std::vector<double>
      probabilities() const
      {
 return _M_param._M_prob.empty()
   ? std::vector<double>(1, 1.0) : _M_param._M_prob;
      }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return result_type(0); }




      result_type
      max() const
      {
 return _M_param._M_prob.empty()
   ? result_type(0) : result_type(_M_param._M_prob.size() - 1);
      }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }





      friend bool
      operator==(const discrete_distribution& __d1,
   const discrete_distribution& __d2)
      { return __d1._M_param == __d2._M_param; }
# 5431 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      template<typename _IntType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::discrete_distribution<_IntType1>& __x);
# 5447 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      template<typename _IntType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::discrete_distribution<_IntType1>& __x);

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;
    };





  template<typename _IntType>
    inline bool
    operator!=(const std::discrete_distribution<_IntType>& __d1,
        const std::discrete_distribution<_IntType>& __d2)
    { return !(__d1 == __d2); }
# 5480 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _RealType = double>
    class piecewise_constant_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");

    public:

      typedef _RealType result_type;

      struct param_type
      {
 typedef piecewise_constant_distribution<_RealType> distribution_type;
 friend class piecewise_constant_distribution<_RealType>;

 param_type()
 : _M_int(), _M_den(), _M_cp()
 { }

 template<typename _InputIteratorB, typename _InputIteratorW>
   param_type(_InputIteratorB __bfirst,
       _InputIteratorB __bend,
       _InputIteratorW __wbegin);

 template<typename _Func>
   param_type(initializer_list<_RealType> __bi, _Func __fw);

 template<typename _Func>
   param_type(size_t __nw, _RealType __xmin, _RealType __xmax,
       _Func __fw);


 param_type(const param_type&) = default;
 param_type& operator=(const param_type&) = default;

 std::vector<_RealType>
 intervals() const
 {
   if (_M_int.empty())
     {
       std::vector<_RealType> __tmp(2);
       __tmp[1] = _RealType(1);
       return __tmp;
     }
   else
     return _M_int;
 }

 std::vector<double>
 densities() const
 { return _M_den.empty() ? std::vector<double>(1, 1.0) : _M_den; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_int == __p2._M_int && __p1._M_den == __p2._M_den; }

      private:
 void
 _M_initialize();

 std::vector<_RealType> _M_int;
 std::vector<double> _M_den;
 std::vector<double> _M_cp;
      };

      explicit
      piecewise_constant_distribution()
      : _M_param()
      { }

      template<typename _InputIteratorB, typename _InputIteratorW>
 piecewise_constant_distribution(_InputIteratorB __bfirst,
     _InputIteratorB __bend,
     _InputIteratorW __wbegin)
 : _M_param(__bfirst, __bend, __wbegin)
 { }

      template<typename _Func>
 piecewise_constant_distribution(initializer_list<_RealType> __bl,
     _Func __fw)
 : _M_param(__bl, __fw)
 { }

      template<typename _Func>
 piecewise_constant_distribution(size_t __nw,
     _RealType __xmin, _RealType __xmax,
     _Func __fw)
 : _M_param(__nw, __xmin, __xmax, __fw)
 { }

      explicit
      piecewise_constant_distribution(const param_type& __p)
      : _M_param(__p)
      { }




      void
      reset()
      { }




      std::vector<_RealType>
      intervals() const
      {
 if (_M_param._M_int.empty())
   {
     std::vector<_RealType> __tmp(2);
     __tmp[1] = _RealType(1);
     return __tmp;
   }
 else
   return _M_param._M_int;
      }




      std::vector<double>
      densities() const
      {
 return _M_param._M_den.empty()
   ? std::vector<double>(1, 1.0) : _M_param._M_den;
      }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      {
 return _M_param._M_int.empty()
   ? result_type(0) : _M_param._M_int.front();
      }




      result_type
      max() const
      {
 return _M_param._M_int.empty()
   ? result_type(1) : _M_param._M_int.back();
      }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }





      friend bool
      operator==(const piecewise_constant_distribution& __d1,
   const piecewise_constant_distribution& __d2)
      { return __d1._M_param == __d2._M_param; }
# 5698 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::piecewise_constant_distribution<_RealType1>& __x);
# 5714 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::piecewise_constant_distribution<_RealType1>& __x);

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;
    };





  template<typename _RealType>
    inline bool
    operator!=(const std::piecewise_constant_distribution<_RealType>& __d1,
        const std::piecewise_constant_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
# 5747 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  template<typename _RealType = double>
    class piecewise_linear_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");

    public:

      typedef _RealType result_type;

      struct param_type
      {
 typedef piecewise_linear_distribution<_RealType> distribution_type;
 friend class piecewise_linear_distribution<_RealType>;

 param_type()
 : _M_int(), _M_den(), _M_cp(), _M_m()
 { }

 template<typename _InputIteratorB, typename _InputIteratorW>
   param_type(_InputIteratorB __bfirst,
       _InputIteratorB __bend,
       _InputIteratorW __wbegin);

 template<typename _Func>
   param_type(initializer_list<_RealType> __bl, _Func __fw);

 template<typename _Func>
   param_type(size_t __nw, _RealType __xmin, _RealType __xmax,
       _Func __fw);


 param_type(const param_type&) = default;
 param_type& operator=(const param_type&) = default;

 std::vector<_RealType>
 intervals() const
 {
   if (_M_int.empty())
     {
       std::vector<_RealType> __tmp(2);
       __tmp[1] = _RealType(1);
       return __tmp;
     }
   else
     return _M_int;
 }

 std::vector<double>
 densities() const
 { return _M_den.empty() ? std::vector<double>(2, 1.0) : _M_den; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return (__p1._M_int == __p2._M_int
    && __p1._M_den == __p2._M_den); }

      private:
 void
 _M_initialize();

 std::vector<_RealType> _M_int;
 std::vector<double> _M_den;
 std::vector<double> _M_cp;
 std::vector<double> _M_m;
      };

      explicit
      piecewise_linear_distribution()
      : _M_param()
      { }

      template<typename _InputIteratorB, typename _InputIteratorW>
 piecewise_linear_distribution(_InputIteratorB __bfirst,
          _InputIteratorB __bend,
          _InputIteratorW __wbegin)
 : _M_param(__bfirst, __bend, __wbegin)
 { }

      template<typename _Func>
 piecewise_linear_distribution(initializer_list<_RealType> __bl,
          _Func __fw)
 : _M_param(__bl, __fw)
 { }

      template<typename _Func>
 piecewise_linear_distribution(size_t __nw,
          _RealType __xmin, _RealType __xmax,
          _Func __fw)
 : _M_param(__nw, __xmin, __xmax, __fw)
 { }

      explicit
      piecewise_linear_distribution(const param_type& __p)
      : _M_param(__p)
      { }




      void
      reset()
      { }




      std::vector<_RealType>
      intervals() const
      {
 if (_M_param._M_int.empty())
   {
     std::vector<_RealType> __tmp(2);
     __tmp[1] = _RealType(1);
     return __tmp;
   }
 else
   return _M_param._M_int;
      }





      std::vector<double>
      densities() const
      {
 return _M_param._M_den.empty()
   ? std::vector<double>(2, 1.0) : _M_param._M_den;
      }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      {
 return _M_param._M_int.empty()
   ? result_type(0) : _M_param._M_int.front();
      }




      result_type
      max() const
      {
 return _M_param._M_int.empty()
   ? result_type(1) : _M_param._M_int.back();
      }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }





      friend bool
      operator==(const piecewise_linear_distribution& __d1,
   const piecewise_linear_distribution& __d2)
      { return __d1._M_param == __d2._M_param; }
# 5968 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::piecewise_linear_distribution<_RealType1>& __x);
# 5984 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::piecewise_linear_distribution<_RealType1>& __x);

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;
    };





  template<typename _RealType>
    inline bool
    operator!=(const std::piecewise_linear_distribution<_RealType>& __d1,
        const std::piecewise_linear_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
# 6025 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.h" 3
  class seed_seq
  {

  public:

    typedef uint_least32_t result_type;


    seed_seq()
    : _M_v()
    { }

    template<typename _IntType>
      seed_seq(std::initializer_list<_IntType> il);

    template<typename _InputIterator>
      seed_seq(_InputIterator __begin, _InputIterator __end);


    template<typename _RandomAccessIterator>
      void
      generate(_RandomAccessIterator __begin, _RandomAccessIterator __end);


    size_t size() const
    { return _M_v.size(); }

    template<typename OutputIterator>
      void
      param(OutputIterator __dest) const
      { std::copy(_M_v.begin(), _M_v.end(), __dest); }

  private:

    std::vector<result_type> _M_v;
  };






}
# 51 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/random" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/opt_random.h" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/opt_random.h" 3
# 1 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/x86intrin.h" 1 3
# 27 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/x86intrin.h" 3
# 1 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/ia32intrin.h" 1 3
# 32 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/ia32intrin.h" 3
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__))
__readeflags(void)
{
  unsigned long long __res = 0;
  __asm__ __volatile__ ("pushf\n\t"
                        "popq %0\n"
                        :"=r"(__res)
                        :
                        :
                       );
  return __res;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
__writeeflags(unsigned long long __f)
{
  __asm__ __volatile__ ("pushq %0\n\t"
                        "popf\n"
                        :
                        :"r"(__f)
                        :"flags"
                       );
}
# 82 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/ia32intrin.h" 3
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__))
__rdpmc(int __A) {
  return __builtin_ia32_rdpmc(__A);
}


static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__))
__rdtsc(void) {
  return __builtin_ia32_rdtsc();
}


static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__))
__rdtscp(unsigned int *__A) {
  return __builtin_ia32_rdtscp(__A);
}
# 28 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/x86intrin.h" 2 3

# 1 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/immintrin.h" 1 3
# 28 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/immintrin.h" 3
# 1 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/mmintrin.h" 1 3
# 31 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/mmintrin.h" 3
typedef long long __m64 __attribute__((__vector_size__(8)));

typedef int __v2si __attribute__((__vector_size__(8)));
typedef short __v4hi __attribute__((__vector_size__(8)));
typedef char __v8qi __attribute__((__vector_size__(8)));

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_empty(void)
{
    __builtin_ia32_emms();
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi32_si64(int __i)
{
    return (__m64)__builtin_ia32_vec_init_v2si(__i, 0);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi64_si32(__m64 __m)
{
    return __builtin_ia32_vec_ext_v2si((__v2si)__m, 0);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi64_m64(long long __i)
{
    return (__m64)__i;
}

static __inline__ long long __attribute__((__always_inline__, __nodebug__))
_mm_cvtm64_si64(__m64 __m)
{
    return (long long)__m;
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_packs_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_packsswb((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_packs_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_packssdw((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_packs_pu16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_packuswb((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckhbw((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckhwd((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckhdq((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpcklbw((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpcklwd((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckldq((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_add_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_add_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_add_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddd((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_adds_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddsb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_adds_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddsw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_adds_pu8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddusb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_adds_pu16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddusw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sub_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sub_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sub_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubd((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_subs_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubsb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_subs_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubsw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_subs_pu8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubusb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_subs_pu16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubusw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_madd_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pmaddwd((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_mulhi_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pmulhw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_mullo_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pmullw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sll_pi16(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psllw((__v4hi)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_slli_pi16(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psllwi((__v4hi)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sll_pi32(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_pslld((__v2si)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_slli_pi32(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_pslldi((__v2si)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sll_si64(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psllq(__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_slli_si64(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psllqi(__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sra_pi16(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psraw((__v4hi)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srai_pi16(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrawi((__v4hi)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sra_pi32(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrad((__v2si)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srai_pi32(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psradi((__v2si)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srl_pi16(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrlw((__v4hi)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srli_pi16(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrlwi((__v4hi)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srl_pi32(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrld((__v2si)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srli_pi32(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrldi((__v2si)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srl_si64(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrlq(__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srli_si64(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrlqi(__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_and_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_pand(__m1, __m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_andnot_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_pandn(__m1, __m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_or_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_por(__m1, __m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_xor_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_pxor(__m1, __m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpeqb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpeqw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpeqd((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpgtb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpgtw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpgtd((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_setzero_si64(void)
{
    return (__m64){ 0LL };
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_set_pi32(int __i1, int __i0)
{
    return (__m64)__builtin_ia32_vec_init_v2si(__i0, __i1);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_set_pi16(short __s3, short __s2, short __s1, short __s0)
{
    return (__m64)__builtin_ia32_vec_init_v4hi(__s0, __s1, __s2, __s3);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_set_pi8(char __b7, char __b6, char __b5, char __b4, char __b3, char __b2,
            char __b1, char __b0)
{
    return (__m64)__builtin_ia32_vec_init_v8qi(__b0, __b1, __b2, __b3,
                                               __b4, __b5, __b6, __b7);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_set1_pi32(int __i)
{
    return _mm_set_pi32(__i, __i);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_set1_pi16(short __w)
{
    return _mm_set_pi16(__w, __w, __w, __w);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_set1_pi8(char __b)
{
    return _mm_set_pi8(__b, __b, __b, __b, __b, __b, __b, __b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_setr_pi32(int __i0, int __i1)
{
    return _mm_set_pi32(__i1, __i0);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_setr_pi16(short __w0, short __w1, short __w2, short __w3)
{
    return _mm_set_pi16(__w3, __w2, __w1, __w0);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_setr_pi8(char __b0, char __b1, char __b2, char __b3, char __b4, char __b5,
             char __b6, char __b7)
{
    return _mm_set_pi8(__b7, __b6, __b5, __b4, __b3, __b2, __b1, __b0);
}
# 29 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/immintrin.h" 2 3



# 1 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/xmmintrin.h" 1 3
# 33 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/xmmintrin.h" 3
typedef int __v4si __attribute__((__vector_size__(16)));
typedef float __v4sf __attribute__((__vector_size__(16)));
typedef float __m128 __attribute__((__vector_size__(16)));





# 1 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/mm_malloc.h" 1 3
# 39 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/mm_malloc.h" 3
extern "C" int posix_memalign(void **__memptr, size_t __alignment, size_t __size);




static __inline__ void *__attribute__((__always_inline__, __nodebug__,
                                       __malloc__))
_mm_malloc(size_t __size, size_t __align)
{
  if (__align == 1) {
    return malloc(__size);
  }

  if (!(__align & (__align - 1)) && __align < sizeof(void *))
    __align = sizeof(void *);

  void *__mallocedMemory;





  if (posix_memalign(&__mallocedMemory, __align, __size))
    return 0;


  return __mallocedMemory;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_free(void *__p)
{
  free(__p);
}
# 41 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/xmmintrin.h" 2 3


static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_add_ss(__m128 __a, __m128 __b)
{
  __a[0] += __b[0];
  return __a;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_add_ps(__m128 __a, __m128 __b)
{
  return __a + __b;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_sub_ss(__m128 __a, __m128 __b)
{
  __a[0] -= __b[0];
  return __a;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_sub_ps(__m128 __a, __m128 __b)
{
  return __a - __b;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_mul_ss(__m128 __a, __m128 __b)
{
  __a[0] *= __b[0];
  return __a;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_mul_ps(__m128 __a, __m128 __b)
{
  return __a * __b;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_div_ss(__m128 __a, __m128 __b)
{
  __a[0] /= __b[0];
  return __a;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_div_ps(__m128 __a, __m128 __b)
{
  return __a / __b;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_sqrt_ss(__m128 __a)
{
  __m128 __c = __builtin_ia32_sqrtss(__a);
  return (__m128) { __c[0], __a[1], __a[2], __a[3] };
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_sqrt_ps(__m128 __a)
{
  return __builtin_ia32_sqrtps(__a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_rcp_ss(__m128 __a)
{
  __m128 __c = __builtin_ia32_rcpss(__a);
  return (__m128) { __c[0], __a[1], __a[2], __a[3] };
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_rcp_ps(__m128 __a)
{
  return __builtin_ia32_rcpps(__a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_rsqrt_ss(__m128 __a)
{
  __m128 __c = __builtin_ia32_rsqrtss(__a);
  return (__m128) { __c[0], __a[1], __a[2], __a[3] };
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_rsqrt_ps(__m128 __a)
{
  return __builtin_ia32_rsqrtps(__a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_min_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_minss(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_min_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_minps(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_max_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_maxss(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_max_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_maxps(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_and_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4si)__a & (__v4si)__b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_andnot_ps(__m128 __a, __m128 __b)
{
  return (__m128)(~(__v4si)__a & (__v4si)__b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_or_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4si)__a | (__v4si)__b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_xor_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4si)__a ^ (__v4si)__b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpss(__a, __b, 0);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__a, __b, 0);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmplt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpss(__a, __b, 1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmplt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__a, __b, 1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmple_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpss(__a, __b, 2);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmple_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__a, __b, 2);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector(__a,
                                         __builtin_ia32_cmpss(__b, __a, 1),
                                         4, 1, 2, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__b, __a, 1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpge_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector(__a,
                                         __builtin_ia32_cmpss(__b, __a, 2),
                                         4, 1, 2, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpge_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__b, __a, 2);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpneq_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpss(__a, __b, 4);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpneq_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__a, __b, 4);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpnlt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpss(__a, __b, 5);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpnlt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__a, __b, 5);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpnle_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpss(__a, __b, 6);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpnle_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__a, __b, 6);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpngt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector(__a,
                                         __builtin_ia32_cmpss(__b, __a, 5),
                                         4, 1, 2, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpngt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__b, __a, 5);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpnge_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector(__a,
                                         __builtin_ia32_cmpss(__b, __a, 6),
                                         4, 1, 2, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpnge_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__b, __a, 6);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpord_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpss(__a, __b, 7);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpord_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__a, __b, 7);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpunord_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpss(__a, __b, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpunord_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpps(__a, __b, 3);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comieq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comieq(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comilt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comilt(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comile_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comile(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comigt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comigt(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comige_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comige(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comineq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comineq(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomieq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomieq(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomilt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomilt(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomile_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomile(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomigt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomigt(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomige_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomige(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomineq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomineq(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvtss_si32(__m128 __a)
{
  return __builtin_ia32_cvtss2si(__a);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvt_ss2si(__m128 __a)
{
  return _mm_cvtss_si32(__a);
}



static __inline__ long long __attribute__((__always_inline__, __nodebug__))
_mm_cvtss_si64(__m128 __a)
{
  return __builtin_ia32_cvtss2si64(__a);
}



static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvtps_pi32(__m128 __a)
{
  return (__m64)__builtin_ia32_cvtps2pi(__a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvt_ps2pi(__m128 __a)
{
  return _mm_cvtps_pi32(__a);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvttss_si32(__m128 __a)
{
  return __a[0];
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvtt_ss2si(__m128 __a)
{
  return _mm_cvttss_si32(__a);
}

static __inline__ long long __attribute__((__always_inline__, __nodebug__))
_mm_cvttss_si64(__m128 __a)
{
  return __a[0];
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvttps_pi32(__m128 __a)
{
  return (__m64)__builtin_ia32_cvttps2pi(__a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvtt_ps2pi(__m128 __a)
{
  return _mm_cvttps_pi32(__a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi32_ss(__m128 __a, int __b)
{
  __a[0] = __b;
  return __a;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvt_si2ss(__m128 __a, int __b)
{
  return _mm_cvtsi32_ss(__a, __b);
}



static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi64_ss(__m128 __a, long long __b)
{
  __a[0] = __b;
  return __a;
}



static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpi32_ps(__m128 __a, __m64 __b)
{
  return __builtin_ia32_cvtpi2ps(__a, (__v2si)__b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvt_pi2ps(__m128 __a, __m64 __b)
{
  return _mm_cvtpi32_ps(__a, __b);
}

static __inline__ float __attribute__((__always_inline__, __nodebug__))
_mm_cvtss_f32(__m128 __a)
{
  return __a[0];
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_loadh_pi(__m128 __a, const __m64 *__p)
{
  typedef float __mm_loadh_pi_v2f32 __attribute__((__vector_size__(8)));
  struct __mm_loadh_pi_struct {
    __mm_loadh_pi_v2f32 __u;
  } __attribute__((__packed__, __may_alias__));
  __mm_loadh_pi_v2f32 __b = ((struct __mm_loadh_pi_struct*)__p)->__u;
  __m128 __bb = __builtin_shufflevector(__b, __b, 0, 1, 0, 1);
  return __builtin_shufflevector(__a, __bb, 0, 1, 4, 5);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_loadl_pi(__m128 __a, const __m64 *__p)
{
  typedef float __mm_loadl_pi_v2f32 __attribute__((__vector_size__(8)));
  struct __mm_loadl_pi_struct {
    __mm_loadl_pi_v2f32 __u;
  } __attribute__((__packed__, __may_alias__));
  __mm_loadl_pi_v2f32 __b = ((struct __mm_loadl_pi_struct*)__p)->__u;
  __m128 __bb = __builtin_shufflevector(__b, __b, 0, 1, 0, 1);
  return __builtin_shufflevector(__a, __bb, 4, 5, 2, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_load_ss(const float *__p)
{
  struct __mm_load_ss_struct {
    float __u;
  } __attribute__((__packed__, __may_alias__));
  float __u = ((struct __mm_load_ss_struct*)__p)->__u;
  return (__m128){ __u, 0, 0, 0 };
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_load1_ps(const float *__p)
{
  struct __mm_load1_ps_struct {
    float __u;
  } __attribute__((__packed__, __may_alias__));
  float __u = ((struct __mm_load1_ps_struct*)__p)->__u;
  return (__m128){ __u, __u, __u, __u };
}



static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_load_ps(const float *__p)
{
  return *(__m128*)__p;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_loadu_ps(const float *__p)
{
  struct __loadu_ps {
    __m128 __v;
  } __attribute__((__packed__, __may_alias__));
  return ((struct __loadu_ps*)__p)->__v;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_loadr_ps(const float *__p)
{
  __m128 __a = _mm_load_ps(__p);
  return __builtin_shufflevector(__a, __a, 3, 2, 1, 0);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_set_ss(float __w)
{
  return (__m128){ __w, 0, 0, 0 };
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_set1_ps(float __w)
{
  return (__m128){ __w, __w, __w, __w };
}


static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_set_ps1(float __w)
{
    return _mm_set1_ps(__w);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_set_ps(float __z, float __y, float __x, float __w)
{
  return (__m128){ __w, __x, __y, __z };
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_setr_ps(float __z, float __y, float __x, float __w)
{
  return (__m128){ __z, __y, __x, __w };
}

static __inline__ __m128 __attribute__((__always_inline__))
_mm_setzero_ps(void)
{
  return (__m128){ 0, 0, 0, 0 };
}

static __inline__ void __attribute__((__always_inline__))
_mm_storeh_pi(__m64 *__p, __m128 __a)
{
  __builtin_ia32_storehps((__v2si *)__p, __a);
}

static __inline__ void __attribute__((__always_inline__))
_mm_storel_pi(__m64 *__p, __m128 __a)
{
  __builtin_ia32_storelps((__v2si *)__p, __a);
}

static __inline__ void __attribute__((__always_inline__))
_mm_store_ss(float *__p, __m128 __a)
{
  struct __mm_store_ss_struct {
    float __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_store_ss_struct*)__p)->__u = __a[0];
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storeu_ps(float *__p, __m128 __a)
{
  __builtin_ia32_storeups(__p, __a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_store1_ps(float *__p, __m128 __a)
{
  __a = __builtin_shufflevector(__a, __a, 0, 0, 0, 0);
  _mm_storeu_ps(__p, __a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_store_ps1(float *__p, __m128 __a)
{
    return _mm_store1_ps(__p, __a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_store_ps(float *__p, __m128 __a)
{
  *(__m128 *)__p = __a;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storer_ps(float *__p, __m128 __a)
{
  __a = __builtin_shufflevector(__a, __a, 3, 2, 1, 0);
  _mm_store_ps(__p, __a);
}
# 682 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/xmmintrin.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_stream_pi(__m64 *__p, __m64 __a)
{
  __builtin_ia32_movntq(__p, __a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_stream_ps(float *__p, __m128 __a)
{
  __builtin_ia32_movntps(__p, __a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_sfence(void)
{
  __builtin_ia32_sfence();
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_extract_pi16(__m64 __a, int __n)
{
  __v4hi __b = (__v4hi)__a;
  return (unsigned short)__b[__n & 3];
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_insert_pi16(__m64 __a, int __d, int __n)
{
   __v4hi __b = (__v4hi)__a;
   __b[__n & 3] = __d;
   return (__m64)__b;
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_max_pi16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pmaxsw((__v4hi)__a, (__v4hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_max_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pmaxub((__v8qi)__a, (__v8qi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_min_pi16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pminsw((__v4hi)__a, (__v4hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_min_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pminub((__v8qi)__a, (__v8qi)__b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_movemask_pi8(__m64 __a)
{
  return __builtin_ia32_pmovmskb((__v8qi)__a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_mulhi_pu16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pmulhuw((__v4hi)__a, (__v4hi)__b);
}





static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_maskmove_si64(__m64 __d, __m64 __n, char *__p)
{
  __builtin_ia32_maskmovq((__v8qi)__d, (__v8qi)__n, __p);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_avg_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pavgb((__v8qi)__a, (__v8qi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_avg_pu16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pavgw((__v4hi)__a, (__v4hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sad_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_psadbw((__v8qi)__a, (__v8qi)__b);
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__))
_mm_getcsr(void)
{
  return __builtin_ia32_stmxcsr();
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_setcsr(unsigned int __i)
{
  __builtin_ia32_ldmxcsr(__i);
}
# 799 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/xmmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector(__a, __b, 2, 6, 3, 7);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector(__a, __b, 0, 4, 1, 5);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_move_ss(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector(__a, __b, 4, 1, 2, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_movehl_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector(__a, __b, 6, 7, 2, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_movelh_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector(__a, __b, 0, 1, 4, 5);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpi16_ps(__m64 __a)
{
  __m64 __b, __c;
  __m128 __r;

  __b = _mm_setzero_si64();
  __b = _mm_cmpgt_pi16(__b, __a);
  __c = _mm_unpackhi_pi16(__a, __b);
  __r = _mm_setzero_ps();
  __r = _mm_cvtpi32_ps(__r, __c);
  __r = _mm_movelh_ps(__r, __r);
  __c = _mm_unpacklo_pi16(__a, __b);
  __r = _mm_cvtpi32_ps(__r, __c);

  return __r;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpu16_ps(__m64 __a)
{
  __m64 __b, __c;
  __m128 __r;

  __b = _mm_setzero_si64();
  __c = _mm_unpackhi_pi16(__a, __b);
  __r = _mm_setzero_ps();
  __r = _mm_cvtpi32_ps(__r, __c);
  __r = _mm_movelh_ps(__r, __r);
  __c = _mm_unpacklo_pi16(__a, __b);
  __r = _mm_cvtpi32_ps(__r, __c);

  return __r;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpi8_ps(__m64 __a)
{
  __m64 __b;

  __b = _mm_setzero_si64();
  __b = _mm_cmpgt_pi8(__b, __a);
  __b = _mm_unpacklo_pi8(__a, __b);

  return _mm_cvtpi16_ps(__b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpu8_ps(__m64 __a)
{
  __m64 __b;

  __b = _mm_setzero_si64();
  __b = _mm_unpacklo_pi8(__a, __b);

  return _mm_cvtpi16_ps(__b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpi32x2_ps(__m64 __a, __m64 __b)
{
  __m128 __c;

  __c = _mm_setzero_ps();
  __c = _mm_cvtpi32_ps(__c, __b);
  __c = _mm_movelh_ps(__c, __c);

  return _mm_cvtpi32_ps(__c, __a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvtps_pi16(__m128 __a)
{
  __m64 __b, __c;

  __b = _mm_cvtps_pi32(__a);
  __a = _mm_movehl_ps(__a, __a);
  __c = _mm_cvtps_pi32(__a);

  return _mm_packs_pi32(__b, __c);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvtps_pi8(__m128 __a)
{
  __m64 __b, __c;

  __b = _mm_cvtps_pi16(__a);
  __c = _mm_setzero_si64();

  return _mm_packs_pi16(__b, __c);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_movemask_ps(__m128 __a)
{
  return __builtin_ia32_movmskps(__a);
}
# 998 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/xmmintrin.h" 3
# 1 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/emmintrin.h" 1 3
# 31 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/emmintrin.h" 3
# 1 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/xmmintrin.h" 1 3
# 32 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/emmintrin.h" 2 3

typedef double __m128d __attribute__((__vector_size__(16)));
typedef long long __m128i __attribute__((__vector_size__(16)));


typedef double __v2df __attribute__ ((__vector_size__ (16)));
typedef long long __v2di __attribute__ ((__vector_size__ (16)));
typedef short __v8hi __attribute__((__vector_size__(16)));
typedef char __v16qi __attribute__((__vector_size__(16)));

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_add_sd(__m128d __a, __m128d __b)
{
  __a[0] += __b[0];
  return __a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_add_pd(__m128d __a, __m128d __b)
{
  return __a + __b;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_sub_sd(__m128d __a, __m128d __b)
{
  __a[0] -= __b[0];
  return __a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_sub_pd(__m128d __a, __m128d __b)
{
  return __a - __b;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_mul_sd(__m128d __a, __m128d __b)
{
  __a[0] *= __b[0];
  return __a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_mul_pd(__m128d __a, __m128d __b)
{
  return __a * __b;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_div_sd(__m128d __a, __m128d __b)
{
  __a[0] /= __b[0];
  return __a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_div_pd(__m128d __a, __m128d __b)
{
  return __a / __b;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_sqrt_sd(__m128d __a, __m128d __b)
{
  __m128d __c = __builtin_ia32_sqrtsd(__b);
  return (__m128d) { __c[0], __a[1] };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_sqrt_pd(__m128d __a)
{
  return __builtin_ia32_sqrtpd(__a);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_min_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_minsd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_min_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_minpd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_max_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_maxsd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_max_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_maxpd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_and_pd(__m128d __a, __m128d __b)
{
  return (__m128d)((__v4si)__a & (__v4si)__b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_andnot_pd(__m128d __a, __m128d __b)
{
  return (__m128d)(~(__v4si)__a & (__v4si)__b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_or_pd(__m128d __a, __m128d __b)
{
  return (__m128d)((__v4si)__a | (__v4si)__b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_xor_pd(__m128d __a, __m128d __b)
{
  return (__m128d)((__v4si)__a ^ (__v4si)__b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__a, __b, 0);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmplt_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__a, __b, 1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmple_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__a, __b, 2);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__b, __a, 1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpge_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__b, __a, 2);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpord_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__a, __b, 7);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpunord_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__a, __b, 3);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpneq_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__a, __b, 4);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpnlt_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__a, __b, 5);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpnle_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__a, __b, 6);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpngt_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__b, __a, 5);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpnge_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmppd(__b, __a, 6);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpsd(__a, __b, 0);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmplt_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpsd(__a, __b, 1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmple_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpsd(__a, __b, 2);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_sd(__m128d __a, __m128d __b)
{
  __m128d __c = __builtin_ia32_cmpsd(__b, __a, 1);
  return (__m128d) { __c[0], __a[1] };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpge_sd(__m128d __a, __m128d __b)
{
  __m128d __c = __builtin_ia32_cmpsd(__b, __a, 2);
  return (__m128d) { __c[0], __a[1] };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpord_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpsd(__a, __b, 7);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpunord_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpsd(__a, __b, 3);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpneq_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpsd(__a, __b, 4);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpnlt_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpsd(__a, __b, 5);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpnle_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpsd(__a, __b, 6);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpngt_sd(__m128d __a, __m128d __b)
{
  __m128d __c = __builtin_ia32_cmpsd(__b, __a, 5);
  return (__m128d) { __c[0], __a[1] };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpnge_sd(__m128d __a, __m128d __b)
{
  __m128d __c = __builtin_ia32_cmpsd(__b, __a, 6);
  return (__m128d) { __c[0], __a[1] };
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comieq_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdeq(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comilt_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdlt(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comile_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdle(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comigt_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdgt(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comige_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdge(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comineq_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdneq(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomieq_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdeq(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomilt_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdlt(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomile_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdle(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomigt_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdgt(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomige_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdge(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomineq_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdneq(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpd_ps(__m128d __a)
{
  return __builtin_ia32_cvtpd2ps(__a);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cvtps_pd(__m128 __a)
{
  return __builtin_ia32_cvtps2pd(__a);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cvtepi32_pd(__m128i __a)
{
  return __builtin_ia32_cvtdq2pd((__v4si)__a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvtpd_epi32(__m128d __a)
{
  return __builtin_ia32_cvtpd2dq(__a);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvtsd_si32(__m128d __a)
{
  return __builtin_ia32_cvtsd2si(__a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtsd_ss(__m128 __a, __m128d __b)
{
  __a[0] = __b[0];
  return __a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi32_sd(__m128d __a, int __b)
{
  __a[0] = __b;
  return __a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cvtss_sd(__m128d __a, __m128 __b)
{
  __a[0] = __b[0];
  return __a;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvttpd_epi32(__m128d __a)
{
  return (__m128i)__builtin_ia32_cvttpd2dq(__a);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvttsd_si32(__m128d __a)
{
  return __a[0];
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpd_pi32(__m128d __a)
{
  return (__m64)__builtin_ia32_cvtpd2pi(__a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvttpd_pi32(__m128d __a)
{
  return (__m64)__builtin_ia32_cvttpd2pi(__a);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cvtpi32_pd(__m64 __a)
{
  return __builtin_ia32_cvtpi2pd((__v2si)__a);
}

static __inline__ double __attribute__((__always_inline__, __nodebug__))
_mm_cvtsd_f64(__m128d __a)
{
  return __a[0];
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_load_pd(double const *__dp)
{
  return *(__m128d*)__dp;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_load1_pd(double const *__dp)
{
  struct __mm_load1_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((struct __mm_load1_pd_struct*)__dp)->__u;
  return (__m128d){ __u, __u };
}



static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_loadr_pd(double const *__dp)
{
  __m128d __u = *(__m128d*)__dp;
  return __builtin_shufflevector(__u, __u, 1, 0);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_loadu_pd(double const *__dp)
{
  struct __loadu_pd {
    __m128d __v;
  } __attribute__((packed, may_alias));
  return ((struct __loadu_pd*)__dp)->__v;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_load_sd(double const *__dp)
{
  struct __mm_load_sd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((struct __mm_load_sd_struct*)__dp)->__u;
  return (__m128d){ __u, 0 };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_loadh_pd(__m128d __a, double const *__dp)
{
  struct __mm_loadh_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((struct __mm_loadh_pd_struct*)__dp)->__u;
  return (__m128d){ __a[0], __u };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_loadl_pd(__m128d __a, double const *__dp)
{
  struct __mm_loadl_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((struct __mm_loadl_pd_struct*)__dp)->__u;
  return (__m128d){ __u, __a[1] };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_set_sd(double __w)
{
  return (__m128d){ __w, 0 };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_set1_pd(double __w)
{
  return (__m128d){ __w, __w };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_set_pd(double __w, double __x)
{
  return (__m128d){ __x, __w };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_setr_pd(double __w, double __x)
{
  return (__m128d){ __w, __x };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_setzero_pd(void)
{
  return (__m128d){ 0, 0 };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_move_sd(__m128d __a, __m128d __b)
{
  return (__m128d){ __b[0], __a[1] };
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_store_sd(double *__dp, __m128d __a)
{
  struct __mm_store_sd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_store_sd_struct*)__dp)->__u = __a[0];
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_store1_pd(double *__dp, __m128d __a)
{
  struct __mm_store1_pd_struct {
    double __u[2];
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_store1_pd_struct*)__dp)->__u[0] = __a[0];
  ((struct __mm_store1_pd_struct*)__dp)->__u[1] = __a[0];
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_store_pd(double *__dp, __m128d __a)
{
  *(__m128d *)__dp = __a;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storeu_pd(double *__dp, __m128d __a)
{
  __builtin_ia32_storeupd(__dp, __a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storer_pd(double *__dp, __m128d __a)
{
  __a = __builtin_shufflevector(__a, __a, 1, 0);
  *(__m128d *)__dp = __a;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storeh_pd(double *__dp, __m128d __a)
{
  struct __mm_storeh_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_storeh_pd_struct*)__dp)->__u = __a[1];
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storel_pd(double *__dp, __m128d __a)
{
  struct __mm_storeh_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_storeh_pd_struct*)__dp)->__u = __a[0];
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_add_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)((__v16qi)__a + (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_add_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)((__v8hi)__a + (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_add_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)((__v4si)__a + (__v4si)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_add_si64(__m64 __a, __m64 __b)
{
  return __a + __b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_add_epi64(__m128i __a, __m128i __b)
{
  return __a + __b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_adds_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_paddsb128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_adds_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_paddsw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_adds_epu8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_paddusb128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_adds_epu16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_paddusw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_avg_epu8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pavgb128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_avg_epu16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pavgw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_madd_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pmaddwd128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_max_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pmaxsw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_max_epu8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pmaxub128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_min_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pminsw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_min_epu8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pminub128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_mulhi_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pmulhw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_mulhi_epu16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pmulhuw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_mullo_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)((__v8hi)__a * (__v8hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_mul_su32(__m64 __a, __m64 __b)
{
  return __builtin_ia32_pmuludq((__v2si)__a, (__v2si)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_mul_epu32(__m128i __a, __m128i __b)
{
  return __builtin_ia32_pmuludq128((__v4si)__a, (__v4si)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sad_epu8(__m128i __a, __m128i __b)
{
  return __builtin_ia32_psadbw128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sub_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)((__v16qi)__a - (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sub_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)((__v8hi)__a - (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sub_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)((__v4si)__a - (__v4si)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sub_si64(__m64 __a, __m64 __b)
{
  return __a - __b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sub_epi64(__m128i __a, __m128i __b)
{
  return __a - __b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_subs_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_psubsb128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_subs_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_psubsw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_subs_epu8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_psubusb128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_subs_epu16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_psubusw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_and_si128(__m128i __a, __m128i __b)
{
  return __a & __b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_andnot_si128(__m128i __a, __m128i __b)
{
  return ~__a & __b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_or_si128(__m128i __a, __m128i __b)
{
  return __a | __b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_xor_si128(__m128i __a, __m128i __b)
{
  return __a ^ __b;
}







static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_slli_epi16(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_psllwi128((__v8hi)__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sll_epi16(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_psllw128((__v8hi)__a, (__v8hi)__count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_slli_epi32(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_pslldi128((__v4si)__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sll_epi32(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_pslld128((__v4si)__a, (__v4si)__count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_slli_epi64(__m128i __a, int __count)
{
  return __builtin_ia32_psllqi128(__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sll_epi64(__m128i __a, __m128i __count)
{
  return __builtin_ia32_psllq128(__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srai_epi16(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_psrawi128((__v8hi)__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sra_epi16(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_psraw128((__v8hi)__a, (__v8hi)__count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srai_epi32(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_psradi128((__v4si)__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sra_epi32(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_psrad128((__v4si)__a, (__v4si)__count);
}
# 901 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srli_epi16(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_psrlwi128((__v8hi)__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srl_epi16(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_psrlw128((__v8hi)__a, (__v8hi)__count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srli_epi32(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_psrldi128((__v4si)__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srl_epi32(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_psrld128((__v4si)__a, (__v4si)__count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srli_epi64(__m128i __a, int __count)
{
  return __builtin_ia32_psrlqi128(__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srl_epi64(__m128i __a, __m128i __count)
{
  return __builtin_ia32_psrlq128(__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)((__v16qi)__a == (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)((__v8hi)__a == (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)((__v4si)__a == (__v4si)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_epi8(__m128i __a, __m128i __b)
{


  typedef signed char __v16qs __attribute__((__vector_size__(16)));
  return (__m128i)((__v16qs)__a > (__v16qs)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)((__v8hi)__a > (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)((__v4si)__a > (__v4si)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmplt_epi8(__m128i __a, __m128i __b)
{
  return _mm_cmpgt_epi8(__b, __a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmplt_epi16(__m128i __a, __m128i __b)
{
  return _mm_cmpgt_epi16(__b, __a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmplt_epi32(__m128i __a, __m128i __b)
{
  return _mm_cmpgt_epi32(__b, __a);
}


static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi64_sd(__m128d __a, long long __b)
{
  __a[0] = __b;
  return __a;
}

static __inline__ long long __attribute__((__always_inline__, __nodebug__))
_mm_cvtsd_si64(__m128d __a)
{
  return __builtin_ia32_cvtsd2si64(__a);
}

static __inline__ long long __attribute__((__always_inline__, __nodebug__))
_mm_cvttsd_si64(__m128d __a)
{
  return __a[0];
}


static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtepi32_ps(__m128i __a)
{
  return __builtin_ia32_cvtdq2ps((__v4si)__a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvtps_epi32(__m128 __a)
{
  return (__m128i)__builtin_ia32_cvtps2dq(__a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvttps_epi32(__m128 __a)
{
  return (__m128i)__builtin_ia32_cvttps2dq(__a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi32_si128(int __a)
{
  return (__m128i)(__v4si){ __a, 0, 0, 0 };
}


static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi64_si128(long long __a)
{
  return (__m128i){ __a, 0 };
}


static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi128_si32(__m128i __a)
{
  __v4si __b = (__v4si)__a;
  return __b[0];
}


static __inline__ long long __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi128_si64(__m128i __a)
{
  return __a[0];
}


static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_load_si128(__m128i const *__p)
{
  return *__p;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_loadu_si128(__m128i const *__p)
{
  struct __loadu_si128 {
    __m128i __v;
  } __attribute__((packed, may_alias));
  return ((struct __loadu_si128*)__p)->__v;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_loadl_epi64(__m128i const *__p)
{
  struct __mm_loadl_epi64_struct {
    long long __u;
  } __attribute__((__packed__, __may_alias__));
  return (__m128i) { ((struct __mm_loadl_epi64_struct*)__p)->__u, 0};
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set_epi64x(long long q1, long long q0)
{
  return (__m128i){ q0, q1 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set_epi64(__m64 q1, __m64 q0)
{
  return (__m128i){ (long long)q0, (long long)q1 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set_epi32(int i3, int i2, int i1, int i0)
{
  return (__m128i)(__v4si){ i0, i1, i2, i3};
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set_epi16(short w7, short w6, short w5, short w4, short w3, short w2, short w1, short w0)
{
  return (__m128i)(__v8hi){ w0, w1, w2, w3, w4, w5, w6, w7 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set_epi8(char b15, char b14, char b13, char b12, char b11, char b10, char b9, char b8, char b7, char b6, char b5, char b4, char b3, char b2, char b1, char b0)
{
  return (__m128i)(__v16qi){ b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set1_epi64x(long long __q)
{
  return (__m128i){ __q, __q };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set1_epi64(__m64 __q)
{
  return (__m128i){ (long long)__q, (long long)__q };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set1_epi32(int __i)
{
  return (__m128i)(__v4si){ __i, __i, __i, __i };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set1_epi16(short __w)
{
  return (__m128i)(__v8hi){ __w, __w, __w, __w, __w, __w, __w, __w };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set1_epi8(char __b)
{
  return (__m128i)(__v16qi){ __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_setr_epi64(__m64 q0, __m64 q1)
{
  return (__m128i){ (long long)q0, (long long)q1 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_setr_epi32(int i0, int i1, int i2, int i3)
{
  return (__m128i)(__v4si){ i0, i1, i2, i3};
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_setr_epi16(short w0, short w1, short w2, short w3, short w4, short w5, short w6, short w7)
{
  return (__m128i)(__v8hi){ w0, w1, w2, w3, w4, w5, w6, w7 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_setr_epi8(char b0, char b1, char b2, char b3, char b4, char b5, char b6, char b7, char b8, char b9, char b10, char b11, char b12, char b13, char b14, char b15)
{
  return (__m128i)(__v16qi){ b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_setzero_si128(void)
{
  return (__m128i){ 0LL, 0LL };
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_store_si128(__m128i *__p, __m128i __b)
{
  *__p = __b;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storeu_si128(__m128i *__p, __m128i __b)
{
  __builtin_ia32_storedqu((char *)__p, (__v16qi)__b);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_maskmoveu_si128(__m128i __d, __m128i __n, char *__p)
{
  __builtin_ia32_maskmovdqu((__v16qi)__d, (__v16qi)__n, __p);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storel_epi64(__m128i *__p, __m128i __a)
{
  struct __mm_storel_epi64_struct {
    long long __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_storel_epi64_struct*)__p)->__u = __a[0];
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_stream_pd(double *__p, __m128d __a)
{
  __builtin_ia32_movntpd(__p, __a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_stream_si128(__m128i *__p, __m128i __a)
{
  __builtin_ia32_movntdq(__p, __a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_stream_si32(int *__p, int __a)
{
  __builtin_ia32_movnti(__p, __a);
}


static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_stream_si64(long long *__p, long long __a)
{
  __builtin_ia32_movnti64(__p, __a);
}


static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_clflush(void const *__p)
{
  __builtin_ia32_clflush(__p);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_lfence(void)
{
  __builtin_ia32_lfence();
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_mfence(void)
{
  __builtin_ia32_mfence();
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_packs_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_packsswb128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_packs_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_packssdw128((__v4si)__a, (__v4si)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_packus_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_packuswb128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_extract_epi16(__m128i __a, int __imm)
{
  __v8hi __b = (__v8hi)__a;
  return (unsigned short)__b[__imm & 7];
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_insert_epi16(__m128i __a, int __b, int __imm)
{
  __v8hi __c = (__v8hi)__a;
  __c[__imm & 7] = __b;
  return (__m128i)__c;
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_movemask_epi8(__m128i __a)
{
  return __builtin_ia32_pmovmskb128((__v16qi)__a);
}
# 1314 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/emmintrin.h" 3
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v16qi)__a, (__v16qi)__b, 8, 16+8, 9, 16+9, 10, 16+10, 11, 16+11, 12, 16+12, 13, 16+13, 14, 16+14, 15, 16+15);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v8hi)__a, (__v8hi)__b, 4, 8+4, 5, 8+5, 6, 8+6, 7, 8+7);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v4si)__a, (__v4si)__b, 2, 4+2, 3, 4+3);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_epi64(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector(__a, __b, 1, 2+1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v16qi)__a, (__v16qi)__b, 0, 16+0, 1, 16+1, 2, 16+2, 3, 16+3, 4, 16+4, 5, 16+5, 6, 16+6, 7, 16+7);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v8hi)__a, (__v8hi)__b, 0, 8+0, 1, 8+1, 2, 8+2, 3, 8+3);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v4si)__a, (__v4si)__b, 0, 4+0, 1, 4+1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_epi64(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector(__a, __b, 0, 2+0);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_movepi64_pi64(__m128i __a)
{
  return (__m64)__a[0];
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_movpi64_epi64(__m64 __a)
{
  return (__m128i){ (long long)__a, 0 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_move_epi64(__m128i __a)
{
  return __builtin_shufflevector(__a, (__m128i){ 0 }, 0, 2);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_pd(__m128d __a, __m128d __b)
{
  return __builtin_shufflevector(__a, __b, 1, 2+1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_pd(__m128d __a, __m128d __b)
{
  return __builtin_shufflevector(__a, __b, 0, 2+0);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_movemask_pd(__m128d __a)
{
  return __builtin_ia32_movmskpd(__a);
}
# 1405 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/emmintrin.h" 3
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_castpd_ps(__m128d __a)
{
  return (__m128)__a;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_castpd_si128(__m128d __a)
{
  return (__m128i)__a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_castps_pd(__m128 __a)
{
  return (__m128d)__a;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_castps_si128(__m128 __a)
{
  return (__m128i)__a;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_castsi128_ps(__m128i __a)
{
  return (__m128)__a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_castsi128_pd(__m128i __a)
{
  return (__m128d)__a;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_pause(void)
{
  __asm__ volatile ("pause");
}
# 999 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/xmmintrin.h" 2 3
# 33 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/immintrin.h" 2 3
# 30 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/x86intrin.h" 2 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/opt_random.h" 2 3
# 37 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/opt_random.h" 3


namespace std __attribute__ ((__visibility__ ("default")))
{
# 216 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/opt_random.h" 3
}
# 52 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/random" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.tcc" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.tcc" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/numeric" 1 3
# 59 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/numeric" 3



# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_numeric.h" 1 3
# 65 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_numeric.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 80 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_numeric.h" 3
  template<typename _ForwardIterator, typename _Tp>
    void
    iota(_ForwardIterator __first, _ForwardIterator __last, _Tp __value)
    {





                                                     ;

      for (; __first != __last; ++__first)
 {
   *__first = __value;
   ++__value;
 }
    }


}



namespace std __attribute__ ((__visibility__ ("default")))
{
# 118 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_numeric.h" 3
  template<typename _InputIterator, typename _Tp>
    inline _Tp
    accumulate(_InputIterator __first, _InputIterator __last, _Tp __init)
    {


                                                     ;

      for (; __first != __last; ++__first)
 __init = __init + *__first;
      return __init;
    }
# 144 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_numeric.h" 3
  template<typename _InputIterator, typename _Tp, typename _BinaryOperation>
    inline _Tp
    accumulate(_InputIterator __first, _InputIterator __last, _Tp __init,
        _BinaryOperation __binary_op)
    {


                                                     ;

      for (; __first != __last; ++__first)
 __init = __binary_op(__init, *__first);
      return __init;
    }
# 172 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_numeric.h" 3
  template<typename _InputIterator1, typename _InputIterator2, typename _Tp>
    inline _Tp
    inner_product(_InputIterator1 __first1, _InputIterator1 __last1,
    _InputIterator2 __first2, _Tp __init)
    {



                                                       ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 __init = __init + (*__first1 * *__first2);
      return __init;
    }
# 203 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_numeric.h" 3
  template<typename _InputIterator1, typename _InputIterator2, typename _Tp,
    typename _BinaryOperation1, typename _BinaryOperation2>
    inline _Tp
    inner_product(_InputIterator1 __first1, _InputIterator1 __last1,
    _InputIterator2 __first2, _Tp __init,
    _BinaryOperation1 __binary_op1,
    _BinaryOperation2 __binary_op2)
    {



                                                       ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 __init = __binary_op1(__init, __binary_op2(*__first1, *__first2));
      return __init;
    }
# 235 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_numeric.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    _OutputIterator
    partial_sum(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;





                                                     ;

      if (__first == __last)
 return __result;
      _ValueType __value = *__first;
      *__result = __value;
      while (++__first != __last)
 {
   __value = __value + *__first;
   *++__result = __value;
 }
      return ++__result;
    }
# 275 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_numeric.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryOperation>
    _OutputIterator
    partial_sum(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, _BinaryOperation __binary_op)
    {
      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;





                                                     ;

      if (__first == __last)
 return __result;
      _ValueType __value = *__first;
      *__result = __value;
      while (++__first != __last)
 {
   __value = __binary_op(__value, *__first);
   *++__result = __value;
 }
      return ++__result;
    }
# 315 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_numeric.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    _OutputIterator
    adjacent_difference(_InputIterator __first,
   _InputIterator __last, _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;





                                                     ;

      if (__first == __last)
 return __result;
      _ValueType __value = *__first;
      *__result = __value;
      while (++__first != __last)
 {
   _ValueType __tmp = *__first;
   *++__result = __tmp - __value;
   __value = std::move(__tmp);
 }
      return ++__result;
    }
# 357 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_numeric.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryOperation>
    _OutputIterator
    adjacent_difference(_InputIterator __first, _InputIterator __last,
   _OutputIterator __result, _BinaryOperation __binary_op)
    {
      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;





                                                     ;

      if (__first == __last)
 return __result;
      _ValueType __value = *__first;
      *__result = __value;
      while (++__first != __last)
 {
   _ValueType __tmp = *__first;
   *++__result = __binary_op(__tmp, __value);
   __value = std::move(__tmp);
 }
      return ++__result;
    }


}
# 63 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/numeric" 2 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.tcc" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  namespace __detail
  {
# 50 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.tcc" 3
    template<typename _Tp, _Tp __m, _Tp __a, _Tp __c>
      _Tp
      _Mod<_Tp, __m, __a, __c, false, true>::
      __calc(_Tp __x)
      {
 if (__a == 1)
   __x %= __m;
 else
   {
     static const _Tp __q = __m / __a;
     static const _Tp __r = __m % __a;

     _Tp __t1 = __a * (__x % __q);
     _Tp __t2 = __r * (__x / __q);
     if (__t1 >= __t2)
       __x = __t1 - __t2;
     else
       __x = __m - __t2 + __t1;
   }

 if (__c != 0)
   {
     const _Tp __d = __m - __x;
     if (__d > __c)
       __x += __c;
     else
       __x = __c - __d;
   }
 return __x;
      }

    template<typename _InputIterator, typename _OutputIterator,
      typename _Tp>
      _OutputIterator
      __normalize(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result, const _Tp& __factor)
      {
 for (; __first != __last; ++__first, ++__result)
   *__result = *__first / __factor;
 return __result;
      }


  }



  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
    constexpr _UIntType
    linear_congruential_engine<_UIntType, __a, __c, __m>::multiplier;

  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
    constexpr _UIntType
    linear_congruential_engine<_UIntType, __a, __c, __m>::increment;

  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
    constexpr _UIntType
    linear_congruential_engine<_UIntType, __a, __c, __m>::modulus;

  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
    constexpr _UIntType
    linear_congruential_engine<_UIntType, __a, __c, __m>::default_seed;





  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
    void
    linear_congruential_engine<_UIntType, __a, __c, __m>::
    seed(result_type __s)
    {
      if ((__detail::__mod<_UIntType, __m>(__c) == 0)
   && (__detail::__mod<_UIntType, __m>(__s) == 0))
 _M_x = 1;
      else
 _M_x = __detail::__mod<_UIntType, __m>(__s);
    }




  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
    template<typename _Sseq>
      typename std::enable_if<std::is_class<_Sseq>::value>::type
      linear_congruential_engine<_UIntType, __a, __c, __m>::
      seed(_Sseq& __q)
      {
 const _UIntType __k0 = __m == 0 ? std::numeric_limits<_UIntType>::digits
                                 : std::__lg(__m);
 const _UIntType __k = (__k0 + 31) / 32;
 uint_least32_t __arr[__k + 3];
 __q.generate(__arr + 0, __arr + __k + 3);
 _UIntType __factor = 1u;
 _UIntType __sum = 0u;
 for (size_t __j = 0; __j < __k; ++__j)
   {
     __sum += __arr[__j + 3] * __factor;
     __factor *= __detail::_Shift<_UIntType, 32>::__value;
   }
 seed(__sum);
      }

  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m,
    typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const linear_congruential_engine<_UIntType,
      __a, __c, __m>& __lcr)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      __os.flags(__ios_base::dec | __ios_base::fixed | __ios_base::left);
      __os.fill(__os.widen(' '));

      __os << __lcr._M_x;

      __os.flags(__flags);
      __os.fill(__fill);
      return __os;
    }

  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m,
    typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        linear_congruential_engine<_UIntType, __a, __c, __m>& __lcr)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec);

      __is >> __lcr._M_x;

      __is.flags(__flags);
      return __is;
    }


  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    constexpr size_t
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::word_size;

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    constexpr size_t
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::state_size;

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    constexpr size_t
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::shift_size;

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    constexpr size_t
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::mask_bits;

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    constexpr _UIntType
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::xor_mask;

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    constexpr size_t
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::tempering_u;

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    constexpr _UIntType
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::tempering_d;

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    constexpr size_t
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::tempering_s;

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    constexpr _UIntType
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::tempering_b;

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    constexpr size_t
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::tempering_t;

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    constexpr _UIntType
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::tempering_c;

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    constexpr size_t
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::tempering_l;

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    constexpr _UIntType
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::
                                              initialization_multiplier;

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    constexpr _UIntType
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::default_seed;

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    void
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::
    seed(result_type __sd)
    {
      _M_x[0] = __detail::__mod<_UIntType,
 __detail::_Shift<_UIntType, __w>::__value>(__sd);

      for (size_t __i = 1; __i < state_size; ++__i)
 {
   _UIntType __x = _M_x[__i - 1];
   __x ^= __x >> (__w - 2);
   __x *= __f;
   __x += __detail::__mod<_UIntType, __n>(__i);
   _M_x[__i] = __detail::__mod<_UIntType,
     __detail::_Shift<_UIntType, __w>::__value>(__x);
 }
      _M_p = state_size;
    }

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    template<typename _Sseq>
      typename std::enable_if<std::is_class<_Sseq>::value>::type
      mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
         __s, __b, __t, __c, __l, __f>::
      seed(_Sseq& __q)
      {
 const _UIntType __upper_mask = (~_UIntType()) << __r;
 const size_t __k = (__w + 31) / 32;
 uint_least32_t __arr[__n * __k];
 __q.generate(__arr + 0, __arr + __n * __k);

 bool __zero = true;
 for (size_t __i = 0; __i < state_size; ++__i)
   {
     _UIntType __factor = 1u;
     _UIntType __sum = 0u;
     for (size_t __j = 0; __j < __k; ++__j)
       {
  __sum += __arr[__k * __i + __j] * __factor;
  __factor *= __detail::_Shift<_UIntType, 32>::__value;
       }
     _M_x[__i] = __detail::__mod<_UIntType,
       __detail::_Shift<_UIntType, __w>::__value>(__sum);

     if (__zero)
       {
  if (__i == 0)
    {
      if ((_M_x[0] & __upper_mask) != 0u)
        __zero = false;
    }
  else if (_M_x[__i] != 0u)
    __zero = false;
       }
   }
        if (__zero)
          _M_x[0] = __detail::_Shift<_UIntType, __w - 1>::__value;
 _M_p = state_size;
      }

  template<typename _UIntType, size_t __w,
    size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    void
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::
    _M_gen_rand(void)
    {
      const _UIntType __upper_mask = (~_UIntType()) << __r;
      const _UIntType __lower_mask = ~__upper_mask;

      for (size_t __k = 0; __k < (__n - __m); ++__k)
        {
   _UIntType __y = ((_M_x[__k] & __upper_mask)
      | (_M_x[__k + 1] & __lower_mask));
   _M_x[__k] = (_M_x[__k + __m] ^ (__y >> 1)
         ^ ((__y & 0x01) ? __a : 0));
        }

      for (size_t __k = (__n - __m); __k < (__n - 1); ++__k)
 {
   _UIntType __y = ((_M_x[__k] & __upper_mask)
      | (_M_x[__k + 1] & __lower_mask));
   _M_x[__k] = (_M_x[__k + (__m - __n)] ^ (__y >> 1)
         ^ ((__y & 0x01) ? __a : 0));
 }

      _UIntType __y = ((_M_x[__n - 1] & __upper_mask)
         | (_M_x[0] & __lower_mask));
      _M_x[__n - 1] = (_M_x[__m - 1] ^ (__y >> 1)
         ^ ((__y & 0x01) ? __a : 0));
      _M_p = 0;
    }

  template<typename _UIntType, size_t __w,
    size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    void
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::
    discard(unsigned long long __z)
    {
      while (__z > state_size - _M_p)
 {
   __z -= state_size - _M_p;
   _M_gen_rand();
 }
      _M_p += __z;
    }

  template<typename _UIntType, size_t __w,
    size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    typename
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::result_type
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::
    operator()()
    {

      if (_M_p >= state_size)
 _M_gen_rand();


      result_type __z = _M_x[_M_p++];
      __z ^= (__z >> __u) & __d;
      __z ^= (__z << __s) & __b;
      __z ^= (__z << __t) & __c;
      __z ^= (__z >> __l);

      return __z;
    }

  template<typename _UIntType, size_t __w,
    size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const mersenne_twister_engine<_UIntType, __w, __n, __m,
        __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::dec | __ios_base::fixed | __ios_base::left);
      __os.fill(__space);

      for (size_t __i = 0; __i < __n; ++__i)
 __os << __x._M_x[__i] << __space;
      __os << __x._M_p;

      __os.flags(__flags);
      __os.fill(__fill);
      return __os;
    }

  template<typename _UIntType, size_t __w,
    size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        mersenne_twister_engine<_UIntType, __w, __n, __m,
        __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      for (size_t __i = 0; __i < __n; ++__i)
 __is >> __x._M_x[__i];
      __is >> __x._M_p;

      __is.flags(__flags);
      return __is;
    }


  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
    constexpr size_t
    subtract_with_carry_engine<_UIntType, __w, __s, __r>::word_size;

  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
    constexpr size_t
    subtract_with_carry_engine<_UIntType, __w, __s, __r>::short_lag;

  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
    constexpr size_t
    subtract_with_carry_engine<_UIntType, __w, __s, __r>::long_lag;

  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
    constexpr _UIntType
    subtract_with_carry_engine<_UIntType, __w, __s, __r>::default_seed;

  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
    void
    subtract_with_carry_engine<_UIntType, __w, __s, __r>::
    seed(result_type __value)
    {
      std::linear_congruential_engine<result_type, 40014u, 0u, 2147483563u>
 __lcg(__value == 0u ? default_seed : __value);

      const size_t __n = (__w + 31) / 32;

      for (size_t __i = 0; __i < long_lag; ++__i)
 {
   _UIntType __sum = 0u;
   _UIntType __factor = 1u;
   for (size_t __j = 0; __j < __n; ++__j)
     {
       __sum += __detail::__mod<uint_least32_t,
         __detail::_Shift<uint_least32_t, 32>::__value>
    (__lcg()) * __factor;
       __factor *= __detail::_Shift<_UIntType, 32>::__value;
     }
   _M_x[__i] = __detail::__mod<_UIntType,
     __detail::_Shift<_UIntType, __w>::__value>(__sum);
 }
      _M_carry = (_M_x[long_lag - 1] == 0) ? 1 : 0;
      _M_p = 0;
    }

  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
    template<typename _Sseq>
      typename std::enable_if<std::is_class<_Sseq>::value>::type
      subtract_with_carry_engine<_UIntType, __w, __s, __r>::
      seed(_Sseq& __q)
      {
 const size_t __k = (__w + 31) / 32;
 uint_least32_t __arr[__r * __k];
 __q.generate(__arr + 0, __arr + __r * __k);

 for (size_t __i = 0; __i < long_lag; ++__i)
   {
     _UIntType __sum = 0u;
     _UIntType __factor = 1u;
     for (size_t __j = 0; __j < __k; ++__j)
       {
  __sum += __arr[__k * __i + __j] * __factor;
  __factor *= __detail::_Shift<_UIntType, 32>::__value;
       }
     _M_x[__i] = __detail::__mod<_UIntType,
       __detail::_Shift<_UIntType, __w>::__value>(__sum);
   }
 _M_carry = (_M_x[long_lag - 1] == 0) ? 1 : 0;
 _M_p = 0;
      }

  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
    typename subtract_with_carry_engine<_UIntType, __w, __s, __r>::
      result_type
    subtract_with_carry_engine<_UIntType, __w, __s, __r>::
    operator()()
    {

      long __ps = _M_p - short_lag;
      if (__ps < 0)
 __ps += long_lag;




      _UIntType __xi;
      if (_M_x[__ps] >= _M_x[_M_p] + _M_carry)
 {
   __xi = _M_x[__ps] - _M_x[_M_p] - _M_carry;
   _M_carry = 0;
 }
      else
 {
   __xi = (__detail::_Shift<_UIntType, __w>::__value
    - _M_x[_M_p] - _M_carry + _M_x[__ps]);
   _M_carry = 1;
 }
      _M_x[_M_p] = __xi;


      if (++_M_p >= long_lag)
 _M_p = 0;

      return __xi;
    }

  template<typename _UIntType, size_t __w, size_t __s, size_t __r,
    typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const subtract_with_carry_engine<_UIntType,
      __w, __s, __r>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::dec | __ios_base::fixed | __ios_base::left);
      __os.fill(__space);

      for (size_t __i = 0; __i < __r; ++__i)
 __os << __x._M_x[__i] << __space;
      __os << __x._M_carry << __space << __x._M_p;

      __os.flags(__flags);
      __os.fill(__fill);
      return __os;
    }

  template<typename _UIntType, size_t __w, size_t __s, size_t __r,
    typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        subtract_with_carry_engine<_UIntType, __w, __s, __r>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      for (size_t __i = 0; __i < __r; ++__i)
 __is >> __x._M_x[__i];
      __is >> __x._M_carry;
      __is >> __x._M_p;

      __is.flags(__flags);
      return __is;
    }


  template<typename _RandomNumberEngine, size_t __p, size_t __r>
    constexpr size_t
    discard_block_engine<_RandomNumberEngine, __p, __r>::block_size;

  template<typename _RandomNumberEngine, size_t __p, size_t __r>
    constexpr size_t
    discard_block_engine<_RandomNumberEngine, __p, __r>::used_block;

  template<typename _RandomNumberEngine, size_t __p, size_t __r>
    typename discard_block_engine<_RandomNumberEngine,
      __p, __r>::result_type
    discard_block_engine<_RandomNumberEngine, __p, __r>::
    operator()()
    {
      if (_M_n >= used_block)
 {
   _M_b.discard(block_size - _M_n);
   _M_n = 0;
 }
      ++_M_n;
      return _M_b();
    }

  template<typename _RandomNumberEngine, size_t __p, size_t __r,
    typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const discard_block_engine<_RandomNumberEngine,
        __p, __r>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::dec | __ios_base::fixed | __ios_base::left);
      __os.fill(__space);

      __os << __x.base() << __space << __x._M_n;

      __os.flags(__flags);
      __os.fill(__fill);
      return __os;
    }

  template<typename _RandomNumberEngine, size_t __p, size_t __r,
    typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        discard_block_engine<_RandomNumberEngine, __p, __r>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      __is >> __x._M_b >> __x._M_n;

      __is.flags(__flags);
      return __is;
    }


  template<typename _RandomNumberEngine, size_t __w, typename _UIntType>
    typename independent_bits_engine<_RandomNumberEngine, __w, _UIntType>::
      result_type
    independent_bits_engine<_RandomNumberEngine, __w, _UIntType>::
    operator()()
    {
      typedef typename _RandomNumberEngine::result_type _Eresult_type;
      const _Eresult_type __r
 = (_M_b.max() - _M_b.min() < std::numeric_limits<_Eresult_type>::max()
    ? _M_b.max() - _M_b.min() + 1 : 0);
      const unsigned __edig = std::numeric_limits<_Eresult_type>::digits;
      const unsigned __m = __r ? std::__lg(__r) : __edig;

      typedef typename std::common_type<_Eresult_type, result_type>::type
 __ctype;
      const unsigned __cdig = std::numeric_limits<__ctype>::digits;

      unsigned __n, __n0;
      __ctype __s0, __s1, __y0, __y1;

      for (size_t __i = 0; __i < 2; ++__i)
 {
   __n = (__w + __m - 1) / __m + __i;
   __n0 = __n - __w % __n;
   const unsigned __w0 = __w / __n;

   __s0 = 0;
   __s1 = 0;
   if (__w0 < __cdig)
     {
       __s0 = __ctype(1) << __w0;
       __s1 = __s0 << 1;
     }

   __y0 = 0;
   __y1 = 0;
   if (__r)
     {
       __y0 = __s0 * (__r / __s0);
       if (__s1)
  __y1 = __s1 * (__r / __s1);

       if (__r - __y0 <= __y0 / __n)
  break;
     }
   else
     break;
 }

      result_type __sum = 0;
      for (size_t __k = 0; __k < __n0; ++__k)
 {
   __ctype __u;
   do
     __u = _M_b() - _M_b.min();
   while (__y0 && __u >= __y0);
   __sum = __s0 * __sum + (__s0 ? __u % __s0 : __u);
 }
      for (size_t __k = __n0; __k < __n; ++__k)
 {
   __ctype __u;
   do
     __u = _M_b() - _M_b.min();
   while (__y1 && __u >= __y1);
   __sum = __s1 * __sum + (__s1 ? __u % __s1 : __u);
 }
      return __sum;
    }


  template<typename _RandomNumberEngine, size_t __k>
    constexpr size_t
    shuffle_order_engine<_RandomNumberEngine, __k>::table_size;

  template<typename _RandomNumberEngine, size_t __k>
    typename shuffle_order_engine<_RandomNumberEngine, __k>::result_type
    shuffle_order_engine<_RandomNumberEngine, __k>::
    operator()()
    {
      size_t __j = __k * ((_M_y - _M_b.min())
     / (_M_b.max() - _M_b.min() + 1.0L));
      _M_y = _M_v[__j];
      _M_v[__j] = _M_b();

      return _M_y;
    }

  template<typename _RandomNumberEngine, size_t __k,
    typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const shuffle_order_engine<_RandomNumberEngine, __k>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::dec | __ios_base::fixed | __ios_base::left);
      __os.fill(__space);

      __os << __x.base();
      for (size_t __i = 0; __i < __k; ++__i)
 __os << __space << __x._M_v[__i];
      __os << __space << __x._M_y;

      __os.flags(__flags);
      __os.fill(__fill);
      return __os;
    }

  template<typename _RandomNumberEngine, size_t __k,
    typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        shuffle_order_engine<_RandomNumberEngine, __k>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      __is >> __x._M_b;
      for (size_t __i = 0; __i < __k; ++__i)
 __is >> __x._M_v[__i];
      __is >> __x._M_y;

      __is.flags(__flags);
      return __is;
    }


  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename uniform_int_distribution<_IntType>::result_type
      uniform_int_distribution<_IntType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 typedef typename _UniformRandomNumberGenerator::result_type
   _Gresult_type;
 typedef typename std::make_unsigned<result_type>::type __utype;
 typedef typename std::common_type<_Gresult_type, __utype>::type
   __uctype;

 const __uctype __urngmin = __urng.min();
 const __uctype __urngmax = __urng.max();
 const __uctype __urngrange = __urngmax - __urngmin;
 const __uctype __urange
   = __uctype(__param.b()) - __uctype(__param.a());

 __uctype __ret;

 if (__urngrange > __urange)
   {

     const __uctype __uerange = __urange + 1;
     const __uctype __scaling = __urngrange / __uerange;
     const __uctype __past = __uerange * __scaling;
     do
       __ret = __uctype(__urng()) - __urngmin;
     while (__ret >= __past);
     __ret /= __scaling;
   }
 else if (__urngrange < __urange)
   {
# 924 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.tcc" 3
     __uctype __tmp;
     do
       {
  const __uctype __uerngrange = __urngrange + 1;
  __tmp = (__uerngrange * operator()
    (__urng, param_type(0, __urange / __uerngrange)));
  __ret = __tmp + (__uctype(__urng()) - __urngmin);
       }
     while (__ret > __urange || __ret < __tmp);
   }
 else
   __ret = __uctype(__urng()) - __urngmin;

 return __ret + __param.a();
      }


  template<typename _IntType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      uniform_int_distribution<_IntType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __param)
      {

 typedef typename _UniformRandomNumberGenerator::result_type
   _Gresult_type;
 typedef typename std::make_unsigned<result_type>::type __utype;
 typedef typename std::common_type<_Gresult_type, __utype>::type
   __uctype;

 const __uctype __urngmin = __urng.min();
 const __uctype __urngmax = __urng.max();
 const __uctype __urngrange = __urngmax - __urngmin;
 const __uctype __urange
   = __uctype(__param.b()) - __uctype(__param.a());

 __uctype __ret;

 if (__urngrange > __urange)
   {
     if (__detail::_Power_of_2(__urngrange + 1)
  && __detail::_Power_of_2(__urange + 1))
       {
  while (__f != __t)
    {
      __ret = __uctype(__urng()) - __urngmin;
      *__f++ = (__ret & __urange) + __param.a();
    }
       }
     else
       {

  const __uctype __uerange = __urange + 1;
  const __uctype __scaling = __urngrange / __uerange;
  const __uctype __past = __uerange * __scaling;
  while (__f != __t)
    {
      do
        __ret = __uctype(__urng()) - __urngmin;
      while (__ret >= __past);
      *__f++ = __ret / __scaling + __param.a();
    }
       }
   }
 else if (__urngrange < __urange)
   {
# 1008 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.tcc" 3
     __uctype __tmp;
     while (__f != __t)
       {
  do
    {
      const __uctype __uerngrange = __urngrange + 1;
      __tmp = (__uerngrange * operator()
        (__urng, param_type(0, __urange / __uerngrange)));
      __ret = __tmp + (__uctype(__urng()) - __urngmin);
    }
  while (__ret > __urange || __ret < __tmp);
  *__f++ = __ret;
       }
   }
 else
   while (__f != __t)
     *__f++ = __uctype(__urng()) - __urngmin + __param.a();
      }

  template<typename _IntType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const uniform_int_distribution<_IntType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);

      __os << __x.a() << __space << __x.b();

      __os.flags(__flags);
      __os.fill(__fill);
      return __os;
    }

  template<typename _IntType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        uniform_int_distribution<_IntType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      _IntType __a, __b;
      __is >> __a >> __b;
      __x.param(typename uniform_int_distribution<_IntType>::
  param_type(__a, __b));

      __is.flags(__flags);
      return __is;
    }


  template<typename _RealType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      uniform_real_distribution<_RealType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __p)
      {

 __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
   __aurng(__urng);
 auto __range = __p.b() - __p.a();
 while (__f != __t)
   *__f++ = __aurng() * __range + __p.a();
      }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const uniform_real_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      __os << __x.a() << __space << __x.b();

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        uniform_real_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::skipws);

      _RealType __a, __b;
      __is >> __a >> __b;
      __x.param(typename uniform_real_distribution<_RealType>::
  param_type(__a, __b));

      __is.flags(__flags);
      return __is;
    }


  template<typename _ForwardIterator,
    typename _UniformRandomNumberGenerator>
    void
    std::bernoulli_distribution::
    __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
      _UniformRandomNumberGenerator& __urng,
      const param_type& __p)
    {

      __detail::_Adaptor<_UniformRandomNumberGenerator, double>
 __aurng(__urng);
      auto __limit = __p.p() * (__aurng.max() - __aurng.min());

      while (__f != __t)
 *__f++ = (__aurng() - __aurng.min()) < __limit;
    }

  template<typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const bernoulli_distribution& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__os.widen(' '));
      __os.precision(std::numeric_limits<double>::max_digits10);

      __os << __x.p();

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }


  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename geometric_distribution<_IntType>::result_type
      geometric_distribution<_IntType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {


 const double __naf =
   (1 - std::numeric_limits<double>::epsilon()) / 2;

 const double __thr =
   std::numeric_limits<_IntType>::max() + __naf;
 __detail::_Adaptor<_UniformRandomNumberGenerator, double>
   __aurng(__urng);

 double __cand;
 do
   __cand = std::floor(std::log(1.0 - __aurng()) / __param._M_log_1_p);
 while (__cand >= __thr);

 return result_type(__cand + __naf);
      }

  template<typename _IntType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      geometric_distribution<_IntType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __param)
      {



 const double __naf =
   (1 - std::numeric_limits<double>::epsilon()) / 2;

 const double __thr =
   std::numeric_limits<_IntType>::max() + __naf;
 __detail::_Adaptor<_UniformRandomNumberGenerator, double>
   __aurng(__urng);

 while (__f != __t)
   {
     double __cand;
     do
       __cand = std::floor(std::log(1.0 - __aurng())
      / __param._M_log_1_p);
     while (__cand >= __thr);

     *__f++ = __cand + __naf;
   }
      }

  template<typename _IntType,
    typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const geometric_distribution<_IntType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__os.widen(' '));
      __os.precision(std::numeric_limits<double>::max_digits10);

      __os << __x.p();

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _IntType,
    typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        geometric_distribution<_IntType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::skipws);

      double __p;
      __is >> __p;
      __x.param(typename geometric_distribution<_IntType>::param_type(__p));

      __is.flags(__flags);
      return __is;
    }


  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename negative_binomial_distribution<_IntType>::result_type
      negative_binomial_distribution<_IntType>::
      operator()(_UniformRandomNumberGenerator& __urng)
      {
 const double __y = _M_gd(__urng);


 std::poisson_distribution<result_type> __poisson(__y);
 return __poisson(__urng);
      }

  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename negative_binomial_distribution<_IntType>::result_type
      negative_binomial_distribution<_IntType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __p)
      {
 typedef typename std::gamma_distribution<double>::param_type
   param_type;

 const double __y =
   _M_gd(__urng, param_type(__p.k(), (1.0 - __p.p()) / __p.p()));

 std::poisson_distribution<result_type> __poisson(__y);
 return __poisson(__urng);
      }

  template<typename _IntType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      negative_binomial_distribution<_IntType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng)
      {

 while (__f != __t)
   {
     const double __y = _M_gd(__urng);


     std::poisson_distribution<result_type> __poisson(__y);
     *__f++ = __poisson(__urng);
   }
      }

  template<typename _IntType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      negative_binomial_distribution<_IntType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __p)
      {

 typename std::gamma_distribution<result_type>::param_type
   __p2(__p.k(), (1.0 - __p.p()) / __p.p());

 while (__f != __t)
   {
     const double __y = _M_gd(__urng, __p2);

     std::poisson_distribution<result_type> __poisson(__y);
     *__f++ = __poisson(__urng);
   }
      }

  template<typename _IntType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const negative_binomial_distribution<_IntType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__os.widen(' '));
      __os.precision(std::numeric_limits<double>::max_digits10);

      __os << __x.k() << __space << __x.p()
    << __space << __x._M_gd;

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _IntType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        negative_binomial_distribution<_IntType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::skipws);

      _IntType __k;
      double __p;
      __is >> __k >> __p >> __x._M_gd;
      __x.param(typename negative_binomial_distribution<_IntType>::
  param_type(__k, __p));

      __is.flags(__flags);
      return __is;
    }


  template<typename _IntType>
    void
    poisson_distribution<_IntType>::param_type::
    _M_initialize()
    {

      if (_M_mean >= 12)
 {
   const double __m = std::floor(_M_mean);
   _M_lm_thr = std::log(_M_mean);
   _M_lfm = std::lgamma(__m + 1);
   _M_sm = std::sqrt(__m);

   const double __pi_4 = 0.7853981633974483096156608458198757L;
   const double __dx = std::sqrt(2 * __m * std::log(32 * __m
             / __pi_4));
   _M_d = std::round(std::max(6.0, std::min(__m, __dx)));
   const double __cx = 2 * __m + _M_d;
   _M_scx = std::sqrt(__cx / 2);
   _M_1cx = 1 / __cx;

   _M_c2b = std::sqrt(__pi_4 * __cx) * std::exp(_M_1cx);
   _M_cb = 2 * __cx * std::exp(-_M_d * _M_1cx * (1 + _M_d / 2))
  / _M_d;
 }
      else

 _M_lm_thr = std::exp(-_M_mean);
      }
# 1432 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.tcc" 3
  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename poisson_distribution<_IntType>::result_type
      poisson_distribution<_IntType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 __detail::_Adaptor<_UniformRandomNumberGenerator, double>
   __aurng(__urng);

 if (__param.mean() >= 12)
   {
     double __x;


     const double __naf =
       (1 - std::numeric_limits<double>::epsilon()) / 2;
     const double __thr =
       std::numeric_limits<_IntType>::max() + __naf;

     const double __m = std::floor(__param.mean());

     const double __spi_2 = 1.2533141373155002512078826424055226L;
     const double __c1 = __param._M_sm * __spi_2;
     const double __c2 = __param._M_c2b + __c1;
     const double __c3 = __c2 + 1;
     const double __c4 = __c3 + 1;

     const double __e178 = 1.0129030479320018583185514777512983L;
     const double __c5 = __c4 + __e178;
     const double __c = __param._M_cb + __c5;
     const double __2cx = 2 * (2 * __m + __param._M_d);

     bool __reject = true;
     do
       {
  const double __u = __c * __aurng();
  const double __e = -std::log(1.0 - __aurng());

  double __w = 0.0;

  if (__u <= __c1)
    {
      const double __n = _M_nd(__urng);
      const double __y = -std::abs(__n) * __param._M_sm - 1;
      __x = std::floor(__y);
      __w = -__n * __n / 2;
      if (__x < -__m)
        continue;
    }
  else if (__u <= __c2)
    {
      const double __n = _M_nd(__urng);
      const double __y = 1 + std::abs(__n) * __param._M_scx;
      __x = std::ceil(__y);
      __w = __y * (2 - __y) * __param._M_1cx;
      if (__x > __param._M_d)
        continue;
    }
  else if (__u <= __c3)


    __x = -1;
  else if (__u <= __c4)
    __x = 0;
  else if (__u <= __c5)
    __x = 1;
  else
    {
      const double __v = -std::log(1.0 - __aurng());
      const double __y = __param._M_d
         + __v * __2cx / __param._M_d;
      __x = std::ceil(__y);
      __w = -__param._M_d * __param._M_1cx * (1 + __y / 2);
    }

  __reject = (__w - __e - __x * __param._M_lm_thr
       > __param._M_lfm - std::lgamma(__x + __m + 1));

  __reject |= __x + __m >= __thr;

       } while (__reject);

     return result_type(__x + __m + __naf);
   }
 else

   {
     _IntType __x = 0;
     double __prod = 1.0;

     do
       {
  __prod *= __aurng();
  __x += 1;
       }
     while (__prod > __param._M_lm_thr);

     return __x - 1;
   }
      }

  template<typename _IntType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      poisson_distribution<_IntType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __param)
      {


 while (__f != __t)
   *__f++ = this->operator()(__urng, __param);
      }

  template<typename _IntType,
    typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const poisson_distribution<_IntType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<double>::max_digits10);

      __os << __x.mean() << __space << __x._M_nd;

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _IntType,
    typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        poisson_distribution<_IntType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::skipws);

      double __mean;
      __is >> __mean >> __x._M_nd;
      __x.param(typename poisson_distribution<_IntType>::param_type(__mean));

      __is.flags(__flags);
      return __is;
    }


  template<typename _IntType>
    void
    binomial_distribution<_IntType>::param_type::
    _M_initialize()
    {
      const double __p12 = _M_p <= 0.5 ? _M_p : 1.0 - _M_p;

      _M_easy = true;


      if (_M_t * __p12 >= 8)
 {
   _M_easy = false;
   const double __np = std::floor(_M_t * __p12);
   const double __pa = __np / _M_t;
   const double __1p = 1 - __pa;

   const double __pi_4 = 0.7853981633974483096156608458198757L;
   const double __d1x =
     std::sqrt(__np * __1p * std::log(32 * __np
          / (81 * __pi_4 * __1p)));
   _M_d1 = std::round(std::max(1.0, __d1x));
   const double __d2x =
     std::sqrt(__np * __1p * std::log(32 * _M_t * __1p
          / (__pi_4 * __pa)));
   _M_d2 = std::round(std::max(1.0, __d2x));


   const double __spi_2 = 1.2533141373155002512078826424055226L;
   _M_s1 = std::sqrt(__np * __1p) * (1 + _M_d1 / (4 * __np));
   _M_s2 = std::sqrt(__np * __1p) * (1 + _M_d2 / (4 * _M_t * __1p));
   _M_c = 2 * _M_d1 / __np;
   _M_a1 = std::exp(_M_c) * _M_s1 * __spi_2;
   const double __a12 = _M_a1 + _M_s2 * __spi_2;
   const double __s1s = _M_s1 * _M_s1;
   _M_a123 = __a12 + (std::exp(_M_d1 / (_M_t * __1p))
        * 2 * __s1s / _M_d1
        * std::exp(-_M_d1 * _M_d1 / (2 * __s1s)));
   const double __s2s = _M_s2 * _M_s2;
   _M_s = (_M_a123 + 2 * __s2s / _M_d2
    * std::exp(-_M_d2 * _M_d2 / (2 * __s2s)));
   _M_lf = (std::lgamma(__np + 1)
     + std::lgamma(_M_t - __np + 1));
   _M_lp1p = std::log(__pa / __1p);

   _M_q = -std::log(1 - (__p12 - __pa) / __1p);
 }
      else

 _M_q = -std::log(1 - __p12);
    }

  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename binomial_distribution<_IntType>::result_type
      binomial_distribution<_IntType>::
      _M_waiting(_UniformRandomNumberGenerator& __urng,
   _IntType __t, double __q)
      {
 _IntType __x = 0;
 double __sum = 0.0;
 __detail::_Adaptor<_UniformRandomNumberGenerator, double>
   __aurng(__urng);

 do
   {
     if (__t == __x)
       return __x;
     const double __e = -std::log(1.0 - __aurng());
     __sum += __e / (__t - __x);
     __x += 1;
   }
 while (__sum <= __q);

 return __x - 1;
      }
# 1682 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.tcc" 3
  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename binomial_distribution<_IntType>::result_type
      binomial_distribution<_IntType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 result_type __ret;
 const _IntType __t = __param.t();
 const double __p = __param.p();
 const double __p12 = __p <= 0.5 ? __p : 1.0 - __p;
 __detail::_Adaptor<_UniformRandomNumberGenerator, double>
   __aurng(__urng);


 if (!__param._M_easy)
   {
     double __x;


     const double __naf =
       (1 - std::numeric_limits<double>::epsilon()) / 2;
     const double __thr =
       std::numeric_limits<_IntType>::max() + __naf;

     const double __np = std::floor(__t * __p12);


     const double __spi_2 = 1.2533141373155002512078826424055226L;
     const double __a1 = __param._M_a1;
     const double __a12 = __a1 + __param._M_s2 * __spi_2;
     const double __a123 = __param._M_a123;
     const double __s1s = __param._M_s1 * __param._M_s1;
     const double __s2s = __param._M_s2 * __param._M_s2;

     bool __reject;
     do
       {
  const double __u = __param._M_s * __aurng();

  double __v;

  if (__u <= __a1)
    {
      const double __n = _M_nd(__urng);
      const double __y = __param._M_s1 * std::abs(__n);
      __reject = __y >= __param._M_d1;
      if (!__reject)
        {
   const double __e = -std::log(1.0 - __aurng());
   __x = std::floor(__y);
   __v = -__e - __n * __n / 2 + __param._M_c;
        }
    }
  else if (__u <= __a12)
    {
      const double __n = _M_nd(__urng);
      const double __y = __param._M_s2 * std::abs(__n);
      __reject = __y >= __param._M_d2;
      if (!__reject)
        {
   const double __e = -std::log(1.0 - __aurng());
   __x = std::floor(-__y);
   __v = -__e - __n * __n / 2;
        }
    }
  else if (__u <= __a123)
    {
      const double __e1 = -std::log(1.0 - __aurng());
      const double __e2 = -std::log(1.0 - __aurng());

      const double __y = __param._M_d1
         + 2 * __s1s * __e1 / __param._M_d1;
      __x = std::floor(__y);
      __v = (-__e2 + __param._M_d1 * (1 / (__t - __np)
          -__y / (2 * __s1s)));
      __reject = false;
    }
  else
    {
      const double __e1 = -std::log(1.0 - __aurng());
      const double __e2 = -std::log(1.0 - __aurng());

      const double __y = __param._M_d2
         + 2 * __s2s * __e1 / __param._M_d2;
      __x = std::floor(-__y);
      __v = -__e2 - __param._M_d2 * __y / (2 * __s2s);
      __reject = false;
    }

  __reject = __reject || __x < -__np || __x > __t - __np;
  if (!__reject)
    {
      const double __lfx =
        std::lgamma(__np + __x + 1)
        + std::lgamma(__t - (__np + __x) + 1);
      __reject = __v > __param._M_lf - __lfx
        + __x * __param._M_lp1p;
    }

  __reject |= __x + __np >= __thr;
       }
     while (__reject);

     __x += __np + __naf;

     const _IntType __z = _M_waiting(__urng, __t - _IntType(__x),
         __param._M_q);
     __ret = _IntType(__x) + __z;
   }
 else

   __ret = _M_waiting(__urng, __t, __param._M_q);

 if (__p12 != __p)
   __ret = __t - __ret;
 return __ret;
      }

  template<typename _IntType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      binomial_distribution<_IntType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __param)
      {


 while (__f != __t)
   *__f++ = this->operator()(__urng, __param);
      }

  template<typename _IntType,
    typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const binomial_distribution<_IntType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<double>::max_digits10);

      __os << __x.t() << __space << __x.p()
    << __space << __x._M_nd;

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _IntType,
    typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        binomial_distribution<_IntType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      _IntType __t;
      double __p;
      __is >> __t >> __p >> __x._M_nd;
      __x.param(typename binomial_distribution<_IntType>::
  param_type(__t, __p));

      __is.flags(__flags);
      return __is;
    }


  template<typename _RealType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      std::exponential_distribution<_RealType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __p)
      {

 __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
   __aurng(__urng);
 while (__f != __t)
   *__f++ = -std::log(result_type(1) - __aurng()) / __p.lambda();
      }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const exponential_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__os.widen(' '));
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      __os << __x.lambda();

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        exponential_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      _RealType __lambda;
      __is >> __lambda;
      __x.param(typename exponential_distribution<_RealType>::
  param_type(__lambda));

      __is.flags(__flags);
      return __is;
    }
# 1931 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/random.tcc" 3
  template<typename _RealType>
    template<typename _UniformRandomNumberGenerator>
      typename normal_distribution<_RealType>::result_type
      normal_distribution<_RealType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 result_type __ret;
 __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
   __aurng(__urng);

 if (_M_saved_available)
   {
     _M_saved_available = false;
     __ret = _M_saved;
   }
 else
   {
     result_type __x, __y, __r2;
     do
       {
  __x = result_type(2.0) * __aurng() - 1.0;
  __y = result_type(2.0) * __aurng() - 1.0;
  __r2 = __x * __x + __y * __y;
       }
     while (__r2 > 1.0 || __r2 == 0.0);

     const result_type __mult = std::sqrt(-2 * std::log(__r2) / __r2);
     _M_saved = __x * __mult;
     _M_saved_available = true;
     __ret = __y * __mult;
   }

 __ret = __ret * __param.stddev() + __param.mean();
 return __ret;
      }

  template<typename _RealType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      normal_distribution<_RealType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __param)
      {


 if (__f == __t)
   return;

 if (_M_saved_available)
   {
     _M_saved_available = false;
     *__f++ = _M_saved * __param.stddev() + __param.mean();

     if (__f == __t)
       return;
   }

 __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
   __aurng(__urng);

 while (__f + 1 < __t)
   {
     result_type __x, __y, __r2;
     do
       {
  __x = result_type(2.0) * __aurng() - 1.0;
  __y = result_type(2.0) * __aurng() - 1.0;
  __r2 = __x * __x + __y * __y;
       }
     while (__r2 > 1.0 || __r2 == 0.0);

     const result_type __mult = std::sqrt(-2 * std::log(__r2) / __r2);
     *__f++ = __y * __mult * __param.stddev() + __param.mean();
     *__f++ = __x * __mult * __param.stddev() + __param.mean();
   }

 if (__f != __t)
   {
     result_type __x, __y, __r2;
     do
       {
  __x = result_type(2.0) * __aurng() - 1.0;
  __y = result_type(2.0) * __aurng() - 1.0;
  __r2 = __x * __x + __y * __y;
       }
     while (__r2 > 1.0 || __r2 == 0.0);

     const result_type __mult = std::sqrt(-2 * std::log(__r2) / __r2);
     _M_saved = __x * __mult;
     _M_saved_available = true;
     *__f = __y * __mult * __param.stddev() + __param.mean();
   }
      }

  template<typename _RealType>
    bool
    operator==(const std::normal_distribution<_RealType>& __d1,
        const std::normal_distribution<_RealType>& __d2)
    {
      if (__d1._M_param == __d2._M_param
   && __d1._M_saved_available == __d2._M_saved_available)
 {
   if (__d1._M_saved_available
       && __d1._M_saved == __d2._M_saved)
     return true;
   else if(!__d1._M_saved_available)
     return true;
   else
     return false;
 }
      else
 return false;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const normal_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      __os << __x.mean() << __space << __x.stddev()
    << __space << __x._M_saved_available;
      if (__x._M_saved_available)
 __os << __space << __x._M_saved;

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        normal_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      double __mean, __stddev;
      __is >> __mean >> __stddev
    >> __x._M_saved_available;
      if (__x._M_saved_available)
 __is >> __x._M_saved;
      __x.param(typename normal_distribution<_RealType>::
  param_type(__mean, __stddev));

      __is.flags(__flags);
      return __is;
    }


  template<typename _RealType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      lognormal_distribution<_RealType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __p)
      {

   while (__f != __t)
     *__f++ = std::exp(__p.s() * _M_nd(__urng) + __p.m());
      }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const lognormal_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      __os << __x.m() << __space << __x.s()
    << __space << __x._M_nd;

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        lognormal_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      _RealType __m, __s;
      __is >> __m >> __s >> __x._M_nd;
      __x.param(typename lognormal_distribution<_RealType>::
  param_type(__m, __s));

      __is.flags(__flags);
      return __is;
    }

  template<typename _RealType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      std::chi_squared_distribution<_RealType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng)
      {

 while (__f != __t)
   *__f++ = 2 * _M_gd(__urng);
      }

  template<typename _RealType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      std::chi_squared_distribution<_RealType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const typename
        std::gamma_distribution<result_type>::param_type& __p)
      {

 while (__f != __t)
   *__f++ = 2 * _M_gd(__urng, __p);
      }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const chi_squared_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      __os << __x.n() << __space << __x._M_gd;

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        chi_squared_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      _RealType __n;
      __is >> __n >> __x._M_gd;
      __x.param(typename chi_squared_distribution<_RealType>::
  param_type(__n));

      __is.flags(__flags);
      return __is;
    }


  template<typename _RealType>
    template<typename _UniformRandomNumberGenerator>
      typename cauchy_distribution<_RealType>::result_type
      cauchy_distribution<_RealType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __p)
      {
 __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
   __aurng(__urng);
 _RealType __u;
 do
   __u = __aurng();
 while (__u == 0.5);

 const _RealType __pi = 3.1415926535897932384626433832795029L;
 return __p.a() + __p.b() * std::tan(__pi * __u);
      }

  template<typename _RealType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      cauchy_distribution<_RealType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __p)
      {

 const _RealType __pi = 3.1415926535897932384626433832795029L;
 __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
   __aurng(__urng);
 while (__f != __t)
   {
     _RealType __u;
     do
       __u = __aurng();
     while (__u == 0.5);

     *__f++ = __p.a() + __p.b() * std::tan(__pi * __u);
   }
      }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const cauchy_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      __os << __x.a() << __space << __x.b();

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        cauchy_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      _RealType __a, __b;
      __is >> __a >> __b;
      __x.param(typename cauchy_distribution<_RealType>::
  param_type(__a, __b));

      __is.flags(__flags);
      return __is;
    }


  template<typename _RealType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      std::fisher_f_distribution<_RealType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng)
      {

 while (__f != __t)
   *__f++ = ((_M_gd_x(__urng) * n()) / (_M_gd_y(__urng) * m()));
      }

  template<typename _RealType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      std::fisher_f_distribution<_RealType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __p)
      {

 typedef typename std::gamma_distribution<result_type>::param_type
   param_type;
 param_type __p1(__p.m() / 2);
 param_type __p2(__p.n() / 2);
 while (__f != __t)
   *__f++ = ((_M_gd_x(__urng, __p1) * n())
      / (_M_gd_y(__urng, __p2) * m()));
      }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const fisher_f_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      __os << __x.m() << __space << __x.n()
    << __space << __x._M_gd_x << __space << __x._M_gd_y;

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        fisher_f_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      _RealType __m, __n;
      __is >> __m >> __n >> __x._M_gd_x >> __x._M_gd_y;
      __x.param(typename fisher_f_distribution<_RealType>::
  param_type(__m, __n));

      __is.flags(__flags);
      return __is;
    }


  template<typename _RealType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      std::student_t_distribution<_RealType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng)
      {

 while (__f != __t)
   *__f++ = _M_nd(__urng) * std::sqrt(n() / _M_gd(__urng));
      }

  template<typename _RealType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      std::student_t_distribution<_RealType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __p)
      {

 typename std::gamma_distribution<result_type>::param_type
   __p2(__p.n() / 2, 2);
 while (__f != __t)
   *__f++ = _M_nd(__urng) * std::sqrt(__p.n() / _M_gd(__urng, __p2));
      }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const student_t_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      __os << __x.n() << __space << __x._M_nd << __space << __x._M_gd;

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        student_t_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      _RealType __n;
      __is >> __n >> __x._M_nd >> __x._M_gd;
      __x.param(typename student_t_distribution<_RealType>::param_type(__n));

      __is.flags(__flags);
      return __is;
    }


  template<typename _RealType>
    void
    gamma_distribution<_RealType>::param_type::
    _M_initialize()
    {
      _M_malpha = _M_alpha < 1.0 ? _M_alpha + _RealType(1.0) : _M_alpha;

      const _RealType __a1 = _M_malpha - _RealType(1.0) / _RealType(3.0);
      _M_a2 = _RealType(1.0) / std::sqrt(_RealType(9.0) * __a1);
    }






  template<typename _RealType>
    template<typename _UniformRandomNumberGenerator>
      typename gamma_distribution<_RealType>::result_type
      gamma_distribution<_RealType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
   __aurng(__urng);

 result_type __u, __v, __n;
 const result_type __a1 = (__param._M_malpha
      - _RealType(1.0) / _RealType(3.0));

 do
   {
     do
       {
  __n = _M_nd(__urng);
  __v = result_type(1.0) + __param._M_a2 * __n;
       }
     while (__v <= 0.0);

     __v = __v * __v * __v;
     __u = __aurng();
   }
 while (__u > result_type(1.0) - 0.331 * __n * __n * __n * __n
        && (std::log(__u) > (0.5 * __n * __n + __a1
        * (1.0 - __v + std::log(__v)))));

 if (__param.alpha() == __param._M_malpha)
   return __a1 * __v * __param.beta();
 else
   {
     do
       __u = __aurng();
     while (__u == 0.0);

     return (std::pow(__u, result_type(1.0) / __param.alpha())
      * __a1 * __v * __param.beta());
   }
      }

  template<typename _RealType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      gamma_distribution<_RealType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __param)
      {

 __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
   __aurng(__urng);

 result_type __u, __v, __n;
 const result_type __a1 = (__param._M_malpha
      - _RealType(1.0) / _RealType(3.0));

 if (__param.alpha() == __param._M_malpha)
   while (__f != __t)
     {
       do
  {
    do
      {
        __n = _M_nd(__urng);
        __v = result_type(1.0) + __param._M_a2 * __n;
      }
    while (__v <= 0.0);

    __v = __v * __v * __v;
    __u = __aurng();
  }
       while (__u > result_type(1.0) - 0.331 * __n * __n * __n * __n
       && (std::log(__u) > (0.5 * __n * __n + __a1
       * (1.0 - __v + std::log(__v)))));

       *__f++ = __a1 * __v * __param.beta();
     }
 else
   while (__f != __t)
     {
       do
  {
    do
      {
        __n = _M_nd(__urng);
        __v = result_type(1.0) + __param._M_a2 * __n;
      }
    while (__v <= 0.0);

    __v = __v * __v * __v;
    __u = __aurng();
  }
       while (__u > result_type(1.0) - 0.331 * __n * __n * __n * __n
       && (std::log(__u) > (0.5 * __n * __n + __a1
       * (1.0 - __v + std::log(__v)))));

       do
  __u = __aurng();
       while (__u == 0.0);

       *__f++ = (std::pow(__u, result_type(1.0) / __param.alpha())
   * __a1 * __v * __param.beta());
     }
      }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const gamma_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      __os << __x.alpha() << __space << __x.beta()
    << __space << __x._M_nd;

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        gamma_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      _RealType __alpha_val, __beta_val;
      __is >> __alpha_val >> __beta_val >> __x._M_nd;
      __x.param(typename gamma_distribution<_RealType>::
  param_type(__alpha_val, __beta_val));

      __is.flags(__flags);
      return __is;
    }


  template<typename _RealType>
    template<typename _UniformRandomNumberGenerator>
      typename weibull_distribution<_RealType>::result_type
      weibull_distribution<_RealType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __p)
      {
 __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
   __aurng(__urng);
 return __p.b() * std::pow(-std::log(result_type(1) - __aurng()),
      result_type(1) / __p.a());
      }

  template<typename _RealType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      weibull_distribution<_RealType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __p)
      {

 __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
   __aurng(__urng);
 auto __inv_a = result_type(1) / __p.a();

 while (__f != __t)
   *__f++ = __p.b() * std::pow(-std::log(result_type(1) - __aurng()),
          __inv_a);
      }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const weibull_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      __os << __x.a() << __space << __x.b();

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        weibull_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      _RealType __a, __b;
      __is >> __a >> __b;
      __x.param(typename weibull_distribution<_RealType>::
  param_type(__a, __b));

      __is.flags(__flags);
      return __is;
    }


  template<typename _RealType>
    template<typename _UniformRandomNumberGenerator>
      typename extreme_value_distribution<_RealType>::result_type
      extreme_value_distribution<_RealType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __p)
      {
 __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
   __aurng(__urng);
 return __p.a() - __p.b() * std::log(-std::log(result_type(1)
            - __aurng()));
      }

  template<typename _RealType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      extreme_value_distribution<_RealType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __p)
      {

 __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
   __aurng(__urng);

 while (__f != __t)
   *__f++ = __p.a() - __p.b() * std::log(-std::log(result_type(1)
         - __aurng()));
      }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const extreme_value_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      __os << __x.a() << __space << __x.b();

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        extreme_value_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      _RealType __a, __b;
      __is >> __a >> __b;
      __x.param(typename extreme_value_distribution<_RealType>::
  param_type(__a, __b));

      __is.flags(__flags);
      return __is;
    }


  template<typename _IntType>
    void
    discrete_distribution<_IntType>::param_type::
    _M_initialize()
    {
      if (_M_prob.size() < 2)
 {
   _M_prob.clear();
   return;
 }

      const double __sum = std::accumulate(_M_prob.begin(),
        _M_prob.end(), 0.0);

      __detail::__normalize(_M_prob.begin(), _M_prob.end(), _M_prob.begin(),
       __sum);

      _M_cp.reserve(_M_prob.size());
      std::partial_sum(_M_prob.begin(), _M_prob.end(),
         std::back_inserter(_M_cp));

      _M_cp[_M_cp.size() - 1] = 1.0;
    }

  template<typename _IntType>
    template<typename _Func>
      discrete_distribution<_IntType>::param_type::
      param_type(size_t __nw, double __xmin, double __xmax, _Func __fw)
      : _M_prob(), _M_cp()
      {
 const size_t __n = __nw == 0 ? 1 : __nw;
 const double __delta = (__xmax - __xmin) / __n;

 _M_prob.reserve(__n);
 for (size_t __k = 0; __k < __nw; ++__k)
   _M_prob.push_back(__fw(__xmin + __k * __delta + 0.5 * __delta));

 _M_initialize();
      }

  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename discrete_distribution<_IntType>::result_type
      discrete_distribution<_IntType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 if (__param._M_cp.empty())
   return result_type(0);

 __detail::_Adaptor<_UniformRandomNumberGenerator, double>
   __aurng(__urng);

 const double __p = __aurng();
 auto __pos = std::lower_bound(__param._M_cp.begin(),
          __param._M_cp.end(), __p);

 return __pos - __param._M_cp.begin();
      }

  template<typename _IntType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      discrete_distribution<_IntType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __param)
      {


 if (__param._M_cp.empty())
   {
     while (__f != __t)
       *__f++ = result_type(0);
     return;
   }

 __detail::_Adaptor<_UniformRandomNumberGenerator, double>
   __aurng(__urng);

 while (__f != __t)
   {
     const double __p = __aurng();
     auto __pos = std::lower_bound(__param._M_cp.begin(),
       __param._M_cp.end(), __p);

     *__f++ = __pos - __param._M_cp.begin();
   }
      }

  template<typename _IntType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const discrete_distribution<_IntType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<double>::max_digits10);

      std::vector<double> __prob = __x.probabilities();
      __os << __prob.size();
      for (auto __dit = __prob.begin(); __dit != __prob.end(); ++__dit)
 __os << __space << *__dit;

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _IntType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        discrete_distribution<_IntType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      size_t __n;
      __is >> __n;

      std::vector<double> __prob_vec;
      __prob_vec.reserve(__n);
      for (; __n != 0; --__n)
 {
   double __prob;
   __is >> __prob;
   __prob_vec.push_back(__prob);
 }

      __x.param(typename discrete_distribution<_IntType>::
  param_type(__prob_vec.begin(), __prob_vec.end()));

      __is.flags(__flags);
      return __is;
    }


  template<typename _RealType>
    void
    piecewise_constant_distribution<_RealType>::param_type::
    _M_initialize()
    {
      if (_M_int.size() < 2
   || (_M_int.size() == 2
       && _M_int[0] == _RealType(0)
       && _M_int[1] == _RealType(1)))
 {
   _M_int.clear();
   _M_den.clear();
   return;
 }

      const double __sum = std::accumulate(_M_den.begin(),
        _M_den.end(), 0.0);

      __detail::__normalize(_M_den.begin(), _M_den.end(), _M_den.begin(),
       __sum);

      _M_cp.reserve(_M_den.size());
      std::partial_sum(_M_den.begin(), _M_den.end(),
         std::back_inserter(_M_cp));


      _M_cp[_M_cp.size() - 1] = 1.0;

      for (size_t __k = 0; __k < _M_den.size(); ++__k)
 _M_den[__k] /= _M_int[__k + 1] - _M_int[__k];
    }

  template<typename _RealType>
    template<typename _InputIteratorB, typename _InputIteratorW>
      piecewise_constant_distribution<_RealType>::param_type::
      param_type(_InputIteratorB __bbegin,
   _InputIteratorB __bend,
   _InputIteratorW __wbegin)
      : _M_int(), _M_den(), _M_cp()
      {
 if (__bbegin != __bend)
   {
     for (;;)
       {
  _M_int.push_back(*__bbegin);
  ++__bbegin;
  if (__bbegin == __bend)
    break;

  _M_den.push_back(*__wbegin);
  ++__wbegin;
       }
   }

 _M_initialize();
      }

  template<typename _RealType>
    template<typename _Func>
      piecewise_constant_distribution<_RealType>::param_type::
      param_type(initializer_list<_RealType> __bl, _Func __fw)
      : _M_int(), _M_den(), _M_cp()
      {
 _M_int.reserve(__bl.size());
 for (auto __biter = __bl.begin(); __biter != __bl.end(); ++__biter)
   _M_int.push_back(*__biter);

 _M_den.reserve(_M_int.size() - 1);
 for (size_t __k = 0; __k < _M_int.size() - 1; ++__k)
   _M_den.push_back(__fw(0.5 * (_M_int[__k + 1] + _M_int[__k])));

 _M_initialize();
      }

  template<typename _RealType>
    template<typename _Func>
      piecewise_constant_distribution<_RealType>::param_type::
      param_type(size_t __nw, _RealType __xmin, _RealType __xmax, _Func __fw)
      : _M_int(), _M_den(), _M_cp()
      {
 const size_t __n = __nw == 0 ? 1 : __nw;
 const _RealType __delta = (__xmax - __xmin) / __n;

 _M_int.reserve(__n + 1);
 for (size_t __k = 0; __k <= __nw; ++__k)
   _M_int.push_back(__xmin + __k * __delta);

 _M_den.reserve(__n);
 for (size_t __k = 0; __k < __nw; ++__k)
   _M_den.push_back(__fw(_M_int[__k] + 0.5 * __delta));

 _M_initialize();
      }

  template<typename _RealType>
    template<typename _UniformRandomNumberGenerator>
      typename piecewise_constant_distribution<_RealType>::result_type
      piecewise_constant_distribution<_RealType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 __detail::_Adaptor<_UniformRandomNumberGenerator, double>
   __aurng(__urng);

 const double __p = __aurng();
 if (__param._M_cp.empty())
   return __p;

 auto __pos = std::lower_bound(__param._M_cp.begin(),
          __param._M_cp.end(), __p);
 const size_t __i = __pos - __param._M_cp.begin();

 const double __pref = __i > 0 ? __param._M_cp[__i - 1] : 0.0;

 return __param._M_int[__i] + (__p - __pref) / __param._M_den[__i];
      }

  template<typename _RealType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      piecewise_constant_distribution<_RealType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __param)
      {

 __detail::_Adaptor<_UniformRandomNumberGenerator, double>
   __aurng(__urng);

 if (__param._M_cp.empty())
   {
     while (__f != __t)
       *__f++ = __aurng();
     return;
   }

 while (__f != __t)
   {
     const double __p = __aurng();

     auto __pos = std::lower_bound(__param._M_cp.begin(),
       __param._M_cp.end(), __p);
     const size_t __i = __pos - __param._M_cp.begin();

     const double __pref = __i > 0 ? __param._M_cp[__i - 1] : 0.0;

     *__f++ = (__param._M_int[__i]
        + (__p - __pref) / __param._M_den[__i]);
   }
      }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const piecewise_constant_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      std::vector<_RealType> __int = __x.intervals();
      __os << __int.size() - 1;

      for (auto __xit = __int.begin(); __xit != __int.end(); ++__xit)
 __os << __space << *__xit;

      std::vector<double> __den = __x.densities();
      for (auto __dit = __den.begin(); __dit != __den.end(); ++__dit)
 __os << __space << *__dit;

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        piecewise_constant_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      size_t __n;
      __is >> __n;

      std::vector<_RealType> __int_vec;
      __int_vec.reserve(__n + 1);
      for (size_t __i = 0; __i <= __n; ++__i)
 {
   _RealType __int;
   __is >> __int;
   __int_vec.push_back(__int);
 }

      std::vector<double> __den_vec;
      __den_vec.reserve(__n);
      for (size_t __i = 0; __i < __n; ++__i)
 {
   double __den;
   __is >> __den;
   __den_vec.push_back(__den);
 }

      __x.param(typename piecewise_constant_distribution<_RealType>::
   param_type(__int_vec.begin(), __int_vec.end(), __den_vec.begin()));

      __is.flags(__flags);
      return __is;
    }


  template<typename _RealType>
    void
    piecewise_linear_distribution<_RealType>::param_type::
    _M_initialize()
    {
      if (_M_int.size() < 2
   || (_M_int.size() == 2
       && _M_int[0] == _RealType(0)
       && _M_int[1] == _RealType(1)
       && _M_den[0] == _M_den[1]))
 {
   _M_int.clear();
   _M_den.clear();
   return;
 }

      double __sum = 0.0;
      _M_cp.reserve(_M_int.size() - 1);
      _M_m.reserve(_M_int.size() - 1);
      for (size_t __k = 0; __k < _M_int.size() - 1; ++__k)
 {
   const _RealType __delta = _M_int[__k + 1] - _M_int[__k];
   __sum += 0.5 * (_M_den[__k + 1] + _M_den[__k]) * __delta;
   _M_cp.push_back(__sum);
   _M_m.push_back((_M_den[__k + 1] - _M_den[__k]) / __delta);
 }


      __detail::__normalize(_M_den.begin(), _M_den.end(), _M_den.begin(),
       __sum);

      __detail::__normalize(_M_cp.begin(), _M_cp.end(), _M_cp.begin(), __sum);

      __detail::__normalize(_M_m.begin(), _M_m.end(), _M_m.begin(), __sum);


      _M_cp[_M_cp.size() - 1] = 1.0;
     }

  template<typename _RealType>
    template<typename _InputIteratorB, typename _InputIteratorW>
      piecewise_linear_distribution<_RealType>::param_type::
      param_type(_InputIteratorB __bbegin,
   _InputIteratorB __bend,
   _InputIteratorW __wbegin)
      : _M_int(), _M_den(), _M_cp(), _M_m()
      {
 for (; __bbegin != __bend; ++__bbegin, ++__wbegin)
   {
     _M_int.push_back(*__bbegin);
     _M_den.push_back(*__wbegin);
   }

 _M_initialize();
      }

  template<typename _RealType>
    template<typename _Func>
      piecewise_linear_distribution<_RealType>::param_type::
      param_type(initializer_list<_RealType> __bl, _Func __fw)
      : _M_int(), _M_den(), _M_cp(), _M_m()
      {
 _M_int.reserve(__bl.size());
 _M_den.reserve(__bl.size());
 for (auto __biter = __bl.begin(); __biter != __bl.end(); ++__biter)
   {
     _M_int.push_back(*__biter);
     _M_den.push_back(__fw(*__biter));
   }

 _M_initialize();
      }

  template<typename _RealType>
    template<typename _Func>
      piecewise_linear_distribution<_RealType>::param_type::
      param_type(size_t __nw, _RealType __xmin, _RealType __xmax, _Func __fw)
      : _M_int(), _M_den(), _M_cp(), _M_m()
      {
 const size_t __n = __nw == 0 ? 1 : __nw;
 const _RealType __delta = (__xmax - __xmin) / __n;

 _M_int.reserve(__n + 1);
 _M_den.reserve(__n + 1);
 for (size_t __k = 0; __k <= __nw; ++__k)
   {
     _M_int.push_back(__xmin + __k * __delta);
     _M_den.push_back(__fw(_M_int[__k] + __delta));
   }

 _M_initialize();
      }

  template<typename _RealType>
    template<typename _UniformRandomNumberGenerator>
      typename piecewise_linear_distribution<_RealType>::result_type
      piecewise_linear_distribution<_RealType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 __detail::_Adaptor<_UniformRandomNumberGenerator, double>
   __aurng(__urng);

 const double __p = __aurng();
 if (__param._M_cp.empty())
   return __p;

 auto __pos = std::lower_bound(__param._M_cp.begin(),
          __param._M_cp.end(), __p);
 const size_t __i = __pos - __param._M_cp.begin();

 const double __pref = __i > 0 ? __param._M_cp[__i - 1] : 0.0;

 const double __a = 0.5 * __param._M_m[__i];
 const double __b = __param._M_den[__i];
 const double __cm = __p - __pref;

 _RealType __x = __param._M_int[__i];
 if (__a == 0)
   __x += __cm / __b;
 else
   {
     const double __d = __b * __b + 4.0 * __a * __cm;
     __x += 0.5 * (std::sqrt(__d) - __b) / __a;
          }

        return __x;
      }

  template<typename _RealType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      piecewise_linear_distribution<_RealType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __param)
      {


 while (__f != __t)
   *__f++ = this->operator()(__urng, __param);
      }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const piecewise_linear_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      std::vector<_RealType> __int = __x.intervals();
      __os << __int.size() - 1;

      for (auto __xit = __int.begin(); __xit != __int.end(); ++__xit)
 __os << __space << *__xit;

      std::vector<double> __den = __x.densities();
      for (auto __dit = __den.begin(); __dit != __den.end(); ++__dit)
 __os << __space << *__dit;

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        piecewise_linear_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      size_t __n;
      __is >> __n;

      std::vector<_RealType> __int_vec;
      __int_vec.reserve(__n + 1);
      for (size_t __i = 0; __i <= __n; ++__i)
 {
   _RealType __int;
   __is >> __int;
   __int_vec.push_back(__int);
 }

      std::vector<double> __den_vec;
      __den_vec.reserve(__n + 1);
      for (size_t __i = 0; __i <= __n; ++__i)
 {
   double __den;
   __is >> __den;
   __den_vec.push_back(__den);
 }

      __x.param(typename piecewise_linear_distribution<_RealType>::
   param_type(__int_vec.begin(), __int_vec.end(), __den_vec.begin()));

      __is.flags(__flags);
      return __is;
    }


  template<typename _IntType>
    seed_seq::seed_seq(std::initializer_list<_IntType> __il)
    {
      for (auto __iter = __il.begin(); __iter != __il.end(); ++__iter)
 _M_v.push_back(__detail::__mod<result_type,
         __detail::_Shift<result_type, 32>::__value>(*__iter));
    }

  template<typename _InputIterator>
    seed_seq::seed_seq(_InputIterator __begin, _InputIterator __end)
    {
      for (_InputIterator __iter = __begin; __iter != __end; ++__iter)
 _M_v.push_back(__detail::__mod<result_type,
         __detail::_Shift<result_type, 32>::__value>(*__iter));
    }

  template<typename _RandomAccessIterator>
    void
    seed_seq::generate(_RandomAccessIterator __begin,
         _RandomAccessIterator __end)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
        _Type;

      if (__begin == __end)
 return;

      std::fill(__begin, __end, _Type(0x8b8b8b8bu));

      const size_t __n = __end - __begin;
      const size_t __s = _M_v.size();
      const size_t __t = (__n >= 623) ? 11
         : (__n >= 68) ? 7
         : (__n >= 39) ? 5
         : (__n >= 7) ? 3
         : (__n - 1) / 2;
      const size_t __p = (__n - __t) / 2;
      const size_t __q = __p + __t;
      const size_t __m = std::max(size_t(__s + 1), __n);

      for (size_t __k = 0; __k < __m; ++__k)
 {
   _Type __arg = (__begin[__k % __n]
    ^ __begin[(__k + __p) % __n]
    ^ __begin[(__k - 1) % __n]);
   _Type __r1 = __arg ^ (__arg >> 27);
   __r1 = __detail::__mod<_Type,
      __detail::_Shift<_Type, 32>::__value>(1664525u * __r1);
   _Type __r2 = __r1;
   if (__k == 0)
     __r2 += __s;
   else if (__k <= __s)
     __r2 += __k % __n + _M_v[__k - 1];
   else
     __r2 += __k % __n;
   __r2 = __detail::__mod<_Type,
            __detail::_Shift<_Type, 32>::__value>(__r2);
   __begin[(__k + __p) % __n] += __r1;
   __begin[(__k + __q) % __n] += __r2;
   __begin[__k % __n] = __r2;
 }

      for (size_t __k = __m; __k < __m + __n; ++__k)
 {
   _Type __arg = (__begin[__k % __n]
    + __begin[(__k + __p) % __n]
    + __begin[(__k - 1) % __n]);
   _Type __r3 = __arg ^ (__arg >> 27);
   __r3 = __detail::__mod<_Type,
     __detail::_Shift<_Type, 32>::__value>(1566083941u * __r3);
   _Type __r4 = __r3 - __k % __n;
   __r4 = __detail::__mod<_Type,
            __detail::_Shift<_Type, 32>::__value>(__r4);
   __begin[(__k + __p) % __n] ^= __r3;
   __begin[(__k + __q) % __n] ^= __r4;
   __begin[__k % __n] = __r4;
 }
    }

  template<typename _RealType, size_t __bits,
    typename _UniformRandomNumberGenerator>
    _RealType
    generate_canonical(_UniformRandomNumberGenerator& __urng)
    {
      const size_t __b
 = std::min(static_cast<size_t>(std::numeric_limits<_RealType>::digits),
                   __bits);
      const long double __r = static_cast<long double>(__urng.max())
       - static_cast<long double>(__urng.min()) + 1.0L;
      const size_t __log2r = std::log(__r) / std::log(2.0L);
      size_t __k = std::max<size_t>(1UL, (__b + __log2r - 1UL) / __log2r);
      _RealType __sum = _RealType(0);
      _RealType __tmp = _RealType(1);
      for (; __k != 0; --__k)
 {
   __sum += _RealType(__urng() - __urng.min()) * __tmp;
   __tmp *= __r;
 }
      return __sum / __tmp;
    }


}
# 53 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/random" 2 3
# 66 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/functional" 1 3
# 47 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/functional" 3






# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/typeinfo" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/typeinfo" 3






#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 80 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/typeinfo" 3
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();



    const char* name() const noexcept
    { return __name[0] == '*' ? __name + 1 : __name; }
# 115 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/typeinfo" 3
    bool before(const type_info& __arg) const noexcept
    { return (__name[0] == '*' && __arg.__name[0] == '*')
 ? __name < __arg.__name
 : __builtin_strcmp (__name, __arg.__name) < 0; }

    bool operator==(const type_info& __arg) const noexcept
    {
      return ((__name == __arg.__name)
       || (__name[0] != '*' &&
    __builtin_strcmp (__name, __arg.__name) == 0));
    }
# 136 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/typeinfo" 3
    bool operator!=(const type_info& __arg) const noexcept
    { return !operator==(__arg); }


    size_t hash_code() const noexcept
    {

      return _Hash_bytes(name(), __builtin_strlen(name()),
    static_cast<size_t>(0xc70f6907UL));



    }



    virtual bool __is_pointer_p() const;


    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;

  protected:
    const char *__name;

    explicit type_info(const char *__n): __name(__n) { }

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);
  };







  class bad_cast : public exception
  {
  public:
    bad_cast() noexcept { }



    virtual ~bad_cast() noexcept;


    virtual const char* what() const noexcept;
  };





  class bad_typeid : public exception
  {
  public:
    bad_typeid () noexcept { }



    virtual ~bad_typeid() noexcept;


    virtual const char* what() const noexcept;
  };
}

}

#pragma GCC visibility pop
# 54 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/functional" 2 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/tuple" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/tuple" 3






# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/array" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/array" 3





# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/stdexcept" 1 3
# 37 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/stdexcept" 3




namespace std __attribute__ ((__visibility__ ("default")))
{
# 55 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/stdexcept" 3
  class logic_error : public exception
  {
    string _M_msg;

  public:

    explicit
    logic_error(const string& __arg);

    virtual ~logic_error() noexcept;



    virtual const char*
    what() const noexcept;
  };



  class domain_error : public logic_error
  {
  public:
    explicit domain_error(const string& __arg);
    virtual ~domain_error() noexcept;
  };


  class invalid_argument : public logic_error
  {
  public:
    explicit invalid_argument(const string& __arg);
    virtual ~invalid_argument() noexcept;
  };



  class length_error : public logic_error
  {
  public:
    explicit length_error(const string& __arg);
    virtual ~length_error() noexcept;
  };



  class out_of_range : public logic_error
  {
  public:
    explicit out_of_range(const string& __arg);
    virtual ~out_of_range() noexcept;
  };






  class runtime_error : public exception
  {
    string _M_msg;

  public:

    explicit
    runtime_error(const string& __arg);

    virtual ~runtime_error() noexcept;



    virtual const char*
    what() const noexcept;
  };


  class range_error : public runtime_error
  {
  public:
    explicit range_error(const string& __arg);
    virtual ~range_error() noexcept;
  };


  class overflow_error : public runtime_error
  {
  public:
    explicit overflow_error(const string& __arg);
    virtual ~overflow_error() noexcept;
  };


  class underflow_error : public runtime_error
  {
  public:
    explicit underflow_error(const string& __arg);
    virtual ~underflow_error() noexcept;
  };




}
# 39 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/array" 2 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, std::size_t _Nm>
    struct __array_traits
    {
      typedef _Tp _Type[_Nm];

      static constexpr _Tp&
      _S_ref(const _Type& __t, std::size_t __n) noexcept
      { return const_cast<_Tp&>(__t[__n]); }
    };

 template<typename _Tp>
   struct __array_traits<_Tp, 0>
   {
     struct _Type { };

     static constexpr _Tp&
     _S_ref(const _Type&, std::size_t) noexcept
     { return *static_cast<_Tp*>(nullptr); }
   };
# 80 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/array" 3
  template<typename _Tp, std::size_t _Nm>
    struct array
    {
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef value_type* iterator;
      typedef const value_type* const_iterator;
      typedef std::size_t size_type;
      typedef std::ptrdiff_t difference_type;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;


      typedef std::__array_traits<_Tp, _Nm> _AT_Type;
      typename _AT_Type::_Type _M_elems;




      void
      fill(const value_type& __u)
      { std::fill_n(begin(), size(), __u); }

      void
      swap(array& __other)
      noexcept(noexcept(swap(std::declval<_Tp&>(), std::declval<_Tp&>())))
      { std::swap_ranges(begin(), end(), __other.begin()); }


      iterator
      begin() noexcept
      { return iterator(data()); }

      const_iterator
      begin() const noexcept
      { return const_iterator(data()); }

      iterator
      end() noexcept
      { return iterator(data() + _Nm); }

      const_iterator
      end() const noexcept
      { return const_iterator(data() + _Nm); }

      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }

      const_iterator
      cbegin() const noexcept
      { return const_iterator(data()); }

      const_iterator
      cend() const noexcept
      { return const_iterator(data() + _Nm); }

      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }

      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }


      constexpr size_type
      size() const noexcept { return _Nm; }

      constexpr size_type
      max_size() const noexcept { return _Nm; }

      constexpr bool
      empty() const noexcept { return size() == 0; }


      reference
      operator[](size_type __n)
      { return _AT_Type::_S_ref(_M_elems, __n); }

      constexpr const_reference
      operator[](size_type __n) const noexcept
      { return _AT_Type::_S_ref(_M_elems, __n); }

      reference
      at(size_type __n)
      {
 if (__n >= _Nm)
   std::__throw_out_of_range(("array::at"));
 return _AT_Type::_S_ref(_M_elems, __n);
      }

      constexpr const_reference
      at(size_type __n) const
      {


 return __n < _Nm ? _AT_Type::_S_ref(_M_elems, __n)
   : (std::__throw_out_of_range(("array::at")),
      _AT_Type::_S_ref(_M_elems, 0));
      }

      reference
      front()
      { return *begin(); }

      constexpr const_reference
      front() const
      { return _AT_Type::_S_ref(_M_elems, 0); }

      reference
      back()
      { return _Nm ? *(end() - 1) : *end(); }

      constexpr const_reference
      back() const
      {
 return _Nm ? _AT_Type::_S_ref(_M_elems, _Nm - 1)
             : _AT_Type::_S_ref(_M_elems, 0);
      }

      pointer
      data() noexcept
      { return std::__addressof(_AT_Type::_S_ref(_M_elems, 0)); }

      const_pointer
      data() const noexcept
      { return std::__addressof(_AT_Type::_S_ref(_M_elems, 0)); }
    };


  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator==(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return std::equal(__one.begin(), __one.end(), __two.begin()); }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one == __two); }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator<(const array<_Tp, _Nm>& __a, const array<_Tp, _Nm>& __b)
    {
      return std::lexicographical_compare(__a.begin(), __a.end(),
       __b.begin(), __b.end());
    }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator>(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return __two < __one; }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator<=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one > __two); }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator>=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one < __two); }


  template<typename _Tp, std::size_t _Nm>
    inline void
    swap(array<_Tp, _Nm>& __one, array<_Tp, _Nm>& __two)
    noexcept(noexcept(__one.swap(__two)))
    { __one.swap(__two); }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr _Tp&
    get(array<_Tp, _Nm>& __arr) noexcept
    {
      static_assert(_Int < _Nm, "index is out of bounds");
      return std::__array_traits<_Tp, _Nm>::
 _S_ref(__arr._M_elems, _Int);
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr _Tp&&
    get(array<_Tp, _Nm>&& __arr) noexcept
    {
      static_assert(_Int < _Nm, "index is out of bounds");
      return std::move(get<_Int>(__arr));
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr const _Tp&
    get(const array<_Tp, _Nm>& __arr) noexcept
    {
      static_assert(_Int < _Nm, "index is out of bounds");
      return std::__array_traits<_Tp, _Nm>::
 _S_ref(__arr._M_elems, _Int);
    }


}

namespace std __attribute__ ((__visibility__ ("default")))
{





  template<typename _Tp>
    class tuple_size;

  template<typename _Tp, std::size_t _Nm>
    struct tuple_size<std::array<_Tp, _Nm>>
    : public integral_constant<std::size_t, _Nm> { };


  template<std::size_t _Int, typename _Tp>
    class tuple_element;

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    struct tuple_element<_Int, std::array<_Tp, _Nm>>
    {
      static_assert(_Int < _Nm, "index is out of bounds");
      typedef _Tp type;
    };


}
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/tuple" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/uses_allocator.h" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/uses_allocator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  struct allocator_arg_t { };

  constexpr allocator_arg_t allocator_arg = allocator_arg_t();

template<typename _Tp> class __has_allocator_type_helper : __sfinae_types { template<typename _Up> struct _Wrap_type { }; template<typename _Up> static __one __test(_Wrap_type<typename _Up::allocator_type>*); template<typename _Up> static __two __test(...); public: static constexpr bool value = sizeof(__test<_Tp>(0)) == 1; }; template<typename _Tp> struct __has_allocator_type : integral_constant<bool, __has_allocator_type_helper <typename remove_cv<_Tp>::type>::value> { };

  template<typename _Tp, typename _Alloc,
    bool = __has_allocator_type<_Tp>::value>
    struct __uses_allocator_helper
    : public false_type { };

  template<typename _Tp, typename _Alloc>
    struct __uses_allocator_helper<_Tp, _Alloc, true>
    : public integral_constant<bool, is_convertible<_Alloc,
         typename _Tp::allocator_type>::value>
    { };


  template<typename _Tp, typename _Alloc>
    struct uses_allocator
    : public integral_constant<bool,
          __uses_allocator_helper<_Tp, _Alloc>::value>
    { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_allocator_arg
    : is_constructible<_Tp, _Alloc, _Args...>
    { static_assert( uses_allocator<_Tp, _Alloc>::value, "uses allocator" ); };

  struct __uses_alloc_base { };
  struct __uses_alloc0 : __uses_alloc_base
  { struct _Anything { _Anything(...) { } } _M_a; };
  template<typename _Alloc>
    struct __uses_alloc1 : __uses_alloc_base { const _Alloc* _M_a; };
  template<typename _Alloc>
    struct __uses_alloc2 : __uses_alloc_base { const _Alloc* _M_a; };

  template<bool, typename _Alloc, typename... _Args>
    struct __uses_alloc;

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<true, _Tp, _Alloc, _Args...>
    : conditional<
        is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value,
        __uses_alloc1<_Alloc>,
        __uses_alloc2<_Alloc>>::type
    { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<false, _Tp, _Alloc, _Args...>
    : __uses_alloc0 { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc_impl
    : __uses_alloc<uses_allocator<_Tp, _Alloc>::value, _Tp, _Alloc, _Args...>
    { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    __uses_alloc_impl<_Tp, _Alloc, _Args...>
    __use_alloc(const _Alloc& __a)
    {
      __uses_alloc_impl<_Tp, _Alloc, _Args...> __ret;
      __ret._M_a = &__a;
      return __ret;
    }


}
# 41 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/tuple" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
# 52 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/tuple" 3
  template<typename _Tp>
    struct __add_c_ref
    { typedef const _Tp& type; };

  template<typename _Tp>
    struct __add_c_ref<_Tp&>
    { typedef _Tp& type; };


  template<typename _Tp>
    struct __add_ref
    { typedef _Tp& type; };

  template<typename _Tp>
    struct __add_ref<_Tp&>
    { typedef _Tp& type; };


  template<typename _Tp>
    struct __add_r_ref
    { typedef _Tp&& type; };

  template<typename _Tp>
    struct __add_r_ref<_Tp&>
    { typedef _Tp& type; };

  template<std::size_t _Idx, typename _Head, bool _IsEmptyNotFinal>
    struct _Head_base;

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, true>
    : public _Head
    {
      constexpr _Head_base()
      : _Head() { }

      constexpr _Head_base(const _Head& __h)
      : _Head(__h) { }

      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
 : _Head(std::forward<_UHead>(__h)) { }

      _Head_base(allocator_arg_t, __uses_alloc0)
      : _Head() { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 : _Head(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 : _Head(*__a._M_a) { }

      template<typename _UHead>
 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _Head(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _Head(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _Head(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b; }
    };

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, false>
    {
      constexpr _Head_base()
      : _M_head_impl() { }

      constexpr _Head_base(const _Head& __h)
      : _M_head_impl(__h) { }

      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
 : _M_head_impl(std::forward<_UHead>(__h)) { }

      _Head_base(allocator_arg_t, __uses_alloc0)
      : _M_head_impl() { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 : _M_head_impl(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 : _M_head_impl(*__a._M_a) { }

      template<typename _UHead>
 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead))
 { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b._M_head_impl; }

      _Head _M_head_impl;
    };
# 185 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/tuple" 3
  template<std::size_t _Idx, typename... _Elements>
    struct _Tuple_impl;





  template<std::size_t _Idx>
    struct _Tuple_impl<_Idx>
    {
      template<std::size_t, typename...> friend class _Tuple_impl;

      _Tuple_impl() = default;

      template<typename _Alloc>
        _Tuple_impl(allocator_arg_t, const _Alloc&) { }

      template<typename _Alloc>
        _Tuple_impl(allocator_arg_t, const _Alloc&, const _Tuple_impl&) { }

      template<typename _Alloc>
        _Tuple_impl(allocator_arg_t, const _Alloc&, _Tuple_impl&&) { }

    protected:
      void _M_swap(_Tuple_impl&) noexcept { }
    };

  template<typename _Tp>
    struct __is_empty_non_tuple : is_empty<_Tp> { };


  template<typename _El0, typename... _El>
    struct __is_empty_non_tuple<tuple<_El0, _El...>> : false_type { };


  template<typename _Tp>
    using __empty_not_final
    = typename conditional<__is_final(_Tp), false_type,
      __is_empty_non_tuple<_Tp>>::type;






  template<std::size_t _Idx, typename _Head, typename... _Tail>
    struct _Tuple_impl<_Idx, _Head, _Tail...>
    : public _Tuple_impl<_Idx + 1, _Tail...>,
      private _Head_base<_Idx, _Head, __empty_not_final<_Head>::value>
    {
      template<std::size_t, typename...> friend class _Tuple_impl;

      typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;
      typedef _Head_base<_Idx, _Head, __empty_not_final<_Head>::value> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr _Inherited&
      _M_tail(_Tuple_impl& __t) noexcept { return __t; }

      static constexpr const _Inherited&
      _M_tail(const _Tuple_impl& __t) noexcept { return __t; }

      constexpr _Tuple_impl()
      : _Inherited(), _Base() { }

      explicit
      constexpr _Tuple_impl(const _Head& __head, const _Tail&... __tail)
      : _Inherited(__tail...), _Base(__head) { }

      template<typename _UHead, typename... _UTail, typename = typename
               enable_if<sizeof...(_Tail) == sizeof...(_UTail)>::type>
        explicit
        constexpr _Tuple_impl(_UHead&& __head, _UTail&&... __tail)
 : _Inherited(std::forward<_UTail>(__tail)...),
   _Base(std::forward<_UHead>(__head)) { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;

      constexpr
      _Tuple_impl(_Tuple_impl&& __in)
      noexcept(__and_<is_nothrow_move_constructible<_Head>,
               is_nothrow_move_constructible<_Inherited>>::value)
      : _Inherited(std::move(_M_tail(__in))),
 _Base(std::forward<_Head>(_M_head(__in))) { }

      template<typename... _UElements>
        constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
   _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }

      template<typename _UHead, typename... _UTails>
        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a),
          _Base(__tag, __use_alloc<_Head>(__a)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Head& __head, const _Tail&... __tail)
 : _Inherited(__tag, __a, __tail...),
          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }

      template<typename _Alloc, typename _UHead, typename... _UTail,
               typename = typename enable_if<sizeof...(_Tail)
          == sizeof...(_UTail)>::type>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _UHead&& __head, _UTail&&... __tail)
 : _Inherited(__tag, __a, std::forward<_UTail>(__tail)...),
          _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
         std::forward<_UHead>(__head)) { }

      template<typename _Alloc>
        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl& __in)
 : _Inherited(__tag, __a, _M_tail(__in)),
          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl&& __in)
 : _Inherited(__tag, __a, std::move(_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
         std::forward<_Head>(_M_head(__in))) { }

      template<typename _Alloc, typename... _UElements>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(__tag, __a,
       _Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
  _Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }

      template<typename _Alloc, typename _UHead, typename... _UTails>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(__tag, __a, std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }

      _Tuple_impl&
      operator=(const _Tuple_impl& __in)
      {
 _M_head(*this) = _M_head(__in);
 _M_tail(*this) = _M_tail(__in);
 return *this;
      }

      _Tuple_impl&
      operator=(_Tuple_impl&& __in)
      noexcept(__and_<is_nothrow_move_assignable<_Head>,
               is_nothrow_move_assignable<_Inherited>>::value)
      {
 _M_head(*this) = std::forward<_Head>(_M_head(__in));
 _M_tail(*this) = std::move(_M_tail(__in));
 return *this;
      }

      template<typename... _UElements>
        _Tuple_impl&
        operator=(const _Tuple_impl<_Idx, _UElements...>& __in)
        {
   _M_head(*this) = _Tuple_impl<_Idx, _UElements...>::_M_head(__in);
   _M_tail(*this) = _Tuple_impl<_Idx, _UElements...>::_M_tail(__in);
   return *this;
 }

      template<typename _UHead, typename... _UTails>
        _Tuple_impl&
        operator=(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
        {
   _M_head(*this) = std::forward<_UHead>
     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in));
   _M_tail(*this) = std::move
     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in));
   return *this;
 }

    protected:
      void
      _M_swap(_Tuple_impl& __in)
      noexcept(noexcept(swap(std::declval<_Head&>(),
        std::declval<_Head&>()))
        && noexcept(_M_tail(__in)._M_swap(_M_tail(__in))))
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
 _Inherited::_M_swap(_M_tail(__in));
      }
    };


  template<typename... _Elements>
    class tuple : public _Tuple_impl<0, _Elements...>
    {
      typedef _Tuple_impl<0, _Elements...> _Inherited;

    public:
      constexpr tuple()
      : _Inherited() { }

      explicit
      constexpr tuple(const _Elements&... __elements)
      : _Inherited(__elements...) { }

      template<typename... _UElements, typename = typename
        enable_if<__and_<is_convertible<_UElements,
     _Elements>...>::value>::type>
 explicit
        constexpr tuple(_UElements&&... __elements)
 : _Inherited(std::forward<_UElements>(__elements)...) { }

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;

      template<typename... _UElements, typename = typename
        enable_if<__and_<is_convertible<const _UElements&,
     _Elements>...>::value>::type>
        constexpr tuple(const tuple<_UElements...>& __in)
        : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
        { }

      template<typename... _UElements, typename = typename
        enable_if<__and_<is_convertible<_UElements,
     _Elements>...>::value>::type>
        constexpr tuple(tuple<_UElements...>&& __in)
        : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }



      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _Elements&... __elements)
 : _Inherited(__tag, __a, __elements...) { }

      template<typename _Alloc, typename... _UElements, typename = typename
        enable_if<sizeof...(_UElements)
    == sizeof...(_Elements)>::type>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       _UElements&&... __elements)
 : _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)
        { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }

      template<typename _Alloc, typename... _UElements, typename = typename
        enable_if<sizeof...(_UElements)
    == sizeof...(_Elements)>::type>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_UElements...>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename _Alloc, typename... _UElements, typename = typename
        enable_if<sizeof...(_UElements)
    == sizeof...(_Elements)>::type>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       tuple<_UElements...>&& __in)
 : _Inherited(__tag, __a,
              static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
 { }

      tuple&
      operator=(const tuple& __in)
      {
 static_cast<_Inherited&>(*this) = __in;
 return *this;
      }

      tuple&
      operator=(tuple&& __in)
      noexcept(is_nothrow_move_assignable<_Inherited>::value)
      {
 static_cast<_Inherited&>(*this) = std::move(__in);
 return *this;
      }

      template<typename... _UElements, typename = typename
        enable_if<sizeof...(_UElements)
    == sizeof...(_Elements)>::type>
        tuple&
        operator=(const tuple<_UElements...>& __in)
        {
   static_cast<_Inherited&>(*this) = __in;
   return *this;
 }

      template<typename... _UElements, typename = typename
        enable_if<sizeof...(_UElements)
    == sizeof...(_Elements)>::type>
        tuple&
        operator=(tuple<_UElements...>&& __in)
        {
   static_cast<_Inherited&>(*this) = std::move(__in);
   return *this;
 }

      void
      swap(tuple& __in)
      noexcept(noexcept(__in._M_swap(__in)))
      { _Inherited::_M_swap(__in); }
    };


  template<>
    class tuple<>
    {
    public:
      void swap(tuple&) noexcept { }
    };



  template<typename _T1, typename _T2>
    class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2>
    {
      typedef _Tuple_impl<0, _T1, _T2> _Inherited;

    public:
      constexpr tuple()
      : _Inherited() { }

      explicit
      constexpr tuple(const _T1& __a1, const _T2& __a2)
      : _Inherited(__a1, __a2) { }

      template<typename _U1, typename _U2, typename = typename
        enable_if<__and_<is_convertible<_U1, _T1>,
    is_convertible<_U2, _T2>>::value>::type>
        explicit
        constexpr tuple(_U1&& __a1, _U2&& __a2)
 : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;

      template<typename _U1, typename _U2, typename = typename
 enable_if<__and_<is_convertible<const _U1&, _T1>,
    is_convertible<const _U2&, _T2>>::value>::type>
        constexpr tuple(const tuple<_U1, _U2>& __in)
 : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }

      template<typename _U1, typename _U2, typename = typename
        enable_if<__and_<is_convertible<_U1, _T1>,
    is_convertible<_U2, _T2>>::value>::type>
        constexpr tuple(tuple<_U1, _U2>&& __in)
 : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }

      template<typename _U1, typename _U2, typename = typename
 enable_if<__and_<is_convertible<const _U1&, _T1>,
    is_convertible<const _U2&, _T2>>::value>::type>
        constexpr tuple(const pair<_U1, _U2>& __in)
 : _Inherited(__in.first, __in.second) { }

      template<typename _U1, typename _U2, typename = typename
        enable_if<__and_<is_convertible<_U1, _T1>,
    is_convertible<_U2, _T2>>::value>::type>
        constexpr tuple(pair<_U1, _U2>&& __in)
 : _Inherited(std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }



      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _T1& __a1, const _T2& __a2)
 : _Inherited(__tag, __a, __a1, __a2) { }

      template<typename _Alloc, typename _U1, typename _U2>
 tuple(allocator_arg_t __tag, const _Alloc& __a, _U1&& __a1, _U2&& __a2)
 : _Inherited(__tag, __a, std::forward<_U1>(__a1),
              std::forward<_U2>(__a2)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }

      template<typename _Alloc, typename _U1, typename _U2>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_U1, _U2>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2>
        tuple(allocator_arg_t __tag, const _Alloc& __a,
       const pair<_U1, _U2>& __in)
 : _Inherited(__tag, __a, __in.first, __in.second) { }

      template<typename _Alloc, typename _U1, typename _U2>
        tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      tuple&
      operator=(const tuple& __in)
      {
 static_cast<_Inherited&>(*this) = __in;
 return *this;
      }

      tuple&
      operator=(tuple&& __in)
      noexcept(is_nothrow_move_assignable<_Inherited>::value)
      {
 static_cast<_Inherited&>(*this) = std::move(__in);
 return *this;
      }

      template<typename _U1, typename _U2>
        tuple&
        operator=(const tuple<_U1, _U2>& __in)
        {
   static_cast<_Inherited&>(*this) = __in;
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(tuple<_U1, _U2>&& __in)
        {
   static_cast<_Inherited&>(*this) = std::move(__in);
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(const pair<_U1, _U2>& __in)
        {
   this->_M_head(*this) = __in.first;
   this->_M_tail(*this)._M_head(*this) = __in.second;
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(pair<_U1, _U2>&& __in)
        {
   this->_M_head(*this) = std::forward<_U1>(__in.first);
   this->_M_tail(*this)._M_head(*this) = std::forward<_U2>(__in.second);
   return *this;
 }

      void
      swap(tuple& __in)
      noexcept(noexcept(__in._M_swap(__in)))
      { _Inherited::_M_swap(__in); }
    };



  template<std::size_t __i, typename _Tp>
    struct tuple_element;





  template<std::size_t __i, typename _Head, typename... _Tail>
    struct tuple_element<__i, tuple<_Head, _Tail...> >
    : tuple_element<__i - 1, tuple<_Tail...> > { };




  template<typename _Head, typename... _Tail>
    struct tuple_element<0, tuple<_Head, _Tail...> >
    {
      typedef _Head type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const _Tp>
    {
      typedef typename
      add_const<typename tuple_element<__i, _Tp>::type>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, volatile _Tp>
    {
      typedef typename
      add_volatile<typename tuple_element<__i, _Tp>::type>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const volatile _Tp>
    {
      typedef typename
      add_cv<typename tuple_element<__i, _Tp>::type>::type type;
    };


  template<typename _Tp>
    struct tuple_size;

  template<typename _Tp>
    struct tuple_size<const _Tp>
    : public integral_constant<
             typename remove_cv<decltype(tuple_size<_Tp>::value)>::type,
             tuple_size<_Tp>::value> { };

  template<typename _Tp>
    struct tuple_size<volatile _Tp>
    : public integral_constant<
             typename remove_cv<decltype(tuple_size<_Tp>::value)>::type,
             tuple_size<_Tp>::value> { };

  template<typename _Tp>
    struct tuple_size<const volatile _Tp>
    : public integral_constant<
             typename remove_cv<decltype(tuple_size<_Tp>::value)>::type,
             tuple_size<_Tp>::value> { };


  template<typename... _Elements>
    struct tuple_size<tuple<_Elements...>>
    : public integral_constant<std::size_t, sizeof...(_Elements)> { };

  template<std::size_t __i, typename _Head, typename... _Tail>
    constexpr typename __add_ref<_Head>::type
    __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }

  template<std::size_t __i, typename _Head, typename... _Tail>
    constexpr typename __add_c_ref<_Head>::type
    __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }




  template<std::size_t __i, typename... _Elements>
    constexpr typename __add_ref<
                      typename tuple_element<__i, tuple<_Elements...>>::type
                    >::type
    get(tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }

  template<std::size_t __i, typename... _Elements>
    constexpr typename __add_c_ref<
                      typename tuple_element<__i, tuple<_Elements...>>::type
                    >::type
    get(const tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }

  template<std::size_t __i, typename... _Elements>
    constexpr typename __add_r_ref<
                      typename tuple_element<__i, tuple<_Elements...>>::type
                    >::type
    get(tuple<_Elements...>&& __t) noexcept
    { return std::forward<typename tuple_element<__i,
 tuple<_Elements...>>::type&&>(get<__i>(__t)); }


  template<std::size_t __check_equal_size, std::size_t __i, std::size_t __j,
    typename _Tp, typename _Up>
    struct __tuple_compare;

  template<std::size_t __i, std::size_t __j, typename _Tp, typename _Up>
    struct __tuple_compare<0, __i, __j, _Tp, _Up>
    {
      static constexpr bool
      __eq(const _Tp& __t, const _Up& __u)
      {
 return (get<__i>(__t) == get<__i>(__u) &&
  __tuple_compare<0, __i + 1, __j, _Tp, _Up>::__eq(__t, __u));
      }

      static constexpr bool
      __less(const _Tp& __t, const _Up& __u)
      {
 return ((get<__i>(__t) < get<__i>(__u))
  || !(get<__i>(__u) < get<__i>(__t)) &&
  __tuple_compare<0, __i + 1, __j, _Tp, _Up>::__less(__t, __u));
      }
    };

  template<std::size_t __i, typename _Tp, typename _Up>
    struct __tuple_compare<0, __i, __i, _Tp, _Up>
    {
      static constexpr bool
      __eq(const _Tp&, const _Up&) { return true; }

      static constexpr bool
      __less(const _Tp&, const _Up&) { return false; }
    };

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator==(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    {
      typedef tuple<_TElements...> _Tp;
      typedef tuple<_UElements...> _Up;
      return bool(__tuple_compare<tuple_size<_Tp>::value - tuple_size<_Up>::value,
       0, tuple_size<_Tp>::value, _Tp, _Up>::__eq(__t, __u));
    }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator<(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    {
      typedef tuple<_TElements...> _Tp;
      typedef tuple<_UElements...> _Up;
      return bool(__tuple_compare<tuple_size<_Tp>::value - tuple_size<_Up>::value,
       0, tuple_size<_Tp>::value, _Tp, _Up>::__less(__t, __u));
    }

  template<typename... _TElements, typename... _UElements>
    inline constexpr bool
    operator!=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t == __u); }

  template<typename... _TElements, typename... _UElements>
    inline constexpr bool
    operator>(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    { return __u < __t; }

  template<typename... _TElements, typename... _UElements>
    inline constexpr bool
    operator<=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__u < __t); }

  template<typename... _TElements, typename... _UElements>
    inline constexpr bool
    operator>=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t < __u); }


  template<typename... _Elements>
    constexpr tuple<typename __decay_and_strip<_Elements>::__type...>
    make_tuple(_Elements&&... __args)
    {
      typedef tuple<typename __decay_and_strip<_Elements>::__type...>
 __result_type;
      return __result_type(std::forward<_Elements>(__args)...);
    }

  template<typename... _Elements>
    tuple<_Elements&&...>
    forward_as_tuple(_Elements&&... __args) noexcept
    { return tuple<_Elements&&...>(std::forward<_Elements>(__args)...); }

  template<typename>
    struct __is_tuple_like_impl : false_type
    { };

  template<typename... _Tps>
    struct __is_tuple_like_impl<tuple<_Tps...>> : true_type
    { };

  template<typename _T1, typename _T2>
    struct __is_tuple_like_impl<pair<_T1, _T2>> : true_type
    { };

  template<typename _Tp, std::size_t _Nm>
    struct __is_tuple_like_impl<array<_Tp, _Nm>> : true_type
    { };


  template<typename _Tp>
    struct __is_tuple_like
    : public __is_tuple_like_impl<typename std::remove_cv
            <typename std::remove_reference<_Tp>::type>::type>::type
    { };



  template<std::size_t... _Indexes>
    struct _Index_tuple
    {
      typedef _Index_tuple<_Indexes..., sizeof...(_Indexes)> __next;
    };


  template<std::size_t _Num>
    struct _Build_index_tuple
    {
      typedef typename _Build_index_tuple<_Num - 1>::__type::__next __type;
    };

  template<>
    struct _Build_index_tuple<0>
    {
      typedef _Index_tuple<> __type;
    };

  template<std::size_t, typename, typename, std::size_t>
    struct __make_tuple_impl;

  template<std::size_t _Idx, typename _Tuple, typename... _Tp,
           std::size_t _Nm>
    struct __make_tuple_impl<_Idx, tuple<_Tp...>, _Tuple, _Nm>
    {
      typedef typename __make_tuple_impl<_Idx + 1, tuple<_Tp...,
 typename std::tuple_element<_Idx, _Tuple>::type>, _Tuple, _Nm>::__type
      __type;
    };

  template<std::size_t _Nm, typename _Tuple, typename... _Tp>
    struct __make_tuple_impl<_Nm, tuple<_Tp...>, _Tuple, _Nm>
    {
      typedef tuple<_Tp...> __type;
    };

  template<typename _Tuple>
    struct __do_make_tuple
    : public __make_tuple_impl<0, tuple<>, _Tuple,
                               std::tuple_size<_Tuple>::value>
    { };


  template<typename _Tuple>
    struct __make_tuple
    : public __do_make_tuple<typename std::remove_cv
            <typename std::remove_reference<_Tuple>::type>::type>
    { };


  template<typename...>
    struct __combine_tuples;

  template<>
    struct __combine_tuples<>
    {
      typedef tuple<> __type;
    };

  template<typename... _Ts>
    struct __combine_tuples<tuple<_Ts...>>
    {
      typedef tuple<_Ts...> __type;
    };

  template<typename... _T1s, typename... _T2s, typename... _Rem>
    struct __combine_tuples<tuple<_T1s...>, tuple<_T2s...>, _Rem...>
    {
      typedef typename __combine_tuples<tuple<_T1s..., _T2s...>,
     _Rem...>::__type __type;
    };


  template<typename... _Tpls>
    struct __tuple_cat_result
    {
      typedef typename __combine_tuples
        <typename __make_tuple<_Tpls>::__type...>::__type __type;
    };



  template<typename...>
    struct __make_1st_indices;

  template<>
    struct __make_1st_indices<>
    {
      typedef std::_Index_tuple<> __type;
    };

  template<typename _Tp, typename... _Tpls>
    struct __make_1st_indices<_Tp, _Tpls...>
    {
      typedef typename std::_Build_index_tuple<std::tuple_size<
 typename std::remove_reference<_Tp>::type>::value>::__type __type;
    };




  template<typename _Ret, typename _Indices, typename... _Tpls>
    struct __tuple_concater;

  template<typename _Ret, std::size_t... _Is, typename _Tp, typename... _Tpls>
    struct __tuple_concater<_Ret, std::_Index_tuple<_Is...>, _Tp, _Tpls...>
    {
      template<typename... _Us>
        static constexpr _Ret
        _S_do(_Tp&& __tp, _Tpls&&... __tps, _Us&&... __us)
        {
   typedef typename __make_1st_indices<_Tpls...>::__type __idx;
   typedef __tuple_concater<_Ret, __idx, _Tpls...> __next;
   return __next::_S_do(std::forward<_Tpls>(__tps)...,
          std::forward<_Us>(__us)...,
          std::get<_Is>(std::forward<_Tp>(__tp))...);
 }
    };

  template<typename _Ret>
    struct __tuple_concater<_Ret, std::_Index_tuple<>>
    {
      template<typename... _Us>
 static constexpr _Ret
 _S_do(_Us&&... __us)
        {
   return _Ret(std::forward<_Us>(__us)...);
 }
    };


  template<typename... _Tpls, typename = typename
           enable_if<__and_<__is_tuple_like<_Tpls>...>::value>::type>
    constexpr auto
    tuple_cat(_Tpls&&... __tpls)
    -> typename __tuple_cat_result<_Tpls...>::__type
    {
      typedef typename __tuple_cat_result<_Tpls...>::__type __ret;
      typedef typename __make_1st_indices<_Tpls...>::__type __idx;
      typedef __tuple_concater<__ret, __idx, _Tpls...> __concater;
      return __concater::_S_do(std::forward<_Tpls>(__tpls)...);
    }


  template<typename... _Elements>
    inline tuple<_Elements&...>
    tie(_Elements&... __args) noexcept
    { return tuple<_Elements&...>(__args...); }


  template<typename... _Elements>
    inline void
    swap(tuple<_Elements...>& __x, tuple<_Elements...>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }



  struct _Swallow_assign
  {
    template<class _Tp>
      const _Swallow_assign&
      operator=(const _Tp&) const
      { return *this; }
  };

  const _Swallow_assign ignore{};


  template<typename... _Types, typename _Alloc>
    struct uses_allocator<tuple<_Types...>, _Alloc> : true_type { };


  template<class _T1, class _T2>
    template<typename... _Args1, typename... _Args2>
      inline
      pair<_T1, _T2>::
      pair(piecewise_construct_t,
    tuple<_Args1...> __first, tuple<_Args2...> __second)
      : pair(__first, __second,
      typename _Build_index_tuple<sizeof...(_Args1)>::__type(),
      typename _Build_index_tuple<sizeof...(_Args2)>::__type())
      { }

  template<class _T1, class _T2>
    template<typename... _Args1, std::size_t... _Indexes1,
             typename... _Args2, std::size_t... _Indexes2>
      inline
      pair<_T1, _T2>::
      pair(tuple<_Args1...>& __tuple1, tuple<_Args2...>& __tuple2,
    _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>)
      : first(std::forward<_Args1>(std::get<_Indexes1>(__tuple1))...),
        second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...)
      { }




}
# 56 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/functional" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _MemberPointer>
    class _Mem_fn;
  template<typename _Tp, typename _Class>
    _Mem_fn<_Tp _Class::*>
    mem_fn(_Tp _Class::*) noexcept;

template<typename _Tp> class __has_result_type_helper : __sfinae_types { template<typename _Up> struct _Wrap_type { }; template<typename _Up> static __one __test(_Wrap_type<typename _Up::result_type>*); template<typename _Up> static __two __test(...); public: static constexpr bool value = sizeof(__test<_Tp>(0)) == 1; }; template<typename _Tp> struct __has_result_type : integral_constant<bool, __has_result_type_helper <typename remove_cv<_Tp>::type>::value> { };


  template<bool _Has_result_type, typename _Functor>
    struct _Maybe_get_result_type
    { };

  template<typename _Functor>
    struct _Maybe_get_result_type<true, _Functor>
    { typedef typename _Functor::result_type result_type; };





  template<typename _Functor>
    struct _Weak_result_type_impl
    : _Maybe_get_result_type<__has_result_type<_Functor>::value, _Functor>
    { };


  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes...)>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes......)>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes...) const>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes......) const>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes...) volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes......) volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes...) const volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes......) const volatile>
    { typedef _Res result_type; };


  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(&)(_ArgTypes...)>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(&)(_ArgTypes......)>
    { typedef _Res result_type; };


  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(*)(_ArgTypes...)>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(*)(_ArgTypes......)>
    { typedef _Res result_type; };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)>
    { typedef _Res result_type; };

  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......)>
    { typedef _Res result_type; };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) const>
    { typedef _Res result_type; };

  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......) const>
    { typedef _Res result_type; };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......) volatile>
    { typedef _Res result_type; };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)
      const volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......)
      const volatile>
    { typedef _Res result_type; };





  template<typename _Functor>
    struct _Weak_result_type
    : _Weak_result_type_impl<typename remove_cv<_Functor>::type>
    { };


  template<typename _Tp>
    struct _Derives_from_unary_function : __sfinae_types
    {
    private:
      template<typename _T1, typename _Res>
 static __one __test(const volatile unary_function<_T1, _Res>*);



      static __two __test(...);

    public:
      static const bool value = sizeof(__test((_Tp*)0)) == 1;
    };


  template<typename _Tp>
    struct _Derives_from_binary_function : __sfinae_types
    {
    private:
      template<typename _T1, typename _T2, typename _Res>
 static __one __test(const volatile binary_function<_T1, _T2, _Res>*);



      static __two __test(...);

    public:
      static const bool value = sizeof(__test((_Tp*)0)) == 1;
    };





  template<typename _Functor, typename... _Args>
    inline
    typename enable_if<
      (!is_member_pointer<_Functor>::value
       && !is_function<_Functor>::value
       && !is_function<typename remove_pointer<_Functor>::type>::value),
      typename result_of<_Functor&(_Args&&...)>::type
    >::type
    __invoke(_Functor& __f, _Args&&... __args)
    {
      return __f(std::forward<_Args>(__args)...);
    }

  template<typename _Functor, typename... _Args>
    inline
    typename enable_if<
             (is_member_pointer<_Functor>::value
              && !is_function<_Functor>::value
              && !is_function<typename remove_pointer<_Functor>::type>::value),
             typename result_of<_Functor(_Args&&...)>::type
           >::type
    __invoke(_Functor& __f, _Args&&... __args)
    {
      return std::mem_fn(__f)(std::forward<_Args>(__args)...);
    }


  template<typename _Functor, typename... _Args>
    inline
    typename enable_if<
      (is_pointer<_Functor>::value
       && is_function<typename remove_pointer<_Functor>::type>::value),
      typename result_of<_Functor(_Args&&...)>::type
    >::type
    __invoke(_Functor __f, _Args&&... __args)
    {
      return __f(std::forward<_Args>(__args)...);
    }






  template<bool _Unary, bool _Binary, typename _Tp>
    struct _Reference_wrapper_base_impl;


  template<typename _Tp>
    struct _Reference_wrapper_base_impl<false, false, _Tp>
    : _Weak_result_type<_Tp>
    { };


  template<typename _Tp>
    struct _Reference_wrapper_base_impl<true, false, _Tp>
    : _Weak_result_type<_Tp>
    {
      typedef typename _Tp::argument_type argument_type;
    };


  template<typename _Tp>
    struct _Reference_wrapper_base_impl<false, true, _Tp>
    : _Weak_result_type<_Tp>
    {
      typedef typename _Tp::first_argument_type first_argument_type;
      typedef typename _Tp::second_argument_type second_argument_type;
    };


   template<typename _Tp>
    struct _Reference_wrapper_base_impl<true, true, _Tp>
    : _Weak_result_type<_Tp>
    {
      typedef typename _Tp::argument_type argument_type;
      typedef typename _Tp::first_argument_type first_argument_type;
      typedef typename _Tp::second_argument_type second_argument_type;
    };

  template<typename _Tp> class __has_argument_type_helper : __sfinae_types { template<typename _Up> struct _Wrap_type { }; template<typename _Up> static __one __test(_Wrap_type<typename _Up::argument_type>*); template<typename _Up> static __two __test(...); public: static constexpr bool value = sizeof(__test<_Tp>(0)) == 1; }; template<typename _Tp> struct __has_argument_type : integral_constant<bool, __has_argument_type_helper <typename remove_cv<_Tp>::type>::value> { };
  template<typename _Tp> class __has_first_argument_type_helper : __sfinae_types { template<typename _Up> struct _Wrap_type { }; template<typename _Up> static __one __test(_Wrap_type<typename _Up::first_argument_type>*); template<typename _Up> static __two __test(...); public: static constexpr bool value = sizeof(__test<_Tp>(0)) == 1; }; template<typename _Tp> struct __has_first_argument_type : integral_constant<bool, __has_first_argument_type_helper <typename remove_cv<_Tp>::type>::value> { };
  template<typename _Tp> class __has_second_argument_type_helper : __sfinae_types { template<typename _Up> struct _Wrap_type { }; template<typename _Up> static __one __test(_Wrap_type<typename _Up::second_argument_type>*); template<typename _Up> static __two __test(...); public: static constexpr bool value = sizeof(__test<_Tp>(0)) == 1; }; template<typename _Tp> struct __has_second_argument_type : integral_constant<bool, __has_second_argument_type_helper <typename remove_cv<_Tp>::type>::value> { };







  template<typename _Tp>
    struct _Reference_wrapper_base
    : _Reference_wrapper_base_impl<
      __has_argument_type<_Tp>::value,
      __has_first_argument_type<_Tp>::value
      && __has_second_argument_type<_Tp>::value,
      _Tp>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1)>
    : unary_function<_T1, _Res>
    { };

  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1) const>
    : unary_function<_T1, _Res>
    { };

  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1) volatile>
    : unary_function<_T1, _Res>
    { };

  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1) const volatile>
    : unary_function<_T1, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2)>
    : binary_function<_T1, _T2, _Res>
    { };

  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2) const>
    : binary_function<_T1, _T2, _Res>
    { };

  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2) volatile>
    : binary_function<_T1, _T2, _Res>
    { };

  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2) const volatile>
    : binary_function<_T1, _T2, _Res>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(*)(_T1)>
    : unary_function<_T1, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(*)(_T1, _T2)>
    : binary_function<_T1, _T2, _Res>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res (_T1::*)()>
    : unary_function<_T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2)>
    : binary_function<_T1*, _T2, _Res>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res (_T1::*)() const>
    : unary_function<const _T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const>
    : binary_function<const _T1*, _T2, _Res>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res (_T1::*)() volatile>
    : unary_function<volatile _T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) volatile>
    : binary_function<volatile _T1*, _T2, _Res>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res (_T1::*)() const volatile>
    : unary_function<const volatile _T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const volatile>
    : binary_function<const volatile _T1*, _T2, _Res>
    { };






  template<typename _Tp>
    class reference_wrapper
    : public _Reference_wrapper_base<typename remove_cv<_Tp>::type>
    {
      _Tp* _M_data;

    public:
      typedef _Tp type;

      reference_wrapper(_Tp& __indata) noexcept
      : _M_data(std::__addressof(__indata))
      { }

      reference_wrapper(_Tp&&) = delete;

      reference_wrapper(const reference_wrapper<_Tp>& __inref) noexcept
      : _M_data(__inref._M_data)
      { }

      reference_wrapper&
      operator=(const reference_wrapper<_Tp>& __inref) noexcept
      {
 _M_data = __inref._M_data;
 return *this;
      }

      operator _Tp&() const noexcept
      { return this->get(); }

      _Tp&
      get() const noexcept
      { return *_M_data; }

      template<typename... _Args>
 typename result_of<_Tp&(_Args&&...)>::type
 operator()(_Args&&... __args) const
 {
   return __invoke(get(), std::forward<_Args>(__args)...);
 }
    };



  template<typename _Tp>
    inline reference_wrapper<_Tp>
    ref(_Tp& __t) noexcept
    { return reference_wrapper<_Tp>(__t); }


  template<typename _Tp>
    inline reference_wrapper<const _Tp>
    cref(const _Tp& __t) noexcept
    { return reference_wrapper<const _Tp>(__t); }

  template<typename _Tp>
    void ref(const _Tp&&) = delete;

  template<typename _Tp>
    void cref(const _Tp&&) = delete;


  template<typename _Tp>
    inline reference_wrapper<_Tp>
    ref(reference_wrapper<_Tp> __t) noexcept
    { return ref(__t.get()); }


  template<typename _Tp>
    inline reference_wrapper<const _Tp>
    cref(reference_wrapper<_Tp> __t) noexcept
    { return cref(__t.get()); }



  template<typename... _Types>
    struct _Pack : integral_constant<size_t, sizeof...(_Types)>
    { };

  template<typename _From, typename _To, bool = _From::value == _To::value>
    struct _AllConvertible : false_type
    { };

  template<typename... _From, typename... _To>
    struct _AllConvertible<_Pack<_From...>, _Pack<_To...>, true>
    : __and_<is_convertible<_From, _To>...>
    { };

  template<typename _Tp1, typename _Tp2>
    using _NotSame = __not_<is_same<typename std::decay<_Tp1>::type,
        typename std::decay<_Tp2>::type>>;






  template<typename _Res, typename... _ArgTypes>
    struct _Maybe_unary_or_binary_function { };


  template<typename _Res, typename _T1>
    struct _Maybe_unary_or_binary_function<_Res, _T1>
    : std::unary_function<_T1, _Res> { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Maybe_unary_or_binary_function<_Res, _T1, _T2>
    : std::binary_function<_T1, _T2, _Res> { };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    class _Mem_fn<_Res (_Class::*)(_ArgTypes...)>
    : public _Maybe_unary_or_binary_function<_Res, _Class*, _ArgTypes...>
    {
      typedef _Res (_Class::*_Functor)(_ArgTypes...);

      template<typename _Tp, typename... _Args>
 _Res
 _M_call(_Tp&& __object, const volatile _Class *,
  _Args&&... __args) const
 {
   return (std::forward<_Tp>(__object).*__pmf)
     (std::forward<_Args>(__args)...);
 }

      template<typename _Tp, typename... _Args>
 _Res
 _M_call(_Tp&& __ptr, const volatile void *, _Args&&... __args) const
 { return ((*__ptr).*__pmf)(std::forward<_Args>(__args)...); }


      template<typename... _Args>
 using _RequireValidArgs
   = _Require<_AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;



      template<typename _Tp, typename... _Args>
 using _RequireValidArgs2
   = _Require<_NotSame<_Class, _Tp>, _NotSame<_Class*, _Tp>,
       _AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;



      template<typename _Tp, typename... _Args>
 using _RequireValidArgs3
   = _Require<is_base_of<_Class, _Tp>,
       _AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;

    public:
      typedef _Res result_type;

      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }


      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>
 _Res
 operator()(_Class& __object, _Args&&... __args) const
 { return (__object.*__pmf)(std::forward<_Args>(__args)...); }

      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>
 _Res
 operator()(_Class&& __object, _Args&&... __args) const
 {
   return (std::move(__object).*__pmf)(std::forward<_Args>(__args)...);
 }


      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>
 _Res
 operator()(_Class* __object, _Args&&... __args) const
 { return (__object->*__pmf)(std::forward<_Args>(__args)...); }


      template<typename _Tp, typename... _Args,
        typename _Req = _RequireValidArgs2<_Tp, _Args...>>
 _Res
 operator()(_Tp&& __object, _Args&&... __args) const
 {
   return _M_call(std::forward<_Tp>(__object), &__object,
       std::forward<_Args>(__args)...);
 }

      template<typename _Tp, typename... _Args,
        typename _Req = _RequireValidArgs3<_Tp, _Args...>>
 _Res
 operator()(reference_wrapper<_Tp> __ref, _Args&&... __args) const
 { return operator()(__ref.get(), std::forward<_Args>(__args)...); }

    private:
      _Functor __pmf;
    };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    class _Mem_fn<_Res (_Class::*)(_ArgTypes...) const>
    : public _Maybe_unary_or_binary_function<_Res, const _Class*,
          _ArgTypes...>
    {
      typedef _Res (_Class::*_Functor)(_ArgTypes...) const;

      template<typename _Tp, typename... _Args>
 _Res
 _M_call(_Tp&& __object, const volatile _Class *,
  _Args&&... __args) const
 {
   return (std::forward<_Tp>(__object).*__pmf)
     (std::forward<_Args>(__args)...);
 }

      template<typename _Tp, typename... _Args>
 _Res
 _M_call(_Tp&& __ptr, const volatile void *, _Args&&... __args) const
 { return ((*__ptr).*__pmf)(std::forward<_Args>(__args)...); }

      template<typename... _Args>
 using _RequireValidArgs
   = _Require<_AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;

      template<typename _Tp, typename... _Args>
 using _RequireValidArgs2
   = _Require<_NotSame<_Class, _Tp>, _NotSame<const _Class*, _Tp>,
       _AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;

      template<typename _Tp, typename... _Args>
 using _RequireValidArgs3
   = _Require<is_base_of<_Class, _Tp>,
       _AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;

    public:
      typedef _Res result_type;

      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }


      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>
 _Res
 operator()(const _Class& __object, _Args&&... __args) const
 { return (__object.*__pmf)(std::forward<_Args>(__args)...); }

      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>
 _Res
 operator()(const _Class&& __object, _Args&&... __args) const
 {
   return (std::move(__object).*__pmf)(std::forward<_Args>(__args)...);
 }


      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>
 _Res
 operator()(const _Class* __object, _Args&&... __args) const
 { return (__object->*__pmf)(std::forward<_Args>(__args)...); }


      template<typename _Tp, typename... _Args,
        typename _Req = _RequireValidArgs2<_Tp, _Args...>>
 _Res operator()(_Tp&& __object, _Args&&... __args) const
 {
   return _M_call(std::forward<_Tp>(__object), &__object,
       std::forward<_Args>(__args)...);
 }

      template<typename _Tp, typename... _Args,
        typename _Req = _RequireValidArgs3<_Tp, _Args...>>
 _Res
 operator()(reference_wrapper<_Tp> __ref, _Args&&... __args) const
 { return operator()(__ref.get(), std::forward<_Args>(__args)...); }

    private:
      _Functor __pmf;
    };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    class _Mem_fn<_Res (_Class::*)(_ArgTypes...) volatile>
    : public _Maybe_unary_or_binary_function<_Res, volatile _Class*,
          _ArgTypes...>
    {
      typedef _Res (_Class::*_Functor)(_ArgTypes...) volatile;

      template<typename _Tp, typename... _Args>
 _Res
 _M_call(_Tp&& __object, const volatile _Class *,
  _Args&&... __args) const
 {
   return (std::forward<_Tp>(__object).*__pmf)
     (std::forward<_Args>(__args)...);
 }

      template<typename _Tp, typename... _Args>
 _Res
 _M_call(_Tp&& __ptr, const volatile void *, _Args&&... __args) const
 { return ((*__ptr).*__pmf)(std::forward<_Args>(__args)...); }

      template<typename... _Args>
 using _RequireValidArgs
   = _Require<_AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;

      template<typename _Tp, typename... _Args>
 using _RequireValidArgs2
   = _Require<_NotSame<_Class, _Tp>, _NotSame<volatile _Class*, _Tp>,
       _AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;

      template<typename _Tp, typename... _Args>
 using _RequireValidArgs3
   = _Require<is_base_of<_Class, _Tp>,
       _AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;

    public:
      typedef _Res result_type;

      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }


      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>
 _Res
 operator()(volatile _Class& __object, _Args&&... __args) const
 { return (__object.*__pmf)(std::forward<_Args>(__args)...); }

      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>
 _Res
 operator()(volatile _Class&& __object, _Args&&... __args) const
 {
   return (std::move(__object).*__pmf)(std::forward<_Args>(__args)...);
 }


      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>
 _Res
 operator()(volatile _Class* __object, _Args&&... __args) const
 { return (__object->*__pmf)(std::forward<_Args>(__args)...); }


      template<typename _Tp, typename... _Args,
        typename _Req = _RequireValidArgs2<_Tp, _Args...>>
 _Res
 operator()(_Tp&& __object, _Args&&... __args) const
 {
   return _M_call(std::forward<_Tp>(__object), &__object,
       std::forward<_Args>(__args)...);
 }

      template<typename _Tp, typename... _Args,
        typename _Req = _RequireValidArgs3<_Tp, _Args...>>
 _Res
 operator()(reference_wrapper<_Tp> __ref, _Args&&... __args) const
 { return operator()(__ref.get(), std::forward<_Args>(__args)...); }

    private:
      _Functor __pmf;
    };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    class _Mem_fn<_Res (_Class::*)(_ArgTypes...) const volatile>
    : public _Maybe_unary_or_binary_function<_Res, const volatile _Class*,
          _ArgTypes...>
    {
      typedef _Res (_Class::*_Functor)(_ArgTypes...) const volatile;

      template<typename _Tp, typename... _Args>
 _Res
 _M_call(_Tp&& __object, const volatile _Class *,
  _Args&&... __args) const
 {
   return (std::forward<_Tp>(__object).*__pmf)
     (std::forward<_Args>(__args)...);
 }

      template<typename _Tp, typename... _Args>
 _Res
 _M_call(_Tp&& __ptr, const volatile void *, _Args&&... __args) const
 { return ((*__ptr).*__pmf)(std::forward<_Args>(__args)...); }

      template<typename... _Args>
 using _RequireValidArgs
   = _Require<_AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;

      template<typename _Tp, typename... _Args>
 using _RequireValidArgs2
   = _Require<_NotSame<_Class, _Tp>,
       _NotSame<const volatile _Class*, _Tp>,
       _AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;

      template<typename _Tp, typename... _Args>
 using _RequireValidArgs3
   = _Require<is_base_of<_Class, _Tp>,
       _AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;

    public:
      typedef _Res result_type;

      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }


      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>
 _Res
 operator()(const volatile _Class& __object, _Args&&... __args) const
 { return (__object.*__pmf)(std::forward<_Args>(__args)...); }

      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>
 _Res
 operator()(const volatile _Class&& __object, _Args&&... __args) const
 {
   return (std::move(__object).*__pmf)(std::forward<_Args>(__args)...);
 }


      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>
 _Res
 operator()(const volatile _Class* __object, _Args&&... __args) const
 { return (__object->*__pmf)(std::forward<_Args>(__args)...); }


      template<typename _Tp, typename... _Args,
        typename _Req = _RequireValidArgs2<_Tp, _Args...>>
 _Res operator()(_Tp&& __object, _Args&&... __args) const
 {
   return _M_call(std::forward<_Tp>(__object), &__object,
       std::forward<_Args>(__args)...);
 }

      template<typename _Tp, typename... _Args,
        typename _Req = _RequireValidArgs3<_Tp, _Args...>>
 _Res
 operator()(reference_wrapper<_Tp> __ref, _Args&&... __args) const
 { return operator()(__ref.get(), std::forward<_Args>(__args)...); }

    private:
      _Functor __pmf;
    };


  template<typename _Tp, bool>
    struct _Mem_fn_const_or_non
    {
      typedef const _Tp& type;
    };

  template<typename _Tp>
    struct _Mem_fn_const_or_non<_Tp, false>
    {
      typedef _Tp& type;
    };

  template<typename _Res, typename _Class>
    class _Mem_fn<_Res _Class::*>
    {
      using __pm_type = _Res _Class::*;




      template<typename _Tp>
 auto
 _M_call(_Tp&& __object, const _Class *) const noexcept
 -> decltype(std::forward<_Tp>(__object).*std::declval<__pm_type&>())
 { return std::forward<_Tp>(__object).*__pm; }

      template<typename _Tp, typename _Up>
 auto
 _M_call(_Tp&& __object, _Up * const *) const noexcept
 -> decltype((*std::forward<_Tp>(__object)).*std::declval<__pm_type&>())
 { return (*std::forward<_Tp>(__object)).*__pm; }

      template<typename _Tp>
 auto
 _M_call(_Tp&& __ptr, const volatile void*) const
 noexcept(noexcept((*__ptr).*std::declval<__pm_type&>()))
 -> decltype((*__ptr).*std::declval<__pm_type&>())
 { return (*__ptr).*__pm; }

    public:
      explicit
      _Mem_fn(_Res _Class::*__pm) noexcept : __pm(__pm) { }


      _Res&
      operator()(_Class& __object) const noexcept
      { return __object.*__pm; }

      const _Res&
      operator()(const _Class& __object) const noexcept
      { return __object.*__pm; }

      _Res&&
      operator()(_Class&& __object) const noexcept
      { return std::forward<_Class>(__object).*__pm; }

      const _Res&&
      operator()(const _Class&& __object) const noexcept
      { return std::forward<const _Class>(__object).*__pm; }


      _Res&
      operator()(_Class* __object) const noexcept
      { return __object->*__pm; }

      const _Res&
      operator()(const _Class* __object) const noexcept
      { return __object->*__pm; }


      template<typename _Tp, typename _Req = _Require<_NotSame<_Class*, _Tp>>>
 auto
 operator()(_Tp&& __unknown) const
 noexcept(noexcept(std::declval<_Mem_fn*>()->_M_call
     (std::forward<_Tp>(__unknown), &__unknown)))
 -> decltype(this->_M_call(std::forward<_Tp>(__unknown), &__unknown))
 { return _M_call(std::forward<_Tp>(__unknown), &__unknown); }

      template<typename _Tp, typename _Req = _Require<is_base_of<_Class, _Tp>>>
 auto
 operator()(reference_wrapper<_Tp> __ref) const
 noexcept(noexcept(std::declval<_Mem_fn&>()(__ref.get())))
 -> decltype((*this)(__ref.get()))
 { return (*this)(__ref.get()); }

    private:
      _Res _Class::*__pm;
    };
# 959 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/functional" 3
  template<typename _Tp, typename _Class>
    inline _Mem_fn<_Tp _Class::*>
    mem_fn(_Tp _Class::* __pm) noexcept
    {
      return _Mem_fn<_Tp _Class::*>(__pm);
    }







  template<typename _Tp>
    struct is_bind_expression
    : public false_type { };






  template<typename _Tp>
    struct is_placeholder
    : public integral_constant<int, 0>
    { };




  template<int _Num> struct _Placeholder { };







  namespace placeholders
  {





    extern const _Placeholder<1> _1;
    extern const _Placeholder<2> _2;
    extern const _Placeholder<3> _3;
    extern const _Placeholder<4> _4;
    extern const _Placeholder<5> _5;
    extern const _Placeholder<6> _6;
    extern const _Placeholder<7> _7;
    extern const _Placeholder<8> _8;
    extern const _Placeholder<9> _9;
    extern const _Placeholder<10> _10;
    extern const _Placeholder<11> _11;
    extern const _Placeholder<12> _12;
    extern const _Placeholder<13> _13;
    extern const _Placeholder<14> _14;
    extern const _Placeholder<15> _15;
    extern const _Placeholder<16> _16;
    extern const _Placeholder<17> _17;
    extern const _Placeholder<18> _18;
    extern const _Placeholder<19> _19;
    extern const _Placeholder<20> _20;
    extern const _Placeholder<21> _21;
    extern const _Placeholder<22> _22;
    extern const _Placeholder<23> _23;
    extern const _Placeholder<24> _24;
    extern const _Placeholder<25> _25;
    extern const _Placeholder<26> _26;
    extern const _Placeholder<27> _27;
    extern const _Placeholder<28> _28;
    extern const _Placeholder<29> _29;

  }
# 1043 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/functional" 3
  template<int _Num>
    struct is_placeholder<_Placeholder<_Num> >
    : public integral_constant<int, _Num>
    { };

  template<int _Num>
    struct is_placeholder<const _Placeholder<_Num> >
    : public integral_constant<int, _Num>
    { };





  struct _No_tuple_element;






  template<std::size_t __i, typename _Tuple, bool _IsSafe>
    struct _Safe_tuple_element_impl
    : tuple_element<__i, _Tuple> { };






  template<std::size_t __i, typename _Tuple>
    struct _Safe_tuple_element_impl<__i, _Tuple, false>
    {
      typedef _No_tuple_element type;
    };





 template<std::size_t __i, typename _Tuple>
   struct _Safe_tuple_element
   : _Safe_tuple_element_impl<__i, _Tuple,
         (__i < tuple_size<_Tuple>::value)>
   { };
# 1100 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/functional" 3
  template<typename _Arg,
    bool _IsBindExp = is_bind_expression<_Arg>::value,
    bool _IsPlaceholder = (is_placeholder<_Arg>::value > 0)>
    class _Mu;





  template<typename _Tp>
    class _Mu<reference_wrapper<_Tp>, false, false>
    {
    public:
      typedef _Tp& result_type;





      template<typename _CVRef, typename _Tuple>
 result_type
 operator()(_CVRef& __arg, _Tuple&) const volatile
 { return __arg.get(); }
    };






  template<typename _Arg>
    class _Mu<_Arg, true, false>
    {
    public:
      template<typename _CVArg, typename... _Args>
 auto
 operator()(_CVArg& __arg,
     tuple<_Args...>& __tuple) const volatile
 -> decltype(__arg(declval<_Args>()...))
 {

   typedef typename _Build_index_tuple<sizeof...(_Args)>::__type
     _Indexes;
   return this->__call(__arg, __tuple, _Indexes());
 }

    private:


      template<typename _CVArg, typename... _Args, std::size_t... _Indexes>
 auto
 __call(_CVArg& __arg, tuple<_Args...>& __tuple,
        const _Index_tuple<_Indexes...>&) const volatile
 -> decltype(__arg(declval<_Args>()...))
 {
   return __arg(std::forward<_Args>(get<_Indexes>(__tuple))...);
 }
    };






  template<typename _Arg>
    class _Mu<_Arg, false, true>
    {
    public:
      template<typename _Signature> class result;

      template<typename _CVMu, typename _CVArg, typename _Tuple>
 class result<_CVMu(_CVArg, _Tuple)>
 {



   typedef typename _Safe_tuple_element<(is_placeholder<_Arg>::value
      - 1), _Tuple>::type
     __base_type;

 public:
   typedef typename add_rvalue_reference<__base_type>::type type;
 };

      template<typename _Tuple>
 typename result<_Mu(_Arg, _Tuple)>::type
 operator()(const volatile _Arg&, _Tuple& __tuple) const volatile
 {
   return std::forward<typename result<_Mu(_Arg, _Tuple)>::type>(
       ::std::get<(is_placeholder<_Arg>::value - 1)>(__tuple));
 }
    };






  template<typename _Arg>
    class _Mu<_Arg, false, false>
    {
    public:
      template<typename _Signature> struct result;

      template<typename _CVMu, typename _CVArg, typename _Tuple>
 struct result<_CVMu(_CVArg, _Tuple)>
 {
   typedef typename add_lvalue_reference<_CVArg>::type type;
 };


      template<typename _CVArg, typename _Tuple>
 _CVArg&&
 operator()(_CVArg&& __arg, _Tuple&) const volatile
 { return std::forward<_CVArg>(__arg); }
    };






  template<typename _Tp>
    struct _Maybe_wrap_member_pointer
    {
      typedef _Tp type;

      static const _Tp&
      __do_wrap(const _Tp& __x)
      { return __x; }

      static _Tp&&
      __do_wrap(_Tp&& __x)
      { return static_cast<_Tp&&>(__x); }
    };






  template<typename _Tp, typename _Class>
    struct _Maybe_wrap_member_pointer<_Tp _Class::*>
    {
      typedef _Mem_fn<_Tp _Class::*> type;

      static type
      __do_wrap(_Tp _Class::* __pm)
      { return type(__pm); }
    };





  template<>
    struct _Maybe_wrap_member_pointer<void>
    {
      typedef void type;
    };


  template<std::size_t _Ind, typename... _Tp>
    inline auto
    __volget(volatile tuple<_Tp...>& __tuple)
    -> typename tuple_element<_Ind, tuple<_Tp...>>::type volatile&
    { return std::get<_Ind>(const_cast<tuple<_Tp...>&>(__tuple)); }


  template<std::size_t _Ind, typename... _Tp>
    inline auto
    __volget(const volatile tuple<_Tp...>& __tuple)
    -> typename tuple_element<_Ind, tuple<_Tp...>>::type const volatile&
    { return std::get<_Ind>(const_cast<const tuple<_Tp...>&>(__tuple)); }


  template<typename _Signature>
    struct _Bind;

   template<typename _Functor, typename... _Bound_args>
    class _Bind<_Functor(_Bound_args...)>
    : public _Weak_result_type<_Functor>
    {
      typedef _Bind __self_type;
      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type
 _Bound_indexes;

      _Functor _M_f;
      tuple<_Bound_args...> _M_bound_args;


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)
 {
   return _M_f(_Mu<_Bound_args>()
        (get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call_c(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) const
 {
   return _M_f(_Mu<_Bound_args>()
        (get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call_v(tuple<_Args...>&& __args,
   _Index_tuple<_Indexes...>) volatile
 {
   return _M_f(_Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call_c_v(tuple<_Args...>&& __args,
     _Index_tuple<_Indexes...>) const volatile
 {
   return _M_f(_Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }

     public:
      template<typename... _Args>
 explicit _Bind(const _Functor& __f, _Args&&... __args)
 : _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      template<typename... _Args>
 explicit _Bind(_Functor&& __f, _Args&&... __args)
 : _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      _Bind(const _Bind&) = default;

      _Bind(_Bind&& __b)
      : _M_f(std::move(__b._M_f)), _M_bound_args(std::move(__b._M_bound_args))
      { }


      template<typename... _Args, typename _Result
 = decltype( std::declval<_Functor>()(
       _Mu<_Bound_args>()( std::declval<_Bound_args&>(),
      std::declval<tuple<_Args...>&>() )... ) )>
 _Result
 operator()(_Args&&... __args)
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args, typename _Result
 = decltype( std::declval<typename enable_if<(sizeof...(_Args) >= 0),
         typename add_const<_Functor>::type>::type>()(
       _Mu<_Bound_args>()( std::declval<const _Bound_args&>(),
      std::declval<tuple<_Args...>&>() )... ) )>
 _Result
 operator()(_Args&&... __args) const
 {
   return this->__call_c<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args, typename _Result
 = decltype( std::declval<typename enable_if<(sizeof...(_Args) >= 0),
                       typename add_volatile<_Functor>::type>::type>()(
       _Mu<_Bound_args>()( std::declval<volatile _Bound_args&>(),
      std::declval<tuple<_Args...>&>() )... ) )>
 _Result
 operator()(_Args&&... __args) volatile
 {
   return this->__call_v<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args, typename _Result
 = decltype( std::declval<typename enable_if<(sizeof...(_Args) >= 0),
                       typename add_cv<_Functor>::type>::type>()(
       _Mu<_Bound_args>()( std::declval<const volatile _Bound_args&>(),
      std::declval<tuple<_Args...>&>() )... ) )>
 _Result
 operator()(_Args&&... __args) const volatile
 {
   return this->__call_c_v<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }
    };


  template<typename _Result, typename _Signature>
    struct _Bind_result;

  template<typename _Result, typename _Functor, typename... _Bound_args>
    class _Bind_result<_Result, _Functor(_Bound_args...)>
    {
      typedef _Bind_result __self_type;
      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type
 _Bound_indexes;

      _Functor _M_f;
      tuple<_Bound_args...> _M_bound_args;


      template<typename _Res>
 struct __enable_if_void : enable_if<is_void<_Res>::value, int> { };
      template<typename _Res>
 struct __disable_if_void : enable_if<!is_void<_Res>::value, int> { };


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 _Result
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __disable_if_void<_Res>::type = 0)
 {
   return _M_f(_Mu<_Bound_args>()
        (get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 void
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __enable_if_void<_Res>::type = 0)
 {
   _M_f(_Mu<_Bound_args>()
        (get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 _Result
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __disable_if_void<_Res>::type = 0) const
 {
   return _M_f(_Mu<_Bound_args>()
        (get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 void
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __enable_if_void<_Res>::type = 0) const
 {
   _M_f(_Mu<_Bound_args>()
        (get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 _Result
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __disable_if_void<_Res>::type = 0) volatile
 {
   return _M_f(_Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 void
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __enable_if_void<_Res>::type = 0) volatile
 {
   _M_f(_Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 _Result
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __disable_if_void<_Res>::type = 0) const volatile
 {
   return _M_f(_Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 void
 __call(tuple<_Args...>&& __args,
        _Index_tuple<_Indexes...>,
     typename __enable_if_void<_Res>::type = 0) const volatile
 {
   _M_f(_Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }

    public:
      typedef _Result result_type;

      template<typename... _Args>
 explicit _Bind_result(const _Functor& __f, _Args&&... __args)
 : _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      template<typename... _Args>
 explicit _Bind_result(_Functor&& __f, _Args&&... __args)
 : _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      _Bind_result(const _Bind_result&) = default;

      _Bind_result(_Bind_result&& __b)
      : _M_f(std::move(__b._M_f)), _M_bound_args(std::move(__b._M_bound_args))
      { }


      template<typename... _Args>
 result_type
 operator()(_Args&&... __args)
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args>
 result_type
 operator()(_Args&&... __args) const
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args>
 result_type
 operator()(_Args&&... __args) volatile
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args>
 result_type
 operator()(_Args&&... __args) const volatile
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }
    };





  template<typename _Signature>
    struct is_bind_expression<_Bind<_Signature> >
    : public true_type { };





  template<typename _Signature>
    struct is_bind_expression<const _Bind<_Signature> >
    : public true_type { };





  template<typename _Signature>
    struct is_bind_expression<volatile _Bind<_Signature> >
    : public true_type { };





  template<typename _Signature>
    struct is_bind_expression<const volatile _Bind<_Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<_Bind_result<_Result, _Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<const _Bind_result<_Result, _Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<volatile _Bind_result<_Result, _Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<const volatile _Bind_result<_Result, _Signature>>
    : public true_type { };




  template<typename _Tp, typename _Tp2 = typename decay<_Tp>::type>
    using __is_socketlike = __or_<is_integral<_Tp2>, is_enum<_Tp2>>;

  template<bool _SocketLike, typename _Func, typename... _BoundArgs>
    struct _Bind_helper
    {
      typedef _Maybe_wrap_member_pointer<typename decay<_Func>::type>
 __maybe_type;
      typedef typename __maybe_type::type __func_type;
      typedef _Bind<__func_type(typename decay<_BoundArgs>::type...)> type;
    };




  template<typename _Func, typename... _BoundArgs>
    struct _Bind_helper<true, _Func, _BoundArgs...>
    { };





  template<typename _Func, typename... _BoundArgs>
    inline typename
    _Bind_helper<__is_socketlike<_Func>::value, _Func, _BoundArgs...>::type
    bind(_Func&& __f, _BoundArgs&&... __args)
    {
      typedef _Bind_helper<false, _Func, _BoundArgs...> __helper_type;
      typedef typename __helper_type::__maybe_type __maybe_type;
      typedef typename __helper_type::type __result_type;
      return __result_type(__maybe_type::__do_wrap(std::forward<_Func>(__f)),
      std::forward<_BoundArgs>(__args)...);
    }

  template<typename _Result, typename _Func, typename... _BoundArgs>
    struct _Bindres_helper
    {
      typedef _Maybe_wrap_member_pointer<typename decay<_Func>::type>
 __maybe_type;
      typedef typename __maybe_type::type __functor_type;
      typedef _Bind_result<_Result,
      __functor_type(typename decay<_BoundArgs>::type...)>
 type;
    };





  template<typename _Result, typename _Func, typename... _BoundArgs>
    inline
    typename _Bindres_helper<_Result, _Func, _BoundArgs...>::type
    bind(_Func&& __f, _BoundArgs&&... __args)
    {
      typedef _Bindres_helper<_Result, _Func, _BoundArgs...> __helper_type;
      typedef typename __helper_type::__maybe_type __maybe_type;
      typedef typename __helper_type::type __result_type;
      return __result_type(__maybe_type::__do_wrap(std::forward<_Func>(__f)),
      std::forward<_BoundArgs>(__args)...);
    }

  template<typename _Signature>
    struct _Bind_simple;

  template<typename _Callable, typename... _Args>
    struct _Bind_simple<_Callable(_Args...)>
    {
      typedef typename result_of<_Callable(_Args...)>::type result_type;

      template<typename... _Args2, typename = typename
               enable_if< sizeof...(_Args) == sizeof...(_Args2)>::type>
        explicit
        _Bind_simple(const _Callable& __callable, _Args2&&... __args)
        : _M_bound(__callable, std::forward<_Args2>(__args)...)
        { }

      template<typename... _Args2, typename = typename
               enable_if< sizeof...(_Args) == sizeof...(_Args2)>::type>
        explicit
        _Bind_simple(_Callable&& __callable, _Args2&&... __args)
        : _M_bound(std::move(__callable), std::forward<_Args2>(__args)...)
        { }

      _Bind_simple(const _Bind_simple&) = default;
      _Bind_simple(_Bind_simple&&) = default;

      result_type
      operator()()
      {
        typedef typename _Build_index_tuple<sizeof...(_Args)>::__type _Indices;
        return _M_invoke(_Indices());
      }

    private:

      template<std::size_t... _Indices>
        typename result_of<_Callable(_Args...)>::type
        _M_invoke(_Index_tuple<_Indices...>)
        {


          return std::forward<_Callable>(std::get<0>(_M_bound))(
              std::forward<_Args>(std::get<_Indices+1>(_M_bound))...);
        }

      std::tuple<_Callable, _Args...> _M_bound;
    };

  template<typename _Func, typename... _BoundArgs>
    struct _Bind_simple_helper
    {
      typedef _Maybe_wrap_member_pointer<typename decay<_Func>::type>
        __maybe_type;
      typedef typename __maybe_type::type __func_type;
      typedef _Bind_simple<__func_type(typename decay<_BoundArgs>::type...)>
        __type;
    };



  template<typename _Callable, typename... _Args>
    typename _Bind_simple_helper<_Callable, _Args...>::__type
    __bind_simple(_Callable&& __callable, _Args&&... __args)
    {
      typedef _Bind_simple_helper<_Callable, _Args...> __helper_type;
      typedef typename __helper_type::__maybe_type __maybe_type;
      typedef typename __helper_type::__type __result_type;
      return __result_type(
          __maybe_type::__do_wrap( std::forward<_Callable>(__callable)),
          std::forward<_Args>(__args)...);
    }






  class bad_function_call : public std::exception
  {
  public:
    virtual ~bad_function_call() noexcept;

    const char* what() const noexcept;
  };






  template<typename _Tp>
    struct __is_location_invariant
    : integral_constant<bool, (is_pointer<_Tp>::value
          || is_member_pointer<_Tp>::value)>
    { };

  class _Undefined_class;

  union _Nocopy_types
  {
    void* _M_object;
    const void* _M_const_object;
    void (*_M_function_pointer)();
    void (_Undefined_class::*_M_member_pointer)();
  };

  union _Any_data
  {
    void* _M_access() { return &_M_pod_data[0]; }
    const void* _M_access() const { return &_M_pod_data[0]; }

    template<typename _Tp>
      _Tp&
      _M_access()
      { return *static_cast<_Tp*>(_M_access()); }

    template<typename _Tp>
      const _Tp&
      _M_access() const
      { return *static_cast<const _Tp*>(_M_access()); }

    _Nocopy_types _M_unused;
    char _M_pod_data[sizeof(_Nocopy_types)];
  };

  enum _Manager_operation
  {
    __get_type_info,
    __get_functor_ptr,
    __clone_functor,
    __destroy_functor
  };



  template<typename _Tp>
    struct _Simple_type_wrapper
    {
      _Simple_type_wrapper(_Tp __value) : __value(__value) { }

      _Tp __value;
    };

  template<typename _Tp>
    struct __is_location_invariant<_Simple_type_wrapper<_Tp> >
    : __is_location_invariant<_Tp>
    { };



  template<typename _Functor>
    inline _Functor&
    __callable_functor(_Functor& __f)
    { return __f; }

  template<typename _Member, typename _Class>
    inline _Mem_fn<_Member _Class::*>
    __callable_functor(_Member _Class::* &__p)
    { return std::mem_fn(__p); }

  template<typename _Member, typename _Class>
    inline _Mem_fn<_Member _Class::*>
    __callable_functor(_Member _Class::* const &__p)
    { return std::mem_fn(__p); }

  template<typename _Member, typename _Class>
    inline _Mem_fn<_Member _Class::*>
    __callable_functor(_Member _Class::* volatile &__p)
    { return std::mem_fn(__p); }

  template<typename _Member, typename _Class>
    inline _Mem_fn<_Member _Class::*>
    __callable_functor(_Member _Class::* const volatile &__p)
    { return std::mem_fn(__p); }

  template<typename _Signature>
    class function;


  class _Function_base
  {
  public:
    static const std::size_t _M_max_size = sizeof(_Nocopy_types);
    static const std::size_t _M_max_align = __alignof__(_Nocopy_types);

    template<typename _Functor>
      class _Base_manager
      {
      protected:
 static const bool __stored_locally =
 (__is_location_invariant<_Functor>::value
  && sizeof(_Functor) <= _M_max_size
  && __alignof__(_Functor) <= _M_max_align
  && (_M_max_align % __alignof__(_Functor) == 0));

 typedef integral_constant<bool, __stored_locally> _Local_storage;


 static _Functor*
 _M_get_pointer(const _Any_data& __source)
 {
   const _Functor* __ptr =
     __stored_locally? std::__addressof(__source._M_access<_Functor>())
                                 : __source._M_access<_Functor*>();
   return const_cast<_Functor*>(__ptr);
 }



 static void
 _M_clone(_Any_data& __dest, const _Any_data& __source, true_type)
 {
   new (__dest._M_access()) _Functor(__source._M_access<_Functor>());
 }



 static void
 _M_clone(_Any_data& __dest, const _Any_data& __source, false_type)
 {
   __dest._M_access<_Functor*>() =
     new _Functor(*__source._M_access<_Functor*>());
 }



 static void
 _M_destroy(_Any_data& __victim, true_type)
 {
   __victim._M_access<_Functor>().~_Functor();
 }


 static void
 _M_destroy(_Any_data& __victim, false_type)
 {
   delete __victim._M_access<_Functor*>();
 }

      public:
 static bool
 _M_manager(_Any_data& __dest, const _Any_data& __source,
     _Manager_operation __op)
 {
   switch (__op)
     {

     case __get_type_info:
       __dest._M_access<const type_info*>() = &typeid(_Functor);
       break;

     case __get_functor_ptr:
       __dest._M_access<_Functor*>() = _M_get_pointer(__source);
       break;

     case __clone_functor:
       _M_clone(__dest, __source, _Local_storage());
       break;

     case __destroy_functor:
       _M_destroy(__dest, _Local_storage());
       break;
     }
   return false;
 }

 static void
 _M_init_functor(_Any_data& __functor, _Functor&& __f)
 { _M_init_functor(__functor, std::move(__f), _Local_storage()); }

 template<typename _Signature>
   static bool
   _M_not_empty_function(const function<_Signature>& __f)
   { return static_cast<bool>(__f); }

 template<typename _Tp>
   static bool
   _M_not_empty_function(_Tp* const& __fp)
   { return __fp; }

 template<typename _Class, typename _Tp>
   static bool
   _M_not_empty_function(_Tp _Class::* const& __mp)
   { return __mp; }

 template<typename _Tp>
   static bool
   _M_not_empty_function(const _Tp&)
   { return true; }

      private:
 static void
 _M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
 { new (__functor._M_access()) _Functor(std::move(__f)); }

 static void
 _M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
 { __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
      };

    template<typename _Functor>
      class _Ref_manager : public _Base_manager<_Functor*>
      {
 typedef _Function_base::_Base_manager<_Functor*> _Base;

      public:
 static bool
 _M_manager(_Any_data& __dest, const _Any_data& __source,
     _Manager_operation __op)
 {
   switch (__op)
     {

     case __get_type_info:
       __dest._M_access<const type_info*>() = &typeid(_Functor);
       break;

     case __get_functor_ptr:
       __dest._M_access<_Functor*>() = *_Base::_M_get_pointer(__source);
       return is_const<_Functor>::value;
       break;

     default:
       _Base::_M_manager(__dest, __source, __op);
     }
   return false;
 }

 static void
 _M_init_functor(_Any_data& __functor, reference_wrapper<_Functor> __f)
 {
   _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
 }
      };

    _Function_base() : _M_manager(0) { }

    ~_Function_base()
    {
      if (_M_manager)
 _M_manager(_M_functor, _M_functor, __destroy_functor);
    }


    bool _M_empty() const { return !_M_manager; }

    typedef bool (*_Manager_type)(_Any_data&, const _Any_data&,
      _Manager_operation);

    _Any_data _M_functor;
    _Manager_type _M_manager;
  };

  template<typename _Signature, typename _Functor>
    class _Function_handler;

  template<typename _Res, typename _Functor, typename... _ArgTypes>
    class _Function_handler<_Res(_ArgTypes...), _Functor>
    : public _Function_base::_Base_manager<_Functor>
    {
      typedef _Function_base::_Base_manager<_Functor> _Base;

    public:
      static _Res
      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)
      {
 return (*_Base::_M_get_pointer(__functor))(
     std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Functor, typename... _ArgTypes>
    class _Function_handler<void(_ArgTypes...), _Functor>
    : public _Function_base::_Base_manager<_Functor>
    {
      typedef _Function_base::_Base_manager<_Functor> _Base;

     public:
      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)
      {
 (*_Base::_M_get_pointer(__functor))(
     std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Res, typename _Functor, typename... _ArgTypes>
    class _Function_handler<_Res(_ArgTypes...), reference_wrapper<_Functor> >
    : public _Function_base::_Ref_manager<_Functor>
    {
      typedef _Function_base::_Ref_manager<_Functor> _Base;

     public:
      static _Res
      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)
      {
 return __callable_functor(**_Base::_M_get_pointer(__functor))(
       std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Functor, typename... _ArgTypes>
    class _Function_handler<void(_ArgTypes...), reference_wrapper<_Functor> >
    : public _Function_base::_Ref_manager<_Functor>
    {
      typedef _Function_base::_Ref_manager<_Functor> _Base;

     public:
      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)
      {
 __callable_functor(**_Base::_M_get_pointer(__functor))(
     std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Class, typename _Member, typename _Res,
    typename... _ArgTypes>
    class _Function_handler<_Res(_ArgTypes...), _Member _Class::*>
    : public _Function_handler<void(_ArgTypes...), _Member _Class::*>
    {
      typedef _Function_handler<void(_ArgTypes...), _Member _Class::*>
 _Base;

     public:
      static _Res
      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)
      {
 return std::mem_fn(_Base::_M_get_pointer(__functor)->__value)(
     std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Class, typename _Member, typename... _ArgTypes>
    class _Function_handler<void(_ArgTypes...), _Member _Class::*>
    : public _Function_base::_Base_manager<
   _Simple_type_wrapper< _Member _Class::* > >
    {
      typedef _Member _Class::* _Functor;
      typedef _Simple_type_wrapper<_Functor> _Wrapper;
      typedef _Function_base::_Base_manager<_Wrapper> _Base;

    public:
      static bool
      _M_manager(_Any_data& __dest, const _Any_data& __source,
   _Manager_operation __op)
      {
 switch (__op)
   {

   case __get_type_info:
     __dest._M_access<const type_info*>() = &typeid(_Functor);
     break;

   case __get_functor_ptr:
     __dest._M_access<_Functor*>() =
       &_Base::_M_get_pointer(__source)->__value;
     break;

   default:
     _Base::_M_manager(__dest, __source, __op);
   }
 return false;
      }

      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)
      {
 std::mem_fn(_Base::_M_get_pointer(__functor)->__value)(
     std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _From, typename _To>
    using __check_func_return_type
      = __or_<is_void<_To>, is_convertible<_From, _To>>;







  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
    : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,
      private _Function_base
    {
      typedef _Res _Signature_type(_ArgTypes...);

      template<typename _Functor>
 using _Invoke = decltype(__callable_functor(std::declval<_Functor&>())
     (std::declval<_ArgTypes>()...) );



      template<typename _Tp>
 using _NotSelf = __not_<is_same<_Tp, function>>;

      template<typename _Functor>
 using _Callable
   = __and_<_NotSelf<_Functor>,
     __check_func_return_type<_Invoke<_Functor>, _Res>>;

      template<typename _Cond, typename _Tp>
 using _Requires = typename enable_if<_Cond::value, _Tp>::type;

    public:
      typedef _Res result_type;







      function() noexcept
      : _Function_base() { }





      function(nullptr_t) noexcept
      : _Function_base() { }
# 2224 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/functional" 3
      function(const function& __x);
# 2233 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/functional" 3
      function(function&& __x) : _Function_base()
      {
 __x.swap(*this);
      }
# 2256 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/functional" 3
      template<typename _Functor,
        typename = _Requires<_Callable<_Functor>, void>>
 function(_Functor);
# 2272 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/functional" 3
      function&
      operator=(const function& __x)
      {
 function(__x).swap(*this);
 return *this;
      }
# 2290 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/functional" 3
      function&
      operator=(function&& __x)
      {
 function(std::move(__x)).swap(*this);
 return *this;
      }
# 2304 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/functional" 3
      function&
      operator=(nullptr_t)
      {
 if (_M_manager)
   {
     _M_manager(_M_functor, _M_functor, __destroy_functor);
     _M_manager = 0;
     _M_invoker = 0;
   }
 return *this;
      }
# 2332 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/functional" 3
      template<typename _Functor>
 _Requires<_Callable<typename decay<_Functor>::type>, function&>
 operator=(_Functor&& __f)
 {
   function(std::forward<_Functor>(__f)).swap(*this);
   return *this;
 }


      template<typename _Functor>
 function&
 operator=(reference_wrapper<_Functor> __f) noexcept
 {
   function(__f).swap(*this);
   return *this;
 }
# 2358 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/functional" 3
      void swap(function& __x)
      {
 std::swap(_M_functor, __x._M_functor);
 std::swap(_M_manager, __x._M_manager);
 std::swap(_M_invoker, __x._M_invoker);
      }
# 2386 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/functional" 3
      explicit operator bool() const noexcept
      { return !_M_empty(); }
# 2399 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/functional" 3
      _Res operator()(_ArgTypes... __args) const;
# 2412 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/functional" 3
      const type_info& target_type() const noexcept;
# 2423 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/functional" 3
      template<typename _Functor> _Functor* target() noexcept;


      template<typename _Functor> const _Functor* target() const noexcept;


    private:
      typedef _Res (*_Invoker_type)(const _Any_data&, _ArgTypes...);
      _Invoker_type _M_invoker;
  };


  template<typename _Res, typename... _ArgTypes>
    function<_Res(_ArgTypes...)>::
    function(const function& __x)
    : _Function_base()
    {
      if (static_cast<bool>(__x))
 {
   __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
   _M_invoker = __x._M_invoker;
   _M_manager = __x._M_manager;
 }
    }

  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor, typename>
      function<_Res(_ArgTypes...)>::
      function(_Functor __f)
      : _Function_base()
      {
 typedef _Function_handler<_Signature_type, _Functor> _My_handler;

 if (_My_handler::_M_not_empty_function(__f))
   {
     _My_handler::_M_init_functor(_M_functor, std::move(__f));
     _M_invoker = &_My_handler::_M_invoke;
     _M_manager = &_My_handler::_M_manager;
   }
      }

  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
 __throw_bad_function_call();
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
    }


  template<typename _Res, typename... _ArgTypes>
    const type_info&
    function<_Res(_ArgTypes...)>::
    target_type() const noexcept
    {
      if (_M_manager)
 {
   _Any_data __typeinfo_result;
   _M_manager(__typeinfo_result, _M_functor, __get_type_info);
   return *__typeinfo_result._M_access<const type_info*>();
 }
      else
 return typeid(void);
    }

  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor>
      _Functor*
      function<_Res(_ArgTypes...)>::
      target() noexcept
      {
 if (typeid(_Functor) == target_type() && _M_manager)
   {
     _Any_data __ptr;
     if (_M_manager(__ptr, _M_functor, __get_functor_ptr)
  && !is_const<_Functor>::value)
       return 0;
     else
       return __ptr._M_access<_Functor*>();
   }
 else
   return 0;
      }

  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor>
      const _Functor*
      function<_Res(_ArgTypes...)>::
      target() const noexcept
      {
 if (typeid(_Functor) == target_type() && _M_manager)
   {
     _Any_data __ptr;
     _M_manager(__ptr, _M_functor, __get_functor_ptr);
     return __ptr._M_access<const _Functor*>();
   }
 else
   return 0;
      }
# 2535 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/functional" 3
  template<typename _Res, typename... _Args>
    inline bool
    operator==(const function<_Res(_Args...)>& __f, nullptr_t) noexcept
    { return !static_cast<bool>(__f); }


  template<typename _Res, typename... _Args>
    inline bool
    operator==(nullptr_t, const function<_Res(_Args...)>& __f) noexcept
    { return !static_cast<bool>(__f); }
# 2553 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/functional" 3
  template<typename _Res, typename... _Args>
    inline bool
    operator!=(const function<_Res(_Args...)>& __f, nullptr_t) noexcept
    { return static_cast<bool>(__f); }


  template<typename _Res, typename... _Args>
    inline bool
    operator!=(nullptr_t, const function<_Res(_Args...)>& __f) noexcept
    { return static_cast<bool>(__f); }
# 2571 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/functional" 3
  template<typename _Res, typename... _Args>
    inline void
    swap(function<_Res(_Args...)>& __x, function<_Res(_Args...)>& __y)
    { __x.swap(__y); }


}
# 67 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Iterator>
    void
    __move_median_to_first(_Iterator __result, _Iterator __a,
      _Iterator __b, _Iterator __c)
    {




      if (*__a < *__b)
 {
   if (*__b < *__c)
     std::iter_swap(__result, __b);
   else if (*__a < *__c)
     std::iter_swap(__result, __c);
   else
     std::iter_swap(__result, __a);
 }
      else if (*__a < *__c)
       std::iter_swap(__result, __a);
      else if (*__b < *__c)
 std::iter_swap(__result, __c);
      else
 std::iter_swap(__result, __b);
    }


  template<typename _Iterator, typename _Compare>
    void
    __move_median_to_first(_Iterator __result, _Iterator __a,
      _Iterator __b, _Iterator __c,
      _Compare __comp)
    {





      if (__comp(*__a, *__b))
 {
   if (__comp(*__b, *__c))
     std::iter_swap(__result, __b);
   else if (__comp(*__a, *__c))
     std::iter_swap(__result, __c);
   else
     std::iter_swap(__result, __a);
 }
      else if (__comp(*__a, *__c))
 std::iter_swap(__result, __a);
      else if (__comp(*__b, *__c))
 std::iter_swap(__result, __c);
      else
 std::iter_swap(__result, __b);
    }




  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    __find(_InputIterator __first, _InputIterator __last,
    const _Tp& __val, input_iterator_tag)
    {
      while (__first != __last && !(*__first == __val))
 ++__first;
      return __first;
    }


  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last,
       _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !bool(__pred(*__first)))
 ++__first;
      return __first;
    }


  template<typename _RandomAccessIterator, typename _Tp>
    _RandomAccessIterator
    __find(_RandomAccessIterator __first, _RandomAccessIterator __last,
    const _Tp& __val, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (*__first == __val)
     return __first;
   ++__first;
 case 2:
   if (*__first == __val)
     return __first;
   ++__first;
 case 1:
   if (*__first == __val)
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }


  template<typename _RandomAccessIterator, typename _Predicate>
    _RandomAccessIterator
    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 2:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 1:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }


  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if_not(_InputIterator __first, _InputIterator __last,
    _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && bool(__pred(*__first)))
 ++__first;
      return __first;
    }


  template<typename _RandomAccessIterator, typename _Predicate>
    _RandomAccessIterator
    __find_if_not(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (!bool(__pred(*__first)))
     return __first;
   ++__first;

   if (!bool(__pred(*__first)))
     return __first;
   ++__first;

   if (!bool(__pred(*__first)))
     return __first;
   ++__first;

   if (!bool(__pred(*__first)))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (!bool(__pred(*__first)))
     return __first;
   ++__first;
 case 2:
   if (!bool(__pred(*__first)))
     return __first;
   ++__first;
 case 1:
   if (!bool(__pred(*__first)))
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }


  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if_not(_InputIterator __first, _InputIterator __last,
    _Predicate __pred)
    {
      return std::__find_if_not(__first, __last, __pred,
    std::__iterator_category(__first));
    }




  template<typename _InputIterator, typename _Predicate, typename _Distance>
    _InputIterator
    __find_if_not_n(_InputIterator __first, _Distance& __len, _Predicate __pred)
    {
      for (; __len; --__len, ++__first)
 if (!bool(__pred(*__first)))
   break;
      return __first;
    }
# 351 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count, const _Tp& __val,
        std::forward_iterator_tag)
    {
      __first = std::find(__first, __last, __val);
      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && *__i == __val)
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = std::find(++__i, __last, __val);
 }
      return __last;
    }






  template<typename _RandomAccessIter, typename _Integer, typename _Tp>
    _RandomAccessIter
    __search_n(_RandomAccessIter __first, _RandomAccessIter __last,
        _Integer __count, const _Tp& __val,
        std::random_access_iterator_tag)
    {

      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;

      _DistanceType __tailSize = __last - __first;
      _DistanceType __remainder = __count;

      while (__remainder <= __tailSize)
 {
   __first += __remainder;
   __tailSize -= __remainder;


   _RandomAccessIter __backTrack = __first;
   while (*--__backTrack == __val)
     {
       if (--__remainder == 0)
         return (__first - __count);
     }
   __remainder = __count + 1 - (__first - __backTrack);
 }
      return __last;
    }
# 421 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
           typename _BinaryPredicate>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count, const _Tp& __val,
        _BinaryPredicate __binary_pred, std::forward_iterator_tag)
    {
      while (__first != __last && !bool(__binary_pred(*__first, __val)))
        ++__first;

      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && bool(__binary_pred(*__i, __val)))
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = ++__i;
   while (__first != __last
   && !bool(__binary_pred(*__first, __val)))
     ++__first;
 }
      return __last;
    }







  template<typename _RandomAccessIter, typename _Integer, typename _Tp,
    typename _BinaryPredicate>
    _RandomAccessIter
    __search_n(_RandomAccessIter __first, _RandomAccessIter __last,
        _Integer __count, const _Tp& __val,
        _BinaryPredicate __binary_pred, std::random_access_iterator_tag)
    {

      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;

      _DistanceType __tailSize = __last - __first;
      _DistanceType __remainder = __count;

      while (__remainder <= __tailSize)
 {
   __first += __remainder;
   __tailSize -= __remainder;


   _RandomAccessIter __backTrack = __first;
   while (__binary_pred(*--__backTrack, __val))
     {
       if (--__remainder == 0)
         return (__first - __count);
     }
   __remainder = __count + 1 - (__first - __backTrack);
 }
      return __last;
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag)
    {
      if (__first2 == __last2)
 return __last1;
      else
 {
   _ForwardIterator1 __result = __last1;
   while (1)
     {
       _ForwardIterator1 __new_result
  = std::search(__first1, __last1, __first2, __last2);
       if (__new_result == __last1)
  return __result;
       else
  {
    __result = __new_result;
    __first1 = __new_result;
    ++__first1;
  }
     }
 }
    }

  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag,
        _BinaryPredicate __comp)
    {
      if (__first2 == __last2)
 return __last1;
      else
 {
   _ForwardIterator1 __result = __last1;
   while (1)
     {
       _ForwardIterator1 __new_result
  = std::search(__first1, __last1, __first2,
      __last2, __comp);
       if (__new_result == __last1)
  return __result;
       else
  {
    __result = __new_result;
    __first1 = __new_result;
    ++__first1;
  }
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag)
    {






      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::search(_RevIterator1(__last1),
             __rlast1,
             _RevIterator2(__last2),
             __rlast2);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }

  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BinaryPredicate>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag,
        _BinaryPredicate __comp)
    {






      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::search(_RevIterator1(__last1), __rlast1,
         _RevIterator2(__last2), __rlast2,
         __comp);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }
# 645 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {






                                                       ;
                                                       ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2));
    }
# 692 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __comp)
    {






                                                       ;
                                                       ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __comp);
    }
# 727 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return __last == std::find_if_not(__first, __last, __pred); }
# 744 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return __last == std::find_if(__first, __last, __pred); }
# 762 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return !std::none_of(__first, __last, __pred); }
# 777 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if_not(_InputIterator __first, _InputIterator __last,
  _Predicate __pred)
    {




                                                     ;
      return std::__find_if_not(__first, __last, __pred);
    }
# 800 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    is_partitioned(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {
      __first = std::find_if_not(__first, __last, __pred);
      return std::none_of(__first, __last, __pred);
    }
# 818 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    partition_point(_ForwardIterator __first, _ForwardIterator __last,
      _Predicate __pred)
    {






                                                     ;

      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__pred(*__middle))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 871 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    _OutputIterator
    remove_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, const _Tp& __value)
    {






                                                     ;

      for (; __first != __last; ++__first)
 if (!(*__first == __value))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
# 908 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    remove_copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {






                                                     ;

      for (; __first != __last; ++__first)
 if (!bool(__pred(*__first)))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
# 947 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {






                                                     ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }


  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    _OutputIterator
    __copy_n(_InputIterator __first, _Size __n,
      _OutputIterator __result, input_iterator_tag)
    {
      if (__n > 0)
 {
   while (true)
     {
       *__result = *__first;
       ++__result;
       if (--__n > 0)
  ++__first;
       else
  break;
     }
 }
      return __result;
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _OutputIterator>
    inline _OutputIterator
    __copy_n(_RandomAccessIterator __first, _Size __n,
      _OutputIterator __result, random_access_iterator_tag)
    { return std::copy(__first, __first + __n, __result); }
# 1011 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    inline _OutputIterator
    copy_n(_InputIterator __first, _Size __n, _OutputIterator __result)
    {





      return std::__copy_n(__first, __n, __result,
      std::__iterator_category(__first));
    }
# 1039 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator1,
    typename _OutputIterator2, typename _Predicate>
    pair<_OutputIterator1, _OutputIterator2>
    partition_copy(_InputIterator __first, _InputIterator __last,
     _OutputIterator1 __out_true, _OutputIterator2 __out_false,
     _Predicate __pred)
    {
# 1054 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
                                                     ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   {
     *__out_true = *__first;
     ++__out_true;
   }
 else
   {
     *__out_false = *__first;
     ++__out_false;
   }

      return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
    }
# 1089 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    remove(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __value)
    {





                                                     ;

      __first = std::find(__first, __last, __value);
      if(__first == __last)
        return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for(; __first != __last; ++__first)
        if(!(*__first == __value))
          {
            *__result = std::move(*__first);
            ++__result;
          }
      return __result;
    }
# 1132 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    remove_if(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {





                                                     ;

      __first = std::find_if(__first, __last, __pred);
      if(__first == __last)
        return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for(; __first != __last; ++__first)
        if(!bool(__pred(*__first)))
          {
            *__result = std::move(*__first);
            ++__result;
          }
      return __result;
    }
# 1172 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last)
    {





                                                     ;


      __first = std::adjacent_find(__first, __last);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!(*__dest == *__first))
   *++__dest = std::move(*__first);
      return ++__dest;
    }
# 1212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last,
           _BinaryPredicate __binary_pred)
    {






                                                     ;


      __first = std::adjacent_find(__first, __last, __binary_pred);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!bool(__binary_pred(*__dest, *__first)))
   *++__dest = std::move(*__first);
      return ++__dest;
    }






  template<typename _ForwardIterator, typename _OutputIterator>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result,
    forward_iterator_tag, output_iterator_tag)
    {

      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!(*__first == *__next))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }






  template<typename _InputIterator, typename _OutputIterator>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result,
    input_iterator_tag, output_iterator_tag)
    {

      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
 if (!(__value == *__first))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }






  template<typename _InputIterator, typename _ForwardIterator>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result,
    input_iterator_tag, forward_iterator_tag)
    {

      *__result = *__first;
      while (++__first != __last)
 if (!(*__result == *__first))
   *++__result = *__first;
      return ++__result;
    }







  template<typename _ForwardIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    forward_iterator_tag, output_iterator_tag)
    {





      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!bool(__binary_pred(*__first, *__next)))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, output_iterator_tag)
    {





      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
 if (!bool(__binary_pred(__value, *__first)))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, forward_iterator_tag)
    {





      *__result = *__first;
      while (++__first != __last)
 if (!bool(__binary_pred(*__result, *__first)))
   *++__result = *__first;
      return ++__result;
    }






  template<typename _BidirectionalIterator>
    void
    __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {
      while (true)
 if (__first == __last || __first == --__last)
   return;
 else
   {
     std::iter_swap(__first, __last);
     ++__first;
   }
    }






  template<typename _RandomAccessIterator>
    void
    __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
       random_access_iterator_tag)
    {
      if (__first == __last)
 return;
      --__last;
      while (__first < __last)
 {
   std::iter_swap(__first, __last);
   ++__first;
   --__last;
 }
    }
# 1440 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline void
    reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
    {



                                                     ;
      std::__reverse(__first, __last, std::__iterator_category(__first));
    }
# 1467 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _OutputIterator>
    _OutputIterator
    reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
   _OutputIterator __result)
    {





                                                     ;

      while (__first != __last)
 {
   --__last;
   *__result = *__last;
   ++__result;
 }
      return __result;
    }





  template<typename _EuclideanRingElement>
    _EuclideanRingElement
    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
    {
      while (__n != 0)
 {
   _EuclideanRingElement __t = __m % __n;
   __m = __n;
   __n = __t;
 }
      return __m;
    }


  template<typename _ForwardIterator>
    void
    __rotate(_ForwardIterator __first,
      _ForwardIterator __middle,
      _ForwardIterator __last,
      forward_iterator_tag)
    {
      if (__first == __middle || __last == __middle)
 return;

      _ForwardIterator __first2 = __middle;
      do
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
 }
      while (__first2 != __last);

      __first2 = __middle;

      while (__first2 != __last)
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
   else if (__first2 == __last)
     __first2 = __middle;
 }
    }


  template<typename _BidirectionalIterator>
    void
    __rotate(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {




      if (__first == __middle || __last == __middle)
 return;

      std::__reverse(__first, __middle, bidirectional_iterator_tag());
      std::__reverse(__middle, __last, bidirectional_iterator_tag());

      while (__first != __middle && __middle != __last)
 {
   std::iter_swap(__first, --__last);
   ++__first;
 }

      if (__first == __middle)
 std::__reverse(__middle, __last, bidirectional_iterator_tag());
      else
 std::__reverse(__first, __middle, bidirectional_iterator_tag());
    }


  template<typename _RandomAccessIterator>
    void
    __rotate(_RandomAccessIterator __first,
      _RandomAccessIterator __middle,
      _RandomAccessIterator __last,
      random_access_iterator_tag)
    {




      if (__first == __middle || __last == __middle)
 return;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      _Distance __n = __last - __first;
      _Distance __k = __middle - __first;

      if (__k == __n - __k)
 {
   std::swap_ranges(__first, __middle, __middle);
   return;
 }

      _RandomAccessIterator __p = __first;

      for (;;)
 {
   if (__k < __n - __k)
     {
       if (__is_pod(_ValueType) && __k == 1)
  {
    _ValueType __t = std::move(*__p);
    std::move(__p + 1, __p + __n, __p);
    *(__p + __n - 1) = std::move(__t);
    return;
  }
       _RandomAccessIterator __q = __p + __k;
       for (_Distance __i = 0; __i < __n - __k; ++ __i)
  {
    std::iter_swap(__p, __q);
    ++__p;
    ++__q;
  }
       __n %= __k;
       if (__n == 0)
  return;
       std::swap(__n, __k);
       __k = __n - __k;
     }
   else
     {
       __k = __n - __k;
       if (__is_pod(_ValueType) && __k == 1)
  {
    _ValueType __t = std::move(*(__p + __n - 1));
    std::move_backward(__p, __p + __n - 1, __p + __n);
    *__p = std::move(__t);
    return;
  }
       _RandomAccessIterator __q = __p + __n;
       __p = __q - __k;
       for (_Distance __i = 0; __i < __n - __k; ++ __i)
  {
    --__p;
    --__q;
    std::iter_swap(__p, __q);
  }
       __n %= __k;
       if (__n == 0)
  return;
       std::swap(__n, __k);
     }
 }
    }
# 1673 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline void
    rotate(_ForwardIterator __first, _ForwardIterator __middle,
    _ForwardIterator __last)
    {



                                                       ;
                                                      ;

      typedef typename iterator_traits<_ForwardIterator>::iterator_category
 _IterType;
      std::__rotate(__first, __middle, __last, _IterType());
    }
# 1709 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _OutputIterator>
    _OutputIterator
    rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
                _ForwardIterator __last, _OutputIterator __result)
    {




                                                       ;
                                                      ;

      return std::copy(__first, __middle,
                       std::copy(__middle, __last, __result));
    }


  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __partition(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred, forward_iterator_tag)
    {
      if (__first == __last)
 return __first;

      while (__pred(*__first))
 if (++__first == __last)
   return __first;

      _ForwardIterator __next = __first;

      while (++__next != __last)
 if (__pred(*__next))
   {
     std::iter_swap(__first, __next);
     ++__first;
   }

      return __first;
    }


  template<typename _BidirectionalIterator, typename _Predicate>
    _BidirectionalIterator
    __partition(_BidirectionalIterator __first, _BidirectionalIterator __last,
  _Predicate __pred, bidirectional_iterator_tag)
    {
      while (true)
 {
   while (true)
     if (__first == __last)
       return __first;
     else if (__pred(*__first))
       ++__first;
     else
       break;
   --__last;
   while (true)
     if (__first == __last)
       return __first;
     else if (!bool(__pred(*__last)))
       --__last;
     else
       break;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }






  template<typename _ForwardIterator, typename _Predicate, typename _Distance>
    _ForwardIterator
    __inplace_stable_partition(_ForwardIterator __first,
          _Predicate __pred, _Distance __len)
    {
      if (__len == 1)
 return __first;
      _ForwardIterator __middle = __first;
      std::advance(__middle, __len / 2);
      _ForwardIterator __left_split =
 std::__inplace_stable_partition(__first, __pred, __len / 2);


      _Distance __right_len = __len - __len / 2;
      _ForwardIterator __right_split =
 std::__find_if_not_n(__middle, __right_len, __pred);
      if (__right_len)
 __right_split = std::__inplace_stable_partition(__middle,
       __pred,
       __right_len);
      std::rotate(__left_split, __middle, __right_split);
      std::advance(__left_split, std::distance(__middle, __right_split));
      return __left_split;
    }







  template<typename _ForwardIterator, typename _Pointer, typename _Predicate,
    typename _Distance>
    _ForwardIterator
    __stable_partition_adaptive(_ForwardIterator __first,
    _ForwardIterator __last,
    _Predicate __pred, _Distance __len,
    _Pointer __buffer,
    _Distance __buffer_size)
    {
      if (__len <= __buffer_size)
 {
   _ForwardIterator __result1 = __first;
   _Pointer __result2 = __buffer;



   *__result2 = std::move(*__first);
   ++__result2;
   ++__first;
   for (; __first != __last; ++__first)
     if (__pred(*__first))
       {
  *__result1 = std::move(*__first);
  ++__result1;
       }
     else
       {
  *__result2 = std::move(*__first);
  ++__result2;
       }
   std::move(__buffer, __result2, __result1);
   return __result1;
 }
      else
 {
   _ForwardIterator __middle = __first;
   std::advance(__middle, __len / 2);
   _ForwardIterator __left_split =
     std::__stable_partition_adaptive(__first, __middle, __pred,
          __len / 2, __buffer,
          __buffer_size);


   _Distance __right_len = __len - __len / 2;
   _ForwardIterator __right_split =
     std::__find_if_not_n(__middle, __right_len, __pred);
   if (__right_len)
     __right_split =
       std::__stable_partition_adaptive(__right_split, __last, __pred,
            __right_len,
            __buffer, __buffer_size);
   std::rotate(__left_split, __middle, __right_split);
   std::advance(__left_split, std::distance(__middle, __right_split));
   return __left_split;
 }
    }
# 1888 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    stable_partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {





                                                     ;

      __first = std::__find_if_not(__first, __last, __pred);

      if (__first == __last)
 return __first;
      else
 {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;
   typedef typename iterator_traits<_ForwardIterator>::difference_type
     _DistanceType;

   _Temporary_buffer<_ForwardIterator, _ValueType> __buf(__first,
        __last);
 if (__buf.size() > 0)
   return
     std::__stable_partition_adaptive(__first, __last, __pred,
       _DistanceType(__buf.requested_size()),
       __buf.begin(),
       _DistanceType(__buf.size()));
 else
   return
     std::__inplace_stable_partition(__first, __pred,
      _DistanceType(__buf.requested_size()));
 }
    }


  template<typename _RandomAccessIterator>
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last)
    {
      std::make_heap(__first, __middle);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (*__i < *__first)
   std::__pop_heap(__first, __middle, __i);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last, _Compare __comp)
    {
      std::make_heap(__first, __middle, __comp);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (__comp(*__i, *__first))
   std::__pop_heap(__first, __middle, __i, __comp);
    }
# 1972 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator>
    _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;
# 1992 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
                                                     ;
                                                                   ;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }
      std::make_heap(__result_first, __result_real_last);
      while (__first != __last)
 {
   if (*__first < *__result_first)
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first));
   ++__first;
 }
      std::sort_heap(__result_first, __result_real_last);
      return __result_real_last;
    }
# 2038 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator, typename _Compare>
    _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last,
        _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;
# 2062 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
                                                     ;
                                                                   ;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }
      std::make_heap(__result_first, __result_real_last, __comp);
      while (__first != __last)
 {
   if (__comp(*__first, *__result_first))
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first),
          __comp);
   ++__first;
 }
      std::sort_heap(__result_first, __result_real_last, __comp);
      return __result_real_last;
    }


  template<typename _RandomAccessIterator>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last)
    {
      typename iterator_traits<_RandomAccessIterator>::value_type
 __val = std::move(*__last);
      _RandomAccessIterator __next = __last;
      --__next;
      while (__val < *__next)
 {
   *__last = std::move(*__next);
   __last = __next;
   --__next;
 }
      *__last = std::move(__val);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last,
         _Compare __comp)
    {
      typename iterator_traits<_RandomAccessIterator>::value_type
 __val = std::move(*__last);
      _RandomAccessIterator __next = __last;
      --__next;
      while (__comp(__val, *__next))
 {
   *__last = std::move(*__next);
   __last = __next;
   --__next;
 }
      *__last = std::move(__val);
    }


  template<typename _RandomAccessIterator>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last)
    {
      if (__first == __last)
 return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   if (*__i < *__first)
     {
       typename iterator_traits<_RandomAccessIterator>::value_type
  __val = std::move(*__i);
       std::move_backward(__first, __i, __i + 1);
       *__first = std::move(__val);
     }
   else
     std::__unguarded_linear_insert(__i);
 }
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last, _Compare __comp)
    {
      if (__first == __last) return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   if (__comp(*__i, *__first))
     {
       typename iterator_traits<_RandomAccessIterator>::value_type
  __val = std::move(*__i);
       std::move_backward(__first, __i, __i + 1);
       *__first = std::move(__val);
     }
   else
     std::__unguarded_linear_insert(__i, __comp);
 }
    }


  template<typename _RandomAccessIterator>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i, __comp);
    }





  enum { _S_threshold = 16 };


  template<typename _RandomAccessIterator>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold));
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last);
 }
      else
 std::__insertion_sort(__first, __last);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last,
       __comp);
 }
      else
 std::__insertion_sort(__first, __last, __comp);
    }


  template<typename _RandomAccessIterator, typename _Tp>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last, const _Tp& __pivot)
    {
      while (true)
 {
   while (*__first < __pivot)
     ++__first;
   --__last;
   while (__pivot < *__last)
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }


  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last,
     const _Tp& __pivot, _Compare __comp)
    {
      while (true)
 {
   while (__comp(*__first, __pivot))
     ++__first;
   --__last;
   while (__comp(__pivot, *__last))
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }


  template<typename _RandomAccessIterator>
    inline _RandomAccessIterator
    __unguarded_partition_pivot(_RandomAccessIterator __first,
    _RandomAccessIterator __last)
    {
      _RandomAccessIterator __mid = __first + (__last - __first) / 2;
      std::__move_median_to_first(__first, __first + 1, __mid, __last - 1);
      return std::__unguarded_partition(__first + 1, __last, *__first);
    }



  template<typename _RandomAccessIterator, typename _Compare>
    inline _RandomAccessIterator
    __unguarded_partition_pivot(_RandomAccessIterator __first,
    _RandomAccessIterator __last, _Compare __comp)
    {
      _RandomAccessIterator __mid = __first + (__last - __first) / 2;
      std::__move_median_to_first(__first, __first + 1, __mid, __last - 1,
      __comp);
      return std::__unguarded_partition(__first + 1, __last, *__first, __comp);
    }


  template<typename _RandomAccessIterator, typename _Size>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit)
    {
      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::partial_sort(__first, __last, __last);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last);
   std::__introsort_loop(__cut, __last, __depth_limit);
   __last = __cut;
 }
    }


  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit, _Compare __comp)
    {
      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::partial_sort(__first, __last, __last, __comp);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last, __comp);
   std::__introsort_loop(__cut, __last, __depth_limit, __comp);
   __last = __cut;
 }
    }



  template<typename _RandomAccessIterator, typename _Size>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last);


       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last);
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last);
    }

  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit,
    _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last, __comp);

       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last, __comp);
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last, __comp);
    }
# 2423 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;






                    ;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(*__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 2470 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;




                                                                  ;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__val < *__middle)
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
# 2519 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;






                    ;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__val, *__middle))
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
# 2572 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;





                                                                  ;
                                                                  ;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__val < *__middle)
     __len = __half;
   else
     {
       _ForwardIterator __left = std::lower_bound(__first, __middle,
        __val);
       std::advance(__first, __len);
       _ForwardIterator __right = std::upper_bound(++__middle, __first,
         __val);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
# 2634 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;
# 2651 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
                    ;

                    ;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(*__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__comp(__val, *__middle))
     __len = __half;
   else
     {
       _ForwardIterator __left = std::lower_bound(__first, __middle,
        __val, __comp);
       std::advance(__first, __len);
       _ForwardIterator __right = std::upper_bound(++__middle, __first,
         __val, __comp);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
# 2695 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;




                                                                  ;
                                                                  ;

      _ForwardIterator __i = std::lower_bound(__first, __last, __val);
      return __i != __last && !(__val < *__i);
    }
# 2728 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;






                    ;

                    ;

      _ForwardIterator __i = std::lower_bound(__first, __last, __val, __comp);
      return __i != __last && !bool(__comp(__val, *__i));
    }




  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    void
    __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first2 < *__first1)
     {
       *__result = std::move(*__first2);
       ++__first2;
     }
   else
     {
       *__result = std::move(*__first1);
       ++__first1;
     }
   ++__result;
 }
      if (__first1 != __last1)
 std::move(__first1, __last1, __result);
    }


  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    void
    __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first2, *__first1))
     {
       *__result = std::move(*__first2);
       ++__first2;
     }
   else
     {
       *__result = std::move(*__first1);
       ++__first1;
     }
   ++__result;
 }
      if (__first1 != __last1)
 std::move(__first1, __last1, __result);
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3>
    void
    __move_merge_adaptive_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result)
    {
      if (__first1 == __last1)
 {
   std::move_backward(__first2, __last2, __result);
   return;
 }
      else if (__first2 == __last2)
 return;

      --__last1;
      --__last2;
      while (true)
 {
   if (*__last2 < *__last1)
     {
       *--__result = std::move(*__last1);
       if (__first1 == __last1)
  {
    std::move_backward(__first2, ++__last2, __result);
    return;
  }
       --__last1;
     }
   else
     {
       *--__result = std::move(*__last2);
       if (__first2 == __last2)
  return;
       --__last2;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3, typename _Compare>
    void
    __move_merge_adaptive_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result,
       _Compare __comp)
    {
      if (__first1 == __last1)
 {
   std::move_backward(__first2, __last2, __result);
   return;
 }
      else if (__first2 == __last2)
 return;

      --__last1;
      --__last2;
      while (true)
 {
   if (__comp(*__last2, *__last1))
     {
       *--__result = std::move(*__last1);
       if (__first1 == __last1)
  {
    std::move_backward(__first2, ++__last2, __result);
    return;
  }
       --__last1;
     }
   else
     {
       *--__result = std::move(*__last2);
       if (__first2 == __last2)
  return;
       --__last2;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _Distance>
    _BidirectionalIterator1
    __rotate_adaptive(_BidirectionalIterator1 __first,
        _BidirectionalIterator1 __middle,
        _BidirectionalIterator1 __last,
        _Distance __len1, _Distance __len2,
        _BidirectionalIterator2 __buffer,
        _Distance __buffer_size)
    {
      _BidirectionalIterator2 __buffer_end;
      if (__len1 > __len2 && __len2 <= __buffer_size)
 {
   if (__len2)
     {
       __buffer_end = std::move(__middle, __last, __buffer);
       std::move_backward(__first, __middle, __last);
       return std::move(__buffer, __buffer_end, __first);
     }
   else
     return __first;
 }
      else if (__len1 <= __buffer_size)
 {
   if (__len1)
     {
       __buffer_end = std::move(__first, __middle, __buffer);
       std::move(__middle, __last, __first);
       return std::move_backward(__buffer, __buffer_end, __last);
     }
   else
     return __last;
 }
      else
 {
   std::rotate(__first, __middle, __last);
   std::advance(__first, std::distance(__middle, __last));
   return __first;
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer>
    void
    __merge_adaptive(_BidirectionalIterator __first,
                     _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::move(__first, __middle, __buffer);
   std::__move_merge_adaptive(__buffer, __buffer_end, __middle, __last,
         __first);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::move(__middle, __last, __buffer);
   std::__move_merge_adaptive_backward(__first, __middle, __buffer,
           __buffer_end, __last);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut = std::lower_bound(__middle, __last,
           *__first_cut);
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut = std::upper_bound(__first, __middle,
          *__second_cut);
       __len11 = std::distance(__first, __first_cut);
     }
   _BidirectionalIterator __new_middle =
     std::__rotate_adaptive(__first_cut, __middle, __second_cut,
       __len1 - __len11, __len22, __buffer,
       __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer, __buffer_size);
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer, typename _Compare>
    void
    __merge_adaptive(_BidirectionalIterator __first,
                     _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size,
       _Compare __comp)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::move(__first, __middle, __buffer);
   std::__move_merge_adaptive(__buffer, __buffer_end, __middle, __last,
         __first, __comp);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::move(__middle, __last, __buffer);
   std::__move_merge_adaptive_backward(__first, __middle, __buffer,
           __buffer_end, __last, __comp);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut = std::lower_bound(__middle, __last, *__first_cut,
           __comp);
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut = std::upper_bound(__first, __middle, *__second_cut,
          __comp);
       __len11 = std::distance(__first, __first_cut);
     }
   _BidirectionalIterator __new_middle =
     std::__rotate_adaptive(__first_cut, __middle, __second_cut,
       __len1 - __len11, __len22, __buffer,
       __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size, __comp);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer,
    __buffer_size, __comp);
 }
    }


  template<typename _BidirectionalIterator, typename _Distance>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2)
    {
      if (__len1 == 0 || __len2 == 0)
 return;
      if (__len1 + __len2 == 2)
 {
   if (*__middle < *__first)
     std::iter_swap(__first, __middle);
   return;
 }
      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut = std::lower_bound(__middle, __last, *__first_cut);
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut = std::upper_bound(__first, __middle, *__second_cut);
   __len11 = std::distance(__first, __first_cut);
 }
      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22);
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Compare>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
                           _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2,
      _Compare __comp)
    {
      if (__len1 == 0 || __len2 == 0)
 return;
      if (__len1 + __len2 == 2)
 {
   if (__comp(*__middle, *__first))
     std::iter_swap(__first, __middle);
   return;
 }
      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut = std::lower_bound(__middle, __last, *__first_cut,
       __comp);
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut = std::upper_bound(__first, __middle, *__second_cut,
      __comp);
   __len11 = std::distance(__first, __first_cut);
 }
      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22, __comp);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22, __comp);
    }
# 3152 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
          _DistanceType;





                                                  ;
                                                 ;

      if (__first == __middle || __middle == __last)
 return;

      _DistanceType __len1 = std::distance(__first, __middle);
      _DistanceType __len2 = std::distance(__middle, __last);

      _Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first,
          __last);
      if (__buf.begin() == 0)
 std::__merge_without_buffer(__first, __middle, __last, __len1, __len2);
      else
 std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
         __buf.begin(), _DistanceType(__buf.size()));
    }
# 3207 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Compare __comp)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
          _DistanceType;






                                                               ;
                                                              ;

      if (__first == __middle || __middle == __last)
 return;

      const _DistanceType __len1 = std::distance(__first, __middle);
      const _DistanceType __len2 = std::distance(__middle, __last);

      _Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first,
          __last);
      if (__buf.begin() == 0)
 std::__merge_without_buffer(__first, __middle, __last, __len1,
        __len2, __comp);
      else
 std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
         __buf.begin(), _DistanceType(__buf.size()),
         __comp);
    }



  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    __move_merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first2 < *__first1)
     {
       *__result = std::move(*__first2);
       ++__first2;
     }
   else
     {
       *__result = std::move(*__first1);
       ++__first1;
     }
   ++__result;
 }
      return std::move(__first2, __last2, std::move(__first1, __last1, __result));


    }


  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    __move_merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first2, *__first1))
     {
       *__result = std::move(*__first2);
       ++__first2;
     }
   else
     {
       *__result = std::move(*__first1);
       ++__first1;
     }
   ++__result;
 }
      return std::move(__first2, __last2, std::move(__first1, __last1, __result));


    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result,
        _Distance __step_size)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::__move_merge(__first, __first + __step_size,
           __first + __step_size,
           __first + __two_step, __result);
   __first += __two_step;
 }

      __step_size = std::min(_Distance(__last - __first), __step_size);
      std::__move_merge(__first, __first + __step_size,
   __first + __step_size, __last, __result);
    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance, typename _Compare>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result, _Distance __step_size,
        _Compare __comp)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::__move_merge(__first, __first + __step_size,
           __first + __step_size,
           __first + __two_step,
           __result, __comp);
   __first += __two_step;
 }
      __step_size = std::min(_Distance(__last - __first), __step_size);

      std::__move_merge(__first,__first + __step_size,
   __first + __step_size, __last, __result, __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last);
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size, _Compare __comp)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size, __comp);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last, __comp);
    }

  enum { _S_chunk_size = 7 };

  template<typename _RandomAccessIterator, typename _Pointer>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
                             _Pointer __buffer)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer, __step_size);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first, __step_size);
   __step_size *= 2;
 }
    }

  template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
                             _Pointer __buffer, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size, __comp);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer,
     __step_size, __comp);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first,
     __step_size, __comp);
   __step_size *= 2;
 }
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
                           _Pointer __buffer, _Distance __buffer_size)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle,
          __buffer, __buffer_size);
   std::__stable_sort_adaptive(__middle, __last,
          __buffer, __buffer_size);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer);
   std::__merge_sort_with_buffer(__middle, __last, __buffer);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size);
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance, typename _Compare>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
                           _Pointer __buffer, _Distance __buffer_size,
                           _Compare __comp)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle, __buffer,
          __buffer_size, __comp);
   std::__stable_sort_adaptive(__middle, __last, __buffer,
          __buffer_size, __comp);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
   std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size,
       __comp);
    }


  template<typename _RandomAccessIterator>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle);
      std::__inplace_stable_sort(__middle, __last);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last, __comp);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle, __comp);
      std::__inplace_stable_sort(__middle, __last, __comp);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle,
      __comp);
    }
# 3547 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;






                                                                ;
                                                                ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first2 < *__first1)
   return false;
 else if(*__first1 < *__first2)
   ++__first1;
 else
   ++__first1, ++__first2;

      return __first2 == __last2;
    }
# 3597 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 3616 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
                                                                             ;
                                                                             ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first2, *__first1))
   return false;
 else if(__comp(*__first1, *__first2))
   ++__first1;
 else
   ++__first1, ++__first2;

      return __first2 == __last2;
    }
# 3652 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {





                                                     ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (*__i < *__ii)
     {
       _BidirectionalIterator __j = __last;
       while (!(*__i < *--__j))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 3709 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {






                                                     ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(*__i, *__ii))
     {
       _BidirectionalIterator __j = __last;
       while (!bool(__comp(*__i, *--__j)))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 3765 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {





                                                     ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (*__ii < *__i)
     {
       _BidirectionalIterator __j = __last;
       while (!(*--__j < *__i))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 3822 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {






                                                     ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(*__ii, *__i))
     {
       _BidirectionalIterator __j = __last;
       while (!bool(__comp(*--__j, *__i)))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 3882 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    _OutputIterator
    replace_copy(_InputIterator __first, _InputIterator __last,
   _OutputIterator __result,
   const _Tp& __old_value, const _Tp& __new_value)
    {






                                                     ;

      for (; __first != __last; ++__first, ++__result)
 if (*__first == __old_value)
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
# 3919 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    _OutputIterator
    replace_copy_if(_InputIterator __first, _InputIterator __last,
      _OutputIterator __result,
      _Predicate __pred, const _Tp& __new_value)
    {






                                                     ;

      for (; __first != __last; ++__first, ++__result)
 if (__pred(*__first))
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
# 3950 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline bool
    is_sorted(_ForwardIterator __first, _ForwardIterator __last)
    { return std::is_sorted_until(__first, __last) == __last; }
# 3964 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    inline bool
    is_sorted(_ForwardIterator __first, _ForwardIterator __last,
       _Compare __comp)
    { return std::is_sorted_until(__first, __last, __comp) == __last; }
# 3978 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;

      if (__first == __last)
 return __last;

      _ForwardIterator __next = __first;
      for (++__next; __next != __last; __first = __next, ++__next)
 if (*__next < *__first)
   return __next;
      return __next;
    }
# 4007 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
      _Compare __comp)
    {





                                                     ;

      if (__first == __last)
 return __last;

      _ForwardIterator __next = __first;
      for (++__next; __next != __last; __first = __next, ++__next)
 if (__comp(*__next, *__first))
   return __next;
      return __next;
    }
# 4037 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _Tp>
    inline pair<const _Tp&, const _Tp&>
    minmax(const _Tp& __a, const _Tp& __b)
    {



      return __b < __a ? pair<const _Tp&, const _Tp&>(__b, __a)
                : pair<const _Tp&, const _Tp&>(__a, __b);
    }
# 4057 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _Tp, typename _Compare>
    inline pair<const _Tp&, const _Tp&>
    minmax(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {
      return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a)
                       : pair<const _Tp&, const _Tp&>(__a, __b);
    }
# 4076 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    pair<_ForwardIterator, _ForwardIterator>
    minmax_element(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;

      _ForwardIterator __next = __first;
      if (__first == __last
   || ++__next == __last)
 return std::make_pair(__first, __first);

      _ForwardIterator __min, __max;
      if (*__next < *__first)
 {
   __min = __next;
   __max = __first;
 }
      else
 {
   __min = __first;
   __max = __next;
 }

      __first = __next;
      ++__first;

      while (__first != __last)
 {
   __next = __first;
   if (++__next == __last)
     {
       if (*__first < *__min)
  __min = __first;
       else if (!(*__first < *__max))
  __max = __first;
       break;
     }

   if (*__next < *__first)
     {
       if (*__next < *__min)
  __min = __next;
       if (!(*__first < *__max))
  __max = __first;
     }
   else
     {
       if (*__first < *__min)
  __min = __first;
       if (!(*__next < *__max))
  __max = __next;
     }

   __first = __next;
   ++__first;
 }

      return std::make_pair(__min, __max);
    }
# 4152 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    pair<_ForwardIterator, _ForwardIterator>
    minmax_element(_ForwardIterator __first, _ForwardIterator __last,
     _Compare __comp)
    {





                                                     ;

      _ForwardIterator __next = __first;
      if (__first == __last
   || ++__next == __last)
 return std::make_pair(__first, __first);

      _ForwardIterator __min, __max;
      if (__comp(*__next, *__first))
 {
   __min = __next;
   __max = __first;
 }
      else
 {
   __min = __first;
   __max = __next;
 }

      __first = __next;
      ++__first;

      while (__first != __last)
 {
   __next = __first;
   if (++__next == __last)
     {
       if (__comp(*__first, *__min))
  __min = __first;
       else if (!__comp(*__first, *__max))
  __max = __first;
       break;
     }

   if (__comp(*__next, *__first))
     {
       if (__comp(*__next, *__min))
  __min = __next;
       if (!__comp(*__first, *__max))
  __max = __first;
     }
   else
     {
       if (__comp(*__first, *__min))
  __min = __first;
       if (!__comp(*__next, *__max))
  __max = __next;
     }

   __first = __next;
   ++__first;
 }

      return std::make_pair(__min, __max);
    }


  template<typename _Tp>
    inline _Tp
    min(initializer_list<_Tp> __l)
    { return *std::min_element(__l.begin(), __l.end()); }

  template<typename _Tp, typename _Compare>
    inline _Tp
    min(initializer_list<_Tp> __l, _Compare __comp)
    { return *std::min_element(__l.begin(), __l.end(), __comp); }

  template<typename _Tp>
    inline _Tp
    max(initializer_list<_Tp> __l)
    { return *std::max_element(__l.begin(), __l.end()); }

  template<typename _Tp, typename _Compare>
    inline _Tp
    max(initializer_list<_Tp> __l, _Compare __comp)
    { return *std::max_element(__l.begin(), __l.end(), __comp); }

  template<typename _Tp>
    inline pair<_Tp, _Tp>
    minmax(initializer_list<_Tp> __l)
    {
      pair<const _Tp*, const _Tp*> __p =
 std::minmax_element(__l.begin(), __l.end());
      return std::make_pair(*__p.first, *__p.second);
    }

  template<typename _Tp, typename _Compare>
    inline pair<_Tp, _Tp>
    minmax(initializer_list<_Tp> __l, _Compare __comp)
    {
      pair<const _Tp*, const _Tp*> __p =
 std::minmax_element(__l.begin(), __l.end(), __comp);
      return std::make_pair(*__p.first, *__p.second);
    }
# 4269 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2)
    {


      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!(*__first1 == *__first2))
   break;

      if (__first1 == __last1)
 return true;



      _ForwardIterator2 __last2 = __first2;
      std::advance(__last2, std::distance(__first1, __last1));
      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
 {
   if (__scan != std::find(__first1, __scan, *__scan))
     continue;

   auto __matches = std::count(__first2, __last2, *__scan);
   if (0 == __matches
       || std::count(__scan, __last1, *__scan) != __matches)
     return false;
 }
      return true;
    }
# 4314 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2, _BinaryPredicate __pred)
    {


      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!bool(__pred(*__first1, *__first2)))
   break;

      if (__first1 == __last1)
 return true;



      _ForwardIterator2 __last2 = __first2;
      std::advance(__last2, std::distance(__first1, __last1));
      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
 {
   using std::placeholders::_1;

   if (__scan != std::find_if(__first1, __scan,
      std::bind(__pred, _1, *__scan)))
     continue;

   auto __matches = std::count_if(__first2, __last2,
      std::bind(__pred, _1, *__scan));
   if (0 == __matches
       || std::count_if(__scan, __last1,
          std::bind(__pred, _1, *__scan)) != __matches)
     return false;
 }
      return true;
    }
# 4364 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator,
    typename _UniformRandomNumberGenerator>
    void
    shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _UniformRandomNumberGenerator&& __g)
    {



                                                     ;

      if (__first == __last)
 return;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      typedef typename std::make_unsigned<_DistanceType>::type __ud_type;
      typedef typename std::uniform_int_distribution<__ud_type> __distr_type;
      typedef typename __distr_type::param_type __p_type;
      __distr_type __d;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 std::iter_swap(__i, __first + __d(__g, __p_type(0, __i - __first)));
    }
# 4409 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Function>
    _Function
    for_each(_InputIterator __first, _InputIterator __last, _Function __f)
    {


                                                     ;
      for (; __first != __last; ++__first)
 __f(*__first);
      return std::move(__f);
    }
# 4430 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    find(_InputIterator __first, _InputIterator __last,
  const _Tp& __val)
    {




                                                     ;
      return std::__find(__first, __last, __val,
           std::__iterator_category(__first));
    }
# 4454 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {




                                                     ;
      return std::__find_if(__first, __last, __pred,
       std::__iterator_category(__first));
    }
# 4484 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2)
    {






                                                       ;
                                                       ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (*__first1 == *__iter)
     return __first1;
      return __last1;
    }
# 4524 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2,
    _BinaryPredicate __comp)
    {






                                                       ;
                                                       ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (__comp(*__first1, *__iter))
     return __first1;
      return __last1;
    }
# 4556 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while(++__next != __last)
 {
   if (*__first == *__next)
     return __first;
   __first = __next;
 }
      return __last;
    }
# 4588 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {





                                                     ;
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while(++__next != __last)
 {
   if (__binary_pred(*__first, *__next))
     return __first;
   __first = __next;
 }
      return __last;
    }
# 4620 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    typename iterator_traits<_InputIterator>::difference_type
    count(_InputIterator __first, _InputIterator __last, const _Tp& __value)
    {




                                                     ;
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (*__first == __value)
   ++__n;
      return __n;
    }
# 4645 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    typename iterator_traits<_InputIterator>::difference_type
    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {




                                                     ;
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (__pred(*__first))
   ++__n;
      return __n;
    }
# 4687 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {






                                                       ;
                                                       ;


      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __p1(__first2);
      if (++__p1 == __last2)
 return std::find(__first1, __last1, *__first2);


      _ForwardIterator2 __p;
      _ForwardIterator1 __current = __first1;

      for (;;)
 {
   __first1 = std::find(__first1, __last1, *__first2);
   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (*__current == *__p)
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }
# 4758 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _BinaryPredicate __predicate)
    {






                                                       ;
                                                       ;


      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __p1(__first2);
      if (++__p1 == __last2)
 {
   while (__first1 != __last1
   && !bool(__predicate(*__first1, *__first2)))
     ++__first1;
   return __first1;
 }


      _ForwardIterator2 __p;
      _ForwardIterator1 __current = __first1;

      for (;;)
 {
   while (__first1 != __last1
   && !bool(__predicate(*__first1, *__first2)))
     ++__first1;
   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (__predicate(*__current, *__p))
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }
# 4833 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val)
    {




                                                     ;

      if (__count <= 0)
 return __first;
      if (__count == 1)
 return std::find(__first, __last, __val);
      return std::__search_n(__first, __last, __count, __val,
        std::__iterator_category(__first));
    }
# 4870 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
           typename _BinaryPredicate>
    _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val,
      _BinaryPredicate __binary_pred)
    {




                                                     ;

      if (__count <= 0)
 return __first;
      if (__count == 1)
 {
   while (__first != __last && !bool(__binary_pred(*__first, __val)))
     ++__first;
   return __first;
 }
      return std::__search_n(__first, __last, __count, __val, __binary_pred,
        std::__iterator_category(__first));
    }
# 4912 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _UnaryOperation>
    _OutputIterator
    transform(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _UnaryOperation __unary_op)
    {





                                                     ;

      for (; __first != __last; ++__first, ++__result)
 *__result = __unary_op(*__first);
      return __result;
    }
# 4949 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _BinaryOperation>
    _OutputIterator
    transform(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _OutputIterator __result,
       _BinaryOperation __binary_op)
    {






                                                       ;

      for (; __first1 != __last1; ++__first1, ++__first2, ++__result)
 *__result = __binary_op(*__first1, *__first2);
      return __result;
    }
# 4982 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    void
    replace(_ForwardIterator __first, _ForwardIterator __last,
     const _Tp& __old_value, const _Tp& __new_value)
    {







                                                     ;

      for (; __first != __last; ++__first)
 if (*__first == __old_value)
   *__first = __new_value;
    }
# 5014 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate, typename _Tp>
    void
    replace_if(_ForwardIterator __first, _ForwardIterator __last,
        _Predicate __pred, const _Tp& __new_value)
    {







                                                     ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   *__first = __new_value;
    }
# 5046 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Generator>
    void
    generate(_ForwardIterator __first, _ForwardIterator __last,
      _Generator __gen)
    {




                                                     ;

      for (; __first != __last; ++__first)
 *__first = __gen();
    }
# 5077 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _OutputIterator, typename _Size, typename _Generator>
    _OutputIterator
    generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
    {





      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __gen();
      return __first;
    }
# 5114 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {






                                                     ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result,
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 5153 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result,
  _BinaryPredicate __binary_pred)
    {




                                                     ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result, __binary_pred,
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 5185 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {



                                                     ;

      if (__first != __last)
 for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
   {
     _RandomAccessIterator __j = __first
     + std::rand() % ((__i - __first) + 1);
     if (__i != __j)
       std::iter_swap(__i, __j);
   }
    }
# 5218 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _RandomNumberGenerator>
    void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,

     _RandomNumberGenerator&& __rand)



    {



                                                     ;

      if (__first == __last)
 return;
      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   _RandomAccessIterator __j = __first + __rand((__i - __first) + 1);
   if (__i != __j)
     std::iter_swap(__i, __j);
 }
    }
# 5258 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {





                                                     ;

      return std::__partition(__first, __last, __pred,
         std::__iterator_category(__first));
    }
# 5292 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;





                                                       ;
                                                      ;

      std::__heap_select(__first, __middle, __last);
      std::sort_heap(__first, __middle);
    }
# 5331 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last,
   _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;






                                                       ;
                                                      ;

      std::__heap_select(__first, __middle, __last, __comp);
      std::sort_heap(__first, __middle, __comp);
    }
# 5368 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;





                                                    ;
                                                   ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2);
    }
# 5407 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;






                                                    ;
                                                   ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2, __comp);
    }
# 5445 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;





                                                     ;

      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2);
   std::__final_insertion_sort(__first, __last);
 }
    }
# 5481 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;






                                                     ;

      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2, __comp);
   std::__final_insertion_sort(__first, __last, __comp);
 }
    }
# 5523 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 5543 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
                                                                ;
                                                                ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first2 < *__first1)
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 5587 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 5608 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
                                                                             ;
                                                                             ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first2, *__first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 5647 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;





                                                     ;

      _Temporary_buffer<_RandomAccessIterator, _ValueType> __buf(__first,
         __last);
      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()));
    }
# 5689 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;







                                                     ;

      _Temporary_buffer<_RandomAccessIterator, _ValueType> __buf(__first,
         __last);
      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last, __comp);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()), __comp);
    }
# 5735 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 5756 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
                                                                ;
                                                                ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first1 < *__first2)
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (*__first2 < *__first1)
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 5802 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 5825 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
                                                                             ;
                                                                             ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first1, *__first2))
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (__comp(*__first2, *__first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 5869 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 5888 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
                                                                ;
                                                                ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   ++__first1;
 else if (*__first2 < *__first1)
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
# 5926 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 5947 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
                                                                             ;
                                                                             ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   ++__first1;
 else if (__comp(*__first2, *__first1))
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
# 5984 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 6003 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
                                                                ;
                                                                ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (*__first2 < *__first1)
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
# 6045 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 6066 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
                                                                             ;
                                                                             ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(*__first2, *__first1))
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
# 6103 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 6124 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
                                                                ;
                                                                ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (*__first2 < *__first1)
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2, std::copy(__first1,
          __last1, __result));
    }
# 6169 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result,
        _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 6193 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
                                                                             ;
                                                                             ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(*__first2, *__first1))
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
# 6226 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (*__first < *__result)
   __result = __first;
      return __result;
    }
# 6254 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {





                                                     ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(*__first, *__result))
   __result = __first;
      return __result;
    }
# 6282 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (*__result < *__first)
   __result = __first;
      return __result;
    }
# 6310 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {





                                                     ;

      if (__first == __last) return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(*__result, *__first))
   __result = __first;
      return __result;
    }


}
# 63 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/algorithm" 2 3
# 30 "/usr/include/gmpxx.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cfloat" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cfloat" 3

# 1 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/float.h" 1 3
# 42 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cfloat" 2 3
# 33 "/usr/include/gmpxx.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/gmp.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/gmp.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstdio" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstdio" 3
# 27 "/usr/include/x86_64-linux-gnu/gmp.h" 2 3 4
# 51 "/usr/include/x86_64-linux-gnu/gmp.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 3


# 1 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/stddef.h" 1 3
# 43 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 2 3
# 52 "/usr/include/x86_64-linux-gnu/gmp.h" 2 3 4
# 140 "/usr/include/x86_64-linux-gnu/gmp.h" 3 4
typedef unsigned long int mp_limb_t;
typedef long int mp_limb_signed_t;


typedef unsigned long int mp_bitcnt_t;




typedef struct
{
  int _mp_alloc;

  int _mp_size;


  mp_limb_t *_mp_d;
} __mpz_struct;




typedef __mpz_struct MP_INT;
typedef __mpz_struct mpz_t[1];

typedef mp_limb_t * mp_ptr;
typedef const mp_limb_t * mp_srcptr;







typedef long int mp_size_t;
typedef long int mp_exp_t;


typedef struct
{
  __mpz_struct _mp_num;
  __mpz_struct _mp_den;
} __mpq_struct;

typedef __mpq_struct MP_RAT;
typedef __mpq_struct mpq_t[1];

typedef struct
{
  int _mp_prec;



  int _mp_size;


  mp_exp_t _mp_exp;
  mp_limb_t *_mp_d;
} __mpf_struct;


typedef __mpf_struct mpf_t[1];


typedef enum
{
  GMP_RAND_ALG_DEFAULT = 0,
  GMP_RAND_ALG_LC = GMP_RAND_ALG_DEFAULT
} gmp_randalg_t;


typedef struct
{
  mpz_t _mp_seed;
  gmp_randalg_t _mp_alg;
  union {
    void *_mp_lc;
  } _mp_algdata;
} __gmp_randstate_struct;
typedef __gmp_randstate_struct gmp_randstate_t[1];



typedef const __mpz_struct *mpz_srcptr;
typedef __mpz_struct *mpz_ptr;
typedef const __mpf_struct *mpf_srcptr;
typedef __mpf_struct *mpf_ptr;
typedef const __mpq_struct *mpq_srcptr;
typedef __mpq_struct *mpq_ptr;
# 476 "/usr/include/x86_64-linux-gnu/gmp.h" 3 4
extern "C" {
using std::FILE;



               void __gmp_set_memory_functions (void *(*) (size_t),
          void *(*) (void *, size_t, size_t),
          void (*) (void *, size_t)) throw ();


               void __gmp_get_memory_functions (void *(**) (size_t),
                                      void *(**) (void *, size_t, size_t),
                                      void (**) (void *, size_t)) throw ();


               extern const int __gmp_bits_per_limb;


               extern int __gmp_errno;


               extern const char * const __gmp_version;






               void __gmp_randinit (gmp_randstate_t, gmp_randalg_t, ...);


               void __gmp_randinit_default (gmp_randstate_t);


               void __gmp_randinit_lc_2exp (gmp_randstate_t, mpz_srcptr, unsigned long int, mp_bitcnt_t);


               int __gmp_randinit_lc_2exp_size (gmp_randstate_t, mp_bitcnt_t);


               void __gmp_randinit_mt (gmp_randstate_t);


               void __gmp_randinit_set (gmp_randstate_t, const __gmp_randstate_struct *);


               void __gmp_randseed (gmp_randstate_t, mpz_srcptr);


               void __gmp_randseed_ui (gmp_randstate_t, unsigned long int);


               void __gmp_randclear (gmp_randstate_t);


               unsigned long __gmp_urandomb_ui (gmp_randstate_t, unsigned long);


               unsigned long __gmp_urandomm_ui (gmp_randstate_t, unsigned long);





               int __gmp_asprintf (char **, const char *, ...);



               int __gmp_fprintf (FILE *, const char *, ...);
# 558 "/usr/include/x86_64-linux-gnu/gmp.h" 3 4
               int __gmp_printf (const char *, ...);


               int __gmp_snprintf (char *, size_t, const char *, ...);


               int __gmp_sprintf (char *, const char *, ...);



               int __gmp_vasprintf (char **, const char *, va_list);




               int __gmp_vfprintf (FILE *, const char *, va_list);




               int __gmp_vprintf (const char *, va_list);




               int __gmp_vsnprintf (char *, size_t, const char *, va_list);




               int __gmp_vsprintf (char *, const char *, va_list);







               int __gmp_fscanf (FILE *, const char *, ...);



               int __gmp_scanf (const char *, ...);


               int __gmp_sscanf (const char *, const char *, ...);



               int __gmp_vfscanf (FILE *, const char *, va_list);




               int __gmp_vscanf (const char *, va_list);




               int __gmp_vsscanf (const char *, const char *, va_list);







               void *__gmpz_realloc (mpz_ptr, mp_size_t);



               void __gmpz_abs (mpz_ptr, mpz_srcptr);



               void __gmpz_add (mpz_ptr, mpz_srcptr, mpz_srcptr);


               void __gmpz_add_ui (mpz_ptr, mpz_srcptr, unsigned long int);


               void __gmpz_addmul (mpz_ptr, mpz_srcptr, mpz_srcptr);


               void __gmpz_addmul_ui (mpz_ptr, mpz_srcptr, unsigned long int);


               void __gmpz_and (mpz_ptr, mpz_srcptr, mpz_srcptr);


               void __gmpz_array_init (mpz_ptr, mp_size_t, mp_size_t);


               void __gmpz_bin_ui (mpz_ptr, mpz_srcptr, unsigned long int);


               void __gmpz_bin_uiui (mpz_ptr, unsigned long int, unsigned long int);


               void __gmpz_cdiv_q (mpz_ptr, mpz_srcptr, mpz_srcptr);


               void __gmpz_cdiv_q_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);


               unsigned long int __gmpz_cdiv_q_ui (mpz_ptr, mpz_srcptr, unsigned long int);


               void __gmpz_cdiv_qr (mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr);


               unsigned long int __gmpz_cdiv_qr_ui (mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long int);


               void __gmpz_cdiv_r (mpz_ptr, mpz_srcptr, mpz_srcptr);


               void __gmpz_cdiv_r_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);


               unsigned long int __gmpz_cdiv_r_ui (mpz_ptr, mpz_srcptr, unsigned long int);


               unsigned long int __gmpz_cdiv_ui (mpz_srcptr, unsigned long int) __attribute__ ((__pure__));


               void __gmpz_clear (mpz_ptr);


               void __gmpz_clears (mpz_ptr, ...);


               void __gmpz_clrbit (mpz_ptr, mp_bitcnt_t);


               int __gmpz_cmp (mpz_srcptr, mpz_srcptr) throw () __attribute__ ((__pure__));


               int __gmpz_cmp_d (mpz_srcptr, double) __attribute__ ((__pure__));


               int __gmpz_cmp_si (mpz_srcptr, signed long int) throw () __attribute__ ((__pure__));


               int __gmpz_cmp_ui (mpz_srcptr, unsigned long int) throw () __attribute__ ((__pure__));


               int __gmpz_cmpabs (mpz_srcptr, mpz_srcptr) throw () __attribute__ ((__pure__));


               int __gmpz_cmpabs_d (mpz_srcptr, double) __attribute__ ((__pure__));


               int __gmpz_cmpabs_ui (mpz_srcptr, unsigned long int) throw () __attribute__ ((__pure__));


               void __gmpz_com (mpz_ptr, mpz_srcptr);


               void __gmpz_combit (mpz_ptr, mp_bitcnt_t);


               int __gmpz_congruent_p (mpz_srcptr, mpz_srcptr, mpz_srcptr) __attribute__ ((__pure__));


               int __gmpz_congruent_2exp_p (mpz_srcptr, mpz_srcptr, mp_bitcnt_t) throw () __attribute__ ((__pure__));


               int __gmpz_congruent_ui_p (mpz_srcptr, unsigned long, unsigned long) __attribute__ ((__pure__));


               void __gmpz_divexact (mpz_ptr, mpz_srcptr, mpz_srcptr);


               void __gmpz_divexact_ui (mpz_ptr, mpz_srcptr, unsigned long);


               int __gmpz_divisible_p (mpz_srcptr, mpz_srcptr) __attribute__ ((__pure__));


               int __gmpz_divisible_ui_p (mpz_srcptr, unsigned long) __attribute__ ((__pure__));


               int __gmpz_divisible_2exp_p (mpz_srcptr, mp_bitcnt_t) throw () __attribute__ ((__pure__));


               void __gmpz_dump (mpz_srcptr);


               void *__gmpz_export (void *, size_t *, int, size_t, int, size_t, mpz_srcptr);


               void __gmpz_fac_ui (mpz_ptr, unsigned long int);


               void __gmpz_2fac_ui (mpz_ptr, unsigned long int);


               void __gmpz_mfac_uiui (mpz_ptr, unsigned long int, unsigned long int);


               void __gmpz_primorial_ui (mpz_ptr, unsigned long int);


               void __gmpz_fdiv_q (mpz_ptr, mpz_srcptr, mpz_srcptr);


               void __gmpz_fdiv_q_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);


               unsigned long int __gmpz_fdiv_q_ui (mpz_ptr, mpz_srcptr, unsigned long int);


               void __gmpz_fdiv_qr (mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr);


               unsigned long int __gmpz_fdiv_qr_ui (mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long int);


               void __gmpz_fdiv_r (mpz_ptr, mpz_srcptr, mpz_srcptr);


               void __gmpz_fdiv_r_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);


               unsigned long int __gmpz_fdiv_r_ui (mpz_ptr, mpz_srcptr, unsigned long int);


               unsigned long int __gmpz_fdiv_ui (mpz_srcptr, unsigned long int) __attribute__ ((__pure__));


               void __gmpz_fib_ui (mpz_ptr, unsigned long int);


               void __gmpz_fib2_ui (mpz_ptr, mpz_ptr, unsigned long int);


               int __gmpz_fits_sint_p (mpz_srcptr) throw () __attribute__ ((__pure__));


               int __gmpz_fits_slong_p (mpz_srcptr) throw () __attribute__ ((__pure__));


               int __gmpz_fits_sshort_p (mpz_srcptr) throw () __attribute__ ((__pure__));



               int __gmpz_fits_uint_p (mpz_srcptr) throw () __attribute__ ((__pure__));




               int __gmpz_fits_ulong_p (mpz_srcptr) throw () __attribute__ ((__pure__));




               int __gmpz_fits_ushort_p (mpz_srcptr) throw () __attribute__ ((__pure__));



               void __gmpz_gcd (mpz_ptr, mpz_srcptr, mpz_srcptr);


               unsigned long int __gmpz_gcd_ui (mpz_ptr, mpz_srcptr, unsigned long int);


               void __gmpz_gcdext (mpz_ptr, mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr);


               double __gmpz_get_d (mpz_srcptr) __attribute__ ((__pure__));


               double __gmpz_get_d_2exp (signed long int *, mpz_srcptr);


                            long int __gmpz_get_si (mpz_srcptr) throw () __attribute__ ((__pure__));


               char *__gmpz_get_str (char *, int, mpz_srcptr);



               unsigned long int __gmpz_get_ui (mpz_srcptr) throw () __attribute__ ((__pure__));




               mp_limb_t __gmpz_getlimbn (mpz_srcptr, mp_size_t) throw () __attribute__ ((__pure__));



               mp_bitcnt_t __gmpz_hamdist (mpz_srcptr, mpz_srcptr) throw () __attribute__ ((__pure__));


               void __gmpz_import (mpz_ptr, size_t, int, size_t, int, size_t, const void *);


               void __gmpz_init (mpz_ptr);


               void __gmpz_init2 (mpz_ptr, mp_bitcnt_t);


               void __gmpz_inits (mpz_ptr, ...);


               void __gmpz_init_set (mpz_ptr, mpz_srcptr);


               void __gmpz_init_set_d (mpz_ptr, double);


               void __gmpz_init_set_si (mpz_ptr, signed long int);


               int __gmpz_init_set_str (mpz_ptr, const char *, int);


               void __gmpz_init_set_ui (mpz_ptr, unsigned long int);



               size_t __gmpz_inp_raw (mpz_ptr, FILE *);




               size_t __gmpz_inp_str (mpz_ptr, FILE *, int);



               int __gmpz_invert (mpz_ptr, mpz_srcptr, mpz_srcptr);


               void __gmpz_ior (mpz_ptr, mpz_srcptr, mpz_srcptr);


               int __gmpz_jacobi (mpz_srcptr, mpz_srcptr) __attribute__ ((__pure__));




               int __gmpz_kronecker_si (mpz_srcptr, long) __attribute__ ((__pure__));


               int __gmpz_kronecker_ui (mpz_srcptr, unsigned long) __attribute__ ((__pure__));


               int __gmpz_si_kronecker (long, mpz_srcptr) __attribute__ ((__pure__));


               int __gmpz_ui_kronecker (unsigned long, mpz_srcptr) __attribute__ ((__pure__));


               void __gmpz_lcm (mpz_ptr, mpz_srcptr, mpz_srcptr);


               void __gmpz_lcm_ui (mpz_ptr, mpz_srcptr, unsigned long);




               void __gmpz_lucnum_ui (mpz_ptr, unsigned long int);


               void __gmpz_lucnum2_ui (mpz_ptr, mpz_ptr, unsigned long int);


               int __gmpz_millerrabin (mpz_srcptr, int) __attribute__ ((__pure__));


               void __gmpz_mod (mpz_ptr, mpz_srcptr, mpz_srcptr);




               void __gmpz_mul (mpz_ptr, mpz_srcptr, mpz_srcptr);


               void __gmpz_mul_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);


               void __gmpz_mul_si (mpz_ptr, mpz_srcptr, long int);


               void __gmpz_mul_ui (mpz_ptr, mpz_srcptr, unsigned long int);



               void __gmpz_neg (mpz_ptr, mpz_srcptr);



               void __gmpz_nextprime (mpz_ptr, mpz_srcptr);



               size_t __gmpz_out_raw (FILE *, mpz_srcptr);




               size_t __gmpz_out_str (FILE *, int, mpz_srcptr);



               int __gmpz_perfect_power_p (mpz_srcptr) __attribute__ ((__pure__));



               int __gmpz_perfect_square_p (mpz_srcptr) __attribute__ ((__pure__));




               mp_bitcnt_t __gmpz_popcount (mpz_srcptr) throw () __attribute__ ((__pure__));



               void __gmpz_pow_ui (mpz_ptr, mpz_srcptr, unsigned long int);


               void __gmpz_powm (mpz_ptr, mpz_srcptr, mpz_srcptr, mpz_srcptr);


               void __gmpz_powm_sec (mpz_ptr, mpz_srcptr, mpz_srcptr, mpz_srcptr);


               void __gmpz_powm_ui (mpz_ptr, mpz_srcptr, unsigned long int, mpz_srcptr);


               int __gmpz_probab_prime_p (mpz_srcptr, int) __attribute__ ((__pure__));


               void __gmpz_random (mpz_ptr, mp_size_t);


               void __gmpz_random2 (mpz_ptr, mp_size_t);


               void __gmpz_realloc2 (mpz_ptr, mp_bitcnt_t);


               mp_bitcnt_t __gmpz_remove (mpz_ptr, mpz_srcptr, mpz_srcptr);


               int __gmpz_root (mpz_ptr, mpz_srcptr, unsigned long int);


               void __gmpz_rootrem (mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long int);


               void __gmpz_rrandomb (mpz_ptr, gmp_randstate_t, mp_bitcnt_t);


               mp_bitcnt_t __gmpz_scan0 (mpz_srcptr, mp_bitcnt_t) throw () __attribute__ ((__pure__));


               mp_bitcnt_t __gmpz_scan1 (mpz_srcptr, mp_bitcnt_t) throw () __attribute__ ((__pure__));


               void __gmpz_set (mpz_ptr, mpz_srcptr);


               void __gmpz_set_d (mpz_ptr, double);


               void __gmpz_set_f (mpz_ptr, mpf_srcptr);



               void __gmpz_set_q (mpz_ptr, mpq_srcptr);



               void __gmpz_set_si (mpz_ptr, signed long int);


               int __gmpz_set_str (mpz_ptr, const char *, int);


               void __gmpz_set_ui (mpz_ptr, unsigned long int);


               void __gmpz_setbit (mpz_ptr, mp_bitcnt_t);



               size_t __gmpz_size (mpz_srcptr) throw () __attribute__ ((__pure__));



               size_t __gmpz_sizeinbase (mpz_srcptr, int) throw () __attribute__ ((__pure__));


               void __gmpz_sqrt (mpz_ptr, mpz_srcptr);


               void __gmpz_sqrtrem (mpz_ptr, mpz_ptr, mpz_srcptr);


               void __gmpz_sub (mpz_ptr, mpz_srcptr, mpz_srcptr);


               void __gmpz_sub_ui (mpz_ptr, mpz_srcptr, unsigned long int);


               void __gmpz_ui_sub (mpz_ptr, unsigned long int, mpz_srcptr);


               void __gmpz_submul (mpz_ptr, mpz_srcptr, mpz_srcptr);


               void __gmpz_submul_ui (mpz_ptr, mpz_srcptr, unsigned long int);


               void __gmpz_swap (mpz_ptr, mpz_ptr) throw ();


               unsigned long int __gmpz_tdiv_ui (mpz_srcptr, unsigned long int) __attribute__ ((__pure__));


               void __gmpz_tdiv_q (mpz_ptr, mpz_srcptr, mpz_srcptr);


               void __gmpz_tdiv_q_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);


               unsigned long int __gmpz_tdiv_q_ui (mpz_ptr, mpz_srcptr, unsigned long int);


               void __gmpz_tdiv_qr (mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr);


               unsigned long int __gmpz_tdiv_qr_ui (mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long int);


               void __gmpz_tdiv_r (mpz_ptr, mpz_srcptr, mpz_srcptr);


               void __gmpz_tdiv_r_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);


               unsigned long int __gmpz_tdiv_r_ui (mpz_ptr, mpz_srcptr, unsigned long int);


               int __gmpz_tstbit (mpz_srcptr, mp_bitcnt_t) throw () __attribute__ ((__pure__));


               void __gmpz_ui_pow_ui (mpz_ptr, unsigned long int, unsigned long int);


               void __gmpz_urandomb (mpz_ptr, gmp_randstate_t, mp_bitcnt_t);


               void __gmpz_urandomm (mpz_ptr, gmp_randstate_t, mpz_srcptr);



               void __gmpz_xor (mpz_ptr, mpz_srcptr, mpz_srcptr);






               void __gmpq_abs (mpq_ptr, mpq_srcptr);



               void __gmpq_add (mpq_ptr, mpq_srcptr, mpq_srcptr);


               void __gmpq_canonicalize (mpq_ptr);


               void __gmpq_clear (mpq_ptr);


               void __gmpq_clears (mpq_ptr, ...);


               int __gmpq_cmp (mpq_srcptr, mpq_srcptr) __attribute__ ((__pure__));


               int __gmpq_cmp_si (mpq_srcptr, long, unsigned long) __attribute__ ((__pure__));


               int __gmpq_cmp_ui (mpq_srcptr, unsigned long int, unsigned long int) __attribute__ ((__pure__));


               void __gmpq_div (mpq_ptr, mpq_srcptr, mpq_srcptr);


               void __gmpq_div_2exp (mpq_ptr, mpq_srcptr, mp_bitcnt_t);


               int __gmpq_equal (mpq_srcptr, mpq_srcptr) throw () __attribute__ ((__pure__));


               void __gmpq_get_num (mpz_ptr, mpq_srcptr);


               void __gmpq_get_den (mpz_ptr, mpq_srcptr);


               double __gmpq_get_d (mpq_srcptr) __attribute__ ((__pure__));


               char *__gmpq_get_str (char *, int, mpq_srcptr);


               void __gmpq_init (mpq_ptr);


               void __gmpq_inits (mpq_ptr, ...);



               size_t __gmpq_inp_str (mpq_ptr, FILE *, int);



               void __gmpq_inv (mpq_ptr, mpq_srcptr);


               void __gmpq_mul (mpq_ptr, mpq_srcptr, mpq_srcptr);


               void __gmpq_mul_2exp (mpq_ptr, mpq_srcptr, mp_bitcnt_t);



               void __gmpq_neg (mpq_ptr, mpq_srcptr);




               size_t __gmpq_out_str (FILE *, int, mpq_srcptr);



               void __gmpq_set (mpq_ptr, mpq_srcptr);


               void __gmpq_set_d (mpq_ptr, double);


               void __gmpq_set_den (mpq_ptr, mpz_srcptr);


               void __gmpq_set_f (mpq_ptr, mpf_srcptr);


               void __gmpq_set_num (mpq_ptr, mpz_srcptr);


               void __gmpq_set_si (mpq_ptr, signed long int, unsigned long int);


               int __gmpq_set_str (mpq_ptr, const char *, int);


               void __gmpq_set_ui (mpq_ptr, unsigned long int, unsigned long int);


               void __gmpq_set_z (mpq_ptr, mpz_srcptr);


               void __gmpq_sub (mpq_ptr, mpq_srcptr, mpq_srcptr);


               void __gmpq_swap (mpq_ptr, mpq_ptr) throw ();





               void __gmpf_abs (mpf_ptr, mpf_srcptr);


               void __gmpf_add (mpf_ptr, mpf_srcptr, mpf_srcptr);


               void __gmpf_add_ui (mpf_ptr, mpf_srcptr, unsigned long int);

               void __gmpf_ceil (mpf_ptr, mpf_srcptr);


               void __gmpf_clear (mpf_ptr);


               void __gmpf_clears (mpf_ptr, ...);


               int __gmpf_cmp (mpf_srcptr, mpf_srcptr) throw () __attribute__ ((__pure__));


               int __gmpf_cmp_d (mpf_srcptr, double) __attribute__ ((__pure__));


               int __gmpf_cmp_si (mpf_srcptr, signed long int) throw () __attribute__ ((__pure__));


               int __gmpf_cmp_ui (mpf_srcptr, unsigned long int) throw () __attribute__ ((__pure__));


               void __gmpf_div (mpf_ptr, mpf_srcptr, mpf_srcptr);


               void __gmpf_div_2exp (mpf_ptr, mpf_srcptr, mp_bitcnt_t);


               void __gmpf_div_ui (mpf_ptr, mpf_srcptr, unsigned long int);


               void __gmpf_dump (mpf_srcptr);


               int __gmpf_eq (mpf_srcptr, mpf_srcptr, mp_bitcnt_t) __attribute__ ((__pure__));


               int __gmpf_fits_sint_p (mpf_srcptr) throw () __attribute__ ((__pure__));


               int __gmpf_fits_slong_p (mpf_srcptr) throw () __attribute__ ((__pure__));


               int __gmpf_fits_sshort_p (mpf_srcptr) throw () __attribute__ ((__pure__));


               int __gmpf_fits_uint_p (mpf_srcptr) throw () __attribute__ ((__pure__));


               int __gmpf_fits_ulong_p (mpf_srcptr) throw () __attribute__ ((__pure__));


               int __gmpf_fits_ushort_p (mpf_srcptr) throw () __attribute__ ((__pure__));


               void __gmpf_floor (mpf_ptr, mpf_srcptr);


               double __gmpf_get_d (mpf_srcptr) __attribute__ ((__pure__));


               double __gmpf_get_d_2exp (signed long int *, mpf_srcptr);


               mp_bitcnt_t __gmpf_get_default_prec (void) throw () __attribute__ ((__pure__));


               mp_bitcnt_t __gmpf_get_prec (mpf_srcptr) throw () __attribute__ ((__pure__));


               long __gmpf_get_si (mpf_srcptr) throw () __attribute__ ((__pure__));


               char *__gmpf_get_str (char *, mp_exp_t *, int, size_t, mpf_srcptr);


               unsigned long __gmpf_get_ui (mpf_srcptr) throw () __attribute__ ((__pure__));


               void __gmpf_init (mpf_ptr);


               void __gmpf_init2 (mpf_ptr, mp_bitcnt_t);


               void __gmpf_inits (mpf_ptr, ...);


               void __gmpf_init_set (mpf_ptr, mpf_srcptr);


               void __gmpf_init_set_d (mpf_ptr, double);


               void __gmpf_init_set_si (mpf_ptr, signed long int);


               int __gmpf_init_set_str (mpf_ptr, const char *, int);


               void __gmpf_init_set_ui (mpf_ptr, unsigned long int);



               size_t __gmpf_inp_str (mpf_ptr, FILE *, int);



               int __gmpf_integer_p (mpf_srcptr) throw () __attribute__ ((__pure__));


               void __gmpf_mul (mpf_ptr, mpf_srcptr, mpf_srcptr);


               void __gmpf_mul_2exp (mpf_ptr, mpf_srcptr, mp_bitcnt_t);


               void __gmpf_mul_ui (mpf_ptr, mpf_srcptr, unsigned long int);


               void __gmpf_neg (mpf_ptr, mpf_srcptr);



               size_t __gmpf_out_str (FILE *, int, size_t, mpf_srcptr);



               void __gmpf_pow_ui (mpf_ptr, mpf_srcptr, unsigned long int);


               void __gmpf_random2 (mpf_ptr, mp_size_t, mp_exp_t);


               void __gmpf_reldiff (mpf_ptr, mpf_srcptr, mpf_srcptr);


               void __gmpf_set (mpf_ptr, mpf_srcptr);


               void __gmpf_set_d (mpf_ptr, double);


               void __gmpf_set_default_prec (mp_bitcnt_t) throw ();


               void __gmpf_set_prec (mpf_ptr, mp_bitcnt_t);


               void __gmpf_set_prec_raw (mpf_ptr, mp_bitcnt_t) throw ();


               void __gmpf_set_q (mpf_ptr, mpq_srcptr);


               void __gmpf_set_si (mpf_ptr, signed long int);


               int __gmpf_set_str (mpf_ptr, const char *, int);


               void __gmpf_set_ui (mpf_ptr, unsigned long int);


               void __gmpf_set_z (mpf_ptr, mpz_srcptr);


               size_t __gmpf_size (mpf_srcptr) throw () __attribute__ ((__pure__));


               void __gmpf_sqrt (mpf_ptr, mpf_srcptr);


               void __gmpf_sqrt_ui (mpf_ptr, unsigned long int);


               void __gmpf_sub (mpf_ptr, mpf_srcptr, mpf_srcptr);


               void __gmpf_sub_ui (mpf_ptr, mpf_srcptr, unsigned long int);


               void __gmpf_swap (mpf_ptr, mpf_ptr) throw ();


               void __gmpf_trunc (mpf_ptr, mpf_srcptr);


               void __gmpf_ui_div (mpf_ptr, unsigned long int, mpf_srcptr);


               void __gmpf_ui_sub (mpf_ptr, unsigned long int, mpf_srcptr);


               void __gmpf_urandomb (mpf_t, gmp_randstate_t, mp_bitcnt_t);
# 1447 "/usr/include/x86_64-linux-gnu/gmp.h" 3 4
               mp_limb_t __gmpn_add (mp_ptr, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t);




               mp_limb_t __gmpn_add_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t) throw ();



               mp_limb_t __gmpn_add_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);


               mp_limb_t __gmpn_addmul_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t);



               int __gmpn_cmp (mp_srcptr, mp_srcptr, mp_size_t) throw () __attribute__ ((__pure__));






               mp_limb_t __gmpn_divexact_by3c (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t);





               mp_limb_t __gmpn_divrem (mp_ptr, mp_size_t, mp_ptr, mp_size_t, mp_srcptr, mp_size_t);


               mp_limb_t __gmpn_divrem_1 (mp_ptr, mp_size_t, mp_srcptr, mp_size_t, mp_limb_t);


               mp_limb_t __gmpn_divrem_2 (mp_ptr, mp_size_t, mp_ptr, mp_size_t, mp_srcptr);


               mp_limb_t __gmpn_div_qr_2 (mp_ptr, mp_ptr, mp_srcptr, mp_size_t, mp_srcptr);


               mp_size_t __gmpn_gcd (mp_ptr, mp_ptr, mp_size_t, mp_ptr, mp_size_t);


               mp_limb_t __gmpn_gcd_1 (mp_srcptr, mp_size_t, mp_limb_t) __attribute__ ((__pure__));


               mp_limb_t __gmpn_gcdext_1 (mp_limb_signed_t *, mp_limb_signed_t *, mp_limb_t, mp_limb_t);


               mp_size_t __gmpn_gcdext (mp_ptr, mp_ptr, mp_size_t *, mp_ptr, mp_size_t, mp_ptr, mp_size_t);


               size_t __gmpn_get_str (unsigned char *, int, mp_ptr, mp_size_t);


               mp_bitcnt_t __gmpn_hamdist (mp_srcptr, mp_srcptr, mp_size_t) throw () __attribute__ ((__pure__));


               mp_limb_t __gmpn_lshift (mp_ptr, mp_srcptr, mp_size_t, unsigned int);


               mp_limb_t __gmpn_mod_1 (mp_srcptr, mp_size_t, mp_limb_t) __attribute__ ((__pure__));


               mp_limb_t __gmpn_mul (mp_ptr, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t);


               mp_limb_t __gmpn_mul_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t);


               void __gmpn_mul_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);


               void __gmpn_sqr (mp_ptr, mp_srcptr, mp_size_t);



               mp_limb_t __gmpn_neg (mp_ptr, mp_srcptr, mp_size_t);




               void __gmpn_com (mp_ptr, mp_srcptr, mp_size_t);



               int __gmpn_perfect_square_p (mp_srcptr, mp_size_t) __attribute__ ((__pure__));


               int __gmpn_perfect_power_p (mp_srcptr, mp_size_t) __attribute__ ((__pure__));


               mp_bitcnt_t __gmpn_popcount (mp_srcptr, mp_size_t) throw () __attribute__ ((__pure__));


               mp_size_t __gmpn_pow_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t, mp_ptr);



               mp_limb_t __gmpn_preinv_mod_1 (mp_srcptr, mp_size_t, mp_limb_t, mp_limb_t) __attribute__ ((__pure__));


               void __gmpn_random (mp_ptr, mp_size_t);


               void __gmpn_random2 (mp_ptr, mp_size_t);


               mp_limb_t __gmpn_rshift (mp_ptr, mp_srcptr, mp_size_t, unsigned int);


               mp_bitcnt_t __gmpn_scan0 (mp_srcptr, mp_bitcnt_t) __attribute__ ((__pure__));


               mp_bitcnt_t __gmpn_scan1 (mp_srcptr, mp_bitcnt_t) __attribute__ ((__pure__));


               mp_size_t __gmpn_set_str (mp_ptr, const unsigned char *, size_t, int);


               mp_size_t __gmpn_sqrtrem (mp_ptr, mp_ptr, mp_srcptr, mp_size_t);



               mp_limb_t __gmpn_sub (mp_ptr, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t);




               mp_limb_t __gmpn_sub_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t) throw ();



               mp_limb_t __gmpn_sub_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);


               mp_limb_t __gmpn_submul_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t);


               void __gmpn_tdiv_qr (mp_ptr, mp_ptr, mp_size_t, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t);


               void __gmpn_and_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);

               void __gmpn_andn_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);

               void __gmpn_nand_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);

               void __gmpn_ior_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);

               void __gmpn_iorn_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);

               void __gmpn_nior_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);

               void __gmpn_xor_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);

               void __gmpn_xnor_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);


               void __gmpn_copyi (mp_ptr, mp_srcptr, mp_size_t);

               void __gmpn_copyd (mp_ptr, mp_srcptr, mp_size_t);

               void __gmpn_zero (mp_ptr, mp_size_t);
# 1630 "/usr/include/x86_64-linux-gnu/gmp.h" 3 4
extern __inline__ __attribute__ ((__gnu_inline__)) void
__gmpz_abs (mpz_ptr __gmp_w, mpz_srcptr __gmp_u)
{
  if (__gmp_w != __gmp_u)
    __gmpz_set (__gmp_w, __gmp_u);
  __gmp_w->_mp_size = ((__gmp_w->_mp_size) >= 0 ? (__gmp_w->_mp_size) : -(__gmp_w->_mp_size));
}
# 1654 "/usr/include/x86_64-linux-gnu/gmp.h" 3 4
extern __inline__ __attribute__ ((__gnu_inline__))

int
__gmpz_fits_uint_p (mpz_srcptr __gmp_z) throw ()
{
  mp_size_t __gmp_n = __gmp_z->_mp_size; mp_ptr __gmp_p = __gmp_z->_mp_d; return (__gmp_n == 0 || (__gmp_n == 1 && __gmp_p[0] <= (~ (unsigned) 0)));;
}




extern __inline__ __attribute__ ((__gnu_inline__))

int
__gmpz_fits_ulong_p (mpz_srcptr __gmp_z) throw ()
{
  mp_size_t __gmp_n = __gmp_z->_mp_size; mp_ptr __gmp_p = __gmp_z->_mp_d; return (__gmp_n == 0 || (__gmp_n == 1 && __gmp_p[0] <= (~ (unsigned long) 0)));;
}




extern __inline__ __attribute__ ((__gnu_inline__))

int
__gmpz_fits_ushort_p (mpz_srcptr __gmp_z) throw ()
{
  mp_size_t __gmp_n = __gmp_z->_mp_size; mp_ptr __gmp_p = __gmp_z->_mp_d; return (__gmp_n == 0 || (__gmp_n == 1 && __gmp_p[0] <= ((unsigned short) ~0)));;
}




extern __inline__ __attribute__ ((__gnu_inline__))

unsigned long
__gmpz_get_ui (mpz_srcptr __gmp_z) throw ()
{
  mp_ptr __gmp_p = __gmp_z->_mp_d;
  mp_size_t __gmp_n = __gmp_z->_mp_size;
  mp_limb_t __gmp_l = __gmp_p[0];






  return (__gmp_n != 0 ? __gmp_l : 0);
# 1710 "/usr/include/x86_64-linux-gnu/gmp.h" 3 4
}




extern __inline__ __attribute__ ((__gnu_inline__))

mp_limb_t
__gmpz_getlimbn (mpz_srcptr __gmp_z, mp_size_t __gmp_n) throw ()
{
  mp_limb_t __gmp_result = 0;
  if (__builtin_expect ((__gmp_n >= 0 && __gmp_n < ((__gmp_z->_mp_size) >= 0 ? (__gmp_z->_mp_size) : -(__gmp_z->_mp_size))) != 0, 1))
    __gmp_result = __gmp_z->_mp_d[__gmp_n];
  return __gmp_result;
}



extern __inline__ __attribute__ ((__gnu_inline__)) void
__gmpz_neg (mpz_ptr __gmp_w, mpz_srcptr __gmp_u)
{
  if (__gmp_w != __gmp_u)
    __gmpz_set (__gmp_w, __gmp_u);
  __gmp_w->_mp_size = - __gmp_w->_mp_size;
}




extern __inline__ __attribute__ ((__gnu_inline__))

int
__gmpz_perfect_square_p (mpz_srcptr __gmp_a)
{
  mp_size_t __gmp_asize;
  int __gmp_result;

  __gmp_asize = __gmp_a->_mp_size;
  __gmp_result = (__gmp_asize >= 0);
  if (__builtin_expect ((__gmp_asize > 0) != 0, 1))
    __gmp_result = __gmpn_perfect_square_p (__gmp_a->_mp_d, __gmp_asize);
  return __gmp_result;
}




extern __inline__ __attribute__ ((__gnu_inline__))

mp_bitcnt_t
__gmpz_popcount (mpz_srcptr __gmp_u) throw ()
{
  mp_size_t __gmp_usize;
  mp_bitcnt_t __gmp_result;

  __gmp_usize = __gmp_u->_mp_size;
  __gmp_result = (__gmp_usize < 0 ? (~ (unsigned long) 0) : 0);
  if (__builtin_expect ((__gmp_usize > 0) != 0, 1))
    __gmp_result = __gmpn_popcount (__gmp_u->_mp_d, __gmp_usize);
  return __gmp_result;
}




extern __inline__ __attribute__ ((__gnu_inline__))

void
__gmpz_set_q (mpz_ptr __gmp_w, mpq_srcptr __gmp_u)
{
  __gmpz_tdiv_q (__gmp_w, (&((__gmp_u)->_mp_num)), (&((__gmp_u)->_mp_den)));
}




extern __inline__ __attribute__ ((__gnu_inline__))

size_t
__gmpz_size (mpz_srcptr __gmp_z) throw ()
{
  return ((__gmp_z->_mp_size) >= 0 ? (__gmp_z->_mp_size) : -(__gmp_z->_mp_size));
}






extern __inline__ __attribute__ ((__gnu_inline__)) void
__gmpq_abs (mpq_ptr __gmp_w, mpq_srcptr __gmp_u)
{
  if (__gmp_w != __gmp_u)
    __gmpq_set (__gmp_w, __gmp_u);
  __gmp_w->_mp_num._mp_size = ((__gmp_w->_mp_num._mp_size) >= 0 ? (__gmp_w->_mp_num._mp_size) : -(__gmp_w->_mp_num._mp_size));
}



extern __inline__ __attribute__ ((__gnu_inline__)) void
__gmpq_neg (mpq_ptr __gmp_w, mpq_srcptr __gmp_u)
{
  if (__gmp_w != __gmp_u)
    __gmpq_set (__gmp_w, __gmp_u);
  __gmp_w->_mp_num._mp_size = - __gmp_w->_mp_num._mp_size;
}
# 2052 "/usr/include/x86_64-linux-gnu/gmp.h" 3 4
extern __inline__ __attribute__ ((__gnu_inline__))

mp_limb_t
__gmpn_add (mp_ptr __gmp_wp, mp_srcptr __gmp_xp, mp_size_t __gmp_xsize, mp_srcptr __gmp_yp, mp_size_t __gmp_ysize)
{
  mp_limb_t __gmp_c;
  do { mp_size_t __gmp_i; mp_limb_t __gmp_x; __gmp_i = (__gmp_ysize); if (__gmp_i != 0) { if (__gmpn_add_n (__gmp_wp, __gmp_xp, __gmp_yp, __gmp_i)) { do { if (__gmp_i >= (__gmp_xsize)) { (__gmp_c) = 1; goto __gmp_done; } __gmp_x = (__gmp_xp)[__gmp_i]; } while ((((__gmp_wp)[__gmp_i++] = (__gmp_x + 1) & ((~ (static_cast<mp_limb_t> (0))) >> 0)) == 0)); } } if ((__gmp_wp) != (__gmp_xp)) do { mp_size_t __gmp_j; ; for (__gmp_j = (__gmp_i); __gmp_j < (__gmp_xsize); __gmp_j++) (__gmp_wp)[__gmp_j] = (__gmp_xp)[__gmp_j]; } while (0); (__gmp_c) = 0; __gmp_done: ; } while (0);
  return __gmp_c;
}




extern __inline__ __attribute__ ((__gnu_inline__))

mp_limb_t
__gmpn_add_1 (mp_ptr __gmp_dst, mp_srcptr __gmp_src, mp_size_t __gmp_size, mp_limb_t __gmp_n) throw ()
{
  mp_limb_t __gmp_c;
  do { mp_size_t __gmp_i; mp_limb_t __gmp_x, __gmp_r; __gmp_x = (__gmp_src)[0]; __gmp_r = __gmp_x + (__gmp_n); (__gmp_dst)[0] = __gmp_r; if (((__gmp_r) < ((__gmp_n)))) { (__gmp_c) = 1; for (__gmp_i = 1; __gmp_i < (__gmp_size);) { __gmp_x = (__gmp_src)[__gmp_i]; __gmp_r = __gmp_x + 1; (__gmp_dst)[__gmp_i] = __gmp_r; ++__gmp_i; if (!((__gmp_r) < (1))) { if ((__gmp_src) != (__gmp_dst)) do { mp_size_t __gmp_j; ; for (__gmp_j = (__gmp_i); __gmp_j < (__gmp_size); __gmp_j++) (__gmp_dst)[__gmp_j] = (__gmp_src)[__gmp_j]; } while (0); (__gmp_c) = 0; break; } } } else { if ((__gmp_src) != (__gmp_dst)) do { mp_size_t __gmp_j; ; for (__gmp_j = (1); __gmp_j < (__gmp_size); __gmp_j++) (__gmp_dst)[__gmp_j] = (__gmp_src)[__gmp_j]; } while (0); (__gmp_c) = 0; } } while (0);
  return __gmp_c;
}




extern __inline__ __attribute__ ((__gnu_inline__))

int
__gmpn_cmp (mp_srcptr __gmp_xp, mp_srcptr __gmp_yp, mp_size_t __gmp_size) throw ()
{
  int __gmp_result;
  do { mp_size_t __gmp_i; mp_limb_t __gmp_x, __gmp_y; (__gmp_result) = 0; __gmp_i = (__gmp_size); while (--__gmp_i >= 0) { __gmp_x = (__gmp_xp)[__gmp_i]; __gmp_y = (__gmp_yp)[__gmp_i]; if (__gmp_x != __gmp_y) { (__gmp_result) = (__gmp_x > __gmp_y ? 1 : -1); break; } } } while (0);
  return __gmp_result;
}




extern __inline__ __attribute__ ((__gnu_inline__))

mp_limb_t
__gmpn_sub (mp_ptr __gmp_wp, mp_srcptr __gmp_xp, mp_size_t __gmp_xsize, mp_srcptr __gmp_yp, mp_size_t __gmp_ysize)
{
  mp_limb_t __gmp_c;
  do { mp_size_t __gmp_i; mp_limb_t __gmp_x; __gmp_i = (__gmp_ysize); if (__gmp_i != 0) { if (__gmpn_sub_n (__gmp_wp, __gmp_xp, __gmp_yp, __gmp_i)) { do { if (__gmp_i >= (__gmp_xsize)) { (__gmp_c) = 1; goto __gmp_done; } __gmp_x = (__gmp_xp)[__gmp_i]; } while ((((__gmp_wp)[__gmp_i++] = (__gmp_x - 1) & ((~ (static_cast<mp_limb_t> (0))) >> 0)), __gmp_x == 0)); } } if ((__gmp_wp) != (__gmp_xp)) do { mp_size_t __gmp_j; ; for (__gmp_j = (__gmp_i); __gmp_j < (__gmp_xsize); __gmp_j++) (__gmp_wp)[__gmp_j] = (__gmp_xp)[__gmp_j]; } while (0); (__gmp_c) = 0; __gmp_done: ; } while (0);
  return __gmp_c;
}




extern __inline__ __attribute__ ((__gnu_inline__))

mp_limb_t
__gmpn_sub_1 (mp_ptr __gmp_dst, mp_srcptr __gmp_src, mp_size_t __gmp_size, mp_limb_t __gmp_n) throw ()
{
  mp_limb_t __gmp_c;
  do { mp_size_t __gmp_i; mp_limb_t __gmp_x, __gmp_r; __gmp_x = (__gmp_src)[0]; __gmp_r = __gmp_x - (__gmp_n); (__gmp_dst)[0] = __gmp_r; if (((__gmp_x) < ((__gmp_n)))) { (__gmp_c) = 1; for (__gmp_i = 1; __gmp_i < (__gmp_size);) { __gmp_x = (__gmp_src)[__gmp_i]; __gmp_r = __gmp_x - 1; (__gmp_dst)[__gmp_i] = __gmp_r; ++__gmp_i; if (!((__gmp_x) < (1))) { if ((__gmp_src) != (__gmp_dst)) do { mp_size_t __gmp_j; ; for (__gmp_j = (__gmp_i); __gmp_j < (__gmp_size); __gmp_j++) (__gmp_dst)[__gmp_j] = (__gmp_src)[__gmp_j]; } while (0); (__gmp_c) = 0; break; } } } else { if ((__gmp_src) != (__gmp_dst)) do { mp_size_t __gmp_j; ; for (__gmp_j = (1); __gmp_j < (__gmp_size); __gmp_j++) (__gmp_dst)[__gmp_j] = (__gmp_src)[__gmp_j]; } while (0); (__gmp_c) = 0; } } while (0);
  return __gmp_c;
}




extern __inline__ __attribute__ ((__gnu_inline__))

mp_limb_t
__gmpn_neg (mp_ptr __gmp_rp, mp_srcptr __gmp_up, mp_size_t __gmp_n)
{
  mp_limb_t __gmp_ul, __gmp_cy;
  __gmp_cy = 0;
  do {
      __gmp_ul = *__gmp_up++;
      *__gmp_rp++ = -__gmp_ul - __gmp_cy;
      __gmp_cy |= __gmp_ul != 0;
  } while (--__gmp_n != 0);
  return __gmp_cy;
}



}
# 2178 "/usr/include/x86_64-linux-gnu/gmp.h" 3 4
                  std::ostream& operator<< (std::ostream &, mpz_srcptr);
                  std::ostream& operator<< (std::ostream &, mpq_srcptr);
                  std::ostream& operator<< (std::ostream &, mpf_srcptr);
                  std::istream& operator>> (std::istream &, mpz_ptr);
                  std::istream& operator>> (std::istream &, mpq_ptr);
                  std::istream& operator>> (std::istream &, mpf_ptr);
# 2209 "/usr/include/x86_64-linux-gnu/gmp.h" 3 4
enum
{
  GMP_ERROR_NONE = 0,
  GMP_ERROR_UNSUPPORTED_ARGUMENT = 1,
  GMP_ERROR_DIVISION_BY_ZERO = 2,
  GMP_ERROR_SQRT_OF_NEGATIVE = 4,
  GMP_ERROR_INVALID_ARGUMENT = 8
};
# 34 "/usr/include/gmpxx.h" 2 3 4
# 69 "/usr/include/gmpxx.h" 3 4
inline void __mpz_set_ui_safe(mpz_ptr p, unsigned long l)
{
  p->_mp_size = (l != 0);
  p->_mp_d[0] = l & ((~ (static_cast<mp_limb_t> (0))) >> 0);





}

inline void __mpz_set_si_safe(mpz_ptr p, long l)
{
  if(l < 0)
  {
    __mpz_set_ui_safe(p, -static_cast<unsigned long>(l));
    __gmpz_neg(p, p);
  }
  else
    __mpz_set_ui_safe(p, l);

}
# 127 "/usr/include/gmpxx.h" 3 4
inline unsigned long __gmpxx_abs_ui (signed long l)
{
  return l >= 0 ? static_cast<unsigned long>(l)
   : -static_cast<unsigned long>(l);
}







struct __gmp_unary_plus
{
  static void eval(mpz_ptr z, mpz_srcptr w) { __gmpz_set(z, w); }
  static void eval(mpq_ptr q, mpq_srcptr r) { __gmpq_set(q, r); }
  static void eval(mpf_ptr f, mpf_srcptr g) { __gmpf_set(f, g); }
};

struct __gmp_unary_minus
{
  static void eval(mpz_ptr z, mpz_srcptr w) { __gmpz_neg(z, w); }
  static void eval(mpq_ptr q, mpq_srcptr r) { __gmpq_neg(q, r); }
  static void eval(mpf_ptr f, mpf_srcptr g) { __gmpf_neg(f, g); }
};

struct __gmp_unary_com
{
  static void eval(mpz_ptr z, mpz_srcptr w) { __gmpz_com(z, w); }
};

struct __gmp_binary_plus
{
  static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)
  { __gmpz_add(z, w, v); }

  static void eval(mpz_ptr z, mpz_srcptr w, unsigned long int l)
  {


    if (__builtin_constant_p(l) && l == 0)
    {
      if (z != w) __gmpz_set(z, w);
    }
    else
      __gmpz_add_ui(z, w, l);
  }
  static void eval(mpz_ptr z, unsigned long int l, mpz_srcptr w)
  { eval(z, w, l); }
  static void eval(mpz_ptr z, mpz_srcptr w, signed long int l)
  {
    if (l >= 0)
      eval(z, w, static_cast<unsigned long>(l));
    else
      __gmpz_sub_ui(z, w, -static_cast<unsigned long>(l));
  }
  static void eval(mpz_ptr z, signed long int l, mpz_srcptr w)
  { eval(z, w, l); }
  static void eval(mpz_ptr z, mpz_srcptr w, double d)
  { mpz_t temp; mp_limb_t limbs[(2 + 1024 / (64 - 0))]; temp->_mp_d = limbs; temp->_mp_alloc = (2 + 1024 / (64 - 0)); __gmpz_set_d (temp, d); __gmpz_add (z, w, temp); }
  static void eval(mpz_ptr z, double d, mpz_srcptr w)
  { eval(z, w, d); }

  static void eval(mpq_ptr q, mpq_srcptr r, mpq_srcptr s)
  { __gmpq_add(q, r, s); }

  static void eval(mpq_ptr q, mpq_srcptr r, unsigned long int l)
  {
    if (__builtin_constant_p(l) && l == 0)
    {
      if (q != r) __gmpq_set(q, r);
    }
    else
    {
      if (q == r)
        __gmpz_addmul_ui((&((q)->_mp_num)), (&((q)->_mp_den)), l);
      else
      {
        __gmpz_mul_ui((&((q)->_mp_num)), (&((r)->_mp_den)), l);
        __gmpz_add((&((q)->_mp_num)), (&((q)->_mp_num)), (&((r)->_mp_num)));
        __gmpz_set((&((q)->_mp_den)), (&((r)->_mp_den)));
      }
    }
  }
  static void eval(mpq_ptr q, unsigned long int l, mpq_srcptr r)
  { eval(q, r, l); }
  static inline void eval(mpq_ptr q, mpq_srcptr r, signed long int l);

  static void eval(mpq_ptr q, signed long int l, mpq_srcptr r)
  { eval(q, r, l); }
  static void eval(mpq_ptr q, mpq_srcptr r, double d)
  {
    mpq_t temp;
    __gmpq_init(temp);
    __gmpq_set_d(temp, d);
    __gmpq_add(q, r, temp);
    __gmpq_clear(temp);
  }
  static void eval(mpq_ptr q, double d, mpq_srcptr r)
  { eval(q, r, d); }

  static void eval(mpq_ptr q, mpq_srcptr r, mpz_srcptr z)
  {
    if (q == r)
      __gmpz_addmul((&((q)->_mp_num)), (&((q)->_mp_den)), z);
    else
    {
      __gmpz_mul((&((q)->_mp_num)), (&((r)->_mp_den)), z);
      __gmpz_add((&((q)->_mp_num)), (&((q)->_mp_num)), (&((r)->_mp_num)));
      __gmpz_set((&((q)->_mp_den)), (&((r)->_mp_den)));
    }
  }
  static void eval(mpq_ptr q, mpz_srcptr z, mpq_srcptr r)
  { eval(q, r, z); }

  static void eval(mpf_ptr f, mpf_srcptr g, mpf_srcptr h)
  { __gmpf_add(f, g, h); }

  static void eval(mpf_ptr f, mpf_srcptr g, unsigned long int l)
  { __gmpf_add_ui(f, g, l); }
  static void eval(mpf_ptr f, unsigned long int l, mpf_srcptr g)
  { __gmpf_add_ui(f, g, l); }
  static void eval(mpf_ptr f, mpf_srcptr g, signed long int l)
  {
    if (l >= 0)
      __gmpf_add_ui(f, g, l);
    else
      __gmpf_sub_ui(f, g, -static_cast<unsigned long>(l));
  }
  static void eval(mpf_ptr f, signed long int l, mpf_srcptr g)
  { eval(f, g, l); }
  static void eval(mpf_ptr f, mpf_srcptr g, double d)
  {
    mpf_t temp;
    __gmpf_init2(temp, 8*sizeof(double));
    __gmpf_set_d(temp, d);
    __gmpf_add(f, g, temp);
    __gmpf_clear(temp);
  }
  static void eval(mpf_ptr f, double d, mpf_srcptr g)
  { eval(f, g, d); }
};

struct __gmp_binary_minus
{
  static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)
  { __gmpz_sub(z, w, v); }

  static void eval(mpz_ptr z, mpz_srcptr w, unsigned long int l)
  {
    if (__builtin_constant_p(l) && l == 0)
    {
      if (z != w) __gmpz_set(z, w);
    }
    else
      __gmpz_sub_ui(z, w, l);
  }
  static void eval(mpz_ptr z, unsigned long int l, mpz_srcptr w)
  {
    if (__builtin_constant_p(l) && l == 0)
    {
      __gmpz_neg(z, w);
    }
    else
      __gmpz_ui_sub(z, l, w);
  }
  static void eval(mpz_ptr z, mpz_srcptr w, signed long int l)
  {
    if (l >= 0)
      eval(z, w, static_cast<unsigned long>(l));
    else
      __gmpz_add_ui(z, w, -static_cast<unsigned long>(l));
  }
  static void eval(mpz_ptr z, signed long int l, mpz_srcptr w)
  {
    if (l >= 0)
      eval(z, static_cast<unsigned long>(l), w);
    else
      {
        __gmpz_add_ui(z, w, -static_cast<unsigned long>(l));
        __gmpz_neg(z, z);
      }
  }
  static void eval(mpz_ptr z, mpz_srcptr w, double d)
  { mpz_t temp; mp_limb_t limbs[(2 + 1024 / (64 - 0))]; temp->_mp_d = limbs; temp->_mp_alloc = (2 + 1024 / (64 - 0)); __gmpz_set_d (temp, d); __gmpz_sub (z, w, temp); }
  static void eval(mpz_ptr z, double d, mpz_srcptr w)
  { mpz_t temp; mp_limb_t limbs[(2 + 1024 / (64 - 0))]; temp->_mp_d = limbs; temp->_mp_alloc = (2 + 1024 / (64 - 0)); __gmpz_set_d (temp, d); __gmpz_sub (z, temp, w); }

  static void eval(mpq_ptr q, mpq_srcptr r, mpq_srcptr s)
  { __gmpq_sub(q, r, s); }

  static void eval(mpq_ptr q, mpq_srcptr r, unsigned long int l)
  {
    if (__builtin_constant_p(l) && l == 0)
    {
      if (q != r) __gmpq_set(q, r);
    }
    else
    {
      if (q == r)
        __gmpz_submul_ui((&((q)->_mp_num)), (&((q)->_mp_den)), l);
      else
      {
        __gmpz_mul_ui((&((q)->_mp_num)), (&((r)->_mp_den)), l);
        __gmpz_sub((&((q)->_mp_num)), (&((r)->_mp_num)), (&((q)->_mp_num)));
        __gmpz_set((&((q)->_mp_den)), (&((r)->_mp_den)));
      }
    }
  }
  static void eval(mpq_ptr q, unsigned long int l, mpq_srcptr r)
  { eval(q, r, l); __gmpq_neg(q, q); }
  static void eval(mpq_ptr q, mpq_srcptr r, signed long int l)
  {
    if (l >= 0)
      eval(q, r, static_cast<unsigned long>(l));
    else
      __gmp_binary_plus::eval(q, r, -static_cast<unsigned long>(l));
  }
  static void eval(mpq_ptr q, signed long int l, mpq_srcptr r)
  { eval(q, r, l); __gmpq_neg(q, q); }
  static void eval(mpq_ptr q, mpq_srcptr r, double d)
  {
    mpq_t temp;
    __gmpq_init(temp);
    __gmpq_set_d(temp, d);
    __gmpq_sub(q, r, temp);
    __gmpq_clear(temp);
  }
  static void eval(mpq_ptr q, double d, mpq_srcptr r)
  {
    mpq_t temp;
    __gmpq_init(temp);
    __gmpq_set_d(temp, d);
    __gmpq_sub(q, temp, r);
    __gmpq_clear(temp);
  }

  static void eval(mpq_ptr q, mpq_srcptr r, mpz_srcptr z)
  {
    if (q == r)
      __gmpz_submul((&((q)->_mp_num)), (&((q)->_mp_den)), z);
    else
    {
      __gmpz_mul((&((q)->_mp_num)), (&((r)->_mp_den)), z);
      __gmpz_sub((&((q)->_mp_num)), (&((r)->_mp_num)), (&((q)->_mp_num)));
      __gmpz_set((&((q)->_mp_den)), (&((r)->_mp_den)));
    }
  }
  static void eval(mpq_ptr q, mpz_srcptr z, mpq_srcptr r)
  { eval(q, r, z); __gmpq_neg(q, q); }

  static void eval(mpf_ptr f, mpf_srcptr g, mpf_srcptr h)
  { __gmpf_sub(f, g, h); }

  static void eval(mpf_ptr f, mpf_srcptr g, unsigned long int l)
  { __gmpf_sub_ui(f, g, l); }
  static void eval(mpf_ptr f, unsigned long int l, mpf_srcptr g)
  { __gmpf_ui_sub(f, l, g); }
  static void eval(mpf_ptr f, mpf_srcptr g, signed long int l)
  {
    if (l >= 0)
      __gmpf_sub_ui(f, g, l);
    else
      __gmpf_add_ui(f, g, -static_cast<unsigned long>(l));
  }
  static void eval(mpf_ptr f, signed long int l, mpf_srcptr g)
  {
    if (l >= 0)
      __gmpf_sub_ui(f, g, l);
    else
      __gmpf_add_ui(f, g, -static_cast<unsigned long>(l));
    __gmpf_neg(f, f);
  }
  static void eval(mpf_ptr f, mpf_srcptr g, double d)
  {
    mpf_t temp;
    __gmpf_init2(temp, 8*sizeof(double));
    __gmpf_set_d(temp, d);
    __gmpf_sub(f, g, temp);
    __gmpf_clear(temp);
  }
  static void eval(mpf_ptr f, double d, mpf_srcptr g)
  {
    mpf_t temp;
    __gmpf_init2(temp, 8*sizeof(double));
    __gmpf_set_d(temp, d);
    __gmpf_sub(f, temp, g);
    __gmpf_clear(temp);
  }
};


inline void
__gmp_binary_plus::eval(mpq_ptr q, mpq_srcptr r, signed long int l)
{
  if (l >= 0)
    eval(q, r, static_cast<unsigned long>(l));
  else
    __gmp_binary_minus::eval(q, r, -static_cast<unsigned long>(l));
}

struct __gmp_binary_lshift
{
  static void eval(mpz_ptr z, mpz_srcptr w, mp_bitcnt_t l)
  {
    if (__builtin_constant_p(l) && (l == 0))
    {
      if (z != w) __gmpz_set(z, w);
    }
    else
      __gmpz_mul_2exp(z, w, l);
  }
  static void eval(mpq_ptr q, mpq_srcptr r, mp_bitcnt_t l)
  {
    if (__builtin_constant_p(l) && (l == 0))
    {
      if (q != r) __gmpq_set(q, r);
    }
    else
      __gmpq_mul_2exp(q, r, l);
  }
  static void eval(mpf_ptr f, mpf_srcptr g, mp_bitcnt_t l)
  { __gmpf_mul_2exp(f, g, l); }
};

struct __gmp_binary_rshift
{
  static void eval(mpz_ptr z, mpz_srcptr w, mp_bitcnt_t l)
  {
    if (__builtin_constant_p(l) && (l == 0))
    {
      if (z != w) __gmpz_set(z, w);
    }
    else
      __gmpz_fdiv_q_2exp(z, w, l);
  }
  static void eval(mpq_ptr q, mpq_srcptr r, mp_bitcnt_t l)
  {
    if (__builtin_constant_p(l) && (l == 0))
    {
      if (q != r) __gmpq_set(q, r);
    }
    else
      __gmpq_div_2exp(q, r, l);
  }
  static void eval(mpf_ptr f, mpf_srcptr g, mp_bitcnt_t l)
  { __gmpf_div_2exp(f, g, l); }
};

struct __gmp_binary_multiplies
{
  static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)
  { __gmpz_mul(z, w, v); }

  static void eval(mpz_ptr z, mpz_srcptr w, unsigned long int l)
  {


    if (__builtin_constant_p(l) && (l & (l-1)) == 0)
    {
      if (l == 0)
      {
        z->_mp_size = 0;
      }
      else
      {
        __gmp_binary_lshift::eval(z, w, __builtin_ctzl(l));
      }
    }
    else

      __gmpz_mul_ui(z, w, l);
  }
  static void eval(mpz_ptr z, unsigned long int l, mpz_srcptr w)
  { eval(z, w, l); }
  static void eval(mpz_ptr z, mpz_srcptr w, signed long int l)
  {
    if (__builtin_constant_p(l))
    {
      if (l >= 0)
        eval(z, w, static_cast<unsigned long>(l));
      else
      {
        eval(z, w, -static_cast<unsigned long>(l));
 __gmpz_neg(z, z);
      }
    }
    else
      __gmpz_mul_si (z, w, l);
  }
  static void eval(mpz_ptr z, signed long int l, mpz_srcptr w)
  { eval(z, w, l); }
  static void eval(mpz_ptr z, mpz_srcptr w, double d)
  { mpz_t temp; mp_limb_t limbs[(2 + 1024 / (64 - 0))]; temp->_mp_d = limbs; temp->_mp_alloc = (2 + 1024 / (64 - 0)); __gmpz_set_d (temp, d); __gmpz_mul (z, w, temp); }
  static void eval(mpz_ptr z, double d, mpz_srcptr w)
  { eval(z, w, d); }

  static void eval(mpq_ptr q, mpq_srcptr r, mpq_srcptr s)
  { __gmpq_mul(q, r, s); }

  static void eval(mpq_ptr q, mpq_srcptr r, unsigned long int l)
  {

    if (__builtin_constant_p(l) && (l & (l-1)) == 0)
    {
      if (l == 0)
      {
 __gmpq_set_ui(q, 0, 1);
      }
      else
      {
        __gmp_binary_lshift::eval(q, r, __builtin_ctzl(l));
      }
    }
    else

    {
      mpq_t temp; mp_limb_t limbs[1 +1]; (&((temp)->_mp_num))->_mp_d = limbs; __mpz_set_ui_safe ((&((temp)->_mp_num)), l); (&((temp)->_mp_den))->_mp_d = limbs + 1; (&((temp)->_mp_den))->_mp_size = 1; (&((temp)->_mp_den))->_mp_d[0] = 1;
      __gmpq_mul (q, r, temp);
    }
  }
  static void eval(mpq_ptr q, unsigned long int l, mpq_srcptr r)
  { eval(q, r, l); }
  static void eval(mpq_ptr q, mpq_srcptr r, signed long int l)
  {
    if (__builtin_constant_p(l))
    {
      if (l >= 0)
        eval(q, r, static_cast<unsigned long>(l));
      else
      {
        eval(q, r, -static_cast<unsigned long>(l));
 __gmpq_neg(q, q);
      }
    }
    else
    {
      mpq_t temp; mp_limb_t limbs[1 +1]; (&((temp)->_mp_num))->_mp_d = limbs; __mpz_set_si_safe ((&((temp)->_mp_num)), l); (&((temp)->_mp_den))->_mp_d = limbs + 1; (&((temp)->_mp_den))->_mp_size = 1; (&((temp)->_mp_den))->_mp_d[0] = 1;
      __gmpq_mul (q, r, temp);
    }
  }
  static void eval(mpq_ptr q, signed long int l, mpq_srcptr r)
  { eval(q, r, l); }
  static void eval(mpq_ptr q, mpq_srcptr r, double d)
  {
    mpq_t temp;
    __gmpq_init(temp);
    __gmpq_set_d(temp, d);
    __gmpq_mul(q, r, temp);
    __gmpq_clear(temp);
  }
  static void eval(mpq_ptr q, double d, mpq_srcptr r)
  { eval(q, r, d); }

  static void eval(mpf_ptr f, mpf_srcptr g, mpf_srcptr h)
  { __gmpf_mul(f, g, h); }

  static void eval(mpf_ptr f, mpf_srcptr g, unsigned long int l)
  { __gmpf_mul_ui(f, g, l); }
  static void eval(mpf_ptr f, unsigned long int l, mpf_srcptr g)
  { __gmpf_mul_ui(f, g, l); }
  static void eval(mpf_ptr f, mpf_srcptr g, signed long int l)
  {
    if (l >= 0)
      __gmpf_mul_ui(f, g, l);
    else
      {
 __gmpf_mul_ui(f, g, -static_cast<unsigned long>(l));
 __gmpf_neg(f, f);
      }
  }
  static void eval(mpf_ptr f, signed long int l, mpf_srcptr g)
  { eval(f, g, l); }
  static void eval(mpf_ptr f, mpf_srcptr g, double d)
  {
    mpf_t temp;
    __gmpf_init2(temp, 8*sizeof(double));
    __gmpf_set_d(temp, d);
    __gmpf_mul(f, g, temp);
    __gmpf_clear(temp);
  }
  static void eval(mpf_ptr f, double d, mpf_srcptr g)
  { eval(f, g, d); }
};

struct __gmp_binary_divides
{
  static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)
  { __gmpz_tdiv_q(z, w, v); }

  static void eval(mpz_ptr z, mpz_srcptr w, unsigned long int l)
  {


    if (__builtin_constant_p(l) && (l & (l-1)) == 0 && l != 0)
    {
      if (l == 1)
      {
        if (z != w) __gmpz_set(z, w);
      }
      else
        __gmpz_tdiv_q_2exp(z, w, __builtin_ctzl(l));

    }
    else

      __gmpz_tdiv_q_ui(z, w, l);
  }
  static void eval(mpz_ptr z, unsigned long int l, mpz_srcptr w)
  {
    if (((w)->_mp_size < 0 ? -1 : (w)->_mp_size > 0) >= 0)
      {
 if (__gmpz_fits_ulong_p(w))
   __gmpz_set_ui(z, l / __gmpz_get_ui(w));
 else
   __gmpz_set_ui(z, 0);
      }
    else
      {
 __gmpz_neg(z, w);
 if (__gmpz_fits_ulong_p(z))
   {
     __gmpz_set_ui(z, l / __gmpz_get_ui(z));
     __gmpz_neg(z, z);
   }
 else
   __gmpz_set_ui(z, 0);
      }
  }
  static void eval(mpz_ptr z, mpz_srcptr w, signed long int l)
  {
    if (l >= 0)
      eval(z, w, static_cast<unsigned long>(l));
    else
      {
 eval(z, w, -static_cast<unsigned long>(l));
 __gmpz_neg(z, z);
      }
  }
  static void eval(mpz_ptr z, signed long int l, mpz_srcptr w)
  {
    if (__gmpz_fits_slong_p(w))
      __gmpz_set_si(z, l / __gmpz_get_si(w));
    else
      {


        __gmpz_set_si (z, (__gmpz_cmpabs_ui (w, __gmpxx_abs_ui(l)) == 0 ? -1 : 0));
      }
  }
  static void eval(mpz_ptr z, mpz_srcptr w, double d)
  { mpz_t temp; mp_limb_t limbs[(2 + 1024 / (64 - 0))]; temp->_mp_d = limbs; temp->_mp_alloc = (2 + 1024 / (64 - 0)); __gmpz_set_d (temp, d); __gmpz_tdiv_q (z, w, temp); }
  static void eval(mpz_ptr z, double d, mpz_srcptr w)
  { mpz_t temp; mp_limb_t limbs[(2 + 1024 / (64 - 0))]; temp->_mp_d = limbs; temp->_mp_alloc = (2 + 1024 / (64 - 0)); __gmpz_set_d (temp, d); __gmpz_tdiv_q (z, temp, w); }

  static void eval(mpq_ptr q, mpq_srcptr r, mpq_srcptr s)
  { __gmpq_div(q, r, s); }

  static void eval(mpq_ptr q, mpq_srcptr r, unsigned long int l)
  {

    if (__builtin_constant_p(l) && (l & (l-1)) == 0 && l != 0)
      __gmp_binary_rshift::eval(q, r, __builtin_ctzl(l));
    else

    {
      mpq_t temp; mp_limb_t limbs[1 +1]; (&((temp)->_mp_num))->_mp_d = limbs; __mpz_set_ui_safe ((&((temp)->_mp_num)), l); (&((temp)->_mp_den))->_mp_d = limbs + 1; (&((temp)->_mp_den))->_mp_size = 1; (&((temp)->_mp_den))->_mp_d[0] = 1;
      __gmpq_div (q, r, temp);
    }
  }
  static void eval(mpq_ptr q, unsigned long int l, mpq_srcptr r)
  { mpq_t temp; mp_limb_t limbs[1 +1]; (&((temp)->_mp_num))->_mp_d = limbs; __mpz_set_ui_safe ((&((temp)->_mp_num)), l); (&((temp)->_mp_den))->_mp_d = limbs + 1; (&((temp)->_mp_den))->_mp_size = 1; (&((temp)->_mp_den))->_mp_d[0] = 1; __gmpq_div (q, temp, r); }
  static void eval(mpq_ptr q, mpq_srcptr r, signed long int l)
  {
    if (__builtin_constant_p(l))
    {
      if (l >= 0)
        eval(q, r, static_cast<unsigned long>(l));
      else
      {
        eval(q, r, -static_cast<unsigned long>(l));
 __gmpq_neg(q, q);
      }
    }
    else
    {
      mpq_t temp; mp_limb_t limbs[1 +1]; (&((temp)->_mp_num))->_mp_d = limbs; __mpz_set_si_safe ((&((temp)->_mp_num)), l); (&((temp)->_mp_den))->_mp_d = limbs + 1; (&((temp)->_mp_den))->_mp_size = 1; (&((temp)->_mp_den))->_mp_d[0] = 1;
      __gmpq_div (q, r, temp);
    }
  }
  static void eval(mpq_ptr q, signed long int l, mpq_srcptr r)
  { mpq_t temp; mp_limb_t limbs[1 +1]; (&((temp)->_mp_num))->_mp_d = limbs; __mpz_set_si_safe ((&((temp)->_mp_num)), l); (&((temp)->_mp_den))->_mp_d = limbs + 1; (&((temp)->_mp_den))->_mp_size = 1; (&((temp)->_mp_den))->_mp_d[0] = 1; __gmpq_div (q, temp, r); }
  static void eval(mpq_ptr q, mpq_srcptr r, double d)
  {
    mpq_t temp;
    __gmpq_init(temp);
    __gmpq_set_d(temp, d);
    __gmpq_div(q, r, temp);
    __gmpq_clear(temp);
  }
  static void eval(mpq_ptr q, double d, mpq_srcptr r)
  {
    mpq_t temp;
    __gmpq_init(temp);
    __gmpq_set_d(temp, d);
    __gmpq_div(q, temp, r);
    __gmpq_clear(temp);
  }

  static void eval(mpf_ptr f, mpf_srcptr g, mpf_srcptr h)
  { __gmpf_div(f, g, h); }

  static void eval(mpf_ptr f, mpf_srcptr g, unsigned long int l)
  { __gmpf_div_ui(f, g, l); }
  static void eval(mpf_ptr f, unsigned long int l, mpf_srcptr g)
  { __gmpf_ui_div(f, l, g); }
  static void eval(mpf_ptr f, mpf_srcptr g, signed long int l)
  {
    if (l >= 0)
      __gmpf_div_ui(f, g, l);
    else
      {
 __gmpf_div_ui(f, g, -static_cast<unsigned long>(l));
 __gmpf_neg(f, f);
      }
  }
  static void eval(mpf_ptr f, signed long int l, mpf_srcptr g)
  {
    if (l >= 0)
      __gmpf_ui_div(f, l, g);
    else
      {
 __gmpf_ui_div(f, -static_cast<unsigned long>(l), g);
 __gmpf_neg(f, f);
      }
  }
  static void eval(mpf_ptr f, mpf_srcptr g, double d)
  {
    mpf_t temp;
    __gmpf_init2(temp, 8*sizeof(double));
    __gmpf_set_d(temp, d);
    __gmpf_div(f, g, temp);
    __gmpf_clear(temp);
  }
  static void eval(mpf_ptr f, double d, mpf_srcptr g)
  {
    mpf_t temp;
    __gmpf_init2(temp, 8*sizeof(double));
    __gmpf_set_d(temp, d);
    __gmpf_div(f, temp, g);
    __gmpf_clear(temp);
  }
};

struct __gmp_binary_modulus
{
  static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)
  { __gmpz_tdiv_r(z, w, v); }

  static void eval(mpz_ptr z, mpz_srcptr w, unsigned long int l)
  { __gmpz_tdiv_r_ui(z, w, l); }
  static void eval(mpz_ptr z, unsigned long int l, mpz_srcptr w)
  {
    if (((w)->_mp_size < 0 ? -1 : (w)->_mp_size > 0) >= 0)
      {
 if (__gmpz_fits_ulong_p(w))
   __gmpz_set_ui(z, l % __gmpz_get_ui(w));
 else
   __gmpz_set_ui(z, l);
      }
    else
      {
 __gmpz_neg(z, w);
 if (__gmpz_fits_ulong_p(z))
   __gmpz_set_ui(z, l % __gmpz_get_ui(z));
 else
   __gmpz_set_ui(z, l);
      }
  }
  static void eval(mpz_ptr z, mpz_srcptr w, signed long int l)
  {
    __gmpz_tdiv_r_ui (z, w, __gmpxx_abs_ui(l));
  }
  static void eval(mpz_ptr z, signed long int l, mpz_srcptr w)
  {
    if (__gmpz_fits_slong_p(w))
      __gmpz_set_si(z, l % __gmpz_get_si(w));
    else
      {


        __gmpz_set_si (z, __gmpz_cmpabs_ui (w, __gmpxx_abs_ui(l)) == 0 ? 0 : l);
      }
  }
  static void eval(mpz_ptr z, mpz_srcptr w, double d)
  { mpz_t temp; mp_limb_t limbs[(2 + 1024 / (64 - 0))]; temp->_mp_d = limbs; temp->_mp_alloc = (2 + 1024 / (64 - 0)); __gmpz_set_d (temp, d); __gmpz_tdiv_r (z, w, temp); }
  static void eval(mpz_ptr z, double d, mpz_srcptr w)
  { mpz_t temp; mp_limb_t limbs[(2 + 1024 / (64 - 0))]; temp->_mp_d = limbs; temp->_mp_alloc = (2 + 1024 / (64 - 0)); __gmpz_set_d (temp, d); __gmpz_tdiv_r (z, temp, w); }
};

struct __gmp_binary_and
{
  static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)
  { __gmpz_and(z, w, v); }

  static void eval(mpz_ptr z, mpz_srcptr w, unsigned long int l)
  { mpz_t temp; mp_limb_t limbs[1]; temp->_mp_d = limbs; __mpz_set_ui_safe (temp, l); __gmpz_and (z, w, temp); }
  static void eval(mpz_ptr z, unsigned long int l, mpz_srcptr w)
  { eval(z, w, l); }
  static void eval(mpz_ptr z, mpz_srcptr w, signed long int l)
  { mpz_t temp; mp_limb_t limbs[1]; temp->_mp_d = limbs; __mpz_set_si_safe (temp, l); __gmpz_and (z, w, temp); }
  static void eval(mpz_ptr z, signed long int l, mpz_srcptr w)
  { eval(z, w, l); }
  static void eval(mpz_ptr z, mpz_srcptr w, double d)
  { mpz_t temp; mp_limb_t limbs[(2 + 1024 / (64 - 0))]; temp->_mp_d = limbs; temp->_mp_alloc = (2 + 1024 / (64 - 0)); __gmpz_set_d (temp, d); __gmpz_and (z, w, temp); }
  static void eval(mpz_ptr z, double d, mpz_srcptr w)
  { eval(z, w, d); }
};

struct __gmp_binary_ior
{
  static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)
  { __gmpz_ior(z, w, v); }
  static void eval(mpz_ptr z, mpz_srcptr w, unsigned long int l)
  { mpz_t temp; mp_limb_t limbs[1]; temp->_mp_d = limbs; __mpz_set_ui_safe (temp, l); __gmpz_ior (z, w, temp); }
  static void eval(mpz_ptr z, unsigned long int l, mpz_srcptr w)
  { eval(z, w, l); }
  static void eval(mpz_ptr z, mpz_srcptr w, signed long int l)
  { mpz_t temp; mp_limb_t limbs[1]; temp->_mp_d = limbs; __mpz_set_si_safe (temp, l); __gmpz_ior (z, w, temp); }
  static void eval(mpz_ptr z, signed long int l, mpz_srcptr w)
  { eval(z, w, l); }
  static void eval(mpz_ptr z, mpz_srcptr w, double d)
  { mpz_t temp; mp_limb_t limbs[(2 + 1024 / (64 - 0))]; temp->_mp_d = limbs; temp->_mp_alloc = (2 + 1024 / (64 - 0)); __gmpz_set_d (temp, d); __gmpz_ior (z, w, temp); }
  static void eval(mpz_ptr z, double d, mpz_srcptr w)
  { eval(z, w, d); }
};

struct __gmp_binary_xor
{
  static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)
  { __gmpz_xor(z, w, v); }
  static void eval(mpz_ptr z, mpz_srcptr w, unsigned long int l)
  { mpz_t temp; mp_limb_t limbs[1]; temp->_mp_d = limbs; __mpz_set_ui_safe (temp, l); __gmpz_xor (z, w, temp); }
  static void eval(mpz_ptr z, unsigned long int l, mpz_srcptr w)
  { eval(z, w, l); }
  static void eval(mpz_ptr z, mpz_srcptr w, signed long int l)
  { mpz_t temp; mp_limb_t limbs[1]; temp->_mp_d = limbs; __mpz_set_si_safe (temp, l); __gmpz_xor (z, w, temp); }
  static void eval(mpz_ptr z, signed long int l, mpz_srcptr w)
  { eval(z, w, l); }
  static void eval(mpz_ptr z, mpz_srcptr w, double d)
  { mpz_t temp; mp_limb_t limbs[(2 + 1024 / (64 - 0))]; temp->_mp_d = limbs; temp->_mp_alloc = (2 + 1024 / (64 - 0)); __gmpz_set_d (temp, d); __gmpz_xor (z, w, temp); }
  static void eval(mpz_ptr z, double d, mpz_srcptr w)
  { eval(z, w, d); }
};

struct __gmp_binary_equal
{
  static bool eval(mpz_srcptr z, mpz_srcptr w) { return __gmpz_cmp(z, w) == 0; }

  static bool eval(mpz_srcptr z, unsigned long int l)
  { return (__builtin_constant_p (l) && (l) == 0 ? ((z)->_mp_size < 0 ? -1 : (z)->_mp_size > 0) : __gmpz_cmp_ui (z,l)) == 0; }
  static bool eval(unsigned long int l, mpz_srcptr z)
  { return (__builtin_constant_p (l) && (l) == 0 ? ((z)->_mp_size < 0 ? -1 : (z)->_mp_size > 0) : __gmpz_cmp_ui (z,l)) == 0; }
  static bool eval(mpz_srcptr z, signed long int l)
  { return (__builtin_constant_p (l) && (l) == 0 ? ((z)->_mp_size < 0 ? -1 : (z)->_mp_size > 0) : __builtin_constant_p (l) && (l) > 0 ? __gmpz_cmp_ui (z, (static_cast<unsigned long int> (l))) : __gmpz_cmp_si (z,l)) == 0; }
  static bool eval(signed long int l, mpz_srcptr z)
  { return (__builtin_constant_p (l) && (l) == 0 ? ((z)->_mp_size < 0 ? -1 : (z)->_mp_size > 0) : __builtin_constant_p (l) && (l) > 0 ? __gmpz_cmp_ui (z, (static_cast<unsigned long int> (l))) : __gmpz_cmp_si (z,l)) == 0; }
  static bool eval(mpz_srcptr z, double d)
  { return __gmpz_cmp_d(z, d) == 0; }
  static bool eval(double d, mpz_srcptr z)
  { return __gmpz_cmp_d(z, d) == 0; }

  static bool eval(mpq_srcptr q, mpq_srcptr r)
  { return __gmpq_equal(q, r) != 0; }

  static bool eval(mpq_srcptr q, unsigned long int l)
  { return (__builtin_constant_p (l) && (l) == 0 ? ((q)->_mp_num._mp_size < 0 ? -1 : (q)->_mp_num._mp_size > 0) : __gmpq_cmp_ui (q,l,1)) == 0; }
  static bool eval(unsigned long int l, mpq_srcptr q)
  { return (__builtin_constant_p (l) && (l) == 0 ? ((q)->_mp_num._mp_size < 0 ? -1 : (q)->_mp_num._mp_size > 0) : __gmpq_cmp_ui (q,l,1)) == 0; }
  static bool eval(mpq_srcptr q, signed long int l)
  { return (__builtin_constant_p ((l) >= 0) && (l) >= 0 ? (__builtin_constant_p ((static_cast<unsigned long> (l))) && ((static_cast<unsigned long> (l))) == 0 ? ((q)->_mp_num._mp_size < 0 ? -1 : (q)->_mp_num._mp_size > 0) : __gmpq_cmp_ui (q,(static_cast<unsigned long> (l)),1)) : __gmpq_cmp_si (q, l, 1)) == 0; }
  static bool eval(signed long int l, mpq_srcptr q)
  { return (__builtin_constant_p ((l) >= 0) && (l) >= 0 ? (__builtin_constant_p ((static_cast<unsigned long> (l))) && ((static_cast<unsigned long> (l))) == 0 ? ((q)->_mp_num._mp_size < 0 ? -1 : (q)->_mp_num._mp_size > 0) : __gmpq_cmp_ui (q,(static_cast<unsigned long> (l)),1)) : __gmpq_cmp_si (q, l, 1)) == 0; }
  static bool eval(mpq_srcptr q, double d)
  {
    bool b;
    mpq_t temp;
    __gmpq_init(temp);
    __gmpq_set_d(temp, d);
    b = (__gmpq_equal(q, temp) != 0);
    __gmpq_clear(temp);
    return b;
  }
  static bool eval(double d, mpq_srcptr q)
  {
    return eval(q, d);
  }

  static bool eval(mpf_srcptr f, mpf_srcptr g) { return __gmpf_cmp(f, g) == 0; }

  static bool eval(mpf_srcptr f, unsigned long int l)
  { return __gmpf_cmp_ui(f, l) == 0; }
  static bool eval(unsigned long int l, mpf_srcptr f)
  { return __gmpf_cmp_ui(f, l) == 0; }
  static bool eval(mpf_srcptr f, signed long int l)
  { return __gmpf_cmp_si(f, l) == 0; }
  static bool eval(signed long int l, mpf_srcptr f)
  { return __gmpf_cmp_si(f, l) == 0; }
  static bool eval(mpf_srcptr f, double d)
  { return __gmpf_cmp_d(f, d) == 0; }
  static bool eval(double d, mpf_srcptr f)
  { return __gmpf_cmp_d(f, d) == 0; }
};

struct __gmp_binary_less
{
  static bool eval(mpz_srcptr z, mpz_srcptr w) { return __gmpz_cmp(z, w) < 0; }

  static bool eval(mpz_srcptr z, unsigned long int l)
  { return (__builtin_constant_p (l) && (l) == 0 ? ((z)->_mp_size < 0 ? -1 : (z)->_mp_size > 0) : __gmpz_cmp_ui (z,l)) < 0; }
  static bool eval(unsigned long int l, mpz_srcptr z)
  { return (__builtin_constant_p (l) && (l) == 0 ? ((z)->_mp_size < 0 ? -1 : (z)->_mp_size > 0) : __gmpz_cmp_ui (z,l)) > 0; }
  static bool eval(mpz_srcptr z, signed long int l)
  { return (__builtin_constant_p (l) && (l) == 0 ? ((z)->_mp_size < 0 ? -1 : (z)->_mp_size > 0) : __builtin_constant_p (l) && (l) > 0 ? __gmpz_cmp_ui (z, (static_cast<unsigned long int> (l))) : __gmpz_cmp_si (z,l)) < 0; }
  static bool eval(signed long int l, mpz_srcptr z)
  { return (__builtin_constant_p (l) && (l) == 0 ? ((z)->_mp_size < 0 ? -1 : (z)->_mp_size > 0) : __builtin_constant_p (l) && (l) > 0 ? __gmpz_cmp_ui (z, (static_cast<unsigned long int> (l))) : __gmpz_cmp_si (z,l)) > 0; }
  static bool eval(mpz_srcptr z, double d)
  { return __gmpz_cmp_d(z, d) < 0; }
  static bool eval(double d, mpz_srcptr z)
  { return __gmpz_cmp_d(z, d) > 0; }

  static bool eval(mpq_srcptr q, mpq_srcptr r) { return __gmpq_cmp(q, r) < 0; }

  static bool eval(mpq_srcptr q, unsigned long int l)
  { return (__builtin_constant_p (l) && (l) == 0 ? ((q)->_mp_num._mp_size < 0 ? -1 : (q)->_mp_num._mp_size > 0) : __gmpq_cmp_ui (q,l,1)) < 0; }
  static bool eval(unsigned long int l, mpq_srcptr q)
  { return (__builtin_constant_p (l) && (l) == 0 ? ((q)->_mp_num._mp_size < 0 ? -1 : (q)->_mp_num._mp_size > 0) : __gmpq_cmp_ui (q,l,1)) > 0; }
  static bool eval(mpq_srcptr q, signed long int l)
  { return (__builtin_constant_p ((l) >= 0) && (l) >= 0 ? (__builtin_constant_p ((static_cast<unsigned long> (l))) && ((static_cast<unsigned long> (l))) == 0 ? ((q)->_mp_num._mp_size < 0 ? -1 : (q)->_mp_num._mp_size > 0) : __gmpq_cmp_ui (q,(static_cast<unsigned long> (l)),1)) : __gmpq_cmp_si (q, l, 1)) < 0; }
  static bool eval(signed long int l, mpq_srcptr q)
  { return (__builtin_constant_p ((l) >= 0) && (l) >= 0 ? (__builtin_constant_p ((static_cast<unsigned long> (l))) && ((static_cast<unsigned long> (l))) == 0 ? ((q)->_mp_num._mp_size < 0 ? -1 : (q)->_mp_num._mp_size > 0) : __gmpq_cmp_ui (q,(static_cast<unsigned long> (l)),1)) : __gmpq_cmp_si (q, l, 1)) > 0; }
  static bool eval(mpq_srcptr q, double d)
  {
    bool b;
    mpq_t temp;
    __gmpq_init(temp);
    __gmpq_set_d(temp, d);
    b = (__gmpq_cmp(q, temp) < 0);
    __gmpq_clear(temp);
    return b;
  }
  static bool eval(double d, mpq_srcptr q)
  {
    bool b;
    mpq_t temp;
    __gmpq_init(temp);
    __gmpq_set_d(temp, d);
    b = (__gmpq_cmp(temp, q) < 0);
    __gmpq_clear(temp);
    return b;
  }

  static bool eval(mpf_srcptr f, mpf_srcptr g) { return __gmpf_cmp(f, g) < 0; }

  static bool eval(mpf_srcptr f, unsigned long int l)
  { return __gmpf_cmp_ui(f, l) < 0; }
  static bool eval(unsigned long int l, mpf_srcptr f)
  { return __gmpf_cmp_ui(f, l) > 0; }
  static bool eval(mpf_srcptr f, signed long int l)
  { return __gmpf_cmp_si(f, l) < 0; }
  static bool eval(signed long int l, mpf_srcptr f)
  { return __gmpf_cmp_si(f, l) > 0; }
  static bool eval(mpf_srcptr f, double d)
  { return __gmpf_cmp_d(f, d) < 0; }
  static bool eval(double d, mpf_srcptr f)
  { return __gmpf_cmp_d(f, d) > 0; }
};

struct __gmp_binary_greater
{
  static bool eval(mpz_srcptr z, mpz_srcptr w) { return __gmpz_cmp(z, w) > 0; }

  static bool eval(mpz_srcptr z, unsigned long int l)
  { return (__builtin_constant_p (l) && (l) == 0 ? ((z)->_mp_size < 0 ? -1 : (z)->_mp_size > 0) : __gmpz_cmp_ui (z,l)) > 0; }
  static bool eval(unsigned long int l, mpz_srcptr z)
  { return (__builtin_constant_p (l) && (l) == 0 ? ((z)->_mp_size < 0 ? -1 : (z)->_mp_size > 0) : __gmpz_cmp_ui (z,l)) < 0; }
  static bool eval(mpz_srcptr z, signed long int l)
  { return (__builtin_constant_p (l) && (l) == 0 ? ((z)->_mp_size < 0 ? -1 : (z)->_mp_size > 0) : __builtin_constant_p (l) && (l) > 0 ? __gmpz_cmp_ui (z, (static_cast<unsigned long int> (l))) : __gmpz_cmp_si (z,l)) > 0; }
  static bool eval(signed long int l, mpz_srcptr z)
  { return (__builtin_constant_p (l) && (l) == 0 ? ((z)->_mp_size < 0 ? -1 : (z)->_mp_size > 0) : __builtin_constant_p (l) && (l) > 0 ? __gmpz_cmp_ui (z, (static_cast<unsigned long int> (l))) : __gmpz_cmp_si (z,l)) < 0; }
  static bool eval(mpz_srcptr z, double d)
  { return __gmpz_cmp_d(z, d) > 0; }
  static bool eval(double d, mpz_srcptr z)
  { return __gmpz_cmp_d(z, d) < 0; }

  static bool eval(mpq_srcptr q, mpq_srcptr r) { return __gmpq_cmp(q, r) > 0; }

  static bool eval(mpq_srcptr q, unsigned long int l)
  { return (__builtin_constant_p (l) && (l) == 0 ? ((q)->_mp_num._mp_size < 0 ? -1 : (q)->_mp_num._mp_size > 0) : __gmpq_cmp_ui (q,l,1)) > 0; }
  static bool eval(unsigned long int l, mpq_srcptr q)
  { return (__builtin_constant_p (l) && (l) == 0 ? ((q)->_mp_num._mp_size < 0 ? -1 : (q)->_mp_num._mp_size > 0) : __gmpq_cmp_ui (q,l,1)) < 0; }
  static bool eval(mpq_srcptr q, signed long int l)
  { return (__builtin_constant_p ((l) >= 0) && (l) >= 0 ? (__builtin_constant_p ((static_cast<unsigned long> (l))) && ((static_cast<unsigned long> (l))) == 0 ? ((q)->_mp_num._mp_size < 0 ? -1 : (q)->_mp_num._mp_size > 0) : __gmpq_cmp_ui (q,(static_cast<unsigned long> (l)),1)) : __gmpq_cmp_si (q, l, 1)) > 0; }
  static bool eval(signed long int l, mpq_srcptr q)
  { return (__builtin_constant_p ((l) >= 0) && (l) >= 0 ? (__builtin_constant_p ((static_cast<unsigned long> (l))) && ((static_cast<unsigned long> (l))) == 0 ? ((q)->_mp_num._mp_size < 0 ? -1 : (q)->_mp_num._mp_size > 0) : __gmpq_cmp_ui (q,(static_cast<unsigned long> (l)),1)) : __gmpq_cmp_si (q, l, 1)) < 0; }
  static bool eval(mpq_srcptr q, double d)
  {
    bool b;
    mpq_t temp;
    __gmpq_init(temp);
    __gmpq_set_d(temp, d);
    b = (__gmpq_cmp(q, temp) > 0);
    __gmpq_clear(temp);
    return b;
  }
  static bool eval(double d, mpq_srcptr q)
  {
    bool b;
    mpq_t temp;
    __gmpq_init(temp);
    __gmpq_set_d(temp, d);
    b = (__gmpq_cmp(temp, q) > 0);
    __gmpq_clear(temp);
    return b;
  }

  static bool eval(mpf_srcptr f, mpf_srcptr g) { return __gmpf_cmp(f, g) > 0; }

  static bool eval(mpf_srcptr f, unsigned long int l)
  { return __gmpf_cmp_ui(f, l) > 0; }
  static bool eval(unsigned long int l, mpf_srcptr f)
  { return __gmpf_cmp_ui(f, l) < 0; }
  static bool eval(mpf_srcptr f, signed long int l)
  { return __gmpf_cmp_si(f, l) > 0; }
  static bool eval(signed long int l, mpf_srcptr f)
  { return __gmpf_cmp_si(f, l) < 0; }
  static bool eval(mpf_srcptr f, double d)
  { return __gmpf_cmp_d(f, d) > 0; }
  static bool eval(double d, mpf_srcptr f)
  { return __gmpf_cmp_d(f, d) < 0; }
};

struct __gmp_unary_increment
{
  static void eval(mpz_ptr z) { __gmpz_add_ui(z, z, 1); }
  static void eval(mpq_ptr q)
  { __gmpz_add((&((q)->_mp_num)), (&((q)->_mp_num)), (&((q)->_mp_den))); }
  static void eval(mpf_ptr f) { __gmpf_add_ui(f, f, 1); }
};

struct __gmp_unary_decrement
{
  static void eval(mpz_ptr z) { __gmpz_sub_ui(z, z, 1); }
  static void eval(mpq_ptr q)
  { __gmpz_sub((&((q)->_mp_num)), (&((q)->_mp_num)), (&((q)->_mp_den))); }
  static void eval(mpf_ptr f) { __gmpf_sub_ui(f, f, 1); }
};

struct __gmp_abs_function
{
  static void eval(mpz_ptr z, mpz_srcptr w) { __gmpz_abs(z, w); }
  static void eval(mpq_ptr q, mpq_srcptr r) { __gmpq_abs(q, r); }
  static void eval(mpf_ptr f, mpf_srcptr g) { __gmpf_abs(f, g); }
};

struct __gmp_trunc_function
{
  static void eval(mpf_ptr f, mpf_srcptr g) { __gmpf_trunc(f, g); }
};

struct __gmp_floor_function
{
  static void eval(mpf_ptr f, mpf_srcptr g) { __gmpf_floor(f, g); }
};

struct __gmp_ceil_function
{
  static void eval(mpf_ptr f, mpf_srcptr g) { __gmpf_ceil(f, g); }
};

struct __gmp_sqrt_function
{
  static void eval(mpz_ptr z, mpz_srcptr w) { __gmpz_sqrt(z, w); }
  static void eval(mpf_ptr f, mpf_srcptr g) { __gmpf_sqrt(f, g); }
};

struct __gmp_hypot_function
{
  static void eval(mpf_ptr f, mpf_srcptr g, mpf_srcptr h)
  {
    mpf_t temp;
    __gmpf_init2(temp, __gmpf_get_prec(f));
    __gmpf_mul(temp, g, g);
    __gmpf_mul(f, h, h);
    __gmpf_add(f, f, temp);
    __gmpf_sqrt(f, f);
    __gmpf_clear(temp);
  }

  static void eval(mpf_ptr f, mpf_srcptr g, unsigned long int l)
  {
    mpf_t temp;
    __gmpf_init2(temp, __gmpf_get_prec(f));
    __gmpf_mul(temp, g, g);
    __gmpf_set_ui(f, l);
    __gmpf_mul(f, f, f);
    __gmpf_add(f, f, temp);
    __gmpf_sqrt(f, f);
    __gmpf_clear(temp);
  }
  static void eval(mpf_ptr f, unsigned long int l, mpf_srcptr g)
  { eval(f, g, l); }
  static void eval(mpf_ptr f, mpf_srcptr g, signed long int l)
  {
    mpf_t temp;
    __gmpf_init2(temp, __gmpf_get_prec(f));
    __gmpf_mul(temp, g, g);
    __gmpf_set_si(f, l);
    __gmpf_mul(f, f, f);
    __gmpf_add(f, f, temp);
    __gmpf_sqrt(f, f);
    __gmpf_clear(temp);
  }
  static void eval(mpf_ptr f, signed long int l, mpf_srcptr g)
  { eval(f, g, l); }
  static void eval(mpf_ptr f, mpf_srcptr g, double d)
  {
    mpf_t temp;
    __gmpf_init2(temp, __gmpf_get_prec(f));
    __gmpf_mul(temp, g, g);
    __gmpf_set_d(f, d);
    __gmpf_mul(f, f, f);
    __gmpf_add(f, f, temp);
    __gmpf_sqrt(f, f);
    __gmpf_clear(temp);
  }
  static void eval(mpf_ptr f, double d, mpf_srcptr g)
  { eval(f, g, d); }
};

struct __gmp_sgn_function
{
  static int eval(mpz_srcptr z) { return ((z)->_mp_size < 0 ? -1 : (z)->_mp_size > 0); }
  static int eval(mpq_srcptr q) { return ((q)->_mp_num._mp_size < 0 ? -1 : (q)->_mp_num._mp_size > 0); }
  static int eval(mpf_srcptr f) { return ((f)->_mp_size < 0 ? -1 : (f)->_mp_size > 0); }
};

struct __gmp_cmp_function
{
  static int eval(mpz_srcptr z, mpz_srcptr w) { return __gmpz_cmp(z, w); }

  static int eval(mpz_srcptr z, unsigned long int l)
  { return (__builtin_constant_p (l) && (l) == 0 ? ((z)->_mp_size < 0 ? -1 : (z)->_mp_size > 0) : __gmpz_cmp_ui (z,l)); }
  static int eval(unsigned long int l, mpz_srcptr z)
  { return -(__builtin_constant_p (l) && (l) == 0 ? ((z)->_mp_size < 0 ? -1 : (z)->_mp_size > 0) : __gmpz_cmp_ui (z,l)); }
  static int eval(mpz_srcptr z, signed long int l)
  { return (__builtin_constant_p (l) && (l) == 0 ? ((z)->_mp_size < 0 ? -1 : (z)->_mp_size > 0) : __builtin_constant_p (l) && (l) > 0 ? __gmpz_cmp_ui (z, (static_cast<unsigned long int> (l))) : __gmpz_cmp_si (z,l)); }
  static int eval(signed long int l, mpz_srcptr z)
  { return -(__builtin_constant_p (l) && (l) == 0 ? ((z)->_mp_size < 0 ? -1 : (z)->_mp_size > 0) : __builtin_constant_p (l) && (l) > 0 ? __gmpz_cmp_ui (z, (static_cast<unsigned long int> (l))) : __gmpz_cmp_si (z,l)); }
  static int eval(mpz_srcptr z, double d)
  { return __gmpz_cmp_d(z, d); }
  static int eval(double d, mpz_srcptr z)
  { return -__gmpz_cmp_d(z, d); }

  static int eval(mpq_srcptr q, mpq_srcptr r) { return __gmpq_cmp(q, r); }

  static int eval(mpq_srcptr q, unsigned long int l)
  { return (__builtin_constant_p (l) && (l) == 0 ? ((q)->_mp_num._mp_size < 0 ? -1 : (q)->_mp_num._mp_size > 0) : __gmpq_cmp_ui (q,l,1)); }
  static int eval(unsigned long int l, mpq_srcptr q)
  { return -(__builtin_constant_p (l) && (l) == 0 ? ((q)->_mp_num._mp_size < 0 ? -1 : (q)->_mp_num._mp_size > 0) : __gmpq_cmp_ui (q,l,1)); }
  static int eval(mpq_srcptr q, signed long int l)
  { return (__builtin_constant_p ((l) >= 0) && (l) >= 0 ? (__builtin_constant_p ((static_cast<unsigned long> (l))) && ((static_cast<unsigned long> (l))) == 0 ? ((q)->_mp_num._mp_size < 0 ? -1 : (q)->_mp_num._mp_size > 0) : __gmpq_cmp_ui (q,(static_cast<unsigned long> (l)),1)) : __gmpq_cmp_si (q, l, 1)); }
  static int eval(signed long int l, mpq_srcptr q)
  { return -(__builtin_constant_p ((l) >= 0) && (l) >= 0 ? (__builtin_constant_p ((static_cast<unsigned long> (l))) && ((static_cast<unsigned long> (l))) == 0 ? ((q)->_mp_num._mp_size < 0 ? -1 : (q)->_mp_num._mp_size > 0) : __gmpq_cmp_ui (q,(static_cast<unsigned long> (l)),1)) : __gmpq_cmp_si (q, l, 1)); }
  static int eval(mpq_srcptr q, double d)
  {
    int i;
    mpq_t temp;
    __gmpq_init(temp);
    __gmpq_set_d(temp, d);
    i = __gmpq_cmp(q, temp);
    __gmpq_clear(temp);
    return i;
  }
  static int eval(double d, mpq_srcptr q)
  {
    int i;
    mpq_t temp;
    __gmpq_init(temp);
    __gmpq_set_d(temp, d);
    i = __gmpq_cmp(temp, q);
    __gmpq_clear(temp);
    return i;
  }

  static int eval(mpf_srcptr f, mpf_srcptr g) { return __gmpf_cmp(f, g); }

  static int eval(mpf_srcptr f, unsigned long int l)
  { return __gmpf_cmp_ui(f, l); }
  static int eval(unsigned long int l, mpf_srcptr f)
  { return -__gmpf_cmp_ui(f, l); }
  static int eval(mpf_srcptr f, signed long int l)
  { return __gmpf_cmp_si(f, l); }
  static int eval(signed long int l, mpf_srcptr f)
  { return -__gmpf_cmp_si(f, l); }
  static int eval(mpf_srcptr f, double d)
  { return __gmpf_cmp_d(f, d); }
  static int eval(double d, mpf_srcptr f)
  { return -__gmpf_cmp_d(f, d); }
};

struct __gmp_rand_function
{
  static void eval(mpz_ptr z, gmp_randstate_t s, mp_bitcnt_t l)
  { __gmpz_urandomb(z, s, l); }
  static void eval(mpz_ptr z, gmp_randstate_t s, mpz_srcptr w)
  { __gmpz_urandomm(z, s, w); }
  static void eval(mpf_ptr f, gmp_randstate_t s, mp_bitcnt_t prec)
  { __gmpf_urandomb(f, s, prec); }
};
# 1255 "/usr/include/gmpxx.h" 3 4
extern "C" {
  typedef void (*__gmp_freefunc_t) (void *, size_t);
}
struct __gmp_alloc_cstring
{
  char *str;
  __gmp_alloc_cstring(char *s) { str = s; }
  ~__gmp_alloc_cstring()
  {
    __gmp_freefunc_t freefunc;
    __gmp_get_memory_functions (__null, __null, &freefunc);
    (*freefunc) (str, std::strlen(str)+1);
  }
};



template <class T, class U>
class __gmp_expr;



template <class T>
struct __gmp_resolve_ref
{
  typedef T ref_type;
};

template <class T, class U>
struct __gmp_resolve_ref<__gmp_expr<T, U> >
{
  typedef const __gmp_expr<T, U> & ref_type;
};


template <class T, class U = T>
struct __gmp_resolve_expr;

template <>
struct __gmp_resolve_expr<mpz_t>
{
  typedef mpz_t value_type;
  typedef mpz_ptr ptr_type;
  typedef mpz_srcptr srcptr_type;
};

template <>
struct __gmp_resolve_expr<mpq_t>
{
  typedef mpq_t value_type;
  typedef mpq_ptr ptr_type;
  typedef mpq_srcptr srcptr_type;
};

template <>
struct __gmp_resolve_expr<mpf_t>
{
  typedef mpf_t value_type;
  typedef mpf_ptr ptr_type;
  typedef mpf_srcptr srcptr_type;
};

template <>
struct __gmp_resolve_expr<mpz_t, mpq_t>
{
  typedef mpq_t value_type;
};

template <>
struct __gmp_resolve_expr<mpq_t, mpz_t>
{
  typedef mpq_t value_type;
};

template <>
struct __gmp_resolve_expr<mpz_t, mpf_t>
{
  typedef mpf_t value_type;
};

template <>
struct __gmp_resolve_expr<mpf_t, mpz_t>
{
  typedef mpf_t value_type;
};

template <>
struct __gmp_resolve_expr<mpq_t, mpf_t>
{
  typedef mpf_t value_type;
};

template <>
struct __gmp_resolve_expr<mpf_t, mpq_t>
{
  typedef mpf_t value_type;
};


namespace std {
  template <class T, class U, class V, class W>
  struct common_type <__gmp_expr<T, U>, __gmp_expr<V, W> >
  {
  private:
    typedef typename __gmp_resolve_expr<T, V>::value_type X;
  public:
    typedef __gmp_expr<X, X> type;
  };

  template <class T, class U>
  struct common_type <__gmp_expr<T, U>, __gmp_expr<T, U> >
  {
    typedef __gmp_expr<T, U> type;
  };
# 1383 "/usr/include/gmpxx.h" 3 4
  template <class T, class U> struct common_type <__gmp_expr<T, U>, signed char > { typedef __gmp_expr<T, T> type; }; template <class T, class U> struct common_type <signed char, __gmp_expr<T, U> > { typedef __gmp_expr<T, T> type; };
  template <class T, class U> struct common_type <__gmp_expr<T, U>, unsigned char > { typedef __gmp_expr<T, T> type; }; template <class T, class U> struct common_type <unsigned char, __gmp_expr<T, U> > { typedef __gmp_expr<T, T> type; };
  template <class T, class U> struct common_type <__gmp_expr<T, U>, signed int > { typedef __gmp_expr<T, T> type; }; template <class T, class U> struct common_type <signed int, __gmp_expr<T, U> > { typedef __gmp_expr<T, T> type; };
  template <class T, class U> struct common_type <__gmp_expr<T, U>, unsigned int > { typedef __gmp_expr<T, T> type; }; template <class T, class U> struct common_type <unsigned int, __gmp_expr<T, U> > { typedef __gmp_expr<T, T> type; };
  template <class T, class U> struct common_type <__gmp_expr<T, U>, signed short int > { typedef __gmp_expr<T, T> type; }; template <class T, class U> struct common_type <signed short int, __gmp_expr<T, U> > { typedef __gmp_expr<T, T> type; };
  template <class T, class U> struct common_type <__gmp_expr<T, U>, unsigned short int > { typedef __gmp_expr<T, T> type; }; template <class T, class U> struct common_type <unsigned short int, __gmp_expr<T, U> > { typedef __gmp_expr<T, T> type; };
  template <class T, class U> struct common_type <__gmp_expr<T, U>, signed long int > { typedef __gmp_expr<T, T> type; }; template <class T, class U> struct common_type <signed long int, __gmp_expr<T, U> > { typedef __gmp_expr<T, T> type; };
  template <class T, class U> struct common_type <__gmp_expr<T, U>, unsigned long int > { typedef __gmp_expr<T, T> type; }; template <class T, class U> struct common_type <unsigned long int, __gmp_expr<T, U> > { typedef __gmp_expr<T, T> type; };
  template <class T, class U> struct common_type <__gmp_expr<T, U>, float > { typedef __gmp_expr<T, T> type; }; template <class T, class U> struct common_type <float, __gmp_expr<T, U> > { typedef __gmp_expr<T, T> type; };
  template <class T, class U> struct common_type <__gmp_expr<T, U>, double > { typedef __gmp_expr<T, T> type; }; template <class T, class U> struct common_type <double, __gmp_expr<T, U> > { typedef __gmp_expr<T, T> type; };

}



template <class T, class Op>
struct __gmp_unary_expr
{
  const T &val;

  __gmp_unary_expr(const T &v) : val(v) { }
private:
  __gmp_unary_expr();
};

template <class T, class U, class Op>
struct __gmp_binary_expr
{
  typename __gmp_resolve_ref<T>::ref_type val1;
  typename __gmp_resolve_ref<U>::ref_type val2;

  __gmp_binary_expr(const T &v1, const U &v2) : val1(v1), val2(v2) { }
private:
  __gmp_binary_expr();
};
# 1456 "/usr/include/gmpxx.h" 3 4
template <>
class __gmp_expr<mpz_t, mpz_t>
{
private:
  typedef mpz_t value_type;
  value_type mp;
public:
  mp_bitcnt_t get_prec() const { return __gmpf_get_default_prec(); }


  __gmp_expr() { __gmpz_init(mp); }

  __gmp_expr(const __gmp_expr &z) { __gmpz_init_set(mp, z.mp); }

  __gmp_expr(__gmp_expr &&z)
  { *mp = *z.mp; __gmpz_init(z.mp); }

  template <class T>
  __gmp_expr(const __gmp_expr<mpz_t, T> &expr)
  { __gmpz_init(mp); __gmp_set_expr(mp, expr); }
  template <class T, class U>
  explicit __gmp_expr(const __gmp_expr<T, U> &expr)
  { __gmpz_init(mp); __gmp_set_expr(mp, expr); }

  __gmp_expr(signed char c) { __gmpz_init_set_si(mp, c); }
  __gmp_expr(unsigned char c) { __gmpz_init_set_ui(mp, c); }

  __gmp_expr(signed int i) { __gmpz_init_set_si(mp, i); }
  __gmp_expr(unsigned int i) { __gmpz_init_set_ui(mp, i); }

  __gmp_expr(signed short int s) { __gmpz_init_set_si(mp, s); }
  __gmp_expr(unsigned short int s) { __gmpz_init_set_ui(mp, s); }

  __gmp_expr(signed long int l) { __gmpz_init_set_si(mp, l); }
  __gmp_expr(unsigned long int l) { __gmpz_init_set_ui(mp, l); }

  __gmp_expr(float f) { __gmpz_init_set_d(mp, f); }
  __gmp_expr(double d) { __gmpz_init_set_d(mp, d); }


  explicit __gmp_expr(const char *s, int base = 0)
  {
    if (__gmpz_init_set_str (mp, s, base) != 0)
      {
        __gmpz_clear (mp);
        throw std::invalid_argument ("mpz_set_str");
      }
  }
  explicit __gmp_expr(const std::string &s, int base = 0)
  {
    if (__gmpz_init_set_str(mp, s.c_str(), base) != 0)
      {
        __gmpz_clear (mp);
        throw std::invalid_argument ("mpz_set_str");
      }
  }

  explicit __gmp_expr(mpz_srcptr z) { __gmpz_init_set(mp, z); }

  ~__gmp_expr() { __gmpz_clear(mp); }

  void swap(__gmp_expr& z) noexcept { std::swap(*mp, *z.mp); }


  __gmp_expr & operator=(const __gmp_expr &z)
  { __gmpz_set(mp, z.mp); return *this; }

  __gmp_expr & operator=(__gmp_expr &&z) noexcept
  { swap(z); return *this; }

  template <class T, class U>
  __gmp_expr<value_type, value_type> & operator=(const __gmp_expr<T, U> &expr)
  { __gmp_set_expr(mp, expr); return *this; }

  __gmp_expr & operator=(signed char c) { __gmpz_set_si(mp, c); return *this; }
  __gmp_expr & operator=(unsigned char c) { __gmpz_set_ui(mp, c); return *this; }

  __gmp_expr & operator=(signed int i) { __gmpz_set_si(mp, i); return *this; }
  __gmp_expr & operator=(unsigned int i) { __gmpz_set_ui(mp, i); return *this; }

  __gmp_expr & operator=(signed short int s)
  { __gmpz_set_si(mp, s); return *this; }
  __gmp_expr & operator=(unsigned short int s)
  { __gmpz_set_ui(mp, s); return *this; }

  __gmp_expr & operator=(signed long int l)
  { __gmpz_set_si(mp, l); return *this; }
  __gmp_expr & operator=(unsigned long int l)
  { __gmpz_set_ui(mp, l); return *this; }

  __gmp_expr & operator=(float f) { __gmpz_set_d(mp, f); return *this; }
  __gmp_expr & operator=(double d) { __gmpz_set_d(mp, d); return *this; }



  __gmp_expr & operator=(const char *s)
  {
    if (__gmpz_set_str (mp, s, 0) != 0)
      throw std::invalid_argument ("mpz_set_str");
    return *this;
  }
  __gmp_expr & operator=(const std::string &s)
  {
    if (__gmpz_set_str(mp, s.c_str(), 0) != 0)
      throw std::invalid_argument ("mpz_set_str");
    return *this;
  }


  int set_str(const char *s, int base)
  { return __gmpz_set_str(mp, s, base); }
  int set_str(const std::string &s, int base)
  { return __gmpz_set_str(mp, s.c_str(), base); }
  std::string get_str(int base = 10) const
  {
    __gmp_alloc_cstring temp(__gmpz_get_str(0, base, mp));
    return std::string(temp.str);
  }


  mpz_srcptr __get_mp() const { return mp; }
  mpz_ptr __get_mp() { return mp; }
  mpz_srcptr get_mpz_t() const { return mp; }
  mpz_ptr get_mpz_t() { return mp; }

  signed long int get_si() const { return __gmpz_get_si(mp); }
  unsigned long int get_ui() const { return __gmpz_get_ui(mp); }
  double get_d() const { return __gmpz_get_d(mp); }



  bool fits_sint_p() const { return __gmpz_fits_sint_p(mp); }
  bool fits_uint_p() const { return __gmpz_fits_uint_p(mp); }
  bool fits_sshort_p() const { return __gmpz_fits_sshort_p(mp); }
  bool fits_ushort_p() const { return __gmpz_fits_ushort_p(mp); }
  bool fits_slong_p() const { return __gmpz_fits_slong_p(mp); }
  bool fits_ulong_p() const { return __gmpz_fits_ulong_p(mp); }





  explicit operator bool() const { return mp->_mp_size != 0; }



  template <class T, class U> __gmp_expr<value_type, value_type> & operator+=(const __gmp_expr<T, U> &); __gmp_expr & operator+=(signed char); __gmp_expr & operator+=(unsigned char); __gmp_expr & operator+=(signed int); __gmp_expr & operator+=(unsigned int); __gmp_expr & operator+=(signed short int); __gmp_expr & operator+=(unsigned short int); __gmp_expr & operator+=(signed long int); __gmp_expr & operator+=(unsigned long int); __gmp_expr & operator+=(float); __gmp_expr & operator+=(double);
  template <class T, class U> __gmp_expr<value_type, value_type> & operator-=(const __gmp_expr<T, U> &); __gmp_expr & operator-=(signed char); __gmp_expr & operator-=(unsigned char); __gmp_expr & operator-=(signed int); __gmp_expr & operator-=(unsigned int); __gmp_expr & operator-=(signed short int); __gmp_expr & operator-=(unsigned short int); __gmp_expr & operator-=(signed long int); __gmp_expr & operator-=(unsigned long int); __gmp_expr & operator-=(float); __gmp_expr & operator-=(double);
  template <class T, class U> __gmp_expr<value_type, value_type> & operator*=(const __gmp_expr<T, U> &); __gmp_expr & operator*=(signed char); __gmp_expr & operator*=(unsigned char); __gmp_expr & operator*=(signed int); __gmp_expr & operator*=(unsigned int); __gmp_expr & operator*=(signed short int); __gmp_expr & operator*=(unsigned short int); __gmp_expr & operator*=(signed long int); __gmp_expr & operator*=(unsigned long int); __gmp_expr & operator*=(float); __gmp_expr & operator*=(double);
  template <class T, class U> __gmp_expr<value_type, value_type> & operator/=(const __gmp_expr<T, U> &); __gmp_expr & operator/=(signed char); __gmp_expr & operator/=(unsigned char); __gmp_expr & operator/=(signed int); __gmp_expr & operator/=(unsigned int); __gmp_expr & operator/=(signed short int); __gmp_expr & operator/=(unsigned short int); __gmp_expr & operator/=(signed long int); __gmp_expr & operator/=(unsigned long int); __gmp_expr & operator/=(float); __gmp_expr & operator/=(double);
  template <class T, class U> __gmp_expr<value_type, value_type> & operator%=(const __gmp_expr<T, U> &); __gmp_expr & operator%=(signed char); __gmp_expr & operator%=(unsigned char); __gmp_expr & operator%=(signed int); __gmp_expr & operator%=(unsigned int); __gmp_expr & operator%=(signed short int); __gmp_expr & operator%=(unsigned short int); __gmp_expr & operator%=(signed long int); __gmp_expr & operator%=(unsigned long int); __gmp_expr & operator%=(float); __gmp_expr & operator%=(double);

  template <class T, class U> __gmp_expr<value_type, value_type> & operator&=(const __gmp_expr<T, U> &); __gmp_expr & operator&=(signed char); __gmp_expr & operator&=(unsigned char); __gmp_expr & operator&=(signed int); __gmp_expr & operator&=(unsigned int); __gmp_expr & operator&=(signed short int); __gmp_expr & operator&=(unsigned short int); __gmp_expr & operator&=(signed long int); __gmp_expr & operator&=(unsigned long int); __gmp_expr & operator&=(float); __gmp_expr & operator&=(double);
  template <class T, class U> __gmp_expr<value_type, value_type> & operator|=(const __gmp_expr<T, U> &); __gmp_expr & operator|=(signed char); __gmp_expr & operator|=(unsigned char); __gmp_expr & operator|=(signed int); __gmp_expr & operator|=(unsigned int); __gmp_expr & operator|=(signed short int); __gmp_expr & operator|=(unsigned short int); __gmp_expr & operator|=(signed long int); __gmp_expr & operator|=(unsigned long int); __gmp_expr & operator|=(float); __gmp_expr & operator|=(double);
  template <class T, class U> __gmp_expr<value_type, value_type> & operator^=(const __gmp_expr<T, U> &); __gmp_expr & operator^=(signed char); __gmp_expr & operator^=(unsigned char); __gmp_expr & operator^=(signed int); __gmp_expr & operator^=(unsigned int); __gmp_expr & operator^=(signed short int); __gmp_expr & operator^=(unsigned short int); __gmp_expr & operator^=(signed long int); __gmp_expr & operator^=(unsigned long int); __gmp_expr & operator^=(float); __gmp_expr & operator^=(double);

  __gmp_expr & operator<<=(mp_bitcnt_t);
  __gmp_expr & operator>>=(mp_bitcnt_t);

  inline __gmp_expr & operator++(); inline __gmp_expr operator++(int);
  inline __gmp_expr & operator--(); inline __gmp_expr operator--(int);
};

typedef __gmp_expr<mpz_t, mpz_t> mpz_class;




template <>
class __gmp_expr<mpq_t, mpq_t>
{
private:
  typedef mpq_t value_type;
  value_type mp;
public:
  mp_bitcnt_t get_prec() const { return __gmpf_get_default_prec(); }
  void canonicalize() { __gmpq_canonicalize(mp); }


  __gmp_expr() { __gmpq_init(mp); }

  __gmp_expr(const __gmp_expr &q)
  {
    __gmpz_init_set((&((mp)->_mp_num)), (&((q.mp)->_mp_num)));
    __gmpz_init_set((&((mp)->_mp_den)), (&((q.mp)->_mp_den)));
  }

  __gmp_expr(__gmp_expr &&q)
  { *mp = *q.mp; __gmpq_init(q.mp); }

  template <class T>
  __gmp_expr(const __gmp_expr<mpz_t, T> &expr)
  { __gmpq_init(mp); __gmp_set_expr(mp, expr); }
  template <class T>
  __gmp_expr(const __gmp_expr<mpq_t, T> &expr)
  { __gmpq_init(mp); __gmp_set_expr(mp, expr); }
  template <class T, class U>
  explicit __gmp_expr(const __gmp_expr<T, U> &expr)
  { __gmpq_init(mp); __gmp_set_expr(mp, expr); }

  __gmp_expr(signed char c) { __gmpq_init(mp); __gmpq_set_si(mp, c, 1); }
  __gmp_expr(unsigned char c) { __gmpq_init(mp); __gmpq_set_ui(mp, c, 1); }

  __gmp_expr(signed int i) { __gmpq_init(mp); __gmpq_set_si(mp, i, 1); }
  __gmp_expr(unsigned int i) { __gmpq_init(mp); __gmpq_set_ui(mp, i, 1); }

  __gmp_expr(signed short int s) { __gmpq_init(mp); __gmpq_set_si(mp, s, 1); }
  __gmp_expr(unsigned short int s) { __gmpq_init(mp); __gmpq_set_ui(mp, s, 1); }

  __gmp_expr(signed long int l) { __gmpq_init(mp); __gmpq_set_si(mp, l, 1); }
  __gmp_expr(unsigned long int l) { __gmpq_init(mp); __gmpq_set_ui(mp, l, 1); }

  __gmp_expr(float f) { __gmpq_init(mp); __gmpq_set_d(mp, f); }
  __gmp_expr(double d) { __gmpq_init(mp); __gmpq_set_d(mp, d); }


  explicit __gmp_expr(const char *s, int base = 0)
  {
    __gmpq_init (mp);


    if (s == 0)
      {

 __gmpz_set_si((&((mp)->_mp_den)), base);
      }
    else if (__gmpq_set_str(mp, s, base) != 0)
      {
        __gmpq_clear (mp);
        throw std::invalid_argument ("mpq_set_str");
      }
  }
  explicit __gmp_expr(const std::string &s, int base = 0)
  {
    __gmpq_init(mp);
    if (__gmpq_set_str (mp, s.c_str(), base) != 0)
      {
        __gmpq_clear (mp);
        throw std::invalid_argument ("mpq_set_str");
      }
  }
  explicit __gmp_expr(mpq_srcptr q)
  {
    __gmpz_init_set((&((mp)->_mp_num)), (&((q)->_mp_num)));
    __gmpz_init_set((&((mp)->_mp_den)), (&((q)->_mp_den)));
  }

  __gmp_expr(const mpz_class &num, const mpz_class &den)
  {
    __gmpz_init_set((&((mp)->_mp_num)), num.get_mpz_t());
    __gmpz_init_set((&((mp)->_mp_den)), den.get_mpz_t());
  }

  ~__gmp_expr() { __gmpq_clear(mp); }

  void swap(__gmp_expr& q) noexcept { std::swap(*mp, *q.mp); }


  __gmp_expr & operator=(const __gmp_expr &q)
  { __gmpq_set(mp, q.mp); return *this; }

  __gmp_expr & operator=(__gmp_expr &&q) noexcept
  { swap(q); return *this; }
  __gmp_expr & operator=(mpz_class &&z) noexcept
  { get_num() = std::move(z); get_den() = 1u; return *this; }

  template <class T, class U>
  __gmp_expr<value_type, value_type> & operator=(const __gmp_expr<T, U> &expr)
  { __gmp_set_expr(mp, expr); return *this; }

  __gmp_expr & operator=(signed char c)
  { __gmpq_set_si(mp, c, 1); return *this; }
  __gmp_expr & operator=(unsigned char c)
  { __gmpq_set_ui(mp, c, 1); return *this; }

  __gmp_expr & operator=(signed int i) { __gmpq_set_si(mp, i, 1); return *this; }
  __gmp_expr & operator=(unsigned int i)
  { __gmpq_set_ui(mp, i, 1); return *this; }

  __gmp_expr & operator=(signed short int s)
  { __gmpq_set_si(mp, s, 1); return *this; }
  __gmp_expr & operator=(unsigned short int s)
  { __gmpq_set_ui(mp, s, 1); return *this; }

  __gmp_expr & operator=(signed long int l)
  { __gmpq_set_si(mp, l, 1); return *this; }
  __gmp_expr & operator=(unsigned long int l)
  { __gmpq_set_ui(mp, l, 1); return *this; }

  __gmp_expr & operator=(float f) { __gmpq_set_d(mp, f); return *this; }
  __gmp_expr & operator=(double d) { __gmpq_set_d(mp, d); return *this; }



  __gmp_expr & operator=(const char *s)
  {
    if (__gmpq_set_str (mp, s, 0) != 0)
      throw std::invalid_argument ("mpq_set_str");
    return *this;
  }
  __gmp_expr & operator=(const std::string &s)
  {
    if (__gmpq_set_str(mp, s.c_str(), 0) != 0)
      throw std::invalid_argument ("mpq_set_str");
    return *this;
  }


  int set_str(const char *s, int base)
  { return __gmpq_set_str(mp, s, base); }
  int set_str(const std::string &s, int base)
  { return __gmpq_set_str(mp, s.c_str(), base); }
  std::string get_str(int base = 10) const
  {
    __gmp_alloc_cstring temp(__gmpq_get_str(0, base, mp));
    return std::string(temp.str);
  }






  const mpz_class & get_num() const
  { return reinterpret_cast<const mpz_class &>(*(&((mp)->_mp_num))); }
  mpz_class & get_num()
  { return reinterpret_cast<mpz_class &>(*(&((mp)->_mp_num))); }
  const mpz_class & get_den() const
  { return reinterpret_cast<const mpz_class &>(*(&((mp)->_mp_den))); }
  mpz_class & get_den()
  { return reinterpret_cast<mpz_class &>(*(&((mp)->_mp_den))); }

  mpq_srcptr __get_mp() const { return mp; }
  mpq_ptr __get_mp() { return mp; }
  mpq_srcptr get_mpq_t() const { return mp; }
  mpq_ptr get_mpq_t() { return mp; }

  mpz_srcptr get_num_mpz_t() const { return (&((mp)->_mp_num)); }
  mpz_ptr get_num_mpz_t() { return (&((mp)->_mp_num)); }
  mpz_srcptr get_den_mpz_t() const { return (&((mp)->_mp_den)); }
  mpz_ptr get_den_mpz_t() { return (&((mp)->_mp_den)); }

  double get_d() const { return __gmpq_get_d(mp); }


  explicit operator bool() const { return (&((mp)->_mp_num))->_mp_size != 0; }



  template <class T, class U> __gmp_expr<value_type, value_type> & operator+=(const __gmp_expr<T, U> &); __gmp_expr & operator+=(signed char); __gmp_expr & operator+=(unsigned char); __gmp_expr & operator+=(signed int); __gmp_expr & operator+=(unsigned int); __gmp_expr & operator+=(signed short int); __gmp_expr & operator+=(unsigned short int); __gmp_expr & operator+=(signed long int); __gmp_expr & operator+=(unsigned long int); __gmp_expr & operator+=(float); __gmp_expr & operator+=(double);
  template <class T, class U> __gmp_expr<value_type, value_type> & operator-=(const __gmp_expr<T, U> &); __gmp_expr & operator-=(signed char); __gmp_expr & operator-=(unsigned char); __gmp_expr & operator-=(signed int); __gmp_expr & operator-=(unsigned int); __gmp_expr & operator-=(signed short int); __gmp_expr & operator-=(unsigned short int); __gmp_expr & operator-=(signed long int); __gmp_expr & operator-=(unsigned long int); __gmp_expr & operator-=(float); __gmp_expr & operator-=(double);
  template <class T, class U> __gmp_expr<value_type, value_type> & operator*=(const __gmp_expr<T, U> &); __gmp_expr & operator*=(signed char); __gmp_expr & operator*=(unsigned char); __gmp_expr & operator*=(signed int); __gmp_expr & operator*=(unsigned int); __gmp_expr & operator*=(signed short int); __gmp_expr & operator*=(unsigned short int); __gmp_expr & operator*=(signed long int); __gmp_expr & operator*=(unsigned long int); __gmp_expr & operator*=(float); __gmp_expr & operator*=(double);
  template <class T, class U> __gmp_expr<value_type, value_type> & operator/=(const __gmp_expr<T, U> &); __gmp_expr & operator/=(signed char); __gmp_expr & operator/=(unsigned char); __gmp_expr & operator/=(signed int); __gmp_expr & operator/=(unsigned int); __gmp_expr & operator/=(signed short int); __gmp_expr & operator/=(unsigned short int); __gmp_expr & operator/=(signed long int); __gmp_expr & operator/=(unsigned long int); __gmp_expr & operator/=(float); __gmp_expr & operator/=(double);

  __gmp_expr & operator<<=(mp_bitcnt_t);
  __gmp_expr & operator>>=(mp_bitcnt_t);

  inline __gmp_expr & operator++(); inline __gmp_expr operator++(int);
  inline __gmp_expr & operator--(); inline __gmp_expr operator--(int);
};

typedef __gmp_expr<mpq_t, mpq_t> mpq_class;




template <>
class __gmp_expr<mpf_t, mpf_t>
{
private:
  typedef mpf_t value_type;
  value_type mp;
public:
  mp_bitcnt_t get_prec() const { return __gmpf_get_prec(mp); }

  void set_prec(mp_bitcnt_t prec) { __gmpf_set_prec(mp, prec); }
  void set_prec_raw(mp_bitcnt_t prec) { __gmpf_set_prec_raw(mp, prec); }


  __gmp_expr() { __gmpf_init(mp); }

  __gmp_expr(const __gmp_expr &f)
  { __gmpf_init2(mp, f.get_prec()); __gmpf_set(mp, f.mp); }

  __gmp_expr(__gmp_expr &&f)
  { *mp = *f.mp; __gmpf_init2(f.mp, get_prec()); }

  __gmp_expr(const __gmp_expr &f, mp_bitcnt_t prec)
  { __gmpf_init2(mp, prec); __gmpf_set(mp, f.mp); }
  template <class T, class U>
  __gmp_expr(const __gmp_expr<T, U> &expr)
  { __gmpf_init2(mp, expr.get_prec()); __gmp_set_expr(mp, expr); }
  template <class T, class U>
  __gmp_expr(const __gmp_expr<T, U> &expr, mp_bitcnt_t prec)
  { __gmpf_init2(mp, prec); __gmp_set_expr(mp, expr); }

  __gmp_expr(signed char c) { __gmpf_init_set_si(mp, c); }
  __gmp_expr(signed char c, mp_bitcnt_t prec)
  { __gmpf_init2(mp, prec); __gmpf_set_si(mp, c); }
  __gmp_expr(unsigned char c) { __gmpf_init_set_ui(mp, c); }
  __gmp_expr(unsigned char c, mp_bitcnt_t prec)
  { __gmpf_init2(mp, prec); __gmpf_set_ui(mp, c); }

  __gmp_expr(signed int i) { __gmpf_init_set_si(mp, i); }
  __gmp_expr(signed int i, mp_bitcnt_t prec)
  { __gmpf_init2(mp, prec); __gmpf_set_si(mp, i); }
  __gmp_expr(unsigned int i) { __gmpf_init_set_ui(mp, i); }
  __gmp_expr(unsigned int i, mp_bitcnt_t prec)
  { __gmpf_init2(mp, prec); __gmpf_set_ui(mp, i); }

  __gmp_expr(signed short int s) { __gmpf_init_set_si(mp, s); }
  __gmp_expr(signed short int s, mp_bitcnt_t prec)
  { __gmpf_init2(mp, prec); __gmpf_set_si(mp, s); }
  __gmp_expr(unsigned short int s) { __gmpf_init_set_ui(mp, s); }
  __gmp_expr(unsigned short int s, mp_bitcnt_t prec)
  { __gmpf_init2(mp, prec); __gmpf_set_ui(mp, s); }

  __gmp_expr(signed long int l) { __gmpf_init_set_si(mp, l); }
  __gmp_expr(signed long int l, mp_bitcnt_t prec)
  { __gmpf_init2(mp, prec); __gmpf_set_si(mp, l); }
  __gmp_expr(unsigned long int l) { __gmpf_init_set_ui(mp, l); }
  __gmp_expr(unsigned long int l, mp_bitcnt_t prec)
  { __gmpf_init2(mp, prec); __gmpf_set_ui(mp, l); }

  __gmp_expr(float f) { __gmpf_init_set_d(mp, f); }
  __gmp_expr(float f, mp_bitcnt_t prec)
  { __gmpf_init2(mp, prec); __gmpf_set_d(mp, f); }
  __gmp_expr(double d) { __gmpf_init_set_d(mp, d); }
  __gmp_expr(double d, mp_bitcnt_t prec)
  { __gmpf_init2(mp, prec); __gmpf_set_d(mp, d); }




  explicit __gmp_expr(const char *s)
  {
    if (__gmpf_init_set_str (mp, s, 0) != 0)
      {
        __gmpf_clear (mp);
        throw std::invalid_argument ("mpf_set_str");
      }
  }
  __gmp_expr(const char *s, mp_bitcnt_t prec, int base = 0)
  {
    __gmpf_init2(mp, prec);
    if (__gmpf_set_str(mp, s, base) != 0)
      {
        __gmpf_clear (mp);
        throw std::invalid_argument ("mpf_set_str");
      }
  }
  explicit __gmp_expr(const std::string &s)
  {
    if (__gmpf_init_set_str(mp, s.c_str(), 0) != 0)
      {
        __gmpf_clear (mp);
        throw std::invalid_argument ("mpf_set_str");
      }
  }
  __gmp_expr(const std::string &s, mp_bitcnt_t prec, int base = 0)
  {
    __gmpf_init2(mp, prec);
    if (__gmpf_set_str(mp, s.c_str(), base) != 0)
      {
        __gmpf_clear (mp);
        throw std::invalid_argument ("mpf_set_str");
      }
  }

  explicit __gmp_expr(mpf_srcptr f)
  { __gmpf_init2(mp, __gmpf_get_prec(f)); __gmpf_set(mp, f); }
  __gmp_expr(mpf_srcptr f, mp_bitcnt_t prec)
  { __gmpf_init2(mp, prec); __gmpf_set(mp, f); }

  ~__gmp_expr() { __gmpf_clear(mp); }

  void swap(__gmp_expr& f) noexcept { std::swap(*mp, *f.mp); }


  __gmp_expr & operator=(const __gmp_expr &f)
  { __gmpf_set(mp, f.mp); return *this; }

  __gmp_expr & operator=(__gmp_expr &&f) noexcept
  { swap(f); return *this; }

  template <class T, class U>
  __gmp_expr<value_type, value_type> & operator=(const __gmp_expr<T, U> &expr)
  { __gmp_set_expr(mp, expr); return *this; }

  __gmp_expr & operator=(signed char c) { __gmpf_set_si(mp, c); return *this; }
  __gmp_expr & operator=(unsigned char c) { __gmpf_set_ui(mp, c); return *this; }

  __gmp_expr & operator=(signed int i) { __gmpf_set_si(mp, i); return *this; }
  __gmp_expr & operator=(unsigned int i) { __gmpf_set_ui(mp, i); return *this; }

  __gmp_expr & operator=(signed short int s)
  { __gmpf_set_si(mp, s); return *this; }
  __gmp_expr & operator=(unsigned short int s)
  { __gmpf_set_ui(mp, s); return *this; }

  __gmp_expr & operator=(signed long int l)
  { __gmpf_set_si(mp, l); return *this; }
  __gmp_expr & operator=(unsigned long int l)
  { __gmpf_set_ui(mp, l); return *this; }

  __gmp_expr & operator=(float f) { __gmpf_set_d(mp, f); return *this; }
  __gmp_expr & operator=(double d) { __gmpf_set_d(mp, d); return *this; }



  __gmp_expr & operator=(const char *s)
  {
    if (__gmpf_set_str (mp, s, 0) != 0)
      throw std::invalid_argument ("mpf_set_str");
    return *this;
  }
  __gmp_expr & operator=(const std::string &s)
  {
    if (__gmpf_set_str(mp, s.c_str(), 0) != 0)
      throw std::invalid_argument ("mpf_set_str");
    return *this;
  }


  int set_str(const char *s, int base)
  { return __gmpf_set_str(mp, s, base); }
  int set_str(const std::string &s, int base)
  { return __gmpf_set_str(mp, s.c_str(), base); }
  std::string get_str(mp_exp_t &expo, int base = 10, size_t size = 0) const
  {
    __gmp_alloc_cstring temp(__gmpf_get_str(0, &expo, base, size, mp));
    return std::string(temp.str);
  }


  mpf_srcptr __get_mp() const { return mp; }
  mpf_ptr __get_mp() { return mp; }
  mpf_srcptr get_mpf_t() const { return mp; }
  mpf_ptr get_mpf_t() { return mp; }

  signed long int get_si() const { return __gmpf_get_si(mp); }
  unsigned long int get_ui() const { return __gmpf_get_ui(mp); }
  double get_d() const { return __gmpf_get_d(mp); }



  bool fits_sint_p() const { return __gmpf_fits_sint_p(mp); }
  bool fits_uint_p() const { return __gmpf_fits_uint_p(mp); }
  bool fits_sshort_p() const { return __gmpf_fits_sshort_p(mp); }
  bool fits_ushort_p() const { return __gmpf_fits_ushort_p(mp); }
  bool fits_slong_p() const { return __gmpf_fits_slong_p(mp); }
  bool fits_ulong_p() const { return __gmpf_fits_ulong_p(mp); }





  explicit operator bool() const { return mp->_mp_size != 0; }



  template <class T, class U> __gmp_expr<value_type, value_type> & operator+=(const __gmp_expr<T, U> &); __gmp_expr & operator+=(signed char); __gmp_expr & operator+=(unsigned char); __gmp_expr & operator+=(signed int); __gmp_expr & operator+=(unsigned int); __gmp_expr & operator+=(signed short int); __gmp_expr & operator+=(unsigned short int); __gmp_expr & operator+=(signed long int); __gmp_expr & operator+=(unsigned long int); __gmp_expr & operator+=(float); __gmp_expr & operator+=(double);
  template <class T, class U> __gmp_expr<value_type, value_type> & operator-=(const __gmp_expr<T, U> &); __gmp_expr & operator-=(signed char); __gmp_expr & operator-=(unsigned char); __gmp_expr & operator-=(signed int); __gmp_expr & operator-=(unsigned int); __gmp_expr & operator-=(signed short int); __gmp_expr & operator-=(unsigned short int); __gmp_expr & operator-=(signed long int); __gmp_expr & operator-=(unsigned long int); __gmp_expr & operator-=(float); __gmp_expr & operator-=(double);
  template <class T, class U> __gmp_expr<value_type, value_type> & operator*=(const __gmp_expr<T, U> &); __gmp_expr & operator*=(signed char); __gmp_expr & operator*=(unsigned char); __gmp_expr & operator*=(signed int); __gmp_expr & operator*=(unsigned int); __gmp_expr & operator*=(signed short int); __gmp_expr & operator*=(unsigned short int); __gmp_expr & operator*=(signed long int); __gmp_expr & operator*=(unsigned long int); __gmp_expr & operator*=(float); __gmp_expr & operator*=(double);
  template <class T, class U> __gmp_expr<value_type, value_type> & operator/=(const __gmp_expr<T, U> &); __gmp_expr & operator/=(signed char); __gmp_expr & operator/=(unsigned char); __gmp_expr & operator/=(signed int); __gmp_expr & operator/=(unsigned int); __gmp_expr & operator/=(signed short int); __gmp_expr & operator/=(unsigned short int); __gmp_expr & operator/=(signed long int); __gmp_expr & operator/=(unsigned long int); __gmp_expr & operator/=(float); __gmp_expr & operator/=(double);

  __gmp_expr & operator<<=(mp_bitcnt_t);
  __gmp_expr & operator>>=(mp_bitcnt_t);

  inline __gmp_expr & operator++(); inline __gmp_expr operator++(int);
  inline __gmp_expr & operator--(); inline __gmp_expr operator--(int);
};

typedef __gmp_expr<mpf_t, mpf_t> mpf_class;






inline mpz_class operator"" _mpz(const char* s)
{
  return mpz_class(s);
}

inline mpq_class operator"" _mpq(const char* s)
{
  mpq_class q;
  q.get_num() = s;
  return q;
}

inline mpf_class operator"" _mpf(const char* s)
{
  return mpf_class(s);
}






template <class T, class U>
inline std::ostream & operator<<
(std::ostream &o, const __gmp_expr<T, U> &expr)
{
  __gmp_expr<T, T> const& temp(expr);
  return o << temp.__get_mp();
}

template <class T>
inline std::istream & operator>>(std::istream &i, __gmp_expr<T, T> &expr)
{
  return i >> expr.__get_mp();
}
# 2085 "/usr/include/gmpxx.h" 3 4
inline void __gmp_set_expr(mpz_ptr z, const mpz_class &w)
{
  __gmpz_set(z, w.get_mpz_t());
}

template <class T>
inline void __gmp_set_expr(mpz_ptr z, const __gmp_expr<mpz_t, T> &expr)
{
  expr.eval(z);
}

template <class T>
inline void __gmp_set_expr(mpz_ptr z, const __gmp_expr<mpq_t, T> &expr)
{
  mpq_class const& temp(expr);
  __gmpz_set_q(z, temp.get_mpq_t());
}

template <class T>
inline void __gmp_set_expr(mpz_ptr z, const __gmp_expr<mpf_t, T> &expr)
{
  mpf_class const& temp(expr);
  __gmpz_set_f(z, temp.get_mpf_t());
}

inline void __gmp_set_expr(mpq_ptr q, const mpz_class &z)
{
  __gmpq_set_z(q, z.get_mpz_t());
}

template <class T>
inline void __gmp_set_expr(mpq_ptr q, const __gmp_expr<mpz_t, T> &expr)
{
  __gmp_set_expr((&((q)->_mp_num)), expr);
  __gmpz_set_ui((&((q)->_mp_den)), 1);
}

inline void __gmp_set_expr(mpq_ptr q, const mpq_class &r)
{
  __gmpq_set(q, r.get_mpq_t());
}

template <class T>
inline void __gmp_set_expr(mpq_ptr q, const __gmp_expr<mpq_t, T> &expr)
{
  expr.eval(q);
}

template <class T>
inline void __gmp_set_expr(mpq_ptr q, const __gmp_expr<mpf_t, T> &expr)
{
  mpf_class const& temp(expr);
  __gmpq_set_f(q, temp.get_mpf_t());
}

template <class T>
inline void __gmp_set_expr(mpf_ptr f, const __gmp_expr<mpz_t, T> &expr)
{
  mpz_class const& temp(expr);
  __gmpf_set_z(f, temp.get_mpz_t());
}

template <class T>
inline void __gmp_set_expr(mpf_ptr f, const __gmp_expr<mpq_t, T> &expr)
{
  mpq_class const& temp(expr);
  __gmpf_set_q(f, temp.get_mpq_t());
}

inline void __gmp_set_expr(mpf_ptr f, const mpf_class &g)
{
  __gmpf_set(f, g.get_mpf_t());
}

template <class T>
inline void __gmp_set_expr(mpf_ptr f, const __gmp_expr<mpf_t, T> &expr)
{
  expr.eval(f);
}




template <class T>
class __gmp_temp
{
  __gmp_expr<T, T> val;
  public:
  template<class U, class V>
  __gmp_temp(U const& u, V) : val (u) {}
  typename __gmp_resolve_expr<T>::srcptr_type
  __get_mp() const { return val.__get_mp(); }
};

template <>
class __gmp_temp <mpf_t>
{
  mpf_class val;
  public:
  template<class U>
  __gmp_temp(U const& u, mpf_ptr res) : val (u, __gmpf_get_prec(res)) {}
  mpf_srcptr __get_mp() const { return val.__get_mp(); }
};
# 2208 "/usr/include/gmpxx.h" 3 4
template <class T, class Op>
class __gmp_expr<T, __gmp_unary_expr<__gmp_expr<T, T>, Op> >
{
private:
  typedef __gmp_expr<T, T> val_type;

  __gmp_unary_expr<val_type, Op> expr;
public:
  explicit __gmp_expr(const val_type &val) : expr(val) { }
  void eval(typename __gmp_resolve_expr<T>::ptr_type p) const
  { Op::eval(p, expr.val.__get_mp()); }
  const val_type & get_val() const { return expr.val; }
  mp_bitcnt_t get_prec() const { return expr.val.get_prec(); }
};




template <class T, class U, class Op>
class __gmp_expr<T, __gmp_unary_expr<__gmp_expr<T, U>, Op> >
{
private:
  typedef __gmp_expr<T, U> val_type;

  __gmp_unary_expr<val_type, Op> expr;
public:
  explicit __gmp_expr(const val_type &val) : expr(val) { }
  void eval(typename __gmp_resolve_expr<T>::ptr_type p) const
  { expr.val.eval(p); Op::eval(p, p); }
  const val_type & get_val() const { return expr.val; }
  mp_bitcnt_t get_prec() const { return expr.val.get_prec(); }
};
# 2254 "/usr/include/gmpxx.h" 3 4
template <class T, class Op>
class __gmp_expr
<T, __gmp_binary_expr<__gmp_expr<T, T>, __gmp_expr<T, T>, Op> >
{
private:
  typedef __gmp_expr<T, T> val1_type;
  typedef __gmp_expr<T, T> val2_type;

  __gmp_binary_expr<val1_type, val2_type, Op> expr;
public:
  __gmp_expr(const val1_type &val1, const val2_type &val2)
    : expr(val1, val2) { }
  void eval(typename __gmp_resolve_expr<T>::ptr_type p) const
  { Op::eval(p, expr.val1.__get_mp(), expr.val2.__get_mp()); }
  const val1_type & get_val1() const { return expr.val1; }
  const val2_type & get_val2() const { return expr.val2; }
  mp_bitcnt_t get_prec() const
  {
    mp_bitcnt_t prec1 = expr.val1.get_prec(),
      prec2 = expr.val2.get_prec();
    return (prec1 > prec2) ? prec1 : prec2;
  }
};




template <class T, class U, class Op>
class __gmp_expr<T, __gmp_binary_expr<__gmp_expr<T, T>, U, Op> >
{
private:
  typedef __gmp_expr<T, T> val1_type;
  typedef U val2_type;

  __gmp_binary_expr<val1_type, val2_type, Op> expr;
public:
  __gmp_expr(const val1_type &val1, const val2_type &val2)
    : expr(val1, val2) { }
  void eval(typename __gmp_resolve_expr<T>::ptr_type p) const
  { Op::eval(p, expr.val1.__get_mp(), expr.val2); }
  const val1_type & get_val1() const { return expr.val1; }
  const val2_type & get_val2() const { return expr.val2; }
  mp_bitcnt_t get_prec() const { return expr.val1.get_prec(); }
};

template <class T, class U, class Op>
class __gmp_expr<T, __gmp_binary_expr<U, __gmp_expr<T, T>, Op> >
{
private:
  typedef U val1_type;
  typedef __gmp_expr<T, T> val2_type;

  __gmp_binary_expr<val1_type, val2_type, Op> expr;
public:
  __gmp_expr(const val1_type &val1, const val2_type &val2)
    : expr(val1, val2) { }
  void eval(typename __gmp_resolve_expr<T>::ptr_type p) const
  { Op::eval(p, expr.val1, expr.val2.__get_mp()); }
  const val1_type & get_val1() const { return expr.val1; }
  const val2_type & get_val2() const { return expr.val2; }
  mp_bitcnt_t get_prec() const { return expr.val2.get_prec(); }
};




template <class T, class U, class V, class Op>
class __gmp_expr
<T, __gmp_binary_expr<__gmp_expr<T, T>, __gmp_expr<U, V>, Op> >
{
private:
  typedef __gmp_expr<T, T> val1_type;
  typedef __gmp_expr<U, V> val2_type;

  __gmp_binary_expr<val1_type, val2_type, Op> expr;
public:
  __gmp_expr(const val1_type &val1, const val2_type &val2)
    : expr(val1, val2) { }
  void eval(typename __gmp_resolve_expr<T>::ptr_type p) const
  {
    if(p != expr.val1.__get_mp())
    {
      __gmp_set_expr(p, expr.val2);
      Op::eval(p, expr.val1.__get_mp(), p);
    }
    else
    {
      __gmp_temp<T> temp(expr.val2, p);
      Op::eval(p, expr.val1.__get_mp(), temp.__get_mp());
    }
  }
  const val1_type & get_val1() const { return expr.val1; }
  const val2_type & get_val2() const { return expr.val2; }
  mp_bitcnt_t get_prec() const
  {
    mp_bitcnt_t prec1 = expr.val1.get_prec(),
      prec2 = expr.val2.get_prec();
    return (prec1 > prec2) ? prec1 : prec2;
  }
};

template <class T, class U, class V, class Op>
class __gmp_expr
<T, __gmp_binary_expr<__gmp_expr<U, V>, __gmp_expr<T, T>, Op> >
{
private:
  typedef __gmp_expr<U, V> val1_type;
  typedef __gmp_expr<T, T> val2_type;

  __gmp_binary_expr<val1_type, val2_type, Op> expr;
public:
  __gmp_expr(const val1_type &val1, const val2_type &val2)
    : expr(val1, val2) { }
  void eval(typename __gmp_resolve_expr<T>::ptr_type p) const
  {
    if(p != expr.val2.__get_mp())
    {
      __gmp_set_expr(p, expr.val1);
      Op::eval(p, p, expr.val2.__get_mp());
    }
    else
    {
      __gmp_temp<T> temp(expr.val1, p);
      Op::eval(p, temp.__get_mp(), expr.val2.__get_mp());
    }
  }
  const val1_type & get_val1() const { return expr.val1; }
  const val2_type & get_val2() const { return expr.val2; }
  mp_bitcnt_t get_prec() const
  {
    mp_bitcnt_t prec1 = expr.val1.get_prec(),
      prec2 = expr.val2.get_prec();
    return (prec1 > prec2) ? prec1 : prec2;
  }
};

template <class T, class U, class Op>
class __gmp_expr
<T, __gmp_binary_expr<__gmp_expr<T, T>, __gmp_expr<T, U>, Op> >
{
private:
  typedef __gmp_expr<T, T> val1_type;
  typedef __gmp_expr<T, U> val2_type;

  __gmp_binary_expr<val1_type, val2_type, Op> expr;
public:
  __gmp_expr(const val1_type &val1, const val2_type &val2)
    : expr(val1, val2) { }
  void eval(typename __gmp_resolve_expr<T>::ptr_type p) const
  {
    if(p != expr.val1.__get_mp())
    {
      __gmp_set_expr(p, expr.val2);
      Op::eval(p, expr.val1.__get_mp(), p);
    }
    else
    {
      __gmp_temp<T> temp(expr.val2, p);
      Op::eval(p, expr.val1.__get_mp(), temp.__get_mp());
    }
  }
  const val1_type & get_val1() const { return expr.val1; }
  const val2_type & get_val2() const { return expr.val2; }
  mp_bitcnt_t get_prec() const
  {
    mp_bitcnt_t prec1 = expr.val1.get_prec(),
      prec2 = expr.val2.get_prec();
    return (prec1 > prec2) ? prec1 : prec2;
  }
};

template <class T, class U, class Op>
class __gmp_expr
<T, __gmp_binary_expr<__gmp_expr<T, U>, __gmp_expr<T, T>, Op> >
{
private:
  typedef __gmp_expr<T, U> val1_type;
  typedef __gmp_expr<T, T> val2_type;

  __gmp_binary_expr<val1_type, val2_type, Op> expr;
public:
  __gmp_expr(const val1_type &val1, const val2_type &val2)
    : expr(val1, val2) { }
  void eval(typename __gmp_resolve_expr<T>::ptr_type p) const
  {
    if(p != expr.val2.__get_mp())
    {
      __gmp_set_expr(p, expr.val1);
      Op::eval(p, p, expr.val2.__get_mp());
    }
    else
    {
      __gmp_temp<T> temp(expr.val1, p);
      Op::eval(p, temp.__get_mp(), expr.val2.__get_mp());
    }
  }
  const val1_type & get_val1() const { return expr.val1; }
  const val2_type & get_val2() const { return expr.val2; }
  mp_bitcnt_t get_prec() const
  {
    mp_bitcnt_t prec1 = expr.val1.get_prec(),
      prec2 = expr.val2.get_prec();
    return (prec1 > prec2) ? prec1 : prec2;
  }
};




template <class T, class U, class V, class Op>
class __gmp_expr<T, __gmp_binary_expr<__gmp_expr<T, U>, V, Op> >
{
private:
  typedef __gmp_expr<T, U> val1_type;
  typedef V val2_type;

  __gmp_binary_expr<val1_type, val2_type, Op> expr;
public:
  __gmp_expr(const val1_type &val1, const val2_type &val2)
    : expr(val1, val2) { }
  void eval(typename __gmp_resolve_expr<T>::ptr_type p) const
  {
    expr.val1.eval(p);
    Op::eval(p, p, expr.val2);
  }
  const val1_type & get_val1() const { return expr.val1; }
  const val2_type & get_val2() const { return expr.val2; }
  mp_bitcnt_t get_prec() const { return expr.val1.get_prec(); }
};

template <class T, class U, class V, class Op>
class __gmp_expr<T, __gmp_binary_expr<U, __gmp_expr<T, V>, Op> >
{
private:
  typedef U val1_type;
  typedef __gmp_expr<T, V> val2_type;

  __gmp_binary_expr<val1_type, val2_type, Op> expr;
public:
  __gmp_expr(const val1_type &val1, const val2_type &val2)
    : expr(val1, val2) { }
  void eval(typename __gmp_resolve_expr<T>::ptr_type p) const
  {
    expr.val2.eval(p);
    Op::eval(p, expr.val1, p);
  }
  const val1_type & get_val1() const { return expr.val1; }
  const val2_type & get_val2() const { return expr.val2; }
  mp_bitcnt_t get_prec() const { return expr.val2.get_prec(); }
};




template <class T, class U, class V, class W, class Op>
class __gmp_expr
<T, __gmp_binary_expr<__gmp_expr<T, U>, __gmp_expr<V, W>, Op> >
{
private:
  typedef __gmp_expr<T, U> val1_type;
  typedef __gmp_expr<V, W> val2_type;

  __gmp_binary_expr<val1_type, val2_type, Op> expr;
public:
  __gmp_expr(const val1_type &val1, const val2_type &val2)
    : expr(val1, val2) { }
  void eval(typename __gmp_resolve_expr<T>::ptr_type p) const
  {
    __gmp_temp<T> temp2(expr.val2, p);
    expr.val1.eval(p);
    Op::eval(p, p, temp2.__get_mp());
  }
  const val1_type & get_val1() const { return expr.val1; }
  const val2_type & get_val2() const { return expr.val2; }
  mp_bitcnt_t get_prec() const
  {
    mp_bitcnt_t prec1 = expr.val1.get_prec(),
      prec2 = expr.val2.get_prec();
    return (prec1 > prec2) ? prec1 : prec2;
  }
};

template <class T, class U, class V, class W, class Op>
class __gmp_expr
<T, __gmp_binary_expr<__gmp_expr<U, V>, __gmp_expr<T, W>, Op> >
{
private:
  typedef __gmp_expr<U, V> val1_type;
  typedef __gmp_expr<T, W> val2_type;

  __gmp_binary_expr<val1_type, val2_type, Op> expr;
public:
  __gmp_expr(const val1_type &val1, const val2_type &val2)
    : expr(val1, val2) { }
  void eval(typename __gmp_resolve_expr<T>::ptr_type p) const
  {
    __gmp_temp<T> temp1(expr.val1, p);
    expr.val2.eval(p);
    Op::eval(p, temp1.__get_mp(), p);
  }
  const val1_type & get_val1() const { return expr.val1; }
  const val2_type & get_val2() const { return expr.val2; }
  mp_bitcnt_t get_prec() const
  {
    mp_bitcnt_t prec1 = expr.val1.get_prec(),
      prec2 = expr.val2.get_prec();
    return (prec1 > prec2) ? prec1 : prec2;
  }
};

template <class T, class U, class V, class Op>
class __gmp_expr
<T, __gmp_binary_expr<__gmp_expr<T, U>, __gmp_expr<T, V>, Op> >
{
private:
  typedef __gmp_expr<T, U> val1_type;
  typedef __gmp_expr<T, V> val2_type;

  __gmp_binary_expr<val1_type, val2_type, Op> expr;
public:
  __gmp_expr(const val1_type &val1, const val2_type &val2)
    : expr(val1, val2) { }
  void eval(typename __gmp_resolve_expr<T>::ptr_type p) const
  {
    __gmp_temp<T> temp2(expr.val2, p);
    expr.val1.eval(p);
    Op::eval(p, p, temp2.__get_mp());
  }
  const val1_type & get_val1() const { return expr.val1; }
  const val2_type & get_val2() const { return expr.val2; }
  mp_bitcnt_t get_prec() const
  {
    mp_bitcnt_t prec1 = expr.val1.get_prec(),
      prec2 = expr.val2.get_prec();
    return (prec1 > prec2) ? prec1 : prec2;
  }
};
# 2773 "/usr/include/gmpxx.h" 3 4
template <> class __gmp_expr<mpq_t, __gmp_binary_expr<mpz_class, mpq_class, __gmp_binary_plus> > { private: typedef mpz_class val1_type; typedef mpq_class val2_type; __gmp_binary_expr<val1_type, val2_type, __gmp_binary_plus> expr; public: __gmp_expr(const val1_type &val1, const val2_type &val2) : expr(val1, val2) { } void eval(mpq_ptr q) const { __gmp_binary_plus::eval(q, expr.val1.get_mpz_t(), expr.val2.get_mpq_t()); } const val1_type & get_val1() const { return expr.val1; } const val2_type & get_val2() const { return expr.val2; } mp_bitcnt_t get_prec() const { return __gmpf_get_default_prec(); } }; template <> class __gmp_expr<mpq_t, __gmp_binary_expr<mpq_class, mpz_class, __gmp_binary_plus> > { private: typedef mpq_class val1_type; typedef mpz_class val2_type; __gmp_binary_expr<val1_type, val2_type, __gmp_binary_plus> expr; public: __gmp_expr(const val1_type &val1, const val2_type &val2) : expr(val1, val2) { } void eval(mpq_ptr q) const { __gmp_binary_plus::eval(q, expr.val1.get_mpq_t(), expr.val2.get_mpz_t()); } const val1_type & get_val1() const { return expr.val1; } const val2_type & get_val2() const { return expr.val2; } mp_bitcnt_t get_prec() const { return __gmpf_get_default_prec(); } }; template <class T> class __gmp_expr <mpq_t, __gmp_binary_expr<mpz_class, __gmp_expr<mpq_t, T>, __gmp_binary_plus> > { private: typedef mpz_class val1_type; typedef __gmp_expr<mpq_t, T> val2_type; __gmp_binary_expr<val1_type, val2_type, __gmp_binary_plus> expr; public: __gmp_expr(const val1_type &val1, const val2_type &val2) : expr(val1, val2) { } void eval(mpq_ptr q) const { mpq_class temp(expr.val2); __gmp_binary_plus::eval(q, expr.val1.get_mpz_t(), temp.get_mpq_t()); } const val1_type & get_val1() const { return expr.val1; } const val2_type & get_val2() const { return expr.val2; } mp_bitcnt_t get_prec() const { return __gmpf_get_default_prec(); } }; template <class T> class __gmp_expr <mpq_t, __gmp_binary_expr<mpq_class, __gmp_expr<mpz_t, T>, __gmp_binary_plus> > { private: typedef mpq_class val1_type; typedef __gmp_expr<mpz_t, T> val2_type; __gmp_binary_expr<val1_type, val2_type, __gmp_binary_plus> expr; public: __gmp_expr(const val1_type &val1, const val2_type &val2) : expr(val1, val2) { } void eval(mpq_ptr q) const { mpz_class temp(expr.val2); __gmp_binary_plus::eval(q, expr.val1.get_mpq_t(), temp.get_mpz_t()); } const val1_type & get_val1() const { return expr.val1; } const val2_type & get_val2() const { return expr.val2; } mp_bitcnt_t get_prec() const { return __gmpf_get_default_prec(); } }; template <class T> class __gmp_expr <mpq_t, __gmp_binary_expr<__gmp_expr<mpz_t, T>, mpq_class, __gmp_binary_plus> > { private: typedef __gmp_expr<mpz_t, T> val1_type; typedef mpq_class val2_type; __gmp_binary_expr<val1_type, val2_type, __gmp_binary_plus> expr; public: __gmp_expr(const val1_type &val1, const val2_type &val2) : expr(val1, val2) { } void eval(mpq_ptr q) const { mpz_class temp(expr.val1); __gmp_binary_plus::eval(q, temp.get_mpz_t(), expr.val2.get_mpq_t()); } const val1_type & get_val1() const { return expr.val1; } const val2_type & get_val2() const { return expr.val2; } mp_bitcnt_t get_prec() const { return __gmpf_get_default_prec(); } }; template <class T> class __gmp_expr <mpq_t, __gmp_binary_expr<__gmp_expr<mpq_t, T>, mpz_class, __gmp_binary_plus> > { private: typedef __gmp_expr<mpq_t, T> val1_type; typedef mpz_class val2_type; __gmp_binary_expr<val1_type, val2_type, __gmp_binary_plus> expr; public: __gmp_expr(const val1_type &val1, const val2_type &val2) : expr(val1, val2) { } void eval(mpq_ptr q) const { mpq_class temp(expr.val1); __gmp_binary_plus::eval(q, temp.get_mpq_t(), expr.val2.get_mpz_t()); } const val1_type & get_val1() const { return expr.val1; } const val2_type & get_val2() const { return expr.val2; } mp_bitcnt_t get_prec() const { return __gmpf_get_default_prec(); } }; template <class T, class U> class __gmp_expr<mpq_t, __gmp_binary_expr <__gmp_expr<mpz_t, T>, __gmp_expr<mpq_t, U>, __gmp_binary_plus> > { private: typedef __gmp_expr<mpz_t, T> val1_type; typedef __gmp_expr<mpq_t, U> val2_type; __gmp_binary_expr<val1_type, val2_type, __gmp_binary_plus> expr; public: __gmp_expr(const val1_type &val1, const val2_type &val2) : expr(val1, val2) { } void eval(mpq_ptr q) const { mpz_class temp1(expr.val1); expr.val2.eval(q); __gmp_binary_plus::eval(q, temp1.get_mpz_t(), q); } const val1_type & get_val1() const { return expr.val1; } const val2_type & get_val2() const { return expr.val2; } mp_bitcnt_t get_prec() const { return __gmpf_get_default_prec(); } }; template <class T, class U> class __gmp_expr<mpq_t, __gmp_binary_expr <__gmp_expr<mpq_t, T>, __gmp_expr<mpz_t, U>, __gmp_binary_plus> > { private: typedef __gmp_expr<mpq_t, T> val1_type; typedef __gmp_expr<mpz_t, U> val2_type; __gmp_binary_expr<val1_type, val2_type, __gmp_binary_plus> expr; public: __gmp_expr(const val1_type &val1, const val2_type &val2) : expr(val1, val2) { } void eval(mpq_ptr q) const { mpz_class temp2(expr.val2); expr.val1.eval(q); __gmp_binary_plus::eval(q, q, temp2.get_mpz_t()); } const val1_type & get_val1() const { return expr.val1; } const val2_type & get_val2() const { return expr.val2; } mp_bitcnt_t get_prec() const { return __gmpf_get_default_prec(); } };
template <> class __gmp_expr<mpq_t, __gmp_binary_expr<mpz_class, mpq_class, __gmp_binary_minus> > { private: typedef mpz_class val1_type; typedef mpq_class val2_type; __gmp_binary_expr<val1_type, val2_type, __gmp_binary_minus> expr; public: __gmp_expr(const val1_type &val1, const val2_type &val2) : expr(val1, val2) { } void eval(mpq_ptr q) const { __gmp_binary_minus::eval(q, expr.val1.get_mpz_t(), expr.val2.get_mpq_t()); } const val1_type & get_val1() const { return expr.val1; } const val2_type & get_val2() const { return expr.val2; } mp_bitcnt_t get_prec() const { return __gmpf_get_default_prec(); } }; template <> class __gmp_expr<mpq_t, __gmp_binary_expr<mpq_class, mpz_class, __gmp_binary_minus> > { private: typedef mpq_class val1_type; typedef mpz_class val2_type; __gmp_binary_expr<val1_type, val2_type, __gmp_binary_minus> expr; public: __gmp_expr(const val1_type &val1, const val2_type &val2) : expr(val1, val2) { } void eval(mpq_ptr q) const { __gmp_binary_minus::eval(q, expr.val1.get_mpq_t(), expr.val2.get_mpz_t()); } const val1_type & get_val1() const { return expr.val1; } const val2_type & get_val2() const { return expr.val2; } mp_bitcnt_t get_prec() const { return __gmpf_get_default_prec(); } }; template <class T> class __gmp_expr <mpq_t, __gmp_binary_expr<mpz_class, __gmp_expr<mpq_t, T>, __gmp_binary_minus> > { private: typedef mpz_class val1_type; typedef __gmp_expr<mpq_t, T> val2_type; __gmp_binary_expr<val1_type, val2_type, __gmp_binary_minus> expr; public: __gmp_expr(const val1_type &val1, const val2_type &val2) : expr(val1, val2) { } void eval(mpq_ptr q) const { mpq_class temp(expr.val2); __gmp_binary_minus::eval(q, expr.val1.get_mpz_t(), temp.get_mpq_t()); } const val1_type & get_val1() const { return expr.val1; } const val2_type & get_val2() const { return expr.val2; } mp_bitcnt_t get_prec() const { return __gmpf_get_default_prec(); } }; template <class T> class __gmp_expr <mpq_t, __gmp_binary_expr<mpq_class, __gmp_expr<mpz_t, T>, __gmp_binary_minus> > { private: typedef mpq_class val1_type; typedef __gmp_expr<mpz_t, T> val2_type; __gmp_binary_expr<val1_type, val2_type, __gmp_binary_minus> expr; public: __gmp_expr(const val1_type &val1, const val2_type &val2) : expr(val1, val2) { } void eval(mpq_ptr q) const { mpz_class temp(expr.val2); __gmp_binary_minus::eval(q, expr.val1.get_mpq_t(), temp.get_mpz_t()); } const val1_type & get_val1() const { return expr.val1; } const val2_type & get_val2() const { return expr.val2; } mp_bitcnt_t get_prec() const { return __gmpf_get_default_prec(); } }; template <class T> class __gmp_expr <mpq_t, __gmp_binary_expr<__gmp_expr<mpz_t, T>, mpq_class, __gmp_binary_minus> > { private: typedef __gmp_expr<mpz_t, T> val1_type; typedef mpq_class val2_type; __gmp_binary_expr<val1_type, val2_type, __gmp_binary_minus> expr; public: __gmp_expr(const val1_type &val1, const val2_type &val2) : expr(val1, val2) { } void eval(mpq_ptr q) const { mpz_class temp(expr.val1); __gmp_binary_minus::eval(q, temp.get_mpz_t(), expr.val2.get_mpq_t()); } const val1_type & get_val1() const { return expr.val1; } const val2_type & get_val2() const { return expr.val2; } mp_bitcnt_t get_prec() const { return __gmpf_get_default_prec(); } }; template <class T> class __gmp_expr <mpq_t, __gmp_binary_expr<__gmp_expr<mpq_t, T>, mpz_class, __gmp_binary_minus> > { private: typedef __gmp_expr<mpq_t, T> val1_type; typedef mpz_class val2_type; __gmp_binary_expr<val1_type, val2_type, __gmp_binary_minus> expr; public: __gmp_expr(const val1_type &val1, const val2_type &val2) : expr(val1, val2) { } void eval(mpq_ptr q) const { mpq_class temp(expr.val1); __gmp_binary_minus::eval(q, temp.get_mpq_t(), expr.val2.get_mpz_t()); } const val1_type & get_val1() const { return expr.val1; } const val2_type & get_val2() const { return expr.val2; } mp_bitcnt_t get_prec() const { return __gmpf_get_default_prec(); } }; template <class T, class U> class __gmp_expr<mpq_t, __gmp_binary_expr <__gmp_expr<mpz_t, T>, __gmp_expr<mpq_t, U>, __gmp_binary_minus> > { private: typedef __gmp_expr<mpz_t, T> val1_type; typedef __gmp_expr<mpq_t, U> val2_type; __gmp_binary_expr<val1_type, val2_type, __gmp_binary_minus> expr; public: __gmp_expr(const val1_type &val1, const val2_type &val2) : expr(val1, val2) { } void eval(mpq_ptr q) const { mpz_class temp1(expr.val1); expr.val2.eval(q); __gmp_binary_minus::eval(q, temp1.get_mpz_t(), q); } const val1_type & get_val1() const { return expr.val1; } const val2_type & get_val2() const { return expr.val2; } mp_bitcnt_t get_prec() const { return __gmpf_get_default_prec(); } }; template <class T, class U> class __gmp_expr<mpq_t, __gmp_binary_expr <__gmp_expr<mpq_t, T>, __gmp_expr<mpz_t, U>, __gmp_binary_minus> > { private: typedef __gmp_expr<mpq_t, T> val1_type; typedef __gmp_expr<mpz_t, U> val2_type; __gmp_binary_expr<val1_type, val2_type, __gmp_binary_minus> expr; public: __gmp_expr(const val1_type &val1, const val2_type &val2) : expr(val1, val2) { } void eval(mpq_ptr q) const { mpz_class temp2(expr.val2); expr.val1.eval(q); __gmp_binary_minus::eval(q, q, temp2.get_mpz_t()); } const val1_type & get_val1() const { return expr.val1; } const val2_type & get_val2() const { return expr.val2; } mp_bitcnt_t get_prec() const { return __gmpf_get_default_prec(); } };
# 3067 "/usr/include/gmpxx.h" 3 4
template <class T, class U> inline __gmp_expr<T, __gmp_unary_expr<__gmp_expr<T, U>, __gmp_unary_plus> > operator+(const __gmp_expr<T, U> &expr) { return __gmp_expr<T, __gmp_unary_expr<__gmp_expr<T, U>, __gmp_unary_plus> >(expr); }
template <class T, class U> inline __gmp_expr<T, __gmp_unary_expr<__gmp_expr<T, U>, __gmp_unary_minus> > operator-(const __gmp_expr<T, U> &expr) { return __gmp_expr<T, __gmp_unary_expr<__gmp_expr<T, U>, __gmp_unary_minus> >(expr); }
template <class T, class U> inline __gmp_expr<T, __gmp_unary_expr<__gmp_expr<T, U>, __gmp_unary_com> > operator~(const __gmp_expr<T, U> &expr) { return __gmp_expr<T, __gmp_unary_expr<__gmp_expr<T, U>, __gmp_unary_com> >(expr); }

template <class T, class U, class V, class W> inline __gmp_expr<typename __gmp_resolve_expr<T, V>::value_type, __gmp_binary_expr<__gmp_expr<T, U>, __gmp_expr<V, W>, __gmp_binary_plus> > operator+(const __gmp_expr<T, U> &expr1, const __gmp_expr<V, W> &expr2) { return __gmp_expr<typename __gmp_resolve_expr<T, V>::value_type, __gmp_binary_expr<__gmp_expr<T, U>, __gmp_expr<V, W>, __gmp_binary_plus> > (expr1, expr2); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_plus> > operator+(const __gmp_expr<T, U> &expr, signed char t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_plus> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_plus> > operator+(signed char t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_plus> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_plus> > operator+(const __gmp_expr<T, U> &expr, unsigned char t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_plus> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_plus> > operator+(unsigned char t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_plus> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_plus> > operator+(const __gmp_expr<T, U> &expr, signed int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_plus> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_plus> > operator+(signed int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_plus> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_plus> > operator+(const __gmp_expr<T, U> &expr, unsigned int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_plus> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_plus> > operator+(unsigned int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_plus> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_plus> > operator+(const __gmp_expr<T, U> &expr, signed short int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_plus> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_plus> > operator+(signed short int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_plus> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_plus> > operator+(const __gmp_expr<T, U> &expr, unsigned short int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_plus> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_plus> > operator+(unsigned short int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_plus> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_plus> > operator+(const __gmp_expr<T, U> &expr, signed long int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_plus> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_plus> > operator+(signed long int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_plus> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_plus> > operator+(const __gmp_expr<T, U> &expr, unsigned long int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_plus> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_plus> > operator+(unsigned long int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_plus> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, double, __gmp_binary_plus> > operator+(const __gmp_expr<T, U> &expr, float t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, double, __gmp_binary_plus> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<double, __gmp_expr<T, U>, __gmp_binary_plus> > operator+(float t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<double, __gmp_expr<T, U>, __gmp_binary_plus> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, double, __gmp_binary_plus> > operator+(const __gmp_expr<T, U> &expr, double t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, double, __gmp_binary_plus> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<double, __gmp_expr<T, U>, __gmp_binary_plus> > operator+(double t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<double, __gmp_expr<T, U>, __gmp_binary_plus> >(t, expr); }
template <class T, class U, class V, class W> inline __gmp_expr<typename __gmp_resolve_expr<T, V>::value_type, __gmp_binary_expr<__gmp_expr<T, U>, __gmp_expr<V, W>, __gmp_binary_minus> > operator-(const __gmp_expr<T, U> &expr1, const __gmp_expr<V, W> &expr2) { return __gmp_expr<typename __gmp_resolve_expr<T, V>::value_type, __gmp_binary_expr<__gmp_expr<T, U>, __gmp_expr<V, W>, __gmp_binary_minus> > (expr1, expr2); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_minus> > operator-(const __gmp_expr<T, U> &expr, signed char t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_minus> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_minus> > operator-(signed char t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_minus> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_minus> > operator-(const __gmp_expr<T, U> &expr, unsigned char t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_minus> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_minus> > operator-(unsigned char t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_minus> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_minus> > operator-(const __gmp_expr<T, U> &expr, signed int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_minus> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_minus> > operator-(signed int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_minus> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_minus> > operator-(const __gmp_expr<T, U> &expr, unsigned int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_minus> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_minus> > operator-(unsigned int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_minus> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_minus> > operator-(const __gmp_expr<T, U> &expr, signed short int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_minus> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_minus> > operator-(signed short int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_minus> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_minus> > operator-(const __gmp_expr<T, U> &expr, unsigned short int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_minus> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_minus> > operator-(unsigned short int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_minus> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_minus> > operator-(const __gmp_expr<T, U> &expr, signed long int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_minus> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_minus> > operator-(signed long int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_minus> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_minus> > operator-(const __gmp_expr<T, U> &expr, unsigned long int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_minus> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_minus> > operator-(unsigned long int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_minus> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, double, __gmp_binary_minus> > operator-(const __gmp_expr<T, U> &expr, float t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, double, __gmp_binary_minus> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<double, __gmp_expr<T, U>, __gmp_binary_minus> > operator-(float t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<double, __gmp_expr<T, U>, __gmp_binary_minus> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, double, __gmp_binary_minus> > operator-(const __gmp_expr<T, U> &expr, double t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, double, __gmp_binary_minus> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<double, __gmp_expr<T, U>, __gmp_binary_minus> > operator-(double t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<double, __gmp_expr<T, U>, __gmp_binary_minus> >(t, expr); }
template <class T, class U, class V, class W> inline __gmp_expr<typename __gmp_resolve_expr<T, V>::value_type, __gmp_binary_expr<__gmp_expr<T, U>, __gmp_expr<V, W>, __gmp_binary_multiplies> > operator*(const __gmp_expr<T, U> &expr1, const __gmp_expr<V, W> &expr2) { return __gmp_expr<typename __gmp_resolve_expr<T, V>::value_type, __gmp_binary_expr<__gmp_expr<T, U>, __gmp_expr<V, W>, __gmp_binary_multiplies> > (expr1, expr2); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_multiplies> > operator*(const __gmp_expr<T, U> &expr, signed char t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_multiplies> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_multiplies> > operator*(signed char t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_multiplies> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_multiplies> > operator*(const __gmp_expr<T, U> &expr, unsigned char t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_multiplies> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_multiplies> > operator*(unsigned char t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_multiplies> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_multiplies> > operator*(const __gmp_expr<T, U> &expr, signed int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_multiplies> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_multiplies> > operator*(signed int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_multiplies> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_multiplies> > operator*(const __gmp_expr<T, U> &expr, unsigned int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_multiplies> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_multiplies> > operator*(unsigned int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_multiplies> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_multiplies> > operator*(const __gmp_expr<T, U> &expr, signed short int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_multiplies> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_multiplies> > operator*(signed short int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_multiplies> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_multiplies> > operator*(const __gmp_expr<T, U> &expr, unsigned short int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_multiplies> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_multiplies> > operator*(unsigned short int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_multiplies> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_multiplies> > operator*(const __gmp_expr<T, U> &expr, signed long int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_multiplies> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_multiplies> > operator*(signed long int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_multiplies> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_multiplies> > operator*(const __gmp_expr<T, U> &expr, unsigned long int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_multiplies> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_multiplies> > operator*(unsigned long int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_multiplies> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, double, __gmp_binary_multiplies> > operator*(const __gmp_expr<T, U> &expr, float t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, double, __gmp_binary_multiplies> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<double, __gmp_expr<T, U>, __gmp_binary_multiplies> > operator*(float t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<double, __gmp_expr<T, U>, __gmp_binary_multiplies> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, double, __gmp_binary_multiplies> > operator*(const __gmp_expr<T, U> &expr, double t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, double, __gmp_binary_multiplies> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<double, __gmp_expr<T, U>, __gmp_binary_multiplies> > operator*(double t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<double, __gmp_expr<T, U>, __gmp_binary_multiplies> >(t, expr); }
template <class T, class U, class V, class W> inline __gmp_expr<typename __gmp_resolve_expr<T, V>::value_type, __gmp_binary_expr<__gmp_expr<T, U>, __gmp_expr<V, W>, __gmp_binary_divides> > operator/(const __gmp_expr<T, U> &expr1, const __gmp_expr<V, W> &expr2) { return __gmp_expr<typename __gmp_resolve_expr<T, V>::value_type, __gmp_binary_expr<__gmp_expr<T, U>, __gmp_expr<V, W>, __gmp_binary_divides> > (expr1, expr2); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_divides> > operator/(const __gmp_expr<T, U> &expr, signed char t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_divides> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_divides> > operator/(signed char t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_divides> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_divides> > operator/(const __gmp_expr<T, U> &expr, unsigned char t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_divides> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_divides> > operator/(unsigned char t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_divides> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_divides> > operator/(const __gmp_expr<T, U> &expr, signed int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_divides> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_divides> > operator/(signed int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_divides> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_divides> > operator/(const __gmp_expr<T, U> &expr, unsigned int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_divides> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_divides> > operator/(unsigned int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_divides> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_divides> > operator/(const __gmp_expr<T, U> &expr, signed short int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_divides> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_divides> > operator/(signed short int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_divides> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_divides> > operator/(const __gmp_expr<T, U> &expr, unsigned short int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_divides> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_divides> > operator/(unsigned short int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_divides> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_divides> > operator/(const __gmp_expr<T, U> &expr, signed long int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_divides> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_divides> > operator/(signed long int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_divides> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_divides> > operator/(const __gmp_expr<T, U> &expr, unsigned long int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_divides> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_divides> > operator/(unsigned long int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_divides> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, double, __gmp_binary_divides> > operator/(const __gmp_expr<T, U> &expr, float t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, double, __gmp_binary_divides> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<double, __gmp_expr<T, U>, __gmp_binary_divides> > operator/(float t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<double, __gmp_expr<T, U>, __gmp_binary_divides> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, double, __gmp_binary_divides> > operator/(const __gmp_expr<T, U> &expr, double t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, double, __gmp_binary_divides> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<double, __gmp_expr<T, U>, __gmp_binary_divides> > operator/(double t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<double, __gmp_expr<T, U>, __gmp_binary_divides> >(t, expr); }
template <class T, class U, class V, class W> inline __gmp_expr<typename __gmp_resolve_expr<T, V>::value_type, __gmp_binary_expr<__gmp_expr<T, U>, __gmp_expr<V, W>, __gmp_binary_modulus> > operator%(const __gmp_expr<T, U> &expr1, const __gmp_expr<V, W> &expr2) { return __gmp_expr<typename __gmp_resolve_expr<T, V>::value_type, __gmp_binary_expr<__gmp_expr<T, U>, __gmp_expr<V, W>, __gmp_binary_modulus> > (expr1, expr2); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_modulus> > operator%(const __gmp_expr<T, U> &expr, signed char t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_modulus> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_modulus> > operator%(signed char t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_modulus> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_modulus> > operator%(const __gmp_expr<T, U> &expr, unsigned char t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_modulus> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_modulus> > operator%(unsigned char t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_modulus> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_modulus> > operator%(const __gmp_expr<T, U> &expr, signed int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_modulus> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_modulus> > operator%(signed int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_modulus> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_modulus> > operator%(const __gmp_expr<T, U> &expr, unsigned int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_modulus> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_modulus> > operator%(unsigned int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_modulus> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_modulus> > operator%(const __gmp_expr<T, U> &expr, signed short int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_modulus> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_modulus> > operator%(signed short int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_modulus> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_modulus> > operator%(const __gmp_expr<T, U> &expr, unsigned short int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_modulus> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_modulus> > operator%(unsigned short int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_modulus> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_modulus> > operator%(const __gmp_expr<T, U> &expr, signed long int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_modulus> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_modulus> > operator%(signed long int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_modulus> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_modulus> > operator%(const __gmp_expr<T, U> &expr, unsigned long int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_modulus> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_modulus> > operator%(unsigned long int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_modulus> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, double, __gmp_binary_modulus> > operator%(const __gmp_expr<T, U> &expr, float t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, double, __gmp_binary_modulus> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<double, __gmp_expr<T, U>, __gmp_binary_modulus> > operator%(float t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<double, __gmp_expr<T, U>, __gmp_binary_modulus> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, double, __gmp_binary_modulus> > operator%(const __gmp_expr<T, U> &expr, double t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, double, __gmp_binary_modulus> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<double, __gmp_expr<T, U>, __gmp_binary_modulus> > operator%(double t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<double, __gmp_expr<T, U>, __gmp_binary_modulus> >(t, expr); }
template <class T, class U, class V, class W> inline __gmp_expr<typename __gmp_resolve_expr<T, V>::value_type, __gmp_binary_expr<__gmp_expr<T, U>, __gmp_expr<V, W>, __gmp_binary_and> > operator&(const __gmp_expr<T, U> &expr1, const __gmp_expr<V, W> &expr2) { return __gmp_expr<typename __gmp_resolve_expr<T, V>::value_type, __gmp_binary_expr<__gmp_expr<T, U>, __gmp_expr<V, W>, __gmp_binary_and> > (expr1, expr2); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_and> > operator&(const __gmp_expr<T, U> &expr, signed char t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_and> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_and> > operator&(signed char t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_and> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_and> > operator&(const __gmp_expr<T, U> &expr, unsigned char t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_and> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_and> > operator&(unsigned char t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_and> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_and> > operator&(const __gmp_expr<T, U> &expr, signed int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_and> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_and> > operator&(signed int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_and> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_and> > operator&(const __gmp_expr<T, U> &expr, unsigned int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_and> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_and> > operator&(unsigned int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_and> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_and> > operator&(const __gmp_expr<T, U> &expr, signed short int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_and> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_and> > operator&(signed short int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_and> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_and> > operator&(const __gmp_expr<T, U> &expr, unsigned short int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_and> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_and> > operator&(unsigned short int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_and> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_and> > operator&(const __gmp_expr<T, U> &expr, signed long int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_and> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_and> > operator&(signed long int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_and> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_and> > operator&(const __gmp_expr<T, U> &expr, unsigned long int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_and> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_and> > operator&(unsigned long int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_and> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, double, __gmp_binary_and> > operator&(const __gmp_expr<T, U> &expr, float t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, double, __gmp_binary_and> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<double, __gmp_expr<T, U>, __gmp_binary_and> > operator&(float t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<double, __gmp_expr<T, U>, __gmp_binary_and> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, double, __gmp_binary_and> > operator&(const __gmp_expr<T, U> &expr, double t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, double, __gmp_binary_and> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<double, __gmp_expr<T, U>, __gmp_binary_and> > operator&(double t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<double, __gmp_expr<T, U>, __gmp_binary_and> >(t, expr); }
template <class T, class U, class V, class W> inline __gmp_expr<typename __gmp_resolve_expr<T, V>::value_type, __gmp_binary_expr<__gmp_expr<T, U>, __gmp_expr<V, W>, __gmp_binary_ior> > operator|(const __gmp_expr<T, U> &expr1, const __gmp_expr<V, W> &expr2) { return __gmp_expr<typename __gmp_resolve_expr<T, V>::value_type, __gmp_binary_expr<__gmp_expr<T, U>, __gmp_expr<V, W>, __gmp_binary_ior> > (expr1, expr2); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_ior> > operator|(const __gmp_expr<T, U> &expr, signed char t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_ior> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_ior> > operator|(signed char t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_ior> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_ior> > operator|(const __gmp_expr<T, U> &expr, unsigned char t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_ior> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_ior> > operator|(unsigned char t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_ior> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_ior> > operator|(const __gmp_expr<T, U> &expr, signed int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_ior> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_ior> > operator|(signed int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_ior> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_ior> > operator|(const __gmp_expr<T, U> &expr, unsigned int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_ior> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_ior> > operator|(unsigned int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_ior> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_ior> > operator|(const __gmp_expr<T, U> &expr, signed short int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_ior> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_ior> > operator|(signed short int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_ior> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_ior> > operator|(const __gmp_expr<T, U> &expr, unsigned short int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_ior> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_ior> > operator|(unsigned short int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_ior> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_ior> > operator|(const __gmp_expr<T, U> &expr, signed long int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_ior> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_ior> > operator|(signed long int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_ior> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_ior> > operator|(const __gmp_expr<T, U> &expr, unsigned long int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_ior> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_ior> > operator|(unsigned long int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_ior> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, double, __gmp_binary_ior> > operator|(const __gmp_expr<T, U> &expr, float t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, double, __gmp_binary_ior> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<double, __gmp_expr<T, U>, __gmp_binary_ior> > operator|(float t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<double, __gmp_expr<T, U>, __gmp_binary_ior> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, double, __gmp_binary_ior> > operator|(const __gmp_expr<T, U> &expr, double t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, double, __gmp_binary_ior> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<double, __gmp_expr<T, U>, __gmp_binary_ior> > operator|(double t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<double, __gmp_expr<T, U>, __gmp_binary_ior> >(t, expr); }
template <class T, class U, class V, class W> inline __gmp_expr<typename __gmp_resolve_expr<T, V>::value_type, __gmp_binary_expr<__gmp_expr<T, U>, __gmp_expr<V, W>, __gmp_binary_xor> > operator^(const __gmp_expr<T, U> &expr1, const __gmp_expr<V, W> &expr2) { return __gmp_expr<typename __gmp_resolve_expr<T, V>::value_type, __gmp_binary_expr<__gmp_expr<T, U>, __gmp_expr<V, W>, __gmp_binary_xor> > (expr1, expr2); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_xor> > operator^(const __gmp_expr<T, U> &expr, signed char t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_xor> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_xor> > operator^(signed char t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_xor> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_xor> > operator^(const __gmp_expr<T, U> &expr, unsigned char t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_xor> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_xor> > operator^(unsigned char t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_xor> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_xor> > operator^(const __gmp_expr<T, U> &expr, signed int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_xor> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_xor> > operator^(signed int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_xor> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_xor> > operator^(const __gmp_expr<T, U> &expr, unsigned int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_xor> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_xor> > operator^(unsigned int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_xor> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_xor> > operator^(const __gmp_expr<T, U> &expr, signed short int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_xor> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_xor> > operator^(signed short int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_xor> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_xor> > operator^(const __gmp_expr<T, U> &expr, unsigned short int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_xor> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_xor> > operator^(unsigned short int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_xor> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_xor> > operator^(const __gmp_expr<T, U> &expr, signed long int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_binary_xor> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_xor> > operator^(signed long int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_binary_xor> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_xor> > operator^(const __gmp_expr<T, U> &expr, unsigned long int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_binary_xor> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_xor> > operator^(unsigned long int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_binary_xor> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, double, __gmp_binary_xor> > operator^(const __gmp_expr<T, U> &expr, float t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, double, __gmp_binary_xor> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<double, __gmp_expr<T, U>, __gmp_binary_xor> > operator^(float t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<double, __gmp_expr<T, U>, __gmp_binary_xor> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, double, __gmp_binary_xor> > operator^(const __gmp_expr<T, U> &expr, double t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, double, __gmp_binary_xor> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<double, __gmp_expr<T, U>, __gmp_binary_xor> > operator^(double t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<double, __gmp_expr<T, U>, __gmp_binary_xor> >(t, expr); }

template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, mp_bitcnt_t, __gmp_binary_lshift> > operator<<(const __gmp_expr<T, U> &expr, mp_bitcnt_t l) { return __gmp_expr<T, __gmp_binary_expr <__gmp_expr<T, U>, mp_bitcnt_t, __gmp_binary_lshift> >(expr, l); }
template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, mp_bitcnt_t, __gmp_binary_rshift> > operator>>(const __gmp_expr<T, U> &expr, mp_bitcnt_t l) { return __gmp_expr<T, __gmp_binary_expr <__gmp_expr<T, U>, mp_bitcnt_t, __gmp_binary_rshift> >(expr, l); }

template <class T, class U, class V, class W> inline bool operator==(const __gmp_expr<T, U> &expr1, const __gmp_expr<V, W> &expr2) { typedef typename __gmp_resolve_expr<T, V>::value_type eval_type; __gmp_expr<eval_type, eval_type> const& temp1(expr1); __gmp_expr<eval_type, eval_type> const& temp2(expr2); return __gmp_binary_equal::eval(temp1.__get_mp(), temp2.__get_mp()); } template <class T, class U> inline bool operator==(const __gmp_expr<T, U> &expr, signed char t) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_equal::eval(temp.__get_mp(), static_cast<signed long int>(t)); } template <class T, class U> inline bool operator==(signed char t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_equal::eval(static_cast<signed long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator==(const __gmp_expr<T, U> &expr, unsigned char t) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_equal::eval(temp.__get_mp(), static_cast<unsigned long int>(t)); } template <class T, class U> inline bool operator==(unsigned char t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_equal::eval(static_cast<unsigned long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator==(const __gmp_expr<T, U> &expr, signed int t) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_equal::eval(temp.__get_mp(), static_cast<signed long int>(t)); } template <class T, class U> inline bool operator==(signed int t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_equal::eval(static_cast<signed long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator==(const __gmp_expr<T, U> &expr, unsigned int t) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_equal::eval(temp.__get_mp(), static_cast<unsigned long int>(t)); } template <class T, class U> inline bool operator==(unsigned int t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_equal::eval(static_cast<unsigned long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator==(const __gmp_expr<T, U> &expr, signed short int t) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_equal::eval(temp.__get_mp(), static_cast<signed long int>(t)); } template <class T, class U> inline bool operator==(signed short int t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_equal::eval(static_cast<signed long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator==(const __gmp_expr<T, U> &expr, unsigned short int t) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_equal::eval(temp.__get_mp(), static_cast<unsigned long int>(t)); } template <class T, class U> inline bool operator==(unsigned short int t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_equal::eval(static_cast<unsigned long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator==(const __gmp_expr<T, U> &expr, signed long int t) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_equal::eval(temp.__get_mp(), static_cast<signed long int>(t)); } template <class T, class U> inline bool operator==(signed long int t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_equal::eval(static_cast<signed long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator==(const __gmp_expr<T, U> &expr, unsigned long int t) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_equal::eval(temp.__get_mp(), static_cast<unsigned long int>(t)); } template <class T, class U> inline bool operator==(unsigned long int t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_equal::eval(static_cast<unsigned long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator==(const __gmp_expr<T, U> &expr, float t) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_equal::eval(temp.__get_mp(), static_cast<double>(t)); } template <class T, class U> inline bool operator==(float t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_equal::eval(static_cast<double>(t), temp.__get_mp()); } template <class T, class U> inline bool operator==(const __gmp_expr<T, U> &expr, double t) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_equal::eval(temp.__get_mp(), static_cast<double>(t)); } template <class T, class U> inline bool operator==(double t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_equal::eval(static_cast<double>(t), temp.__get_mp()); }
template <class T, class U, class V, class W> inline bool operator!=(const __gmp_expr<T, U> &expr1, const __gmp_expr<V, W> &expr2) { typedef typename __gmp_resolve_expr<T, V>::value_type eval_type; __gmp_expr<eval_type, eval_type> const& temp1(expr1); __gmp_expr<eval_type, eval_type> const& temp2(expr2); return ! __gmp_binary_equal::eval(temp1.__get_mp(), temp2.__get_mp()); } template <class T, class U> inline bool operator!=(const __gmp_expr<T, U> &expr, signed char t) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_equal::eval(temp.__get_mp(), static_cast<signed long int>(t)); } template <class T, class U> inline bool operator!=(signed char t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_equal::eval(static_cast<signed long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator!=(const __gmp_expr<T, U> &expr, unsigned char t) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_equal::eval(temp.__get_mp(), static_cast<unsigned long int>(t)); } template <class T, class U> inline bool operator!=(unsigned char t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_equal::eval(static_cast<unsigned long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator!=(const __gmp_expr<T, U> &expr, signed int t) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_equal::eval(temp.__get_mp(), static_cast<signed long int>(t)); } template <class T, class U> inline bool operator!=(signed int t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_equal::eval(static_cast<signed long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator!=(const __gmp_expr<T, U> &expr, unsigned int t) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_equal::eval(temp.__get_mp(), static_cast<unsigned long int>(t)); } template <class T, class U> inline bool operator!=(unsigned int t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_equal::eval(static_cast<unsigned long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator!=(const __gmp_expr<T, U> &expr, signed short int t) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_equal::eval(temp.__get_mp(), static_cast<signed long int>(t)); } template <class T, class U> inline bool operator!=(signed short int t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_equal::eval(static_cast<signed long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator!=(const __gmp_expr<T, U> &expr, unsigned short int t) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_equal::eval(temp.__get_mp(), static_cast<unsigned long int>(t)); } template <class T, class U> inline bool operator!=(unsigned short int t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_equal::eval(static_cast<unsigned long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator!=(const __gmp_expr<T, U> &expr, signed long int t) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_equal::eval(temp.__get_mp(), static_cast<signed long int>(t)); } template <class T, class U> inline bool operator!=(signed long int t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_equal::eval(static_cast<signed long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator!=(const __gmp_expr<T, U> &expr, unsigned long int t) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_equal::eval(temp.__get_mp(), static_cast<unsigned long int>(t)); } template <class T, class U> inline bool operator!=(unsigned long int t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_equal::eval(static_cast<unsigned long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator!=(const __gmp_expr<T, U> &expr, float t) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_equal::eval(temp.__get_mp(), static_cast<double>(t)); } template <class T, class U> inline bool operator!=(float t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_equal::eval(static_cast<double>(t), temp.__get_mp()); } template <class T, class U> inline bool operator!=(const __gmp_expr<T, U> &expr, double t) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_equal::eval(temp.__get_mp(), static_cast<double>(t)); } template <class T, class U> inline bool operator!=(double t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_equal::eval(static_cast<double>(t), temp.__get_mp()); }
template <class T, class U, class V, class W> inline bool operator<(const __gmp_expr<T, U> &expr1, const __gmp_expr<V, W> &expr2) { typedef typename __gmp_resolve_expr<T, V>::value_type eval_type; __gmp_expr<eval_type, eval_type> const& temp1(expr1); __gmp_expr<eval_type, eval_type> const& temp2(expr2); return __gmp_binary_less::eval(temp1.__get_mp(), temp2.__get_mp()); } template <class T, class U> inline bool operator<(const __gmp_expr<T, U> &expr, signed char t) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_less::eval(temp.__get_mp(), static_cast<signed long int>(t)); } template <class T, class U> inline bool operator<(signed char t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_less::eval(static_cast<signed long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator<(const __gmp_expr<T, U> &expr, unsigned char t) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_less::eval(temp.__get_mp(), static_cast<unsigned long int>(t)); } template <class T, class U> inline bool operator<(unsigned char t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_less::eval(static_cast<unsigned long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator<(const __gmp_expr<T, U> &expr, signed int t) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_less::eval(temp.__get_mp(), static_cast<signed long int>(t)); } template <class T, class U> inline bool operator<(signed int t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_less::eval(static_cast<signed long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator<(const __gmp_expr<T, U> &expr, unsigned int t) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_less::eval(temp.__get_mp(), static_cast<unsigned long int>(t)); } template <class T, class U> inline bool operator<(unsigned int t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_less::eval(static_cast<unsigned long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator<(const __gmp_expr<T, U> &expr, signed short int t) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_less::eval(temp.__get_mp(), static_cast<signed long int>(t)); } template <class T, class U> inline bool operator<(signed short int t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_less::eval(static_cast<signed long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator<(const __gmp_expr<T, U> &expr, unsigned short int t) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_less::eval(temp.__get_mp(), static_cast<unsigned long int>(t)); } template <class T, class U> inline bool operator<(unsigned short int t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_less::eval(static_cast<unsigned long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator<(const __gmp_expr<T, U> &expr, signed long int t) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_less::eval(temp.__get_mp(), static_cast<signed long int>(t)); } template <class T, class U> inline bool operator<(signed long int t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_less::eval(static_cast<signed long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator<(const __gmp_expr<T, U> &expr, unsigned long int t) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_less::eval(temp.__get_mp(), static_cast<unsigned long int>(t)); } template <class T, class U> inline bool operator<(unsigned long int t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_less::eval(static_cast<unsigned long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator<(const __gmp_expr<T, U> &expr, float t) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_less::eval(temp.__get_mp(), static_cast<double>(t)); } template <class T, class U> inline bool operator<(float t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_less::eval(static_cast<double>(t), temp.__get_mp()); } template <class T, class U> inline bool operator<(const __gmp_expr<T, U> &expr, double t) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_less::eval(temp.__get_mp(), static_cast<double>(t)); } template <class T, class U> inline bool operator<(double t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_less::eval(static_cast<double>(t), temp.__get_mp()); }
template <class T, class U, class V, class W> inline bool operator<=(const __gmp_expr<T, U> &expr1, const __gmp_expr<V, W> &expr2) { typedef typename __gmp_resolve_expr<T, V>::value_type eval_type; __gmp_expr<eval_type, eval_type> const& temp1(expr1); __gmp_expr<eval_type, eval_type> const& temp2(expr2); return ! __gmp_binary_greater::eval(temp1.__get_mp(), temp2.__get_mp()); } template <class T, class U> inline bool operator<=(const __gmp_expr<T, U> &expr, signed char t) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_greater::eval(temp.__get_mp(), static_cast<signed long int>(t)); } template <class T, class U> inline bool operator<=(signed char t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_greater::eval(static_cast<signed long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator<=(const __gmp_expr<T, U> &expr, unsigned char t) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_greater::eval(temp.__get_mp(), static_cast<unsigned long int>(t)); } template <class T, class U> inline bool operator<=(unsigned char t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_greater::eval(static_cast<unsigned long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator<=(const __gmp_expr<T, U> &expr, signed int t) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_greater::eval(temp.__get_mp(), static_cast<signed long int>(t)); } template <class T, class U> inline bool operator<=(signed int t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_greater::eval(static_cast<signed long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator<=(const __gmp_expr<T, U> &expr, unsigned int t) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_greater::eval(temp.__get_mp(), static_cast<unsigned long int>(t)); } template <class T, class U> inline bool operator<=(unsigned int t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_greater::eval(static_cast<unsigned long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator<=(const __gmp_expr<T, U> &expr, signed short int t) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_greater::eval(temp.__get_mp(), static_cast<signed long int>(t)); } template <class T, class U> inline bool operator<=(signed short int t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_greater::eval(static_cast<signed long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator<=(const __gmp_expr<T, U> &expr, unsigned short int t) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_greater::eval(temp.__get_mp(), static_cast<unsigned long int>(t)); } template <class T, class U> inline bool operator<=(unsigned short int t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_greater::eval(static_cast<unsigned long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator<=(const __gmp_expr<T, U> &expr, signed long int t) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_greater::eval(temp.__get_mp(), static_cast<signed long int>(t)); } template <class T, class U> inline bool operator<=(signed long int t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_greater::eval(static_cast<signed long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator<=(const __gmp_expr<T, U> &expr, unsigned long int t) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_greater::eval(temp.__get_mp(), static_cast<unsigned long int>(t)); } template <class T, class U> inline bool operator<=(unsigned long int t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_greater::eval(static_cast<unsigned long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator<=(const __gmp_expr<T, U> &expr, float t) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_greater::eval(temp.__get_mp(), static_cast<double>(t)); } template <class T, class U> inline bool operator<=(float t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_greater::eval(static_cast<double>(t), temp.__get_mp()); } template <class T, class U> inline bool operator<=(const __gmp_expr<T, U> &expr, double t) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_greater::eval(temp.__get_mp(), static_cast<double>(t)); } template <class T, class U> inline bool operator<=(double t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_greater::eval(static_cast<double>(t), temp.__get_mp()); }
template <class T, class U, class V, class W> inline bool operator>(const __gmp_expr<T, U> &expr1, const __gmp_expr<V, W> &expr2) { typedef typename __gmp_resolve_expr<T, V>::value_type eval_type; __gmp_expr<eval_type, eval_type> const& temp1(expr1); __gmp_expr<eval_type, eval_type> const& temp2(expr2); return __gmp_binary_greater::eval(temp1.__get_mp(), temp2.__get_mp()); } template <class T, class U> inline bool operator>(const __gmp_expr<T, U> &expr, signed char t) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_greater::eval(temp.__get_mp(), static_cast<signed long int>(t)); } template <class T, class U> inline bool operator>(signed char t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_greater::eval(static_cast<signed long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator>(const __gmp_expr<T, U> &expr, unsigned char t) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_greater::eval(temp.__get_mp(), static_cast<unsigned long int>(t)); } template <class T, class U> inline bool operator>(unsigned char t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_greater::eval(static_cast<unsigned long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator>(const __gmp_expr<T, U> &expr, signed int t) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_greater::eval(temp.__get_mp(), static_cast<signed long int>(t)); } template <class T, class U> inline bool operator>(signed int t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_greater::eval(static_cast<signed long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator>(const __gmp_expr<T, U> &expr, unsigned int t) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_greater::eval(temp.__get_mp(), static_cast<unsigned long int>(t)); } template <class T, class U> inline bool operator>(unsigned int t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_greater::eval(static_cast<unsigned long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator>(const __gmp_expr<T, U> &expr, signed short int t) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_greater::eval(temp.__get_mp(), static_cast<signed long int>(t)); } template <class T, class U> inline bool operator>(signed short int t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_greater::eval(static_cast<signed long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator>(const __gmp_expr<T, U> &expr, unsigned short int t) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_greater::eval(temp.__get_mp(), static_cast<unsigned long int>(t)); } template <class T, class U> inline bool operator>(unsigned short int t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_greater::eval(static_cast<unsigned long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator>(const __gmp_expr<T, U> &expr, signed long int t) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_greater::eval(temp.__get_mp(), static_cast<signed long int>(t)); } template <class T, class U> inline bool operator>(signed long int t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_greater::eval(static_cast<signed long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator>(const __gmp_expr<T, U> &expr, unsigned long int t) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_greater::eval(temp.__get_mp(), static_cast<unsigned long int>(t)); } template <class T, class U> inline bool operator>(unsigned long int t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_greater::eval(static_cast<unsigned long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator>(const __gmp_expr<T, U> &expr, float t) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_greater::eval(temp.__get_mp(), static_cast<double>(t)); } template <class T, class U> inline bool operator>(float t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_greater::eval(static_cast<double>(t), temp.__get_mp()); } template <class T, class U> inline bool operator>(const __gmp_expr<T, U> &expr, double t) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_greater::eval(temp.__get_mp(), static_cast<double>(t)); } template <class T, class U> inline bool operator>(double t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return __gmp_binary_greater::eval(static_cast<double>(t), temp.__get_mp()); }
template <class T, class U, class V, class W> inline bool operator>=(const __gmp_expr<T, U> &expr1, const __gmp_expr<V, W> &expr2) { typedef typename __gmp_resolve_expr<T, V>::value_type eval_type; __gmp_expr<eval_type, eval_type> const& temp1(expr1); __gmp_expr<eval_type, eval_type> const& temp2(expr2); return ! __gmp_binary_less::eval(temp1.__get_mp(), temp2.__get_mp()); } template <class T, class U> inline bool operator>=(const __gmp_expr<T, U> &expr, signed char t) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_less::eval(temp.__get_mp(), static_cast<signed long int>(t)); } template <class T, class U> inline bool operator>=(signed char t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_less::eval(static_cast<signed long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator>=(const __gmp_expr<T, U> &expr, unsigned char t) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_less::eval(temp.__get_mp(), static_cast<unsigned long int>(t)); } template <class T, class U> inline bool operator>=(unsigned char t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_less::eval(static_cast<unsigned long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator>=(const __gmp_expr<T, U> &expr, signed int t) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_less::eval(temp.__get_mp(), static_cast<signed long int>(t)); } template <class T, class U> inline bool operator>=(signed int t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_less::eval(static_cast<signed long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator>=(const __gmp_expr<T, U> &expr, unsigned int t) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_less::eval(temp.__get_mp(), static_cast<unsigned long int>(t)); } template <class T, class U> inline bool operator>=(unsigned int t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_less::eval(static_cast<unsigned long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator>=(const __gmp_expr<T, U> &expr, signed short int t) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_less::eval(temp.__get_mp(), static_cast<signed long int>(t)); } template <class T, class U> inline bool operator>=(signed short int t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_less::eval(static_cast<signed long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator>=(const __gmp_expr<T, U> &expr, unsigned short int t) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_less::eval(temp.__get_mp(), static_cast<unsigned long int>(t)); } template <class T, class U> inline bool operator>=(unsigned short int t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_less::eval(static_cast<unsigned long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator>=(const __gmp_expr<T, U> &expr, signed long int t) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_less::eval(temp.__get_mp(), static_cast<signed long int>(t)); } template <class T, class U> inline bool operator>=(signed long int t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_less::eval(static_cast<signed long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator>=(const __gmp_expr<T, U> &expr, unsigned long int t) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_less::eval(temp.__get_mp(), static_cast<unsigned long int>(t)); } template <class T, class U> inline bool operator>=(unsigned long int t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_less::eval(static_cast<unsigned long int>(t), temp.__get_mp()); } template <class T, class U> inline bool operator>=(const __gmp_expr<T, U> &expr, float t) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_less::eval(temp.__get_mp(), static_cast<double>(t)); } template <class T, class U> inline bool operator>=(float t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_less::eval(static_cast<double>(t), temp.__get_mp()); } template <class T, class U> inline bool operator>=(const __gmp_expr<T, U> &expr, double t) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_less::eval(temp.__get_mp(), static_cast<double>(t)); } template <class T, class U> inline bool operator>=(double t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return ! __gmp_binary_less::eval(static_cast<double>(t), temp.__get_mp()); }

template <class T, class U> inline __gmp_expr<T, __gmp_unary_expr<__gmp_expr<T, U>, __gmp_abs_function> > abs(const __gmp_expr<T, U> &expr) { return __gmp_expr<T, __gmp_unary_expr<__gmp_expr<T, U>, __gmp_abs_function> >(expr); }
template <class T, class U> inline __gmp_expr<T, __gmp_unary_expr<__gmp_expr<T, U>, __gmp_trunc_function> > trunc(const __gmp_expr<T, U> &expr) { return __gmp_expr<T, __gmp_unary_expr<__gmp_expr<T, U>, __gmp_trunc_function> >(expr); }
template <class T, class U> inline __gmp_expr<T, __gmp_unary_expr<__gmp_expr<T, U>, __gmp_floor_function> > floor(const __gmp_expr<T, U> &expr) { return __gmp_expr<T, __gmp_unary_expr<__gmp_expr<T, U>, __gmp_floor_function> >(expr); }
template <class T, class U> inline __gmp_expr<T, __gmp_unary_expr<__gmp_expr<T, U>, __gmp_ceil_function> > ceil(const __gmp_expr<T, U> &expr) { return __gmp_expr<T, __gmp_unary_expr<__gmp_expr<T, U>, __gmp_ceil_function> >(expr); }
template <class T, class U> inline __gmp_expr<T, __gmp_unary_expr<__gmp_expr<T, U>, __gmp_sqrt_function> > sqrt(const __gmp_expr<T, U> &expr) { return __gmp_expr<T, __gmp_unary_expr<__gmp_expr<T, U>, __gmp_sqrt_function> >(expr); }
template <class T, class U, class V, class W> inline __gmp_expr<typename __gmp_resolve_expr<T, V>::value_type, __gmp_binary_expr<__gmp_expr<T, U>, __gmp_expr<V, W>, __gmp_hypot_function> > hypot(const __gmp_expr<T, U> &expr1, const __gmp_expr<V, W> &expr2) { return __gmp_expr<typename __gmp_resolve_expr<T, V>::value_type, __gmp_binary_expr<__gmp_expr<T, U>, __gmp_expr<V, W>, __gmp_hypot_function> > (expr1, expr2); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_hypot_function> > hypot(const __gmp_expr<T, U> &expr, signed char t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_hypot_function> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_hypot_function> > hypot(signed char t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_hypot_function> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_hypot_function> > hypot(const __gmp_expr<T, U> &expr, unsigned char t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_hypot_function> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_hypot_function> > hypot(unsigned char t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_hypot_function> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_hypot_function> > hypot(const __gmp_expr<T, U> &expr, signed int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_hypot_function> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_hypot_function> > hypot(signed int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_hypot_function> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_hypot_function> > hypot(const __gmp_expr<T, U> &expr, unsigned int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_hypot_function> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_hypot_function> > hypot(unsigned int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_hypot_function> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_hypot_function> > hypot(const __gmp_expr<T, U> &expr, signed short int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_hypot_function> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_hypot_function> > hypot(signed short int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_hypot_function> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_hypot_function> > hypot(const __gmp_expr<T, U> &expr, unsigned short int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_hypot_function> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_hypot_function> > hypot(unsigned short int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_hypot_function> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_hypot_function> > hypot(const __gmp_expr<T, U> &expr, signed long int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, signed long int, __gmp_hypot_function> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_hypot_function> > hypot(signed long int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<signed long int, __gmp_expr<T, U>, __gmp_hypot_function> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_hypot_function> > hypot(const __gmp_expr<T, U> &expr, unsigned long int t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, unsigned long int, __gmp_hypot_function> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_hypot_function> > hypot(unsigned long int t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<unsigned long int, __gmp_expr<T, U>, __gmp_hypot_function> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, double, __gmp_hypot_function> > hypot(const __gmp_expr<T, U> &expr, float t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, double, __gmp_hypot_function> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<double, __gmp_expr<T, U>, __gmp_hypot_function> > hypot(float t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<double, __gmp_expr<T, U>, __gmp_hypot_function> >(t, expr); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, double, __gmp_hypot_function> > hypot(const __gmp_expr<T, U> &expr, double t) { return __gmp_expr <T, __gmp_binary_expr<__gmp_expr<T, U>, double, __gmp_hypot_function> >(expr, t); } template <class T, class U> inline __gmp_expr <T, __gmp_binary_expr<double, __gmp_expr<T, U>, __gmp_hypot_function> > hypot(double t, const __gmp_expr<T, U> &expr) { return __gmp_expr <T, __gmp_binary_expr<double, __gmp_expr<T, U>, __gmp_hypot_function> >(t, expr); }

template <class T, class U> inline int sgn(const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return __gmp_sgn_function::eval(temp.__get_mp()); }
template <class T, class U, class V, class W> inline int cmp(const __gmp_expr<T, U> &expr1, const __gmp_expr<V, W> &expr2) { typedef typename __gmp_resolve_expr<T, V>::value_type eval_type; __gmp_expr<eval_type, eval_type> const& temp1(expr1); __gmp_expr<eval_type, eval_type> const& temp2(expr2); return __gmp_cmp_function::eval(temp1.__get_mp(), temp2.__get_mp()); } template <class T, class U> inline int cmp(const __gmp_expr<T, U> &expr, signed char t) { __gmp_expr<T, T> const& temp(expr); return __gmp_cmp_function::eval(temp.__get_mp(), static_cast<signed long int>(t)); } template <class T, class U> inline int cmp(signed char t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return __gmp_cmp_function::eval(static_cast<signed long int>(t), temp.__get_mp()); } template <class T, class U> inline int cmp(const __gmp_expr<T, U> &expr, unsigned char t) { __gmp_expr<T, T> const& temp(expr); return __gmp_cmp_function::eval(temp.__get_mp(), static_cast<unsigned long int>(t)); } template <class T, class U> inline int cmp(unsigned char t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return __gmp_cmp_function::eval(static_cast<unsigned long int>(t), temp.__get_mp()); } template <class T, class U> inline int cmp(const __gmp_expr<T, U> &expr, signed int t) { __gmp_expr<T, T> const& temp(expr); return __gmp_cmp_function::eval(temp.__get_mp(), static_cast<signed long int>(t)); } template <class T, class U> inline int cmp(signed int t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return __gmp_cmp_function::eval(static_cast<signed long int>(t), temp.__get_mp()); } template <class T, class U> inline int cmp(const __gmp_expr<T, U> &expr, unsigned int t) { __gmp_expr<T, T> const& temp(expr); return __gmp_cmp_function::eval(temp.__get_mp(), static_cast<unsigned long int>(t)); } template <class T, class U> inline int cmp(unsigned int t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return __gmp_cmp_function::eval(static_cast<unsigned long int>(t), temp.__get_mp()); } template <class T, class U> inline int cmp(const __gmp_expr<T, U> &expr, signed short int t) { __gmp_expr<T, T> const& temp(expr); return __gmp_cmp_function::eval(temp.__get_mp(), static_cast<signed long int>(t)); } template <class T, class U> inline int cmp(signed short int t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return __gmp_cmp_function::eval(static_cast<signed long int>(t), temp.__get_mp()); } template <class T, class U> inline int cmp(const __gmp_expr<T, U> &expr, unsigned short int t) { __gmp_expr<T, T> const& temp(expr); return __gmp_cmp_function::eval(temp.__get_mp(), static_cast<unsigned long int>(t)); } template <class T, class U> inline int cmp(unsigned short int t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return __gmp_cmp_function::eval(static_cast<unsigned long int>(t), temp.__get_mp()); } template <class T, class U> inline int cmp(const __gmp_expr<T, U> &expr, signed long int t) { __gmp_expr<T, T> const& temp(expr); return __gmp_cmp_function::eval(temp.__get_mp(), static_cast<signed long int>(t)); } template <class T, class U> inline int cmp(signed long int t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return __gmp_cmp_function::eval(static_cast<signed long int>(t), temp.__get_mp()); } template <class T, class U> inline int cmp(const __gmp_expr<T, U> &expr, unsigned long int t) { __gmp_expr<T, T> const& temp(expr); return __gmp_cmp_function::eval(temp.__get_mp(), static_cast<unsigned long int>(t)); } template <class T, class U> inline int cmp(unsigned long int t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return __gmp_cmp_function::eval(static_cast<unsigned long int>(t), temp.__get_mp()); } template <class T, class U> inline int cmp(const __gmp_expr<T, U> &expr, float t) { __gmp_expr<T, T> const& temp(expr); return __gmp_cmp_function::eval(temp.__get_mp(), static_cast<double>(t)); } template <class T, class U> inline int cmp(float t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return __gmp_cmp_function::eval(static_cast<double>(t), temp.__get_mp()); } template <class T, class U> inline int cmp(const __gmp_expr<T, U> &expr, double t) { __gmp_expr<T, T> const& temp(expr); return __gmp_cmp_function::eval(temp.__get_mp(), static_cast<double>(t)); } template <class T, class U> inline int cmp(double t, const __gmp_expr<T, U> &expr) { __gmp_expr<T, T> const& temp(expr); return __gmp_cmp_function::eval(static_cast<double>(t), temp.__get_mp()); }

template <class T>
void swap(__gmp_expr<T, T>& x, __gmp_expr<T, T>& y) noexcept
{ x.swap(y); }



template <class T, class U> inline mpz_class & mpz_class::operator+=(const __gmp_expr<T, U> &expr) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, __gmp_expr<T, U>, __gmp_binary_plus> >(*this, expr)); return *this; } inline mpz_class & mpz_class::operator+=(signed char t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, signed long int, __gmp_binary_plus> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator+=(unsigned char t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, unsigned long int, __gmp_binary_plus> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator+=(signed int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, signed long int, __gmp_binary_plus> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator+=(unsigned int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, unsigned long int, __gmp_binary_plus> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator+=(signed short int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, signed long int, __gmp_binary_plus> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator+=(unsigned short int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, unsigned long int, __gmp_binary_plus> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator+=(signed long int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, signed long int, __gmp_binary_plus> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator+=(unsigned long int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, unsigned long int, __gmp_binary_plus> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator+=(float t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, double, __gmp_binary_plus> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator+=(double t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, double, __gmp_binary_plus> >(*this, t)); return *this; }
template <class T, class U> inline mpz_class & mpz_class::operator-=(const __gmp_expr<T, U> &expr) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, __gmp_expr<T, U>, __gmp_binary_minus> >(*this, expr)); return *this; } inline mpz_class & mpz_class::operator-=(signed char t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, signed long int, __gmp_binary_minus> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator-=(unsigned char t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, unsigned long int, __gmp_binary_minus> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator-=(signed int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, signed long int, __gmp_binary_minus> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator-=(unsigned int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, unsigned long int, __gmp_binary_minus> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator-=(signed short int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, signed long int, __gmp_binary_minus> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator-=(unsigned short int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, unsigned long int, __gmp_binary_minus> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator-=(signed long int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, signed long int, __gmp_binary_minus> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator-=(unsigned long int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, unsigned long int, __gmp_binary_minus> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator-=(float t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, double, __gmp_binary_minus> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator-=(double t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, double, __gmp_binary_minus> >(*this, t)); return *this; }
template <class T, class U> inline mpz_class & mpz_class::operator*=(const __gmp_expr<T, U> &expr) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, __gmp_expr<T, U>, __gmp_binary_multiplies> >(*this, expr)); return *this; } inline mpz_class & mpz_class::operator*=(signed char t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, signed long int, __gmp_binary_multiplies> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator*=(unsigned char t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, unsigned long int, __gmp_binary_multiplies> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator*=(signed int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, signed long int, __gmp_binary_multiplies> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator*=(unsigned int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, unsigned long int, __gmp_binary_multiplies> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator*=(signed short int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, signed long int, __gmp_binary_multiplies> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator*=(unsigned short int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, unsigned long int, __gmp_binary_multiplies> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator*=(signed long int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, signed long int, __gmp_binary_multiplies> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator*=(unsigned long int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, unsigned long int, __gmp_binary_multiplies> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator*=(float t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, double, __gmp_binary_multiplies> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator*=(double t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, double, __gmp_binary_multiplies> >(*this, t)); return *this; }
template <class T, class U> inline mpz_class & mpz_class::operator/=(const __gmp_expr<T, U> &expr) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, __gmp_expr<T, U>, __gmp_binary_divides> >(*this, expr)); return *this; } inline mpz_class & mpz_class::operator/=(signed char t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, signed long int, __gmp_binary_divides> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator/=(unsigned char t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, unsigned long int, __gmp_binary_divides> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator/=(signed int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, signed long int, __gmp_binary_divides> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator/=(unsigned int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, unsigned long int, __gmp_binary_divides> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator/=(signed short int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, signed long int, __gmp_binary_divides> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator/=(unsigned short int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, unsigned long int, __gmp_binary_divides> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator/=(signed long int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, signed long int, __gmp_binary_divides> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator/=(unsigned long int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, unsigned long int, __gmp_binary_divides> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator/=(float t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, double, __gmp_binary_divides> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator/=(double t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, double, __gmp_binary_divides> >(*this, t)); return *this; }
template <class T, class U> inline mpz_class & mpz_class::operator%=(const __gmp_expr<T, U> &expr) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, __gmp_expr<T, U>, __gmp_binary_modulus> >(*this, expr)); return *this; } inline mpz_class & mpz_class::operator%=(signed char t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, signed long int, __gmp_binary_modulus> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator%=(unsigned char t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, unsigned long int, __gmp_binary_modulus> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator%=(signed int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, signed long int, __gmp_binary_modulus> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator%=(unsigned int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, unsigned long int, __gmp_binary_modulus> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator%=(signed short int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, signed long int, __gmp_binary_modulus> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator%=(unsigned short int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, unsigned long int, __gmp_binary_modulus> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator%=(signed long int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, signed long int, __gmp_binary_modulus> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator%=(unsigned long int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, unsigned long int, __gmp_binary_modulus> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator%=(float t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, double, __gmp_binary_modulus> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator%=(double t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, double, __gmp_binary_modulus> >(*this, t)); return *this; }

template <class T, class U> inline mpz_class & mpz_class::operator&=(const __gmp_expr<T, U> &expr) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, __gmp_expr<T, U>, __gmp_binary_and> >(*this, expr)); return *this; } inline mpz_class & mpz_class::operator&=(signed char t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, signed long int, __gmp_binary_and> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator&=(unsigned char t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, unsigned long int, __gmp_binary_and> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator&=(signed int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, signed long int, __gmp_binary_and> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator&=(unsigned int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, unsigned long int, __gmp_binary_and> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator&=(signed short int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, signed long int, __gmp_binary_and> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator&=(unsigned short int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, unsigned long int, __gmp_binary_and> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator&=(signed long int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, signed long int, __gmp_binary_and> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator&=(unsigned long int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, unsigned long int, __gmp_binary_and> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator&=(float t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, double, __gmp_binary_and> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator&=(double t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, double, __gmp_binary_and> >(*this, t)); return *this; }
template <class T, class U> inline mpz_class & mpz_class::operator|=(const __gmp_expr<T, U> &expr) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, __gmp_expr<T, U>, __gmp_binary_ior> >(*this, expr)); return *this; } inline mpz_class & mpz_class::operator|=(signed char t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, signed long int, __gmp_binary_ior> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator|=(unsigned char t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, unsigned long int, __gmp_binary_ior> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator|=(signed int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, signed long int, __gmp_binary_ior> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator|=(unsigned int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, unsigned long int, __gmp_binary_ior> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator|=(signed short int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, signed long int, __gmp_binary_ior> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator|=(unsigned short int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, unsigned long int, __gmp_binary_ior> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator|=(signed long int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, signed long int, __gmp_binary_ior> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator|=(unsigned long int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, unsigned long int, __gmp_binary_ior> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator|=(float t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, double, __gmp_binary_ior> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator|=(double t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, double, __gmp_binary_ior> >(*this, t)); return *this; }
template <class T, class U> inline mpz_class & mpz_class::operator^=(const __gmp_expr<T, U> &expr) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, __gmp_expr<T, U>, __gmp_binary_xor> >(*this, expr)); return *this; } inline mpz_class & mpz_class::operator^=(signed char t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, signed long int, __gmp_binary_xor> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator^=(unsigned char t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, unsigned long int, __gmp_binary_xor> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator^=(signed int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, signed long int, __gmp_binary_xor> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator^=(unsigned int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, unsigned long int, __gmp_binary_xor> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator^=(signed short int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, signed long int, __gmp_binary_xor> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator^=(unsigned short int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, unsigned long int, __gmp_binary_xor> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator^=(signed long int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, signed long int, __gmp_binary_xor> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator^=(unsigned long int t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, unsigned long int, __gmp_binary_xor> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator^=(float t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, double, __gmp_binary_xor> >(*this, t)); return *this; } inline mpz_class & mpz_class::operator^=(double t) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, double, __gmp_binary_xor> >(*this, t)); return *this; }

inline mpz_class & mpz_class::operator<<=(mp_bitcnt_t l) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, mp_bitcnt_t, __gmp_binary_lshift> >(*this, l)); return *this; }
inline mpz_class & mpz_class::operator>>=(mp_bitcnt_t l) { __gmp_set_expr(mp, __gmp_expr<mpz_t, __gmp_binary_expr <mpz_class, mp_bitcnt_t, __gmp_binary_rshift> >(*this, l)); return *this; }

inline mpz_class & mpz_class::operator++() { __gmp_unary_increment::eval(mp); return *this; } inline mpz_class mpz_class::operator++(int) { mpz_class temp(*this); __gmp_unary_increment::eval(mp); return temp; }
inline mpz_class & mpz_class::operator--() { __gmp_unary_decrement::eval(mp); return *this; } inline mpz_class mpz_class::operator--(int) { mpz_class temp(*this); __gmp_unary_decrement::eval(mp); return temp; }



template <class T, class U> inline mpq_class & mpq_class::operator+=(const __gmp_expr<T, U> &expr) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, __gmp_expr<T, U>, __gmp_binary_plus> >(*this, expr)); return *this; } inline mpq_class & mpq_class::operator+=(signed char t) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, signed long int, __gmp_binary_plus> >(*this, t)); return *this; } inline mpq_class & mpq_class::operator+=(unsigned char t) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, unsigned long int, __gmp_binary_plus> >(*this, t)); return *this; } inline mpq_class & mpq_class::operator+=(signed int t) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, signed long int, __gmp_binary_plus> >(*this, t)); return *this; } inline mpq_class & mpq_class::operator+=(unsigned int t) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, unsigned long int, __gmp_binary_plus> >(*this, t)); return *this; } inline mpq_class & mpq_class::operator+=(signed short int t) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, signed long int, __gmp_binary_plus> >(*this, t)); return *this; } inline mpq_class & mpq_class::operator+=(unsigned short int t) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, unsigned long int, __gmp_binary_plus> >(*this, t)); return *this; } inline mpq_class & mpq_class::operator+=(signed long int t) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, signed long int, __gmp_binary_plus> >(*this, t)); return *this; } inline mpq_class & mpq_class::operator+=(unsigned long int t) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, unsigned long int, __gmp_binary_plus> >(*this, t)); return *this; } inline mpq_class & mpq_class::operator+=(float t) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, double, __gmp_binary_plus> >(*this, t)); return *this; } inline mpq_class & mpq_class::operator+=(double t) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, double, __gmp_binary_plus> >(*this, t)); return *this; }
template <class T, class U> inline mpq_class & mpq_class::operator-=(const __gmp_expr<T, U> &expr) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, __gmp_expr<T, U>, __gmp_binary_minus> >(*this, expr)); return *this; } inline mpq_class & mpq_class::operator-=(signed char t) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, signed long int, __gmp_binary_minus> >(*this, t)); return *this; } inline mpq_class & mpq_class::operator-=(unsigned char t) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, unsigned long int, __gmp_binary_minus> >(*this, t)); return *this; } inline mpq_class & mpq_class::operator-=(signed int t) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, signed long int, __gmp_binary_minus> >(*this, t)); return *this; } inline mpq_class & mpq_class::operator-=(unsigned int t) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, unsigned long int, __gmp_binary_minus> >(*this, t)); return *this; } inline mpq_class & mpq_class::operator-=(signed short int t) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, signed long int, __gmp_binary_minus> >(*this, t)); return *this; } inline mpq_class & mpq_class::operator-=(unsigned short int t) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, unsigned long int, __gmp_binary_minus> >(*this, t)); return *this; } inline mpq_class & mpq_class::operator-=(signed long int t) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, signed long int, __gmp_binary_minus> >(*this, t)); return *this; } inline mpq_class & mpq_class::operator-=(unsigned long int t) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, unsigned long int, __gmp_binary_minus> >(*this, t)); return *this; } inline mpq_class & mpq_class::operator-=(float t) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, double, __gmp_binary_minus> >(*this, t)); return *this; } inline mpq_class & mpq_class::operator-=(double t) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, double, __gmp_binary_minus> >(*this, t)); return *this; }
template <class T, class U> inline mpq_class & mpq_class::operator*=(const __gmp_expr<T, U> &expr) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, __gmp_expr<T, U>, __gmp_binary_multiplies> >(*this, expr)); return *this; } inline mpq_class & mpq_class::operator*=(signed char t) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, signed long int, __gmp_binary_multiplies> >(*this, t)); return *this; } inline mpq_class & mpq_class::operator*=(unsigned char t) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, unsigned long int, __gmp_binary_multiplies> >(*this, t)); return *this; } inline mpq_class & mpq_class::operator*=(signed int t) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, signed long int, __gmp_binary_multiplies> >(*this, t)); return *this; } inline mpq_class & mpq_class::operator*=(unsigned int t) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, unsigned long int, __gmp_binary_multiplies> >(*this, t)); return *this; } inline mpq_class & mpq_class::operator*=(signed short int t) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, signed long int, __gmp_binary_multiplies> >(*this, t)); return *this; } inline mpq_class & mpq_class::operator*=(unsigned short int t) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, unsigned long int, __gmp_binary_multiplies> >(*this, t)); return *this; } inline mpq_class & mpq_class::operator*=(signed long int t) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, signed long int, __gmp_binary_multiplies> >(*this, t)); return *this; } inline mpq_class & mpq_class::operator*=(unsigned long int t) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, unsigned long int, __gmp_binary_multiplies> >(*this, t)); return *this; } inline mpq_class & mpq_class::operator*=(float t) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, double, __gmp_binary_multiplies> >(*this, t)); return *this; } inline mpq_class & mpq_class::operator*=(double t) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, double, __gmp_binary_multiplies> >(*this, t)); return *this; }
template <class T, class U> inline mpq_class & mpq_class::operator/=(const __gmp_expr<T, U> &expr) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, __gmp_expr<T, U>, __gmp_binary_divides> >(*this, expr)); return *this; } inline mpq_class & mpq_class::operator/=(signed char t) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, signed long int, __gmp_binary_divides> >(*this, t)); return *this; } inline mpq_class & mpq_class::operator/=(unsigned char t) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, unsigned long int, __gmp_binary_divides> >(*this, t)); return *this; } inline mpq_class & mpq_class::operator/=(signed int t) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, signed long int, __gmp_binary_divides> >(*this, t)); return *this; } inline mpq_class & mpq_class::operator/=(unsigned int t) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, unsigned long int, __gmp_binary_divides> >(*this, t)); return *this; } inline mpq_class & mpq_class::operator/=(signed short int t) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, signed long int, __gmp_binary_divides> >(*this, t)); return *this; } inline mpq_class & mpq_class::operator/=(unsigned short int t) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, unsigned long int, __gmp_binary_divides> >(*this, t)); return *this; } inline mpq_class & mpq_class::operator/=(signed long int t) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, signed long int, __gmp_binary_divides> >(*this, t)); return *this; } inline mpq_class & mpq_class::operator/=(unsigned long int t) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, unsigned long int, __gmp_binary_divides> >(*this, t)); return *this; } inline mpq_class & mpq_class::operator/=(float t) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, double, __gmp_binary_divides> >(*this, t)); return *this; } inline mpq_class & mpq_class::operator/=(double t) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, double, __gmp_binary_divides> >(*this, t)); return *this; }

inline mpq_class & mpq_class::operator<<=(mp_bitcnt_t l) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, mp_bitcnt_t, __gmp_binary_lshift> >(*this, l)); return *this; }
inline mpq_class & mpq_class::operator>>=(mp_bitcnt_t l) { __gmp_set_expr(mp, __gmp_expr<mpq_t, __gmp_binary_expr <mpq_class, mp_bitcnt_t, __gmp_binary_rshift> >(*this, l)); return *this; }

inline mpq_class & mpq_class::operator++() { __gmp_unary_increment::eval(mp); return *this; } inline mpq_class mpq_class::operator++(int) { mpq_class temp(*this); __gmp_unary_increment::eval(mp); return temp; }
inline mpq_class & mpq_class::operator--() { __gmp_unary_decrement::eval(mp); return *this; } inline mpq_class mpq_class::operator--(int) { mpq_class temp(*this); __gmp_unary_decrement::eval(mp); return temp; }



template <class T, class U> inline mpf_class & mpf_class::operator+=(const __gmp_expr<T, U> &expr) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, __gmp_expr<T, U>, __gmp_binary_plus> >(*this, expr)); return *this; } inline mpf_class & mpf_class::operator+=(signed char t) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, signed long int, __gmp_binary_plus> >(*this, t)); return *this; } inline mpf_class & mpf_class::operator+=(unsigned char t) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, unsigned long int, __gmp_binary_plus> >(*this, t)); return *this; } inline mpf_class & mpf_class::operator+=(signed int t) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, signed long int, __gmp_binary_plus> >(*this, t)); return *this; } inline mpf_class & mpf_class::operator+=(unsigned int t) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, unsigned long int, __gmp_binary_plus> >(*this, t)); return *this; } inline mpf_class & mpf_class::operator+=(signed short int t) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, signed long int, __gmp_binary_plus> >(*this, t)); return *this; } inline mpf_class & mpf_class::operator+=(unsigned short int t) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, unsigned long int, __gmp_binary_plus> >(*this, t)); return *this; } inline mpf_class & mpf_class::operator+=(signed long int t) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, signed long int, __gmp_binary_plus> >(*this, t)); return *this; } inline mpf_class & mpf_class::operator+=(unsigned long int t) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, unsigned long int, __gmp_binary_plus> >(*this, t)); return *this; } inline mpf_class & mpf_class::operator+=(float t) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, double, __gmp_binary_plus> >(*this, t)); return *this; } inline mpf_class & mpf_class::operator+=(double t) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, double, __gmp_binary_plus> >(*this, t)); return *this; }
template <class T, class U> inline mpf_class & mpf_class::operator-=(const __gmp_expr<T, U> &expr) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, __gmp_expr<T, U>, __gmp_binary_minus> >(*this, expr)); return *this; } inline mpf_class & mpf_class::operator-=(signed char t) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, signed long int, __gmp_binary_minus> >(*this, t)); return *this; } inline mpf_class & mpf_class::operator-=(unsigned char t) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, unsigned long int, __gmp_binary_minus> >(*this, t)); return *this; } inline mpf_class & mpf_class::operator-=(signed int t) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, signed long int, __gmp_binary_minus> >(*this, t)); return *this; } inline mpf_class & mpf_class::operator-=(unsigned int t) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, unsigned long int, __gmp_binary_minus> >(*this, t)); return *this; } inline mpf_class & mpf_class::operator-=(signed short int t) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, signed long int, __gmp_binary_minus> >(*this, t)); return *this; } inline mpf_class & mpf_class::operator-=(unsigned short int t) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, unsigned long int, __gmp_binary_minus> >(*this, t)); return *this; } inline mpf_class & mpf_class::operator-=(signed long int t) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, signed long int, __gmp_binary_minus> >(*this, t)); return *this; } inline mpf_class & mpf_class::operator-=(unsigned long int t) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, unsigned long int, __gmp_binary_minus> >(*this, t)); return *this; } inline mpf_class & mpf_class::operator-=(float t) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, double, __gmp_binary_minus> >(*this, t)); return *this; } inline mpf_class & mpf_class::operator-=(double t) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, double, __gmp_binary_minus> >(*this, t)); return *this; }
template <class T, class U> inline mpf_class & mpf_class::operator*=(const __gmp_expr<T, U> &expr) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, __gmp_expr<T, U>, __gmp_binary_multiplies> >(*this, expr)); return *this; } inline mpf_class & mpf_class::operator*=(signed char t) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, signed long int, __gmp_binary_multiplies> >(*this, t)); return *this; } inline mpf_class & mpf_class::operator*=(unsigned char t) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, unsigned long int, __gmp_binary_multiplies> >(*this, t)); return *this; } inline mpf_class & mpf_class::operator*=(signed int t) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, signed long int, __gmp_binary_multiplies> >(*this, t)); return *this; } inline mpf_class & mpf_class::operator*=(unsigned int t) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, unsigned long int, __gmp_binary_multiplies> >(*this, t)); return *this; } inline mpf_class & mpf_class::operator*=(signed short int t) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, signed long int, __gmp_binary_multiplies> >(*this, t)); return *this; } inline mpf_class & mpf_class::operator*=(unsigned short int t) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, unsigned long int, __gmp_binary_multiplies> >(*this, t)); return *this; } inline mpf_class & mpf_class::operator*=(signed long int t) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, signed long int, __gmp_binary_multiplies> >(*this, t)); return *this; } inline mpf_class & mpf_class::operator*=(unsigned long int t) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, unsigned long int, __gmp_binary_multiplies> >(*this, t)); return *this; } inline mpf_class & mpf_class::operator*=(float t) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, double, __gmp_binary_multiplies> >(*this, t)); return *this; } inline mpf_class & mpf_class::operator*=(double t) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, double, __gmp_binary_multiplies> >(*this, t)); return *this; }
template <class T, class U> inline mpf_class & mpf_class::operator/=(const __gmp_expr<T, U> &expr) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, __gmp_expr<T, U>, __gmp_binary_divides> >(*this, expr)); return *this; } inline mpf_class & mpf_class::operator/=(signed char t) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, signed long int, __gmp_binary_divides> >(*this, t)); return *this; } inline mpf_class & mpf_class::operator/=(unsigned char t) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, unsigned long int, __gmp_binary_divides> >(*this, t)); return *this; } inline mpf_class & mpf_class::operator/=(signed int t) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, signed long int, __gmp_binary_divides> >(*this, t)); return *this; } inline mpf_class & mpf_class::operator/=(unsigned int t) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, unsigned long int, __gmp_binary_divides> >(*this, t)); return *this; } inline mpf_class & mpf_class::operator/=(signed short int t) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, signed long int, __gmp_binary_divides> >(*this, t)); return *this; } inline mpf_class & mpf_class::operator/=(unsigned short int t) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, unsigned long int, __gmp_binary_divides> >(*this, t)); return *this; } inline mpf_class & mpf_class::operator/=(signed long int t) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, signed long int, __gmp_binary_divides> >(*this, t)); return *this; } inline mpf_class & mpf_class::operator/=(unsigned long int t) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, unsigned long int, __gmp_binary_divides> >(*this, t)); return *this; } inline mpf_class & mpf_class::operator/=(float t) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, double, __gmp_binary_divides> >(*this, t)); return *this; } inline mpf_class & mpf_class::operator/=(double t) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, double, __gmp_binary_divides> >(*this, t)); return *this; }

inline mpf_class & mpf_class::operator<<=(mp_bitcnt_t l) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, mp_bitcnt_t, __gmp_binary_lshift> >(*this, l)); return *this; }
inline mpf_class & mpf_class::operator>>=(mp_bitcnt_t l) { __gmp_set_expr(mp, __gmp_expr<mpf_t, __gmp_binary_expr <mpf_class, mp_bitcnt_t, __gmp_binary_rshift> >(*this, l)); return *this; }

inline mpf_class & mpf_class::operator++() { __gmp_unary_increment::eval(mp); return *this; } inline mpf_class mpf_class::operator++(int) { mpf_class temp(*this); __gmp_unary_increment::eval(mp); return temp; }
inline mpf_class & mpf_class::operator--() { __gmp_unary_decrement::eval(mp); return *this; } inline mpf_class mpf_class::operator--(int) { mpf_class temp(*this); __gmp_unary_decrement::eval(mp); return temp; }





class __gmp_urandomb_value { };
class __gmp_urandomm_value { };

template <>
class __gmp_expr<mpz_t, __gmp_urandomb_value>
{
private:
  __gmp_randstate_struct *state;
  mp_bitcnt_t bits;
public:
  __gmp_expr(gmp_randstate_t s, mp_bitcnt_t l) : state(s), bits(l) { }
  void eval(mpz_ptr z) const { __gmp_rand_function::eval(z, state, bits); }
  mp_bitcnt_t get_prec() const { return __gmpf_get_default_prec(); }
};

template <>
class __gmp_expr<mpz_t, __gmp_urandomm_value>
{
private:
  __gmp_randstate_struct *state;
  mpz_class range;
public:
  __gmp_expr(gmp_randstate_t s, const mpz_class &z) : state(s), range(z) { }
  void eval(mpz_ptr z) const
  { __gmp_rand_function::eval(z, state, range.get_mpz_t()); }
  mp_bitcnt_t get_prec() const { return __gmpf_get_default_prec(); }
};

template <>
class __gmp_expr<mpf_t, __gmp_urandomb_value>
{
private:
  __gmp_randstate_struct *state;
  mp_bitcnt_t bits;
public:
  __gmp_expr(gmp_randstate_t s, mp_bitcnt_t l) : state(s), bits(l) { }
  void eval(mpf_ptr f) const
  {
    __gmp_rand_function::eval(f, state,
 (bits>0) ? bits : __gmpf_get_prec(f));
  }
  mp_bitcnt_t get_prec() const
  {
    if (bits == 0)
      return __gmpf_get_default_prec();
    else
      return bits;
  }
};

extern "C" {
  typedef void __gmp_randinit_default_t (gmp_randstate_t);
  typedef void __gmp_randinit_lc_2exp_t (gmp_randstate_t, mpz_srcptr, unsigned long int, mp_bitcnt_t);
  typedef int __gmp_randinit_lc_2exp_size_t (gmp_randstate_t, mp_bitcnt_t);
}

class gmp_randclass
{
private:
  gmp_randstate_t state;


  gmp_randclass(const gmp_randclass &);
  void operator=(const gmp_randclass &);
public:

  gmp_randclass(gmp_randalg_t alg, unsigned long int size)
  {
    switch (alg)
      {
      case GMP_RAND_ALG_LC:
      default:
 __gmp_randinit(state, alg, size);
 break;
      }
  }


  gmp_randclass(__gmp_randinit_default_t* f) { f(state); }


  gmp_randclass(__gmp_randinit_lc_2exp_t* f,
  mpz_class z, unsigned long int l1, mp_bitcnt_t l2)
  { f(state, z.get_mpz_t(), l1, l2); }


  gmp_randclass(__gmp_randinit_lc_2exp_size_t* f,
  mp_bitcnt_t size)
  {
    if (f (state, size) == 0)
      throw std::length_error ("gmp_randinit_lc_2exp_size");
  }

  ~gmp_randclass() { __gmp_randclear(state); }


  void seed();
  void seed(unsigned long int s) { __gmp_randseed_ui(state, s); }
  void seed(const mpz_class &z) { __gmp_randseed(state, z.get_mpz_t()); }


  __gmp_expr<mpz_t, __gmp_urandomb_value> get_z_bits(mp_bitcnt_t l)
  { return __gmp_expr<mpz_t, __gmp_urandomb_value>(state, l); }
  __gmp_expr<mpz_t, __gmp_urandomb_value> get_z_bits(const mpz_class &z)
  { return get_z_bits(z.get_ui()); }


  __gmp_expr<mpz_t, __gmp_urandomm_value> get_z_range(const mpz_class &z)
  { return __gmp_expr<mpz_t, __gmp_urandomm_value>(state, z); }

  __gmp_expr<mpf_t, __gmp_urandomb_value> get_f(mp_bitcnt_t prec = 0)
  { return __gmp_expr<mpf_t, __gmp_urandomb_value>(state, prec); }
};




namespace std {
  template <> class numeric_limits<mpz_class>
  {
  public:
    static const bool is_specialized = true;
    static mpz_class min() { return mpz_class(); }
    static mpz_class max() { return mpz_class(); }
    static mpz_class lowest() { return mpz_class(); }
    static const int digits = 0;
    static const int digits10 = 0;
    static const int max_digits10 = 0;
    static const bool is_signed = true;
    static const bool is_integer = true;
    static const bool is_exact = true;
    static const int radix = 2;
    static mpz_class epsilon() { return mpz_class(); }
    static mpz_class round_error() { return mpz_class(); }
    static const int min_exponent = 0;
    static const int min_exponent10 = 0;
    static const int max_exponent = 0;
    static const int max_exponent10 = 0;
    static const bool has_infinity = false;
    static const bool has_quiet_NaN = false;
    static const bool has_signaling_NaN = false;
    static const float_denorm_style has_denorm = denorm_absent;
    static const bool has_denorm_loss = false;
    static mpz_class infinity() { return mpz_class(); }
    static mpz_class quiet_NaN() { return mpz_class(); }
    static mpz_class signaling_NaN() { return mpz_class(); }
    static mpz_class denorm_min() { return mpz_class(); }
    static const bool is_iec559 = false;
    static const bool is_bounded = false;
    static const bool is_modulo = false;
    static const bool traps = false;
    static const bool tinyness_before = false;
    static const float_round_style round_style = round_toward_zero;
  };

  template <> class numeric_limits<mpq_class>
  {
  public:
    static const bool is_specialized = true;
    static mpq_class min() { return mpq_class(); }
    static mpq_class max() { return mpq_class(); }
    static mpq_class lowest() { return mpq_class(); }
    static const int digits = 0;
    static const int digits10 = 0;
    static const int max_digits10 = 0;
    static const bool is_signed = true;
    static const bool is_integer = false;
    static const bool is_exact = true;
    static const int radix = 2;
    static mpq_class epsilon() { return mpq_class(); }
    static mpq_class round_error() { return mpq_class(); }
    static const int min_exponent = 0;
    static const int min_exponent10 = 0;
    static const int max_exponent = 0;
    static const int max_exponent10 = 0;
    static const bool has_infinity = false;
    static const bool has_quiet_NaN = false;
    static const bool has_signaling_NaN = false;
    static const float_denorm_style has_denorm = denorm_absent;
    static const bool has_denorm_loss = false;
    static mpq_class infinity() { return mpq_class(); }
    static mpq_class quiet_NaN() { return mpq_class(); }
    static mpq_class signaling_NaN() { return mpq_class(); }
    static mpq_class denorm_min() { return mpq_class(); }
    static const bool is_iec559 = false;
    static const bool is_bounded = false;
    static const bool is_modulo = false;
    static const bool traps = false;
    static const bool tinyness_before = false;
    static const float_round_style round_style = round_toward_zero;
  };

  template <> class numeric_limits<mpf_class>
  {
  public:
    static const bool is_specialized = true;
    static mpf_class min() { return mpf_class(); }
    static mpf_class max() { return mpf_class(); }
    static mpf_class lowest() { return mpf_class(); }
    static const int digits = 0;
    static const int digits10 = 0;
    static const int max_digits10 = 0;
    static const bool is_signed = true;
    static const bool is_integer = false;
    static const bool is_exact = false;
    static const int radix = 2;
    static mpf_class epsilon() { return mpf_class(); }
    static mpf_class round_error() { return mpf_class(); }
    static const int min_exponent = 0;
    static const int min_exponent10 = 0;
    static const int max_exponent = 0;
    static const int max_exponent10 = 0;
    static const bool has_infinity = false;
    static const bool has_quiet_NaN = false;
    static const bool has_signaling_NaN = false;
    static const float_denorm_style has_denorm = denorm_absent;
    static const bool has_denorm_loss = false;
    static mpf_class infinity() { return mpf_class(); }
    static mpf_class quiet_NaN() { return mpf_class(); }
    static mpf_class signaling_NaN() { return mpf_class(); }
    static mpf_class denorm_min() { return mpf_class(); }
    static const bool is_iec559 = false;
    static const bool is_bounded = false;
    static const bool is_modulo = false;
    static const bool traps = false;
    static const bool tinyness_before = false;
    static const float_round_style round_style = round_indeterminate;
  };
}
# 5 "../ir/ir.h" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cassert" 1 3
# 42 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cassert" 3

# 1 "/usr/include/assert.h" 1 3 4
# 66 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 44 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cassert" 2 3
# 6 "../ir/ir.h" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/sstream" 1 3
# 37 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/sstream" 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/istream" 1 3
# 37 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/istream" 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ios" 1 3
# 37 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ios" 3





# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/ios_base.h" 1 3
# 38 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/ios_base.h" 3



# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_classes.h" 1 3
# 38 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_classes.h" 3





namespace std __attribute__ ((__visibility__ ("default")))
{
# 62 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_classes.h" 3
  class locale
  {
  public:


    typedef int category;


    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;
# 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_classes.h" 3
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
        time | monetary | messages);
# 117 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_classes.h" 3
    locale() throw();
# 126 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_classes.h" 3
    locale(const locale& __other) throw();
# 136 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_classes.h" 3
    explicit
    locale(const char* __s);
# 151 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_classes.h" 3
    locale(const locale& __base, const char* __s, category __cat);
# 164 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_classes.h" 3
    locale(const locale& __base, const locale& __add, category __cat);
# 177 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_classes.h" 3
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);


    ~locale() throw();
# 191 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_classes.h" 3
    const locale&
    operator=(const locale& __other) throw();
# 206 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_classes.h" 3
    template<typename _Facet>
      locale
      combine(const locale& __other) const;






    string
    name() const;
# 225 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_classes.h" 3
    bool
    operator==(const locale& __other) const throw();







    bool
    operator!=(const locale& __other) const throw()
    { return !(this->operator==(__other)); }
# 253 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_classes.h" 3
    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
   const basic_string<_Char, _Traits, _Alloc>& __s2) const;
# 269 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_classes.h" 3
    static locale
    global(const locale& __loc);




    static const locale&
    classic();

  private:

    _Impl* _M_impl;


    static _Impl* _S_classic;


    static _Impl* _S_global;





    static const char* const* const _S_categories;
# 304 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_classes.h" 3
    enum { _S_categories_size = 6 + 6 };


    static __gthread_once_t _S_once;


    explicit
    locale(_Impl*) throw();

    static void
    _S_initialize();

    static void
    _S_initialize_once() throw();

    static category
    _S_normalize_category(category);

    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);
  };
# 338 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_classes.h" 3
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    mutable _Atomic_word _M_refcount;


    static __c_locale _S_c_locale;


    static const char _S_c_name[2];


    static __gthread_once_t _S_once;


    static void
    _S_initialize_once();

  protected:
# 369 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_classes.h" 3
    explicit
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)
    { }


    virtual
    ~facet();

    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
         __c_locale __old = 0);

    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc) throw();

    static void
    _S_destroy_c_locale(__c_locale& __cloc);

    static __c_locale
    _S_lc_ctype_c_locale(__c_locale __cloc, const char* __s);



    static __c_locale
    _S_get_c_locale();

    __attribute__ ((__const__)) static const char*
    _S_get_c_name() throw();

  private:
    void
    _M_add_reference() const throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() const throw()
    {

                                                           ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
                                                              ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    facet(const facet&);

    facet&
    operator=(const facet&);
  };
# 436 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_classes.h" 3
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();




    mutable size_t _M_index;


    static _Atomic_word _S_refcount;

    void
    operator=(const id&);

    id(const id&);

  public:



    id() { }

    size_t
    _M_id() const throw();
  };



  class locale::_Impl
  {
  public:

    friend class locale;
    friend class locale::facet;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;

  private:

    _Atomic_word _M_refcount;
    const facet** _M_facets;
    size_t _M_facets_size;
    const facet** _M_caches;
    char** _M_names;
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];

    void
    _M_add_reference() throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() throw()
    {

                                                           ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
                                                              ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) throw();

   ~_Impl() throw();

    _Impl(const _Impl&);

    void
    operator=(const _Impl&);

    bool
    _M_check_same_name()
    {
      bool __ret = true;
      if (_M_names[1])

 for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
   __ret = __builtin_strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }

    void
    _M_replace_categories(const _Impl*, category);

    void
    _M_replace_category(const _Impl*, const locale::id* const*);

    void
    _M_replace_facet(const _Impl*, const locale::id*);

    void
    _M_install_facet(const locale::id*, const facet*);

    template<typename _Facet>
      void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }

    void
    _M_install_cache(const facet*, size_t);
  };
# 583 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_classes.h" 3
  template<typename _CharT>
    class collate : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_collate;

    public:

      static locale::id id;
# 610 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_classes.h" 3
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }
# 624 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_classes.h" 3
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }
# 641 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_classes.h" 3
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
       const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }
# 660 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_classes.h" 3
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }
# 674 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_classes.h" 3
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }


      int
      _M_compare(const _CharT*, const _CharT*) const throw();

      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const throw();

  protected:

      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }
# 703 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_classes.h" 3
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
   const _CharT* __lo2, const _CharT* __hi2) const;
# 717 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_classes.h" 3
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;
# 730 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_classes.h" 3
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };

  template<typename _CharT>
    locale::id collate<_CharT>::id;


  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const throw();

  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const throw();


  template<>
    int
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const throw();

  template<>
    size_t
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const throw();



  template<typename _CharT>
    class collate_byname : public collate<_CharT>
    {
    public:


      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_collate);
     this->_S_create_c_locale(this->_M_c_locale_collate, __s);
   }
      }

    protected:
      virtual
      ~collate_byname() { }
    };


}


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_classes.tcc" 1 3
# 38 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_classes.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Facet>
    locale::
    locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);

      try
 { _M_impl->_M_install_facet(&_Facet::id, __f); }
      catch(...)
 {
   _M_impl->_M_remove_reference();
   throw;
 }
      delete [] _M_impl->_M_names[0];
      _M_impl->_M_names[0] = 0;
    }

  template<typename _Facet>
    locale
    locale::
    combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      try
 {
   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
 }
      catch(...)
 {
   __tmp->_M_remove_reference();
   throw;
 }
      return locale(__tmp);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::
    operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
        const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
    __s2.data(), __s2.data() + __s2.length()) < 0);
    }
# 102 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_classes.tcc" 3
  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw()
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size

       && dynamic_cast<const _Facet*>(__facets[__i]));



    }
# 130 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_classes.tcc" 3
  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
        __throw_bad_cast();

      return dynamic_cast<const _Facet&>(*__facets[__i]);



    }



  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const throw ()
    { return 0; }


  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const throw ()
    { return 0; }

  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
        const _CharT* __lo2, const _CharT* __hi2) const
    {


      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);

      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();




      for (;;)
 {
   const int __res = _M_compare(__p, __q);
   if (__res)
     return __res;

   __p += char_traits<_CharT>::length(__p);
   __q += char_traits<_CharT>::length(__q);
   if (__p == __pend && __q == __qend)
     return 0;
   else if (__p == __pend)
     return -1;
   else if (__q == __qend)
     return 1;

   __p++;
   __q++;
 }
    }

  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {
      string_type __ret;


      const string_type __str(__lo, __hi);

      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();

      size_t __len = (__hi - __lo) * 2;

      _CharT* __c = new _CharT[__len];

      try
 {



   for (;;)
     {

       size_t __res = _M_transform(__c, __p, __len);


       if (__res >= __len)
  {
    __len = __res + 1;
    delete [] __c, __c = 0;
    __c = new _CharT[__len];
    __res = _M_transform(__c, __p, __len);
  }

       __ret.append(__c, __res);
       __p += char_traits<_CharT>::length(__p);
       if (__p == __pend)
  break;

       __p++;
       __ret.push_back(_CharT());
     }
 }
      catch(...)
 {
   delete [] __c;
   throw;
 }

      delete [] __c;

      return __ret;
    }

  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
 __val =
   *__lo + ((__val << 7)
     | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::
    __digits - 7)));
      return static_cast<long>(__val);
    }




  extern template class collate<char>;
  extern template class collate_byname<char>;

  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);

  extern template
    bool
    has_facet<collate<char> >(const locale&);


  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;

  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<collate<wchar_t> >(const locale&);




}
# 788 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_classes.h" 2 3
# 42 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/ios_base.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{






  enum _Ios_Fmtflags
    {
      _S_boolalpha = 1L << 0,
      _S_dec = 1L << 1,
      _S_fixed = 1L << 2,
      _S_hex = 1L << 3,
      _S_internal = 1L << 4,
      _S_left = 1L << 5,
      _S_oct = 1L << 6,
      _S_right = 1L << 7,
      _S_scientific = 1L << 8,
      _S_showbase = 1L << 9,
      _S_showpoint = 1L << 10,
      _S_showpos = 1L << 11,
      _S_skipws = 1L << 12,
      _S_unitbuf = 1L << 13,
      _S_uppercase = 1L << 14,
      _S_adjustfield = _S_left | _S_right | _S_internal,
      _S_basefield = _S_dec | _S_oct | _S_hex,
      _S_floatfield = _S_scientific | _S_fixed,
      _S_ios_fmtflags_end = 1L << 16,
      _S_ios_fmtflags_max = 2147483647,
      _S_ios_fmtflags_min = ~2147483647
    };

  inline constexpr _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }

  inline const _Ios_Fmtflags&
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }

  inline const _Ios_Fmtflags&
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }

  inline const _Ios_Fmtflags&
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }


  enum _Ios_Openmode
    {
      _S_app = 1L << 0,
      _S_ate = 1L << 1,
      _S_bin = 1L << 2,
      _S_in = 1L << 3,
      _S_out = 1L << 4,
      _S_trunc = 1L << 5,
      _S_ios_openmode_end = 1L << 16,
      _S_ios_openmode_max = 2147483647,
      _S_ios_openmode_min = ~2147483647
    };

  inline constexpr _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }

  inline const _Ios_Openmode&
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }

  inline const _Ios_Openmode&
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }

  inline const _Ios_Openmode&
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }


  enum _Ios_Iostate
    {
      _S_goodbit = 0,
      _S_badbit = 1L << 0,
      _S_eofbit = 1L << 1,
      _S_failbit = 1L << 2,
      _S_ios_iostate_end = 1L << 16,
      _S_ios_iostate_max = 2147483647,
      _S_ios_iostate_min = ~2147483647
    };

  inline constexpr _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }

  inline const _Ios_Iostate&
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }

  inline const _Ios_Iostate&
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }

  inline const _Ios_Iostate&
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }


  enum _Ios_Seekdir
    {
      _S_beg = 0,
      _S_cur = 1,
      _S_end = 2,
      _S_ios_seekdir_end = 1L << 16
    };
# 205 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/ios_base.h" 3
  class ios_base
  {
  public:







    class failure : public exception
    {
    public:


      explicit
      failure(const string& __str) throw();



      virtual
      ~failure() throw();

      virtual const char*
      what() const throw();

    private:
      string _M_msg;
    };
# 261 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/ios_base.h" 3
    typedef _Ios_Fmtflags fmtflags;


    static const fmtflags boolalpha = _S_boolalpha;


    static const fmtflags dec = _S_dec;


    static const fmtflags fixed = _S_fixed;


    static const fmtflags hex = _S_hex;




    static const fmtflags internal = _S_internal;



    static const fmtflags left = _S_left;


    static const fmtflags oct = _S_oct;



    static const fmtflags right = _S_right;


    static const fmtflags scientific = _S_scientific;



    static const fmtflags showbase = _S_showbase;



    static const fmtflags showpoint = _S_showpoint;


    static const fmtflags showpos = _S_showpos;


    static const fmtflags skipws = _S_skipws;


    static const fmtflags unitbuf = _S_unitbuf;



    static const fmtflags uppercase = _S_uppercase;


    static const fmtflags adjustfield = _S_adjustfield;


    static const fmtflags basefield = _S_basefield;


    static const fmtflags floatfield = _S_floatfield;
# 336 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/ios_base.h" 3
    typedef _Ios_Iostate iostate;



    static const iostate badbit = _S_badbit;


    static const iostate eofbit = _S_eofbit;




    static const iostate failbit = _S_failbit;


    static const iostate goodbit = _S_goodbit;
# 367 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/ios_base.h" 3
    typedef _Ios_Openmode openmode;


    static const openmode app = _S_app;


    static const openmode ate = _S_ate;




    static const openmode binary = _S_bin;


    static const openmode in = _S_in;


    static const openmode out = _S_out;


    static const openmode trunc = _S_trunc;
# 399 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/ios_base.h" 3
    typedef _Ios_Seekdir seekdir;


    static const seekdir beg = _S_beg;


    static const seekdir cur = _S_cur;


    static const seekdir end = _S_end;


    typedef int io_state;
    typedef int open_mode;
    typedef int seek_dir;

    typedef std::streampos streampos;
    typedef std::streamoff streamoff;
# 425 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/ios_base.h" 3
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };
# 442 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/ios_base.h" 3
    typedef void (*event_callback) (event __e, ios_base& __b, int __i);
# 454 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/ios_base.h" 3
    void
    register_callback(event_callback __fn, int __index);

  protected:
    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;



    struct _Callback_list
    {

      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;

      _Callback_list(ios_base::event_callback __fn, int __index,
       _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }

      void
      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }


      int
      _M_remove_reference()
      {

                                                             ;
        int __res = __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1);
        if (__res == 0)
          {
                                                                ;
          }
        return __res;
      }
    };

     _Callback_list* _M_callbacks;

    void
    _M_call_callbacks(event __ev) throw();

    void
    _M_dispose_callbacks(void) throw();


    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };


    _Words _M_word_zero;



    enum { _S_local_word_size = 8 };
    _Words _M_local_word[_S_local_word_size];


    int _M_word_size;
    _Words* _M_word;

    _Words&
    _M_grow_words(int __index, bool __iword);


    locale _M_ios_locale;

    void
    _M_init() throw();

  public:





    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();

    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };






    fmtflags
    flags() const
    { return _M_flags; }
# 567 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/ios_base.h" 3
    fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
# 583 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
# 600 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }







    void
    unsetf(fmtflags __mask)
    { _M_flags &= ~__mask; }
# 626 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/ios_base.h" 3
    streamsize
    precision() const
    { return _M_precision; }






    streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }







    streamsize
    width() const
    { return _M_width; }






    streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
# 677 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/ios_base.h" 3
    static bool
    sync_with_stdio(bool __sync = true);
# 689 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/ios_base.h" 3
    locale
    imbue(const locale& __loc) throw();
# 700 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/ios_base.h" 3
    locale
    getloc() const
    { return _M_ios_locale; }
# 711 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/ios_base.h" 3
    const locale&
    _M_getloc() const
    { return _M_ios_locale; }
# 730 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/ios_base.h" 3
    static int
    xalloc() throw();
# 746 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/ios_base.h" 3
    long&
    iword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }
# 767 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/ios_base.h" 3
    void*&
    pword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }
# 784 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/ios_base.h" 3
    virtual ~ios_base();

  protected:
    ios_base() throw ();



  private:
    ios_base(const ios_base&);

    ios_base&
    operator=(const ios_base&);
  };



  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }


  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }



  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }


  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }


  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }



  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }



  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }


}
# 43 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ios" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/streambuf" 1 3
# 37 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/streambuf" 3








namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,
     basic_streambuf<_CharT, _Traits>*, bool&);
# 119 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/streambuf" 3
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:






      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;




      typedef basic_streambuf<char_type, traits_type> __streambuf_type;


      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;

      friend streamsize
      __copy_streambufs_eof<>(basic_streambuf*, basic_streambuf*, bool&);

      template<bool _IsMove, typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
        __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
      istreambuf_iterator<_CharT2> >::__type
        find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&,
     basic_string<_CharT2, _Traits2, _Alloc>&);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        getline(basic_istream<_CharT2, _Traits2>&,
  basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);

    protected:







      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;


      locale _M_buf_locale;

  public:

      virtual
      ~basic_streambuf()
      { }
# 208 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/streambuf" 3
      locale
      pubimbue(const locale& __loc)
      {
 locale __tmp(this->getloc());
 this->imbue(__loc);
 _M_buf_locale = __loc;
 return __tmp;
      }
# 225 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/streambuf" 3
      locale
      getloc() const
      { return _M_buf_locale; }
# 238 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/streambuf" 3
      basic_streambuf*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }
# 250 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/streambuf" 3
      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }
# 262 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/streambuf" 3
      pos_type
      pubseekpos(pos_type __sp,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }




      int
      pubsync() { return this->sync(); }
# 283 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/streambuf" 3
      streamsize
      in_avail()
      {
 const streamsize __ret = this->egptr() - this->gptr();
 return __ret ? __ret : this->showmanyc();
      }
# 297 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/streambuf" 3
      int_type
      snextc()
      {
 int_type __ret = traits_type::eof();
 if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
             __ret), true))
   __ret = this->sgetc();
 return __ret;
      }
# 315 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/streambuf" 3
      int_type
      sbumpc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 else
   __ret = this->uflow();
 return __ret;
      }
# 337 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/streambuf" 3
      int_type
      sgetc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   __ret = traits_type::to_int_type(*this->gptr());
 else
   __ret = this->underflow();
 return __ret;
      }
# 356 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/streambuf" 3
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
# 371 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/streambuf" 3
      int_type
      sputbackc(char_type __c)
      {
 int_type __ret;
 const bool __testpos = this->eback() < this->gptr();
 if (__builtin_expect(!__testpos ||
        !traits_type::eq(__c, this->gptr()[-1]), false))
   __ret = this->pbackfail(traits_type::to_int_type(__c));
 else
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 return __ret;
      }
# 396 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/streambuf" 3
      int_type
      sungetc()
      {
 int_type __ret;
 if (__builtin_expect(this->eback() < this->gptr(), true))
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 else
   __ret = this->pbackfail();
 return __ret;
      }
# 423 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/streambuf" 3
      int_type
      sputc(char_type __c)
      {
 int_type __ret;
 if (__builtin_expect(this->pptr() < this->epptr(), true))
   {
     *this->pptr() = __c;
     this->pbump(1);
     __ret = traits_type::to_int_type(__c);
   }
 else
   __ret = this->overflow(traits_type::to_int_type(__c));
 return __ret;
      }
# 449 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/streambuf" 3
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }

    protected:
# 463 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/streambuf" 3
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }
# 481 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/streambuf" 3
      char_type*
      eback() const { return _M_in_beg; }

      char_type*
      gptr() const { return _M_in_cur; }

      char_type*
      egptr() const { return _M_in_end; }
# 497 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/streambuf" 3
      void
      gbump(int __n) { _M_in_cur += __n; }
# 508 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/streambuf" 3
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
 _M_in_beg = __gbeg;
 _M_in_cur = __gnext;
 _M_in_end = __gend;
      }
# 528 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/streambuf" 3
      char_type*
      pbase() const { return _M_out_beg; }

      char_type*
      pptr() const { return _M_out_cur; }

      char_type*
      epptr() const { return _M_out_end; }
# 544 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/streambuf" 3
      void
      pbump(int __n) { _M_out_cur += __n; }
# 554 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/streambuf" 3
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
 _M_out_beg = _M_out_cur = __pbeg;
 _M_out_end = __pend;
      }
# 575 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/streambuf" 3
      virtual void
      imbue(const locale& __loc)
      { }
# 590 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/streambuf" 3
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
# 601 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/streambuf" 3
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 613 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/streambuf" 3
      virtual pos_type
      seekpos(pos_type,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 626 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/streambuf" 3
      virtual int
      sync() { return 0; }
# 648 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/streambuf" 3
      virtual streamsize
      showmanyc() { return 0; }
# 664 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/streambuf" 3
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
# 686 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/streambuf" 3
      virtual int_type
      underflow()
      { return traits_type::eof(); }
# 699 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/streambuf" 3
      virtual int_type
      uflow()
      {
 int_type __ret = traits_type::eof();
 const bool __testeof = traits_type::eq_int_type(this->underflow(),
       __ret);
 if (!__testeof)
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 return __ret;
      }
# 723 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/streambuf" 3
      virtual int_type
      pbackfail(int_type __c = traits_type::eof())
      { return traits_type::eof(); }
# 741 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/streambuf" 3
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
# 767 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/streambuf" 3
      virtual int_type
      overflow(int_type __c = traits_type::eof())
      { return traits_type::eof(); }



    public:
# 782 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/streambuf" 3
      void
      stossc()
      {
 if (this->gptr() < this->egptr())
   this->gbump(1);
 else
   this->uflow();
      }



      void
      __safe_gbump(streamsize __n) { _M_in_cur += __n; }

      void
      __safe_pbump(streamsize __n) { _M_out_cur += __n; }

    private:


      basic_streambuf(const basic_streambuf& __sb)
      : _M_in_beg(__sb._M_in_beg), _M_in_cur(__sb._M_in_cur),
      _M_in_end(__sb._M_in_end), _M_out_beg(__sb._M_out_beg),
      _M_out_cur(__sb._M_out_cur), _M_out_end(__sb._M_out_cur),
      _M_buf_locale(__sb._M_buf_locale)
      { }

      basic_streambuf&
      operator=(const basic_streambuf&) { return *this; };
    };


  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>* __sbin,
     basic_streambuf<char>* __sbout, bool& __ineof);

  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,
     basic_streambuf<wchar_t>* __sbout, bool& __ineof);



}


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/streambuf.tcc" 1 3
# 38 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/streambuf.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->egptr() - this->gptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(__s, this->gptr(), __len);
       __ret += __len;
       __s += __len;
       this->__safe_gbump(__len);
     }

   if (__ret < __n)
     {
       const int_type __c = this->uflow();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    traits_type::assign(*__s++, traits_type::to_char_type(__c));
    ++__ret;
  }
       else
  break;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->epptr() - this->pptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(this->pptr(), __s, __len);
       __ret += __len;
       __s += __len;
       this->__safe_pbump(__len);
     }

   if (__ret < __n)
     {
       int_type __c = this->overflow(traits_type::to_int_type(*__s));
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    ++__ret;
    ++__s;
  }
       else
  break;
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,
     basic_streambuf<_CharT, _Traits>* __sbout,
     bool& __ineof)
    {
      streamsize __ret = 0;
      __ineof = true;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
 {
   __c = __sbout->sputc(_Traits::to_char_type(__c));
   if (_Traits::eq_int_type(__c, _Traits::eof()))
     {
       __ineof = false;
       break;
     }
   ++__ret;
   __c = __sbin->snextc();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    inline streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout)
    {
      bool __ineof;
      return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }




  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*,
        basic_streambuf<char>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>*,
     basic_streambuf<char>*, bool&);


  extern template class basic_streambuf<wchar_t>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<wchar_t>*,
        basic_streambuf<wchar_t>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>*,
     basic_streambuf<wchar_t>*, bool&);




}
# 829 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/streambuf" 2 3
# 44 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ios" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_ios.h" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_ios.h" 3



# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 1 3
# 38 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cwctype" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cwctype" 3
# 50 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cwctype" 3
# 1 "/usr/include/wctype.h" 1 3 4
# 33 "/usr/include/wctype.h" 3 4
# 1 "/usr/include/wchar.h" 1 3 4
# 34 "/usr/include/wctype.h" 2 3 4
# 52 "/usr/include/wctype.h" 3 4
typedef unsigned long int wctype_t;
# 71 "/usr/include/wctype.h" 3 4
enum
{
  __ISwupper = 0,
  __ISwlower = 1,
  __ISwalpha = 2,
  __ISwdigit = 3,
  __ISwxdigit = 4,
  __ISwspace = 5,
  __ISwprint = 6,
  __ISwgraph = 7,
  __ISwblank = 8,
  __ISwcntrl = 9,
  __ISwpunct = 10,
  __ISwalnum = 11,

  _ISwupper = ((__ISwupper) < 8 ? (int) ((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int) ((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int) ((1UL << (__ISwupper)) >> 8) : (int) ((1UL << (__ISwupper)) >> 24)))),
  _ISwlower = ((__ISwlower) < 8 ? (int) ((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int) ((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int) ((1UL << (__ISwlower)) >> 8) : (int) ((1UL << (__ISwlower)) >> 24)))),
  _ISwalpha = ((__ISwalpha) < 8 ? (int) ((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int) ((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int) ((1UL << (__ISwalpha)) >> 8) : (int) ((1UL << (__ISwalpha)) >> 24)))),
  _ISwdigit = ((__ISwdigit) < 8 ? (int) ((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int) ((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int) ((1UL << (__ISwdigit)) >> 8) : (int) ((1UL << (__ISwdigit)) >> 24)))),
  _ISwxdigit = ((__ISwxdigit) < 8 ? (int) ((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int) ((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int) ((1UL << (__ISwxdigit)) >> 8) : (int) ((1UL << (__ISwxdigit)) >> 24)))),
  _ISwspace = ((__ISwspace) < 8 ? (int) ((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int) ((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int) ((1UL << (__ISwspace)) >> 8) : (int) ((1UL << (__ISwspace)) >> 24)))),
  _ISwprint = ((__ISwprint) < 8 ? (int) ((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int) ((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int) ((1UL << (__ISwprint)) >> 8) : (int) ((1UL << (__ISwprint)) >> 24)))),
  _ISwgraph = ((__ISwgraph) < 8 ? (int) ((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int) ((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int) ((1UL << (__ISwgraph)) >> 8) : (int) ((1UL << (__ISwgraph)) >> 24)))),
  _ISwblank = ((__ISwblank) < 8 ? (int) ((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int) ((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int) ((1UL << (__ISwblank)) >> 8) : (int) ((1UL << (__ISwblank)) >> 24)))),
  _ISwcntrl = ((__ISwcntrl) < 8 ? (int) ((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int) ((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int) ((1UL << (__ISwcntrl)) >> 8) : (int) ((1UL << (__ISwcntrl)) >> 24)))),
  _ISwpunct = ((__ISwpunct) < 8 ? (int) ((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int) ((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int) ((1UL << (__ISwpunct)) >> 8) : (int) ((1UL << (__ISwpunct)) >> 24)))),
  _ISwalnum = ((__ISwalnum) < 8 ? (int) ((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int) ((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int) ((1UL << (__ISwalnum)) >> 8) : (int) ((1UL << (__ISwalnum)) >> 24))))
};



extern "C" {
# 111 "/usr/include/wctype.h" 3 4
extern int iswalnum (wint_t __wc) throw ();





extern int iswalpha (wint_t __wc) throw ();


extern int iswcntrl (wint_t __wc) throw ();



extern int iswdigit (wint_t __wc) throw ();



extern int iswgraph (wint_t __wc) throw ();




extern int iswlower (wint_t __wc) throw ();


extern int iswprint (wint_t __wc) throw ();




extern int iswpunct (wint_t __wc) throw ();




extern int iswspace (wint_t __wc) throw ();




extern int iswupper (wint_t __wc) throw ();




extern int iswxdigit (wint_t __wc) throw ();





extern int iswblank (wint_t __wc) throw ();
# 171 "/usr/include/wctype.h" 3 4
extern wctype_t wctype (const char *__property) throw ();



extern int iswctype (wint_t __wc, wctype_t __desc) throw ();
# 186 "/usr/include/wctype.h" 3 4
typedef const __int32_t *wctrans_t;







extern wint_t towlower (wint_t __wc) throw ();


extern wint_t towupper (wint_t __wc) throw ();


}
# 213 "/usr/include/wctype.h" 3 4
extern "C" {




extern wctrans_t wctrans (const char *__property) throw ();


extern wint_t towctrans (wint_t __wc, wctrans_t __desc) throw ();
# 230 "/usr/include/wctype.h" 3 4
extern int iswalnum_l (wint_t __wc, __locale_t __locale) throw ();





extern int iswalpha_l (wint_t __wc, __locale_t __locale) throw ();


extern int iswcntrl_l (wint_t __wc, __locale_t __locale) throw ();



extern int iswdigit_l (wint_t __wc, __locale_t __locale) throw ();



extern int iswgraph_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswlower_l (wint_t __wc, __locale_t __locale) throw ();


extern int iswprint_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswpunct_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswspace_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswupper_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswxdigit_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswblank_l (wint_t __wc, __locale_t __locale) throw ();



extern wctype_t wctype_l (const char *__property, __locale_t __locale)
     throw ();



extern int iswctype_l (wint_t __wc, wctype_t __desc, __locale_t __locale)
     throw ();







extern wint_t towlower_l (wint_t __wc, __locale_t __locale) throw ();


extern wint_t towupper_l (wint_t __wc, __locale_t __locale) throw ();



extern wctrans_t wctrans_l (const char *__property, __locale_t __locale)
     throw ();


extern wint_t towctrans_l (wint_t __wc, wctrans_t __desc,
      __locale_t __locale) throw ();



}
# 51 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cwctype" 2 3
# 80 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cwctype" 3
namespace std
{
  using ::wctrans_t;
  using ::wctype_t;
  using ::wint_t;

  using ::iswalnum;
  using ::iswalpha;

  using ::iswblank;

  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;
}
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cctype" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cctype" 3
# 41 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/ctype_base.h" 1 3
# 36 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/ctype_base.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  struct ctype_base
  {

    typedef const int* __to_type;



    typedef unsigned short mask;
    static const mask upper = _ISupper;
    static const mask lower = _ISlower;
    static const mask alpha = _ISalpha;
    static const mask digit = _ISdigit;
    static const mask xdigit = _ISxdigit;
    static const mask space = _ISspace;
    static const mask print = _ISprint;
    static const mask graph = _ISalpha | _ISdigit | _ISpunct;
    static const mask cntrl = _IScntrl;
    static const mask punct = _ISpunct;
    static const mask alnum = _ISalpha | _ISdigit;
  };


}
# 42 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 2 3






# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/streambuf_iterator.h" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/streambuf_iterator.h" 3




namespace std __attribute__ ((__visibility__ ("default")))
{
# 49 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/streambuf_iterator.h" 3
  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
                      _CharT*,


        _CharT>



    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

      template<bool _IsMove, typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
 __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
               istreambuf_iterator<_CharT2> >::__type
 find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

    private:







      mutable streambuf_type* _M_sbuf;
      mutable int_type _M_c;

    public:

      constexpr istreambuf_iterator() noexcept
      : _M_sbuf(0), _M_c(traits_type::eof()) { }


      istreambuf_iterator(const istreambuf_iterator&) noexcept = default;

      ~istreambuf_iterator() = default;



      istreambuf_iterator(istream_type& __s) noexcept
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }


      istreambuf_iterator(streambuf_type* __s) noexcept
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }




      char_type
      operator*() const
      {







 return traits_type::to_char_type(_M_get());
      }


      istreambuf_iterator&
      operator++()
      {


                        ;
 if (_M_sbuf)
   {
     _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return *this;
      }


      istreambuf_iterator
      operator++(int)
      {


                        ;

 istreambuf_iterator __old = *this;
 if (_M_sbuf)
   {
     __old._M_c = _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return __old;
      }





      bool
      equal(const istreambuf_iterator& __b) const
      { return _M_at_eof() == __b._M_at_eof(); }

    private:
      int_type
      _M_get() const
      {
 const int_type __eof = traits_type::eof();
 int_type __ret = __eof;
 if (_M_sbuf)
   {
     if (!traits_type::eq_int_type(_M_c, __eof))
       __ret = _M_c;
     else if (!traits_type::eq_int_type((__ret = _M_sbuf->sgetc()),
            __eof))
       _M_c = __ret;
     else
       _M_sbuf = 0;
   }
 return __ret;
      }

      bool
      _M_at_eof() const
      {
 const int_type __eof = traits_type::eof();
 return traits_type::eq_int_type(_M_get(), __eof);
      }
    };

  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }

  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }


  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;

    public:

      ostreambuf_iterator(ostream_type& __s) noexcept
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator(streambuf_type* __s) noexcept
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator&
      operator=(_CharT __c)
      {
 if (!_M_failed &&
     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
   _M_failed = true;
 return *this;
      }


      ostreambuf_iterator&
      operator*()
      { return *this; }


      ostreambuf_iterator&
      operator++(int)
      { return *this; }


      ostreambuf_iterator&
      operator++()
      { return *this; }


      bool
      failed() const noexcept
      { return _M_failed; }

      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
 if (__builtin_expect(!_M_failed, true)
     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
    false))
   _M_failed = true;
 return *this;
      }
    };


  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                           ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last,
  ostreambuf_iterator<_CharT> __result)
    {
      if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed)
 {
   bool __ineof;
   __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
   if (!__ineof)
     __result._M_failed = true;
 }
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(_CharT* __first, _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(const _CharT* __first, const _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT> __first,
     istreambuf_iterator<_CharT> __last, _CharT* __result)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof()))
     {
       const streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    traits_type::copy(__result, __sb->gptr(), __n);
    __sb->__safe_gbump(__n);
    __result += __n;
    __c = __sb->underflow();
  }
       else
  {
    *__result++ = traits_type::to_char_type(__c);
    __c = __sb->snextc();
  }
     }
 }
      return __result;
    }

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
          istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last, const _CharT& __val)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   const int_type __ival = traits_type::to_int_type(__val);
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof())
   && !traits_type::eq_int_type(__c, __ival))
     {
       streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    const _CharT* __p = traits_type::find(__sb->gptr(),
       __n, __val);
    if (__p)
      __n = __p - __sb->gptr();
    __sb->__safe_gbump(__n);
    __c = __sb->sgetc();
  }
       else
  __c = __sb->snextc();
     }

   if (!traits_type::eq_int_type(__c, traits_type::eof()))
     __first._M_c = __c;
   else
     __first._M_sbuf = 0;
 }
      return __first;
    }




}
# 49 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
# 64 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
  template<typename _Tp>
    void
    __convert_to_v(const char*, _Tp&, ios_base::iostate&,
     const __c_locale&) throw();


  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
     const __c_locale&) throw();



  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
      const _CharT* __olds, streamsize __newlen, streamsize __oldlen);
    };






  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last);




  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }


  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
 *__s = __ws[__j];
      return __s;
    }
# 142 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:


      typedef _CharT char_type;
# 161 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }
# 178 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }
# 194 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }
# 210 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }
# 224 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 239 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 253 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 268 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 285 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }
# 304 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }
# 323 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }
# 345 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
       char __dfault, char* __to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }

    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }

      virtual
      ~__ctype_abstract_base() { }
# 370 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const = 0;
# 389 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
     mask* __vec) const = 0;
# 408 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
   const char_type* __hi) const = 0;
# 427 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const = 0;
# 445 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const = 0;
# 462 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;
# 478 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const = 0;
# 495 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;
# 514 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const = 0;
# 535 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const = 0;
# 556 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const = 0;
# 581 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const = 0;
    };
# 604 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:

      typedef _CharT char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;


      static locale::id id;

      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }

   protected:
      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type __c) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type __c) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char __c) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const;
    };

  template<typename _CharT>
    locale::id ctype<_CharT>::id;
# 673 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:


      typedef char char_type;

    protected:

      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow_ok;


    public:

      static locale::id id;

      static const size_t table_size = 1 + static_cast<unsigned char>(-1);
# 710 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);
# 723 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
     size_t __refs = 0);
# 736 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      inline bool
      is(mask __m, char __c) const;
# 751 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;
# 765 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;
# 779 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;
# 794 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 811 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 827 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 844 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 864 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      {
 if (_M_widen_ok)
   return _M_widen[static_cast<unsigned char>(__c)];
 this->_M_widen_init();
 return this->do_widen(__c);
      }
# 891 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (_M_widen_ok == 1)
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_widen_ok)
   _M_widen_init();
 return this->do_widen(__lo, __hi, __to);
      }
# 922 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      {
 if (_M_narrow[static_cast<unsigned char>(__c)])
   return _M_narrow[static_cast<unsigned char>(__c)];
 const char __t = do_narrow(__c, __dfault);
 if (__t != __dfault)
   _M_narrow[static_cast<unsigned char>(__c)] = __t;
 return __t;
      }
# 955 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
      char __dfault, char* __to) const
      {
 if (__builtin_expect(_M_narrow_ok == 1, true))
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_narrow_ok)
   _M_narrow_init();
 return this->do_narrow(__lo, __hi, __dfault, __to);
      }





      const mask*
      table() const throw()
      { return _M_table; }


      static const mask*
      classic_table() throw();
    protected:







      virtual
      ~ctype();
# 1004 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const;
# 1021 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1037 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const;
# 1054 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1074 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const
      { return __c; }
# 1097 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 __builtin_memcpy(__to, __lo, __hi - __lo);
 return __hi;
      }
# 1123 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const
      { return __c; }
# 1149 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const
      {
 __builtin_memcpy(__to, __lo, __hi - __lo);
 return __hi;
      }

    private:
      void _M_narrow_init() const;
      void _M_widen_init() const;
    };
# 1174 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
  template<>
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
    {
    public:


      typedef wchar_t char_type;
      typedef wctype_t __wmask_type;

    protected:
      __c_locale _M_c_locale_ctype;


      bool _M_narrow_ok;
      char _M_narrow[128];
      wint_t _M_widen[1 + static_cast<unsigned char>(-1)];


      mask _M_bit[16];
      __wmask_type _M_wmask[16];

    public:


      static locale::id id;
# 1207 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      explicit
      ctype(size_t __refs = 0);
# 1218 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, size_t __refs = 0);

    protected:
      __wmask_type
      _M_convert_to_wmask(const mask __m) const throw();


      virtual
      ~ctype();
# 1242 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const;
# 1261 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
# 1279 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
# 1297 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;
# 1314 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const;
# 1331 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1347 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const;
# 1364 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1384 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const;
# 1406 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const;
# 1429 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const;
# 1455 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const;


      void
      _M_initialize_ctype() throw();
    };



  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef typename ctype<_CharT>::mask mask;

      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname() { };
    };


  template<>
    class ctype_byname<char> : public ctype<char>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname();
    };


  template<>
    class ctype_byname<wchar_t> : public ctype<wchar_t>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname();
    };



}



# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/ctype_inline.h" 1 3
# 37 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/ctype_inline.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  bool
  ctype<char>::
  is(mask __m, char __c) const
  { return _M_table[static_cast<unsigned char>(__c)] & __m; }

  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    while (__low < __high)
      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    return __high;
  }

  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && !(_M_table[static_cast<unsigned char>(*__low)] & __m))
      ++__low;
    return __low;
  }

  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && (_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
      ++__low;
    return __low;
  }


}
# 1512 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  class __num_base
  {
  public:


    enum
      {
 _S_ominus,
 _S_oplus,
 _S_ox,
 _S_oX,
 _S_odigits,
 _S_odigits_end = _S_odigits + 16,
 _S_oudigits = _S_odigits_end,
 _S_oudigits_end = _S_oudigits + 16,
 _S_oe = _S_odigits + 14,
 _S_oE = _S_oudigits + 14,
 _S_oend = _S_oudigits_end
      };






    static const char* _S_atoms_out;



    static const char* _S_atoms_in;

    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };



    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod) throw();
  };

  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT* _M_truename;
      size_t _M_truename_size;
      const _CharT* _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;





      _CharT _M_atoms_out[__num_base::_S_oend];





      _CharT _M_atoms_in[__num_base::_S_iend];

      bool _M_allocated;

      __numpunct_cache(size_t __refs = 0)
      : facet(__refs), _M_grouping(0), _M_grouping_size(0),
 _M_use_grouping(false),
 _M_truename(0), _M_truename_size(0), _M_falsename(0),
 _M_falsename_size(0), _M_decimal_point(_CharT()),
 _M_thousands_sep(_CharT()), _M_allocated(false)
 { }

      ~__numpunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);

      explicit
      __numpunct_cache(const __numpunct_cache&);
    };

  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_truename;
   delete [] _M_falsename;
 }
    }
# 1640 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __numpunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;

    public:

      static locale::id id;






      explicit
      numpunct(size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(); }
# 1678 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }
# 1692 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(__cloc); }
# 1706 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1719 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1750 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1763 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      string_type
      truename() const
      { return this->do_truename(); }
# 1776 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      string_type
      falsename() const
      { return this->do_falsename(); }

    protected:

      virtual
      ~numpunct();
# 1793 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1805 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1818 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1831 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }
# 1844 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }


      void
      _M_initialize_numpunct(__c_locale __cloc = 0);
    };

  template<typename _CharT>
    locale::id numpunct<_CharT>::id;

  template<>
    numpunct<char>::~numpunct();

  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);


  template<>
    numpunct<wchar_t>::~numpunct();

  template<>
    void
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);



  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_numpunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }

    protected:
      virtual
      ~numpunct_byname() { }
    };
# 1914 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
# 1935 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }
# 1961 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 1998 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2058 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2101 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

    protected:

      virtual ~num_get() { }

      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
         string&) const;

      template<typename _ValueT>
 iter_type
 _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
         _ValueT&) const;

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type
 _M_find(const _CharT2*, size_t __len, _CharT2 __c) const
 {
   int __ret = -1;
   if (__len <= 10)
     {
       if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
  __ret = __c - _CharT2('0');
     }
   else
     {
       if (__c >= _CharT2('0') && __c <= _CharT2('9'))
  __ret = __c - _CharT2('0');
       else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
  __ret = 10 + (__c - _CharT2('a'));
       else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
  __ret = 10 + (__c - _CharT2('A'));
     }
   return __ret;
 }

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,
          int>::__type
 _M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const
 {
   int __ret = -1;
   const char_type* __q = char_traits<_CharT2>::find(__zero, __len, __c);
   if (__q)
     {
       __ret = __q - __zero;
       if (__ret > 15)
  __ret -= 6;
     }
   return __ret;
 }
# 2172 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned short& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned int& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, float&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
      double&) const;







      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
      long double&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, void*&) const;
# 2235 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
    };

  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
# 2253 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 2274 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }
# 2292 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2334 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   unsigned long __v) const
      { return this->do_put(__s, __io, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   unsigned long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2397 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   long double __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2422 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   const void* __v) const
      { return this->do_put(__s, __io, __fill, __v); }

    protected:
      template<typename _ValueT>
 iter_type
 _M_insert_float(iter_type, ios_base& __io, char_type __fill,
   char __mod, _ValueT __v) const;

      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
       char_type __sep, const char_type* __p, char_type* __new,
       char_type* __cs, int& __len) const;

      template<typename _ValueT>
 iter_type
 _M_insert_int(iter_type, ios_base& __io, char_type __fill,
        _ValueT __v) const;

      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
     char_type __sep, ios_base& __io, char_type* __new,
     char_type* __cs, int& __len) const;

      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
      char_type* __new, const char_type* __cs, int& __len) const;


      virtual
      ~num_put() { };
# 2470 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const;

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type, ios_base&, char_type, double) const;






      virtual iter_type
      do_put(iter_type, ios_base&, char_type, long double) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type, const void*) const;







    };

  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;
# 2528 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 3
  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }


  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }


  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }


  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }


  template<typename _CharT>
    inline bool
    islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }


  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }


  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }


  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }


  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }


  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }


  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }


  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }


  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }


}


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.tcc" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };


  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
 const size_t __i = numpunct<_CharT>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __numpunct_cache<_CharT>* __tmp = 0;
     try
       {
  __tmp = new __numpunct_cache<_CharT>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };

  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      _M_allocated = true;

      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);

      char* __grouping = 0;
      _CharT* __truename = 0;
      _CharT* __falsename = 0;
      try
 {
   _M_grouping_size = __np.grouping().size();
   __grouping = new char[_M_grouping_size];
   __np.grouping().copy(__grouping, _M_grouping_size);
   _M_grouping = __grouping;
   _M_use_grouping = (_M_grouping_size
        && static_cast<signed char>(_M_grouping[0]) > 0
        && (_M_grouping[0]
     != __gnu_cxx::__numeric_traits<char>::__max));

   _M_truename_size = __np.truename().size();
   __truename = new _CharT[_M_truename_size];
   __np.truename().copy(__truename, _M_truename_size);
   _M_truename = __truename;

   _M_falsename_size = __np.falsename().size();
   __falsename = new _CharT[_M_falsename_size];
   __np.falsename().copy(__falsename, _M_falsename_size);
   _M_falsename = __falsename;

   _M_decimal_point = __np.decimal_point();
   _M_thousands_sep = __np.thousands_sep();

   const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
   __ct.widen(__num_base::_S_atoms_out,
       __num_base::_S_atoms_out
       + __num_base::_S_oend, _M_atoms_out);
   __ct.widen(__num_base::_S_atoms_in,
       __num_base::_S_atoms_in
       + __num_base::_S_iend, _M_atoms_in);
 }
      catch(...)
 {
   delete [] __grouping;
   delete [] __truename;
   delete [] __falsename;
   throw;
 }
    }
# 136 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.tcc" 3
  __attribute__ ((__pure__)) bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp) throw ();



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      typedef __numpunct_cache<_CharT> __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;
      char_type __c = char_type();


      bool __testeof = __beg == __end;


      if (!__testeof)
 {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
     {
       __xtrc += __plus ? '+' : '-';
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 }


      bool __found_mantissa = false;
      int __sep_pos = 0;
      while (!__testeof)
 {
   if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       || __c == __lc->_M_decimal_point)
     break;
   else if (__c == __lit[__num_base::_S_izero])
     {
       if (!__found_mantissa)
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       ++__sep_pos;

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
   else
     break;
 }


      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
 __found_grouping.reserve(32);
      const char_type* __lit_zero = __lit + __num_base::_S_izero;

      if (!__lc->_M_allocated)

 while (!__testeof)
   {
     const int __digit = _M_find(__lit_zero, 10, __c);
     if (__digit != -1)
       {
  __xtrc += '0' + __digit;
  __found_mantissa = true;
       }
     else if (__c == __lc->_M_decimal_point
       && !__found_dec && !__found_sci)
       {
  __xtrc += '.';
  __found_dec = true;
       }
     else if ((__c == __lit[__num_base::_S_ie]
        || __c == __lit[__num_base::_S_iE])
       && !__found_sci && __found_mantissa)
       {

  __xtrc += 'e';
  __found_sci = true;


  if (++__beg != __end)
    {
      __c = *__beg;
      const bool __plus = __c == __lit[__num_base::_S_iplus];
      if (__plus || __c == __lit[__num_base::_S_iminus])
        __xtrc += __plus ? '+' : '-';
      else
        continue;
    }
  else
    {
      __testeof = true;
      break;
    }
       }
     else
       break;

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }
      else
 while (!__testeof)
   {


     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       {
  if (!__found_dec && !__found_sci)
    {


      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {


   __xtrc.clear();
   break;
        }
    }
  else
    break;
       }
     else if (__c == __lc->_M_decimal_point)
       {
  if (!__found_dec && !__found_sci)
    {



      if (__found_grouping.size())
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += '.';
      __found_dec = true;
    }
  else
    break;
       }
     else
       {
  const char_type* __q =
    __traits_type::find(__lit_zero, 10, __c);
  if (__q)
    {
      __xtrc += '0' + (__q - __lit_zero);
      __found_mantissa = true;
      ++__sep_pos;
    }
  else if ((__c == __lit[__num_base::_S_ie]
     || __c == __lit[__num_base::_S_iE])
    && !__found_sci && __found_mantissa)
    {

      if (__found_grouping.size() && !__found_dec)
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += 'e';
      __found_sci = true;


      if (++__beg != __end)
        {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping
     && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
        __xtrc += __plus ? '+' : '-';
   else
     continue;
        }
      else
        {
   __testeof = true;
   break;
        }
    }
  else
    break;
       }

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }



      if (__found_grouping.size())
        {

   if (!__found_dec && !__found_sci)
     __found_grouping += static_cast<char>(__sep_pos);

          if (!std::__verify_grouping(__lc->_M_grouping,
          __lc->_M_grouping_size,
          __found_grouping))
     __err = ios_base::failbit;
        }

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT> __traits_type;
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_in;
 char_type __c = char_type();


 const ios_base::fmtflags __basefield = __io.flags()
                                        & ios_base::basefield;
 const bool __oct = __basefield == ios_base::oct;
 int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);


 bool __testeof = __beg == __end;


 bool __negative = false;
 if (!__testeof)
   {
     __c = *__beg;
     __negative = __c == __lit[__num_base::_S_iminus];
     if ((__negative || __c == __lit[__num_base::_S_iplus])
  && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  && !(__c == __lc->_M_decimal_point))
       {
  if (++__beg != __end)
    __c = *__beg;
  else
    __testeof = true;
       }
   }



 bool __found_zero = false;
 int __sep_pos = 0;
 while (!__testeof)
   {
     if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  || __c == __lc->_M_decimal_point)
       break;
     else if (__c == __lit[__num_base::_S_izero]
       && (!__found_zero || __base == 10))
       {
  __found_zero = true;
  ++__sep_pos;
  if (__basefield == 0)
    __base = 8;
  if (__base == 8)
    __sep_pos = 0;
       }
     else if (__found_zero
       && (__c == __lit[__num_base::_S_ix]
    || __c == __lit[__num_base::_S_iX]))
       {
  if (__basefield == 0)
    __base = 16;
  if (__base == 16)
    {
      __found_zero = false;
      __sep_pos = 0;
    }
  else
    break;
       }
     else
       break;

     if (++__beg != __end)
       {
  __c = *__beg;
  if (!__found_zero)
    break;
       }
     else
       __testeof = true;
   }



 const size_t __len = (__base == 16 ? __num_base::_S_iend
         - __num_base::_S_izero : __base);


 string __found_grouping;
 if (__lc->_M_use_grouping)
   __found_grouping.reserve(32);
 bool __testfail = false;
 bool __testoverflow = false;
 const __unsigned_type __max =
   (__negative && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
   ? -__gnu_cxx::__numeric_traits<_ValueT>::__min
   : __gnu_cxx::__numeric_traits<_ValueT>::__max;
 const __unsigned_type __smax = __max / __base;
 __unsigned_type __result = 0;
 int __digit = 0;
 const char_type* __lit_zero = __lit + __num_base::_S_izero;

 if (!__lc->_M_allocated)

   while (!__testeof)
     {
       __digit = _M_find(__lit_zero, __len, __c);
       if (__digit == -1)
  break;

       if (__result > __smax)
  __testoverflow = true;
       else
  {
    __result *= __base;
    __testoverflow |= __result > __max - __digit;
    __result += __digit;
    ++__sep_pos;
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 else
   while (!__testeof)
     {


       if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  {


    if (__sep_pos)
      {
        __found_grouping += static_cast<char>(__sep_pos);
        __sep_pos = 0;
      }
    else
      {
        __testfail = true;
        break;
      }
  }
       else if (__c == __lc->_M_decimal_point)
  break;
       else
  {
    const char_type* __q =
      __traits_type::find(__lit_zero, __len, __c);
    if (!__q)
      break;

    __digit = __q - __lit_zero;
    if (__digit > 15)
      __digit -= 6;
    if (__result > __smax)
      __testoverflow = true;
    else
      {
        __result *= __base;
        __testoverflow |= __result > __max - __digit;
        __result += __digit;
        ++__sep_pos;
      }
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }



 if (__found_grouping.size())
   {

     __found_grouping += static_cast<char>(__sep_pos);

     if (!std::__verify_grouping(__lc->_M_grouping,
     __lc->_M_grouping_size,
     __found_grouping))
       __err = ios_base::failbit;
   }



 if ((!__sep_pos && !__found_zero && !__found_grouping.size())
     || __testfail)
   {
     __v = 0;
     __err = ios_base::failbit;
   }
 else if (__testoverflow)
   {
     if (__negative
  && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__min;
     else
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__max;
     __err = ios_base::failbit;
   }
 else
   __v = __negative ? -__result : __result;

 if (__testeof)
   __err |= ios_base::eofbit;
 return __beg;
      }



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {



   long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
   if (__l == 0 || __l == 1)
     __v = bool(__l);
   else
     {


       __v = true;
       __err = ios_base::failbit;
       if (__beg == __end)
  __err |= ios_base::eofbit;
     }
        }
      else
        {

   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   bool __testf = true;
   bool __testt = true;
   bool __donef = __lc->_M_falsename_size == 0;
   bool __donet = __lc->_M_truename_size == 0;
   bool __testeof = false;
   size_t __n = 0;
   while (!__donef || !__donet)
     {
       if (__beg == __end)
  {
    __testeof = true;
    break;
  }

       const char_type __c = *__beg;

       if (!__donef)
  __testf = __c == __lc->_M_falsename[__n];

       if (!__testf && __donet)
  break;

       if (!__donet)
  __testt = __c == __lc->_M_truename[__n];

       if (!__testt && __donef)
  break;

       if (!__testt && !__testf)
  break;

       ++__n;
       ++__beg;

       __donef = !__testf || __n >= __lc->_M_falsename_size;
       __donet = !__testt || __n >= __lc->_M_truename_size;
     }
   if (__testf && __n == __lc->_M_falsename_size && __n)
     {
       __v = false;
       if (__testt && __n == __lc->_M_truename_size)
  __err = ios_base::failbit;
       else
  __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else if (__testt && __n == __lc->_M_truename_size && __n)
     {
       __v = true;
       __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else
     {


       __v = false;
       __err = ios_base::failbit;
       if (__testeof)
  __err |= ios_base::eofbit;
     }
 }
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
# 730 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {

      typedef ios_base::fmtflags fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags((__fmt & ~ios_base::basefield) | ios_base::hex);

      typedef __gnu_cxx::__conditional_type<(sizeof(void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      _UIntPtrType __ul;
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);


      __io.flags(__fmt);

      __v = reinterpret_cast<void*>(__ul);
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
    _CharT* __new, const _CharT* __cs, int& __len) const
    {


      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new,
        __cs, __w, __len);
      __len = static_cast<int>(__w);
    }



  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
    ios_base::fmtflags __flags, bool __dec)
    {
      _CharT* __buf = __bufend;
      if (__builtin_expect(__dec, true))
 {

   do
     {
       *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
       __v /= 10;
     }
   while (__v != 0);
 }
      else if ((__flags & ios_base::basefield) == ios_base::oct)
 {

   do
     {
       *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];
       __v >>= 3;
     }
   while (__v != 0);
 }
      else
 {

   const bool __uppercase = __flags & ios_base::uppercase;
   const int __case_offset = __uppercase ? __num_base::_S_oudigits
                                         : __num_base::_S_odigits;
   do
     {
       *--__buf = __lit[(__v & 0xf) + __case_offset];
       __v >>= 4;
     }
   while (__v != 0);
 }
      return __bufend - __buf;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
   ios_base&, _CharT* __new, _CharT* __cs, int& __len) const
    {
      _CharT* __p = std::__add_grouping(__new, __sep, __grouping,
     __grouping_size, __cs, __cs + __len);
      __len = __p - __new;
    }

  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
      _ValueT __v) const
      {
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_out;
 const ios_base::fmtflags __flags = __io.flags();


 const int __ilen = 5 * sizeof(_ValueT);
 _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __ilen));



 const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
 const bool __dec = (__basefield != ios_base::oct
       && __basefield != ios_base::hex);
 const __unsigned_type __u = ((__v > 0 || !__dec)
         ? __unsigned_type(__v)
         : -__unsigned_type(__v));
  int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
 __cs += __ilen - __len;


 if (__lc->_M_use_grouping)
   {


     _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * (__len + 1)
          * 2));
     _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
     __cs = __cs2 + 2;
   }


 if (__builtin_expect(__dec, true))
   {

     if (__v >= 0)
       {
  if (bool(__flags & ios_base::showpos)
      && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
    *--__cs = __lit[__num_base::_S_oplus], ++__len;
       }
     else
       *--__cs = __lit[__num_base::_S_ominus], ++__len;
   }
 else if (bool(__flags & ios_base::showbase) && __v)
   {
     if (__basefield == ios_base::oct)
       *--__cs = __lit[__num_base::_S_odigits], ++__len;
     else
       {

  const bool __uppercase = __flags & ios_base::uppercase;
  *--__cs = __lit[__num_base::_S_ox + __uppercase];

  *--__cs = __lit[__num_base::_S_odigits];
  __len += 2;
       }
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __cs3, __cs, __len);
     __cs = __cs3;
   }
 __io.width(0);



 return std::__write(__s, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT* __p, _CharT* __new,
     _CharT* __cs, int& __len) const
    {



      const int __declen = __p ? __p - __cs : __len;
      _CharT* __p2 = std::__add_grouping(__new, __sep, __grouping,
      __grouping_size,
      __cs, __cs + __declen);


      int __newlen = __p2 - __new;
      if (__p)
 {
   char_traits<_CharT>::copy(__p2, __p, __len - __declen);
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }
# 966 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
         _ValueT __v) const
      {
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);


 const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();

 const int __max_digits =
   __gnu_cxx::__numeric_traits<_ValueT>::__digits10;


 int __len;

 char __fbuf[16];
 __num_base::_S_format_float(__io, __fbuf, __mod);




 int __cs_size = __max_digits * 3;
 char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
 __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
          __fbuf, __prec, __v);


 if (__len >= __cs_size)
   {
     __cs_size = __len + 1;
     __cs = static_cast<char*>(__builtin_alloca(__cs_size));
     __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
       __fbuf, __prec, __v);
   }
# 1027 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.tcc" 3
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __len));
 __ctype.widen(__cs, __cs + __len, __ws);


 _CharT* __wp = 0;
 const char* __p = char_traits<char>::find(__cs, __len, '.');
 if (__p)
   {
     __wp = __ws + (__p - __cs);
     *__wp = __lc->_M_decimal_point;
   }




 if (__lc->_M_use_grouping
     && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9'
          && __cs[1] >= '0' && __cs[2] >= '0')))
   {


     _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len * 2));

     streamsize __off = 0;
     if (__cs[0] == '-' || __cs[0] == '+')
       {
  __off = 1;
  __ws2[0] = __ws[0];
  __len -= 1;
       }

     _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
      __lc->_M_thousands_sep, __wp, __ws2 + __off,
      __ws + __off, __len);
     __len += __off;

     __ws = __ws2;
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __ws3, __ws, __len);
     __ws = __ws3;
   }
 __io.width(0);



 return std::__write(__s, __ws, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   const _CharT* __name = __v ? __lc->_M_truename
                              : __lc->_M_falsename;
   int __len = __v ? __lc->_M_truename_size
                   : __lc->_M_falsename_size;

   const streamsize __w = __io.width();
   if (__w > static_cast<streamsize>(__len))
     {
       const streamsize __plen = __w - __len;
       _CharT* __ps
  = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
       * __plen));

       char_traits<_CharT>::assign(__ps, __plen, __fill);
       __io.width(0);

       if ((__flags & ios_base::adjustfield) == ios_base::left)
  {
    __s = std::__write(__s, __name, __len);
    __s = std::__write(__s, __ps, __plen);
  }
       else
  {
    __s = std::__write(__s, __ps, __plen);
    __s = std::__write(__s, __name, __len);
  }
       return __s;
     }
   __io.width(0);
   __s = std::__write(__s, __name, __len);
 }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }
# 1152 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
    long double __v) const
    { return _M_insert_float(__s, __io, __fill, 'L', __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
      | ios_base::uppercase);
      __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));

      typedef __gnu_cxx::__conditional_type<(sizeof(const void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      __s = _M_insert_int(__s, __io, __fill,
     reinterpret_cast<_UIntPtrType>(__v));
      __io.flags(__flags);
      return __s;
    }
# 1189 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
       _CharT* __news, const _CharT* __olds,
       streamsize __newlen, streamsize __oldlen)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;


      if (__adjust == ios_base::left)
 {
   _Traits::copy(__news, __olds, __oldlen);
   _Traits::assign(__news + __oldlen, __plen, __fill);
   return;
 }

      size_t __mod = 0;
      if (__adjust == ios_base::internal)
 {



          const locale& __loc = __io._M_getloc();
   const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

   if (__ctype.widen('-') == __olds[0]
       || __ctype.widen('+') == __olds[0])
     {
       __news[0] = __olds[0];
       __mod = 1;
       ++__news;
     }
   else if (__ctype.widen('0') == __olds[0]
     && __oldlen > 1
     && (__ctype.widen('x') == __olds[1]
         || __ctype.widen('X') == __olds[1]))
     {
       __news[0] = __olds[0];
       __news[1] = __olds[1];
       __mod = 2;
       __news += 2;
     }

 }
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }

  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last)
    {
      size_t __idx = 0;
      size_t __ctr = 0;

      while (__last - __first > __gbeg[__idx]
      && static_cast<signed char>(__gbeg[__idx]) > 0
      && __gbeg[__idx] != __gnu_cxx::__numeric_traits<char>::__max)
 {
   __last -= __gbeg[__idx];
   __idx < __gsize - 1 ? ++__idx : ++__ctr;
 }

      while (__first != __last)
 *__s++ = *__first++;

      while (__ctr--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      while (__idx--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      return __s;
    }




  extern template class numpunct<char>;
  extern template class numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class ctype_byname<char>;

  extern template
    const ctype<char>&
    use_facet<ctype<char> >(const locale&);

  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);

  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);

  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);

  extern template
    bool
    has_facet<ctype<char> >(const locale&);

  extern template
    bool
    has_facet<numpunct<char> >(const locale&);

  extern template
    bool
    has_facet<num_put<char> >(const locale&);

  extern template
    bool
    has_facet<num_get<char> >(const locale&);


  extern template class numpunct<wchar_t>;
  extern template class numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class ctype_byname<wchar_t>;

  extern template
    const ctype<wchar_t>&
    use_facet<ctype<wchar_t> >(const locale&);

  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);

  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);

  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);

 extern template
    bool
    has_facet<ctype<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<numpunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_get<wchar_t> >(const locale&);




}
# 2609 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets.h" 2 3
# 38 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_ios.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 __throw_bad_cast();
      return *__f;
    }
# 65 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_ios.h" 3
  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:






      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;






      typedef ctype<_CharT> __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
           __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
           __num_get_type;



    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;


      const __ctype_type* _M_ctype;

      const __num_put_type* _M_num_put;

      const __num_get_type* _M_num_get;

    public:







      operator void*() const
      { return this->fail() ? 0 : const_cast<basic_ios*>(this); }

      bool
      operator!() const
      { return this->fail(); }
# 130 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_ios.h" 3
      iostate
      rdstate() const
      { return _M_streambuf_state; }
# 141 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_ios.h" 3
      void
      clear(iostate __state = goodbit);







      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }




      void
      _M_setstate(iostate __state)
      {


 _M_streambuf_state |= __state;
 if (this->exceptions() & __state)
   throw;
      }







      bool
      good() const
      { return this->rdstate() == 0; }







      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
# 194 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_ios.h" 3
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }







      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
# 215 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_ios.h" 3
      iostate
      exceptions() const
      { return _M_exception; }
# 250 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_ios.h" 3
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }







      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
 _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }







      virtual
      ~basic_ios() { }
# 288 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
# 300 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }







      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
# 340 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_ios.h" 3
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);
# 354 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_ios.h" 3
      basic_ios&
      copyfmt(const basic_ios& __rhs);







      char_type
      fill() const
      {
 if (!_M_fill_init)
   {
     _M_fill = this->widen(' ');
     _M_fill_init = true;
   }
 return _M_fill;
      }
# 383 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_ios.h" 3
      char_type
      fill(char_type __ch)
      {
 char_type __old = this->fill();
 _M_fill = __ch;
 return __old;
      }
# 403 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_ios.h" 3
      locale
      imbue(const locale& __loc);
# 423 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_ios.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return __check_facet(_M_ctype).narrow(__c, __dfault); }
# 442 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_ios.h" 3
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }

    protected:







      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
 _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }







      void
      init(basic_streambuf<_CharT, _Traits>* __sb);

      void
      _M_cache_locale(const locale& __loc);
    };


}


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_ios.tcc" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_ios.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
 _M_streambuf_state = __state;
      else
   _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
 __throw_ios_failure(("basic_ios::clear"));
    }

  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }

  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {


      if (this != &__rhs)
 {




   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
                      _M_local_word : new _Words[__rhs._M_word_size];


   _Callback_list* __cb = __rhs._M_callbacks;
   if (__cb)
     __cb->_M_add_reference();
   _M_call_callbacks(erase_event);
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks();


   _M_callbacks = __cb;
   for (int __i = 0; __i < __rhs._M_word_size; ++__i)
     __words[__i] = __rhs._M_word[__i];
   _M_word = __words;
   _M_word_size = __rhs._M_word_size;

   this->flags(__rhs.flags());
   this->width(__rhs.width());
   this->precision(__rhs.precision());
   this->tie(__rhs.tie());
   this->fill(__rhs.fill());
   _M_ios_locale = __rhs.getloc();
   _M_cache_locale(_M_ios_locale);

   _M_call_callbacks(copyfmt_event);


   this->exceptions(__rhs.exceptions());
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
 this->rdbuf()->pubimbue(__loc);
      return __old;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {

      ios_base::_M_init();


      _M_cache_locale(_M_ios_locale);
# 146 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_ios.tcc" 3
      _M_fill = _CharT();
      _M_fill_init = false;

      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
 _M_ctype = &use_facet<__ctype_type>(__loc);
      else
 _M_ctype = 0;

      if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
 _M_num_put = &use_facet<__num_put_type>(__loc);
      else
 _M_num_put = 0;

      if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
 _M_num_get = &use_facet<__num_get_type>(__loc);
      else
 _M_num_get = 0;
    }




  extern template class basic_ios<char>;


  extern template class basic_ios<wchar_t>;




}
# 476 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/basic_ios.h" 2 3
# 45 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ios" 2 3
# 39 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/istream" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ostream" 1 3
# 37 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ostream" 3




namespace std __attribute__ ((__visibility__ ("default")))
{
# 57 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ostream" 3
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;
# 83 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ostream" 3
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }






      virtual
      ~basic_ostream() { }


      class sentry;
      friend class sentry;
# 107 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ostream" 3
      __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&))
      {



 return __pf(*this);
      }

      __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&))
      {



 __pf(*this);
 return *this;
      }

      __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&))
      {



 __pf(*this);
 return *this;
      }
# 165 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ostream" 3
      __ostream_type&
      operator<<(long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(bool __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(short __n);

      __ostream_type&
      operator<<(unsigned short __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }

      __ostream_type&
      operator<<(int __n);

      __ostream_type&
      operator<<(unsigned int __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }


      __ostream_type&
      operator<<(long long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long long __n)
      { return _M_insert(__n); }
# 219 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ostream" 3
      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(float __f)
      {


 return _M_insert(static_cast<double>(__f));
      }

      __ostream_type&
      operator<<(long double __f)
      { return _M_insert(__f); }
# 244 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ostream" 3
      __ostream_type&
      operator<<(const void* __p)
      { return _M_insert(__p); }
# 269 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ostream" 3
      __ostream_type&
      operator<<(__streambuf_type* __sb);
# 302 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ostream" 3
      __ostream_type&
      put(char_type __c);






      void
      _M_write(const char_type* __s, streamsize __n)
      {
 const streamsize __put = this->rdbuf()->sputn(__s, __n);
 if (__put != __n)
   this->setstate(ios_base::badbit);
      }
# 334 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ostream" 3
      __ostream_type&
      write(const char_type* __s, streamsize __n);
# 347 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ostream" 3
      __ostream_type&
      flush();
# 357 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ostream" 3
      pos_type
      tellp();
# 368 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ostream" 3
      __ostream_type&
      seekp(pos_type);
# 380 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ostream" 3
       __ostream_type&
      seekp(off_type, ios_base::seekdir);

    protected:
      basic_ostream()
      { this->init(0); }

      template<typename _ValueT>
 __ostream_type&
 _M_insert(_ValueT __v);
    };
# 399 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ostream" 3
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {

      bool _M_ok;
      basic_ostream<_CharT, _Traits>& _M_os;

    public:
# 418 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ostream" 3
      explicit
      sentry(basic_ostream<_CharT, _Traits>& __os);
# 428 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ostream" 3
      ~sentry()
      {

 if (bool(_M_os.flags() & ios_base::unitbuf) && !uncaught_exception())
   {

     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
       _M_os.setstate(ios_base::badbit);
   }
      }
# 447 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ostream" 3
      explicit

      operator bool() const
      { return _M_ok; }
    };
# 469 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    { return __ostream_insert(__out, &__c, 1); }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }


  template <class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    { return __ostream_insert(__out, &__c, 1); }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
# 511 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
# 562 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
# 574 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }






  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }
# 600 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ostream" 3
  template<typename _CharT, typename _Traits, typename _Tp>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>&& __os, const _Tp& __x)
    {
      __os << __x;
      return __os;
    }



}


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/ostream.tcc" 1 3
# 38 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/ostream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {

      if (__os.tie() && __os.good())
 __os.tie()->flush();

      if (__os.good())
 _M_ok = true;
      else
 __os.setstate(ios_base::failbit);
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_ostream<_CharT, _Traits>&
      basic_ostream<_CharT, _Traits>::
      _M_insert(_ValueT __v)
      {
 sentry __cerb(*this);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_put_type& __np = __check_facet(this->_M_num_put);
  if (__np.put(*this, *this, this->fill(), __v).failed())
    __err |= ios_base::badbit;
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(short __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(int __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this);
      if (__cerb && __sbin)
 {
   try
     {
       if (!__copy_streambufs(__sbin, this->rdbuf()))
  __err |= ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbin)
 __err |= ios_base::badbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {






      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __put = this->rdbuf()->sputc(__c);
       if (traits_type::eq_int_type(__put, traits_type::eof()))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {







      sentry __cerb(*this);
      if (__cerb)
 {
   try
     { _M_write(__s, __n); }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {



      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
     __err |= ios_base::badbit;
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 {


   const size_t __clen = char_traits<char>::length(__s);
   try
     {
       struct __ptr_guard
       {
  _CharT *__p;
  __ptr_guard (_CharT *__ip): __p(__ip) { }
  ~__ptr_guard() { delete[] __p; }
  _CharT* __get() { return __p; }
       } __pg (new _CharT[__clen]);

       _CharT *__ws = __pg.__get();
       for (size_t __i = 0; __i < __clen; ++__i)
  __ws[__i] = __out.widen(__s[__i]);
       __ostream_insert(__out, __ws, __clen);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
    }




  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);

  extern template ostream& ostream::_M_insert(long);
  extern template ostream& ostream::_M_insert(unsigned long);
  extern template ostream& ostream::_M_insert(bool);

  extern template ostream& ostream::_M_insert(long long);
  extern template ostream& ostream::_M_insert(unsigned long long);

  extern template ostream& ostream::_M_insert(double);
  extern template ostream& ostream::_M_insert(long double);
  extern template ostream& ostream::_M_insert(const void*);


  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);

  extern template wostream& wostream::_M_insert(long);
  extern template wostream& wostream::_M_insert(unsigned long);
  extern template wostream& wostream::_M_insert(bool);

  extern template wostream& wostream::_M_insert(long long);
  extern template wostream& wostream::_M_insert(unsigned long long);

  extern template wostream& wostream::_M_insert(double);
  extern template wostream& wostream::_M_insert(long double);
  extern template wostream& wostream::_M_insert(const void*);




}
# 613 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ostream" 2 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/istream" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
# 57 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;
      typedef ctype<_CharT> __ctype_type;

    protected:





      streamsize _M_gcount;

    public:







      explicit
      basic_istream(__streambuf_type* __sb)
      : _M_gcount(streamsize(0))
      { this->init(__sb); }






      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }


      class sentry;
      friend class sentry;
# 119 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/istream" 3
      __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&))
      { return __pf(*this); }

      __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&))
      {
 __pf(*this);
 return *this;
      }

      __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&))
      {
 __pf(*this);
 return *this;
      }
# 167 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/istream" 3
      __istream_type&
      operator>>(bool& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(short& __n);

      __istream_type&
      operator>>(unsigned short& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(long long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long long& __n)
      { return _M_extract(__n); }
# 213 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/istream" 3
      __istream_type&
      operator>>(float& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(long double& __f)
      { return _M_extract(__f); }
# 234 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/istream" 3
      __istream_type&
      operator>>(void*& __p)
      { return _M_extract(__p); }
# 258 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/istream" 3
      __istream_type&
      operator>>(__streambuf_type* __sb);
# 268 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/istream" 3
      streamsize
      gcount() const
      { return _M_gcount; }
# 301 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/istream" 3
      int_type
      get();
# 315 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/istream" 3
      __istream_type&
      get(char_type& __c);
# 342 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
# 353 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
# 376 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/istream" 3
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
# 386 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/istream" 3
      __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
# 415 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
# 426 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
# 450 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/istream" 3
      __istream_type&
      ignore(streamsize __n, int_type __delim);

      __istream_type&
      ignore(streamsize __n);

      __istream_type&
      ignore();
# 467 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/istream" 3
      int_type
      peek();
# 485 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/istream" 3
      __istream_type&
      read(char_type* __s, streamsize __n);
# 504 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/istream" 3
      streamsize
      readsome(char_type* __s, streamsize __n);
# 521 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/istream" 3
      __istream_type&
      putback(char_type __c);
# 537 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/istream" 3
      __istream_type&
      unget();
# 555 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/istream" 3
      int
      sync();
# 570 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/istream" 3
      pos_type
      tellg();
# 585 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/istream" 3
      __istream_type&
      seekg(pos_type);
# 601 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/istream" 3
      __istream_type&
      seekg(off_type, ios_base::seekdir);


    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }

      template<typename _ValueT>
 __istream_type&
 _M_extract(_ValueT& __v);
    };


  template<>
    basic_istream<char>&
    basic_istream<char>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n, int_type __delim);


  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n, int_type __delim);
# 656 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {

      bool _M_ok;

    public:

      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
# 692 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/istream" 3
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
# 703 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/istream" 3
      explicit

      operator bool() const
      { return _M_ok; }
    };
# 721 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
# 763 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);


  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __in, char* __s);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
# 794 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:



      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;







      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(__sb), __ostream_type(__sb) { }




      virtual
      ~basic_iostream() { }

    protected:
      basic_iostream()
      : __istream_type(), __ostream_type() { }
    };
# 854 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);
# 870 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/istream" 3
  template<typename _CharT, typename _Traits, typename _Tp>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>&& __is, _Tp& __x)
    {
      __is >> __x;
      return __is;
    }



}


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/istream.tcc" 1 3
# 38 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/istream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::goodbit;
      if (__in.good())
 {
   if (__in.tie())
     __in.tie()->flush();
   if (!__noskip && bool(__in.flags() & ios_base::skipws))
     {
       const __int_type __eof = traits_type::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();

       const __ctype_type& __ct = __check_facet(__in._M_ctype);
       while (!traits_type::eq_int_type(__c, __eof)
       && __ct.is(ctype_base::space,
    traits_type::to_char_type(__c)))
  __c = __sb->snextc();




       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
 }

      if (__in.good() && __err == ios_base::goodbit)
 _M_ok = true;
      else
 {
   __err |= ios_base::failbit;
   __in.setstate(__err);
 }
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_istream<_CharT, _Traits>&
      basic_istream<_CharT, _Traits>::
      _M_extract(_ValueT& __v)
      {
 sentry __cerb(*this, false);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_get_type& __ng = __check_facet(this->_M_num_get);
  __ng.get(*this, 0, *this, __err, __v);
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<short>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<short>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__max;
  }
       else
  __n = short(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<int>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<int>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__max;
  }
       else
  __n = int(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
 {
   try
     {
       bool __ineof;
       if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
  __err |= ios_base::failbit;
       if (__ineof)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::failbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbout)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       __c = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__c, __eof))
  _M_gcount = 1;
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __cb = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__cb, traits_type::eof()))
  {
    _M_gcount = 1;
    __c = traits_type::to_char_type(__cb);
  }
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();

       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    *__s++ = traits_type::to_char_type(__c);
    ++_M_gcount;
    __c = __sb->snextc();
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __this_sb = this->rdbuf();
       int_type __c = __this_sb->sgetc();
       char_type __c2 = traits_type::to_char_type(__c);

       while (!traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim)
       && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
  {
    ++_M_gcount;
    __c = __this_sb->snextc();
    __c2 = traits_type::to_char_type(__c);
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    __err |= ios_base::failbit;
                }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
        }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
        __err |= ios_base::failbit;
      if (__err)
        this->setstate(__err);
      return *this;
    }




  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();

       if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
  __err |= ios_base::eofbit;
       else
  _M_gcount = 1;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
# 513 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/istream.tcc" 3
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

       if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();


       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof)
    && !traits_type::eq_int_type(__c, __delim))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof)
        && !traits_type::eq_int_type(__c, __delim))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
       else if (traits_type::eq_int_type(__c, __delim))
  {
    if (_M_gcount
        < __gnu_cxx::__numeric_traits<streamsize>::__max)
      ++_M_gcount;
    __sb->sbumpc();
  }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __c = this->rdbuf()->sgetc();
       if (traits_type::eq_int_type(__c, traits_type::eof()))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       _M_gcount = this->rdbuf()->sgetn(__s, __n);
       if (_M_gcount != __n)
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {

       const streamsize __num = this->rdbuf()->in_avail();
       if (__num > 0)
  _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
       else if (__num == -1)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return _M_gcount;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sungetc(), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {


      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __streambuf_type* __sb = this->rdbuf();
       if (__sb)
  {
    if (__sb->pubsync() == -1)
      __err |= ios_base::badbit;
    else
      __ret = 0;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {


      pos_type __ret = pos_type(-1);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       if (!this->fail())
  __ret = this->rdbuf()->pubseekoff(0, ios_base::cur,
        ios_base::in);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekpos(__pos,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const __int_type __cb = __in.rdbuf()->sbumpc();
       if (!_Traits::eq_int_type(__cb, _Traits::eof()))
  __c = _Traits::to_char_type(__cb);
       else
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;

      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       streamsize __num = __in.width();
       if (__num <= 0)
  __num = __gnu_cxx::__numeric_traits<streamsize>::__max;

       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());

       const int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       int_type __c = __sb->sgetc();

       while (__extracted < __num - 1
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    *__s++ = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;



       *__s = char_type();
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename __istream_type::int_type __int_type;
      typedef ctype<_CharT> __ctype_type;

      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();

      while (!_Traits::eq_int_type(__c, __eof)
      && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
 __c = __sb->snextc();

       if (_Traits::eq_int_type(__c, __eof))
  __in.setstate(ios_base::eofbit);
      return __in;
    }




  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);

  extern template istream& istream::_M_extract(unsigned short&);
  extern template istream& istream::_M_extract(unsigned int&);
  extern template istream& istream::_M_extract(long&);
  extern template istream& istream::_M_extract(unsigned long&);
  extern template istream& istream::_M_extract(bool&);

  extern template istream& istream::_M_extract(long long&);
  extern template istream& istream::_M_extract(unsigned long long&);

  extern template istream& istream::_M_extract(float&);
  extern template istream& istream::_M_extract(double&);
  extern template istream& istream::_M_extract(long double&);
  extern template istream& istream::_M_extract(void*&);

  extern template class basic_iostream<char>;


  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template wistream& operator>>(wistream&, wchar_t*);

  extern template wistream& wistream::_M_extract(unsigned short&);
  extern template wistream& wistream::_M_extract(unsigned int&);
  extern template wistream& wistream::_M_extract(long&);
  extern template wistream& wistream::_M_extract(unsigned long&);
  extern template wistream& wistream::_M_extract(bool&);

  extern template wistream& wistream::_M_extract(long long&);
  extern template wistream& wistream::_M_extract(unsigned long long&);

  extern template wistream& wistream::_M_extract(float&);
  extern template wistream& wistream::_M_extract(double&);
  extern template wistream& wistream::_M_extract(long double&);
  extern template wistream& wistream::_M_extract(void*&);

  extern template class basic_iostream<wchar_t>;




}
# 883 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/istream" 2 3
# 39 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/sstream" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{
# 63 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;

      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_string<char_type, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;

    protected:

      ios_base::openmode _M_mode;


      __string_type _M_string;

    public:
# 97 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/sstream" 3
      explicit
      basic_stringbuf(ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(__mode), _M_string()
      { }
# 110 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/sstream" 3
      explicit
      basic_stringbuf(const __string_type& __str,
        ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(), _M_string(__str.data(), __str.size())
      { _M_stringbuf_init(__mode); }
# 125 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/sstream" 3
      __string_type
      str() const
      {
 __string_type __ret;
 if (this->pptr())
   {

     if (this->pptr() > this->egptr())
       __ret = __string_type(this->pbase(), this->pptr());
     else
        __ret = __string_type(this->pbase(), this->egptr());
   }
 else
   __ret = _M_string;
 return __ret;
      }
# 149 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/sstream" 3
      void
      str(const __string_type& __s)
      {

 _M_string.assign(__s.data(), __s.size());
 _M_stringbuf_init(_M_mode);
      }

    protected:

      void
      _M_stringbuf_init(ios_base::openmode __mode)
      {
 _M_mode = __mode;
 __size_type __len = 0;
 if (_M_mode & (ios_base::ate | ios_base::app))
   __len = _M_string.size();
 _M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
      }

      virtual streamsize
      showmanyc()
      {
 streamsize __ret = -1;
 if (_M_mode & ios_base::in)
   {
     _M_update_egptr();
     __ret = this->egptr() - this->gptr();
   }
 return __ret;
      }

      virtual int_type
      underflow();

      virtual int_type
      pbackfail(int_type __c = traits_type::eof());

      virtual int_type
      overflow(int_type __c = traits_type::eof());
# 201 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/sstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n)
      {
 if (__s && __n >= 0)
   {






     _M_string.clear();


     _M_sync(__s, __n, 0);
   }
 return this;
      }

      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);

      virtual pos_type
      seekpos(pos_type __sp,
       ios_base::openmode __mode = ios_base::in | ios_base::out);




      void
      _M_sync(char_type* __base, __size_type __i, __size_type __o);



      void
      _M_update_egptr()
      {
 const bool __testin = _M_mode & ios_base::in;
 if (this->pptr() && this->pptr() > this->egptr())
   {
     if (__testin)
       this->setg(this->eback(), this->gptr(), this->pptr());
     else
       this->setg(this->pptr(), this->pptr(), this->pptr());
   }
      }



      void
      _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off);
    };
# 271 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_istringstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 307 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/sstream" 3
      explicit
      basic_istringstream(ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__mode | ios_base::in)
      { this->init(&_M_stringbuf); }
# 325 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/sstream" 3
      explicit
      basic_istringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
      { this->init(&_M_stringbuf); }







      ~basic_istringstream()
      { }
# 347 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 386 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_ostringstream : public basic_ostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 422 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/sstream" 3
      explicit
      basic_ostringstream(ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__mode | ios_base::out)
      { this->init(&_M_stringbuf); }
# 440 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/sstream" 3
      explicit
      basic_ostringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__str, __mode | ios_base::out)
      { this->init(&_M_stringbuf); }







      ~basic_ostringstream()
      { }
# 462 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 501 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 536 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/sstream" 3
      explicit
      basic_stringstream(ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__m)
      { this->init(&_M_stringbuf); }
# 552 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/sstream" 3
      explicit
      basic_stringstream(const __string_type& __str,
    ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__str, __m)
      { this->init(&_M_stringbuf); }







      ~basic_stringstream()
      { }
# 574 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };


}


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/sstream.tcc" 1 3
# 38 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/sstream.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    pbackfail(int_type __c)
    {
      int_type __ret = traits_type::eof();
      if (this->eback() < this->gptr())
 {


   const bool __testeof = traits_type::eq_int_type(__c, __ret);
   if (!__testeof)
     {
       const bool __testeq = traits_type::eq(traits_type::
          to_char_type(__c),
          this->gptr()[-1]);
       const bool __testout = this->_M_mode & ios_base::out;
       if (__testeq || __testout)
  {
    this->gbump(-1);
    if (!__testeq)
      *this->gptr() = traits_type::to_char_type(__c);
    __ret = __c;
  }
     }
   else
     {
       this->gbump(-1);
       __ret = traits_type::not_eof(__c);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    overflow(int_type __c)
    {
      const bool __testout = this->_M_mode & ios_base::out;
      if (__builtin_expect(!__testout, false))
 return traits_type::eof();

      const bool __testeof = traits_type::eq_int_type(__c, traits_type::eof());
      if (__builtin_expect(__testeof, false))
 return traits_type::not_eof(__c);

      const __size_type __capacity = _M_string.capacity();
      const __size_type __max_size = _M_string.max_size();
      const bool __testput = this->pptr() < this->epptr();
      if (__builtin_expect(!__testput && __capacity == __max_size, false))
 return traits_type::eof();



      const char_type __conv = traits_type::to_char_type(__c);
      if (!__testput)
 {
# 110 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/sstream.tcc" 3
   const __size_type __opt_len = std::max(__size_type(2 * __capacity),
       __size_type(512));
   const __size_type __len = std::min(__opt_len, __max_size);
   __string_type __tmp;
   __tmp.reserve(__len);
   if (this->pbase())
     __tmp.assign(this->pbase(), this->epptr() - this->pbase());
   __tmp.push_back(__conv);
   _M_string.swap(__tmp);
   _M_sync(const_cast<char_type*>(_M_string.data()),
    this->gptr() - this->eback(), this->pptr() - this->pbase());
 }
      else
 *this->pptr() = __conv;
      this->pbump(1);
      return __c;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = this->_M_mode & ios_base::in;
      if (__testin)
 {

   _M_update_egptr();

   if (this->gptr() < this->egptr())
     __ret = traits_type::to_int_type(*this->gptr());
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;
      const bool __testboth = __testin && __testout && __way != ios_base::cur;
      __testin &= !(__mode & ios_base::out);
      __testout &= !(__mode & ios_base::in);



      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !__off) && (__testin || __testout || __testboth))
 {
   _M_update_egptr();

   off_type __newoffi = __off;
   off_type __newoffo = __newoffi;
   if (__way == ios_base::cur)
     {
       __newoffi += this->gptr() - __beg;
       __newoffo += this->pptr() - __beg;
     }
   else if (__way == ios_base::end)
     __newoffo = __newoffi += this->egptr() - __beg;

   if ((__testin || __testboth)
       && __newoffi >= 0
       && this->egptr() - __beg >= __newoffi)
     {
       this->setg(this->eback(), this->eback() + __newoffi,
    this->egptr());
       __ret = pos_type(__newoffi);
     }
   if ((__testout || __testboth)
       && __newoffo >= 0
       && this->egptr() - __beg >= __newoffo)
     {
       _M_pbump(this->pbase(), this->epptr(), __newoffo);
       __ret = pos_type(__newoffo);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekpos(pos_type __sp, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      const bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      const bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;

      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !off_type(__sp)) && (__testin || __testout))
 {
   _M_update_egptr();

   const off_type __pos(__sp);
   const bool __testpos = (0 <= __pos
      && __pos <= this->egptr() - __beg);
   if (__testpos)
     {
       if (__testin)
  this->setg(this->eback(), this->eback() + __pos,
      this->egptr());
       if (__testout)
  _M_pbump(this->pbase(), this->epptr(), __pos);
       __ret = __sp;
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_sync(char_type* __base, __size_type __i, __size_type __o)
    {
      const bool __testin = _M_mode & ios_base::in;
      const bool __testout = _M_mode & ios_base::out;
      char_type* __endg = __base + _M_string.size();
      char_type* __endp = __base + _M_string.capacity();

      if (__base != _M_string.data())
 {

   __endg += __i;
   __i = 0;
   __endp = __endg;
 }

      if (__testin)
 this->setg(__base, __base + __i, __endg);
      if (__testout)
 {
   _M_pbump(__base, __endp, __o);



   if (!__testin)
     this->setg(__endg, __endg, __endg);
 }
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off)
    {
      this->setp(__pbeg, __pend);
      while (__off > __gnu_cxx::__numeric_traits<int>::__max)
 {
   this->pbump(__gnu_cxx::__numeric_traits<int>::__max);
   __off -= __gnu_cxx::__numeric_traits<int>::__max;
 }
      this->pbump(__off);
    }




  extern template class basic_stringbuf<char>;
  extern template class basic_istringstream<char>;
  extern template class basic_ostringstream<char>;
  extern template class basic_stringstream<char>;


  extern template class basic_stringbuf<wchar_t>;
  extern template class basic_istringstream<wchar_t>;
  extern template class basic_ostringstream<wchar_t>;
  extern template class basic_stringstream<wchar_t>;




}
# 601 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/sstream" 2 3
# 7 "../ir/ir.h" 2

# 1 "../lib/log.h" 1



# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/iostream" 1 3
# 37 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/iostream" 3





namespace std __attribute__ ((__visibility__ ("default")))
{
# 60 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/iostream" 3
  extern istream cin;
  extern ostream cout;
  extern ostream cerr;
  extern ostream clog;


  extern wistream wcin;
  extern wostream wcout;
  extern wostream wcerr;
  extern wostream wclog;




  static ios_base::Init __ioinit;


}
# 5 "../lib/log.h" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/set" 1 3
# 59 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/set" 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_tree.h" 1 3
# 69 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_tree.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 89 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_tree.h" 3
  enum _Rb_tree_color { _S_red = false, _S_black = true };

  struct _Rb_tree_node_base
  {
    typedef _Rb_tree_node_base* _Base_ptr;
    typedef const _Rb_tree_node_base* _Const_Base_ptr;

    _Rb_tree_color _M_color;
    _Base_ptr _M_parent;
    _Base_ptr _M_left;
    _Base_ptr _M_right;

    static _Base_ptr
    _S_minimum(_Base_ptr __x)
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Const_Base_ptr
    _S_minimum(_Const_Base_ptr __x)
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Base_ptr
    _S_maximum(_Base_ptr __x)
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }

    static _Const_Base_ptr
    _S_maximum(_Const_Base_ptr __x)
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }
  };

  template<typename _Val>
    struct _Rb_tree_node : public _Rb_tree_node_base
    {
      typedef _Rb_tree_node<_Val>* _Link_type;
      _Val _M_value_field;


      template<typename... _Args>
        _Rb_tree_node(_Args&&... __args)
 : _Rb_tree_node_base(),
   _M_value_field(std::forward<_Args>(__args)...) { }

    };

  __attribute__ ((__pure__)) _Rb_tree_node_base*
  _Rb_tree_increment(_Rb_tree_node_base* __x) throw ();

  __attribute__ ((__pure__)) const _Rb_tree_node_base*
  _Rb_tree_increment(const _Rb_tree_node_base* __x) throw ();

  __attribute__ ((__pure__)) _Rb_tree_node_base*
  _Rb_tree_decrement(_Rb_tree_node_base* __x) throw ();

  __attribute__ ((__pure__)) const _Rb_tree_node_base*
  _Rb_tree_decrement(const _Rb_tree_node_base* __x) throw ();

  template<typename _Tp>
    struct _Rb_tree_iterator
    {
      typedef _Tp value_type;
      typedef _Tp& reference;
      typedef _Tp* pointer;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;

      typedef _Rb_tree_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;
      typedef _Rb_tree_node<_Tp>* _Link_type;

      _Rb_tree_iterator()
      : _M_node() { }

      explicit
      _Rb_tree_iterator(_Link_type __x)
      : _M_node(__x) { }

      reference
      operator*() const
      { return static_cast<_Link_type>(_M_node)->_M_value_field; }

      pointer
      operator->() const
      { return std::__addressof(static_cast<_Link_type>
    (_M_node)->_M_value_field); }

      _Self&
      operator++()
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }

      _Base_ptr _M_node;
  };

  template<typename _Tp>
    struct _Rb_tree_const_iterator
    {
      typedef _Tp value_type;
      typedef const _Tp& reference;
      typedef const _Tp* pointer;

      typedef _Rb_tree_iterator<_Tp> iterator;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;

      typedef _Rb_tree_const_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;
      typedef const _Rb_tree_node<_Tp>* _Link_type;

      _Rb_tree_const_iterator()
      : _M_node() { }

      explicit
      _Rb_tree_const_iterator(_Link_type __x)
      : _M_node(__x) { }

      _Rb_tree_const_iterator(const iterator& __it)
      : _M_node(__it._M_node) { }

      iterator
      _M_const_cast() const
      { return iterator(static_cast<typename iterator::_Link_type>
   (const_cast<typename iterator::_Base_ptr>(_M_node))); }

      reference
      operator*() const
      { return static_cast<_Link_type>(_M_node)->_M_value_field; }

      pointer
      operator->() const
      { return std::__addressof(static_cast<_Link_type>
    (_M_node)->_M_value_field); }

      _Self&
      operator++()
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }

      _Base_ptr _M_node;
    };

  template<typename _Val>
    inline bool
    operator==(const _Rb_tree_iterator<_Val>& __x,
               const _Rb_tree_const_iterator<_Val>& __y)
    { return __x._M_node == __y._M_node; }

  template<typename _Val>
    inline bool
    operator!=(const _Rb_tree_iterator<_Val>& __x,
               const _Rb_tree_const_iterator<_Val>& __y)
    { return __x._M_node != __y._M_node; }

  void
  _Rb_tree_insert_and_rebalance(const bool __insert_left,
                                _Rb_tree_node_base* __x,
                                _Rb_tree_node_base* __p,
                                _Rb_tree_node_base& __header) throw ();

  _Rb_tree_node_base*
  _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z,
          _Rb_tree_node_base& __header) throw ();


  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc = allocator<_Val> >
    class _Rb_tree
    {
      typedef typename _Alloc::template rebind<_Rb_tree_node<_Val> >::other
              _Node_allocator;

    protected:
      typedef _Rb_tree_node_base* _Base_ptr;
      typedef const _Rb_tree_node_base* _Const_Base_ptr;

    public:
      typedef _Key key_type;
      typedef _Val value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef _Rb_tree_node<_Val>* _Link_type;
      typedef const _Rb_tree_node<_Val>* _Const_Link_type;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

      _Node_allocator&
      _M_get_Node_allocator() noexcept
      { return *static_cast<_Node_allocator*>(&this->_M_impl); }

      const _Node_allocator&
      _M_get_Node_allocator() const noexcept
      { return *static_cast<const _Node_allocator*>(&this->_M_impl); }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Node_allocator()); }

    protected:
      _Link_type
      _M_get_node()
      { return _M_impl._Node_allocator::allocate(1); }

      void
      _M_put_node(_Link_type __p)
      { _M_impl._Node_allocator::deallocate(__p, 1); }
# 399 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_tree.h" 3
      template<typename... _Args>
        _Link_type
        _M_create_node(_Args&&... __args)
 {
   _Link_type __tmp = _M_get_node();
   try
     {
       allocator_traits<_Node_allocator>::
  construct(_M_get_Node_allocator(), __tmp,
     std::forward<_Args>(__args)...);
     }
   catch(...)
     {
       _M_put_node(__tmp);
       throw;
     }
   return __tmp;
 }

      void
      _M_destroy_node(_Link_type __p)
      {
 _M_get_Node_allocator().destroy(__p);
 _M_put_node(__p);
      }


      _Link_type
      _M_clone_node(_Const_Link_type __x)
      {
 _Link_type __tmp = _M_create_node(__x->_M_value_field);
 __tmp->_M_color = __x->_M_color;
 __tmp->_M_left = 0;
 __tmp->_M_right = 0;
 return __tmp;
      }

    protected:
      template<typename _Key_compare,
        bool _Is_pod_comparator = __is_pod(_Key_compare)>
        struct _Rb_tree_impl : public _Node_allocator
        {
   _Key_compare _M_key_compare;
   _Rb_tree_node_base _M_header;
   size_type _M_node_count;

   _Rb_tree_impl()
   : _Node_allocator(), _M_key_compare(), _M_header(),
     _M_node_count(0)
   { _M_initialize(); }

   _Rb_tree_impl(const _Key_compare& __comp, const _Node_allocator& __a)
   : _Node_allocator(__a), _M_key_compare(__comp), _M_header(),
     _M_node_count(0)
   { _M_initialize(); }


   _Rb_tree_impl(const _Key_compare& __comp, _Node_allocator&& __a)
   : _Node_allocator(std::move(__a)), _M_key_compare(__comp),
     _M_header(), _M_node_count(0)
   { _M_initialize(); }


 private:
   void
   _M_initialize()
   {
     this->_M_header._M_color = _S_red;
     this->_M_header._M_parent = 0;
     this->_M_header._M_left = &this->_M_header;
     this->_M_header._M_right = &this->_M_header;
   }
 };

      _Rb_tree_impl<_Compare> _M_impl;

    protected:
      _Base_ptr&
      _M_root()
      { return this->_M_impl._M_header._M_parent; }

      _Const_Base_ptr
      _M_root() const
      { return this->_M_impl._M_header._M_parent; }

      _Base_ptr&
      _M_leftmost()
      { return this->_M_impl._M_header._M_left; }

      _Const_Base_ptr
      _M_leftmost() const
      { return this->_M_impl._M_header._M_left; }

      _Base_ptr&
      _M_rightmost()
      { return this->_M_impl._M_header._M_right; }

      _Const_Base_ptr
      _M_rightmost() const
      { return this->_M_impl._M_header._M_right; }

      _Link_type
      _M_begin()
      { return static_cast<_Link_type>(this->_M_impl._M_header._M_parent); }

      _Const_Link_type
      _M_begin() const
      {
 return static_cast<_Const_Link_type>
   (this->_M_impl._M_header._M_parent);
      }

      _Link_type
      _M_end()
      { return reinterpret_cast<_Link_type>(&this->_M_impl._M_header); }

      _Const_Link_type
      _M_end() const
      { return reinterpret_cast<_Const_Link_type>(&this->_M_impl._M_header); }

      static const_reference
      _S_value(_Const_Link_type __x)
      { return __x->_M_value_field; }

      static const _Key&
      _S_key(_Const_Link_type __x)
      { return _KeyOfValue()(_S_value(__x)); }

      static _Link_type
      _S_left(_Base_ptr __x)
      { return static_cast<_Link_type>(__x->_M_left); }

      static _Const_Link_type
      _S_left(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x->_M_left); }

      static _Link_type
      _S_right(_Base_ptr __x)
      { return static_cast<_Link_type>(__x->_M_right); }

      static _Const_Link_type
      _S_right(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x->_M_right); }

      static const_reference
      _S_value(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x)->_M_value_field; }

      static const _Key&
      _S_key(_Const_Base_ptr __x)
      { return _KeyOfValue()(_S_value(__x)); }

      static _Base_ptr
      _S_minimum(_Base_ptr __x)
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Const_Base_ptr
      _S_minimum(_Const_Base_ptr __x)
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Base_ptr
      _S_maximum(_Base_ptr __x)
      { return _Rb_tree_node_base::_S_maximum(__x); }

      static _Const_Base_ptr
      _S_maximum(_Const_Base_ptr __x)
      { return _Rb_tree_node_base::_S_maximum(__x); }

    public:
      typedef _Rb_tree_iterator<value_type> iterator;
      typedef _Rb_tree_const_iterator<value_type> const_iterator;

      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    private:
      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_unique_pos(const key_type& __k);

      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_equal_pos(const key_type& __k);

      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_hint_unique_pos(const_iterator __pos,
        const key_type& __k);

      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_hint_equal_pos(const_iterator __pos,
       const key_type& __k);


      template<typename _Arg>
        iterator
        _M_insert_(_Base_ptr __x, _Base_ptr __y, _Arg&& __v);

      iterator
      _M_insert_node(_Base_ptr __x, _Base_ptr __y, _Link_type __z);

      template<typename _Arg>
        iterator
        _M_insert_lower(_Base_ptr __y, _Arg&& __v);

      template<typename _Arg>
        iterator
        _M_insert_equal_lower(_Arg&& __x);

      iterator
      _M_insert_lower_node(_Base_ptr __p, _Link_type __z);

      iterator
      _M_insert_equal_lower_node(_Link_type __z);
# 624 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_tree.h" 3
      _Link_type
      _M_copy(_Const_Link_type __x, _Link_type __p);

      void
      _M_erase(_Link_type __x);

      iterator
      _M_lower_bound(_Link_type __x, _Link_type __y,
       const _Key& __k);

      const_iterator
      _M_lower_bound(_Const_Link_type __x, _Const_Link_type __y,
       const _Key& __k) const;

      iterator
      _M_upper_bound(_Link_type __x, _Link_type __y,
       const _Key& __k);

      const_iterator
      _M_upper_bound(_Const_Link_type __x, _Const_Link_type __y,
       const _Key& __k) const;

    public:

      _Rb_tree() { }

      _Rb_tree(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_impl(__comp, _Node_allocator(__a)) { }

      _Rb_tree(const _Rb_tree& __x)
      : _M_impl(__x._M_impl._M_key_compare, __x._M_get_Node_allocator())
      {
 if (__x._M_root() != 0)
   {
     _M_root() = _M_copy(__x._M_begin(), _M_end());
     _M_leftmost() = _S_minimum(_M_root());
     _M_rightmost() = _S_maximum(_M_root());
     _M_impl._M_node_count = __x._M_impl._M_node_count;
   }
      }


      _Rb_tree(_Rb_tree&& __x);


      ~_Rb_tree() noexcept
      { _M_erase(_M_begin()); }

      _Rb_tree&
      operator=(const _Rb_tree& __x);


      _Compare
      key_comp() const
      { return _M_impl._M_key_compare; }

      iterator
      begin() noexcept
      {
 return iterator(static_cast<_Link_type>
   (this->_M_impl._M_header._M_left));
      }

      const_iterator
      begin() const noexcept
      {
 return const_iterator(static_cast<_Const_Link_type>
         (this->_M_impl._M_header._M_left));
      }

      iterator
      end() noexcept
      { return iterator(static_cast<_Link_type>(&this->_M_impl._M_header)); }

      const_iterator
      end() const noexcept
      {
 return const_iterator(static_cast<_Const_Link_type>
         (&this->_M_impl._M_header));
      }

      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }

      bool
      empty() const noexcept
      { return _M_impl._M_node_count == 0; }

      size_type
      size() const noexcept
      { return _M_impl._M_node_count; }

      size_type
      max_size() const noexcept
      { return _M_get_Node_allocator().max_size(); }

      void
      swap(_Rb_tree& __t);



      template<typename _Arg>
        pair<iterator, bool>
        _M_insert_unique(_Arg&& __x);

      template<typename _Arg>
        iterator
        _M_insert_equal(_Arg&& __x);

      template<typename _Arg>
        iterator
        _M_insert_unique_(const_iterator __position, _Arg&& __x);

      template<typename _Arg>
        iterator
        _M_insert_equal_(const_iterator __position, _Arg&& __x);

      template<typename... _Args>
 pair<iterator, bool>
 _M_emplace_unique(_Args&&... __args);

      template<typename... _Args>
 iterator
 _M_emplace_equal(_Args&&... __args);

      template<typename... _Args>
 iterator
 _M_emplace_hint_unique(const_iterator __pos, _Args&&... __args);

      template<typename... _Args>
 iterator
 _M_emplace_hint_equal(const_iterator __pos, _Args&&... __args);
# 784 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_tree.h" 3
      template<typename _InputIterator>
        void
        _M_insert_unique(_InputIterator __first, _InputIterator __last);

      template<typename _InputIterator>
        void
        _M_insert_equal(_InputIterator __first, _InputIterator __last);

    private:
      void
      _M_erase_aux(const_iterator __position);

      void
      _M_erase_aux(const_iterator __first, const_iterator __last);

    public:



      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(const_iterator __position)
      {
 const_iterator __result = __position;
 ++__result;
 _M_erase_aux(__position);
 return __result._M_const_cast();
      }


      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(iterator __position)
      {
 iterator __result = __position;
 ++__result;
 _M_erase_aux(__position);
 return __result;
      }
# 832 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_tree.h" 3
      size_type
      erase(const key_type& __x);




      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(const_iterator __first, const_iterator __last)
      {
 _M_erase_aux(__first, __last);
 return __last._M_const_cast();
      }
# 854 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_tree.h" 3
      void
      erase(const key_type* __first, const key_type* __last);

      void
      clear() noexcept
      {
        _M_erase(_M_begin());
        _M_leftmost() = _M_end();
        _M_root() = 0;
        _M_rightmost() = _M_end();
        _M_impl._M_node_count = 0;
      }


      iterator
      find(const key_type& __k);

      const_iterator
      find(const key_type& __k) const;

      size_type
      count(const key_type& __k) const;

      iterator
      lower_bound(const key_type& __k)
      { return _M_lower_bound(_M_begin(), _M_end(), __k); }

      const_iterator
      lower_bound(const key_type& __k) const
      { return _M_lower_bound(_M_begin(), _M_end(), __k); }

      iterator
      upper_bound(const key_type& __k)
      { return _M_upper_bound(_M_begin(), _M_end(), __k); }

      const_iterator
      upper_bound(const key_type& __k) const
      { return _M_upper_bound(_M_begin(), _M_end(), __k); }

      pair<iterator, iterator>
      equal_range(const key_type& __k);

      pair<const_iterator, const_iterator>
      equal_range(const key_type& __k) const;


      bool
      __rb_verify() const;
    };

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator==(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    {
      return __x.size() == __y.size()
      && std::equal(__x.begin(), __x.end(), __y.begin());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator<(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    {
      return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator!=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__x == __y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator>(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return __y < __x; }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator<=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__y < __x); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator>=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__x < __y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline void
    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
  _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { __x.swap(__y); }


  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _Rb_tree(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&& __x)
    : _M_impl(__x._M_impl._M_key_compare,
       std::move(__x._M_get_Node_allocator()))
    {
      if (__x._M_root() != 0)
 {
   _M_root() = __x._M_root();
   _M_leftmost() = __x._M_leftmost();
   _M_rightmost() = __x._M_rightmost();
   _M_root()->_M_parent = _M_end();

   __x._M_root() = 0;
   __x._M_leftmost() = __x._M_end();
   __x._M_rightmost() = __x._M_end();

   this->_M_impl._M_node_count = __x._M_impl._M_node_count;
   __x._M_impl._M_node_count = 0;
 }
    }


  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    operator=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x)
    {
      if (this != &__x)
 {

   clear();
   _M_impl._M_key_compare = __x._M_impl._M_key_compare;
   if (__x._M_root() != 0)
     {
       _M_root() = _M_copy(__x._M_begin(), _M_end());
       _M_leftmost() = _S_minimum(_M_root());
       _M_rightmost() = _S_maximum(_M_root());
       _M_impl._M_node_count = __x._M_impl._M_node_count;
     }
 }
      return *this;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>

    template<typename _Arg>

    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::

    _M_insert_(_Base_ptr __x, _Base_ptr __p, _Arg&& __v)



    {
      bool __insert_left = (__x != 0 || __p == _M_end()
       || _M_impl._M_key_compare(_KeyOfValue()(__v),
            _S_key(__p)));

      _Link_type __z = _M_create_node(std::forward<_Arg>(__v));

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>

    template<typename _Arg>

    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::

    _M_insert_lower(_Base_ptr __p, _Arg&& __v)



    {
      bool __insert_left = (__p == _M_end()
       || !_M_impl._M_key_compare(_S_key(__p),
             _KeyOfValue()(__v)));

      _Link_type __z = _M_create_node(std::forward<_Arg>(__v));

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>

    template<typename _Arg>

    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::

    _M_insert_equal_lower(_Arg&& __v)



    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = !_M_impl._M_key_compare(_S_key(__x), _KeyOfValue()(__v)) ?
         _S_left(__x) : _S_right(__x);
 }
      return _M_insert_lower(__y, std::forward<_Arg>(__v));
    }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type
    _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::
    _M_copy(_Const_Link_type __x, _Link_type __p)
    {

      _Link_type __top = _M_clone_node(__x);
      __top->_M_parent = __p;

      try
 {
   if (__x->_M_right)
     __top->_M_right = _M_copy(_S_right(__x), __top);
   __p = __top;
   __x = _S_left(__x);

   while (__x != 0)
     {
       _Link_type __y = _M_clone_node(__x);
       __p->_M_left = __y;
       __y->_M_parent = __p;
       if (__x->_M_right)
  __y->_M_right = _M_copy(_S_right(__x), __y);
       __p = __y;
       __x = _S_left(__x);
     }
 }
      catch(...)
 {
   _M_erase(__top);
   throw;
 }
      return __top;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase(_Link_type __x)
    {

      while (__x != 0)
 {
   _M_erase(_S_right(__x));
   _Link_type __y = _S_left(__x);
   _M_destroy_node(__x);
   __x = __y;
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Link_type __x, _Link_type __y,
     const _Key& __k)
    {
      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Const_Link_type __x, _Const_Link_type __y,
     const _Key& __k) const
    {
      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_upper_bound(_Link_type __x, _Link_type __y,
     const _Key& __k)
    {
      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_upper_bound(_Const_Link_type __x, _Const_Link_type __y,
     const _Key& __k) const
    {
      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    equal_range(const _Key& __k)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   if (_M_impl._M_key_compare(_S_key(__x), __k))
     __x = _S_right(__x);
   else if (_M_impl._M_key_compare(__k, _S_key(__x)))
     __y = __x, __x = _S_left(__x);
   else
     {
       _Link_type __xu(__x), __yu(__y);
       __y = __x, __x = _S_left(__x);
       __xu = _S_right(__xu);
       return pair<iterator,
            iterator>(_M_lower_bound(__x, __y, __k),
        _M_upper_bound(__xu, __yu, __k));
     }
 }
      return pair<iterator, iterator>(iterator(__y),
          iterator(__y));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::const_iterator,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::const_iterator>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    equal_range(const _Key& __k) const
    {
      _Const_Link_type __x = _M_begin();
      _Const_Link_type __y = _M_end();
      while (__x != 0)
 {
   if (_M_impl._M_key_compare(_S_key(__x), __k))
     __x = _S_right(__x);
   else if (_M_impl._M_key_compare(__k, _S_key(__x)))
     __y = __x, __x = _S_left(__x);
   else
     {
       _Const_Link_type __xu(__x), __yu(__y);
       __y = __x, __x = _S_left(__x);
       __xu = _S_right(__xu);
       return pair<const_iterator,
            const_iterator>(_M_lower_bound(__x, __y, __k),
       _M_upper_bound(__xu, __yu, __k));
     }
 }
      return pair<const_iterator, const_iterator>(const_iterator(__y),
        const_iterator(__y));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __t)
    {
      if (_M_root() == 0)
 {
   if (__t._M_root() != 0)
     {
       _M_root() = __t._M_root();
       _M_leftmost() = __t._M_leftmost();
       _M_rightmost() = __t._M_rightmost();
       _M_root()->_M_parent = _M_end();

       __t._M_root() = 0;
       __t._M_leftmost() = __t._M_end();
       __t._M_rightmost() = __t._M_end();
     }
 }
      else if (__t._M_root() == 0)
 {
   __t._M_root() = _M_root();
   __t._M_leftmost() = _M_leftmost();
   __t._M_rightmost() = _M_rightmost();
   __t._M_root()->_M_parent = __t._M_end();

   _M_root() = 0;
   _M_leftmost() = _M_end();
   _M_rightmost() = _M_end();
 }
      else
 {
   std::swap(_M_root(),__t._M_root());
   std::swap(_M_leftmost(),__t._M_leftmost());
   std::swap(_M_rightmost(),__t._M_rightmost());

   _M_root()->_M_parent = _M_end();
   __t._M_root()->_M_parent = __t._M_end();
 }

      std::swap(this->_M_impl._M_node_count, __t._M_impl._M_node_count);
      std::swap(this->_M_impl._M_key_compare, __t._M_impl._M_key_compare);



      std::__alloc_swap<_Node_allocator>::
 _S_do_it(_M_get_Node_allocator(), __t._M_get_Node_allocator());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_unique_pos(const key_type& __k)
    {
      typedef pair<_Base_ptr, _Base_ptr> _Res;
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      bool __comp = true;
      while (__x != 0)
 {
   __y = __x;
   __comp = _M_impl._M_key_compare(__k, _S_key(__x));
   __x = __comp ? _S_left(__x) : _S_right(__x);
 }
      iterator __j = iterator(__y);
      if (__comp)
 {
   if (__j == begin())
     return _Res(__x, __y);
   else
     --__j;
 }
      if (_M_impl._M_key_compare(_S_key(__j._M_node), __k))
 return _Res(__x, __y);
      return _Res(__j._M_node, 0);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_equal_pos(const key_type& __k)
    {
      typedef pair<_Base_ptr, _Base_ptr> _Res;
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = _M_impl._M_key_compare(__k, _S_key(__x)) ?
         _S_left(__x) : _S_right(__x);
 }
      return _Res(__x, __y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>

    template<typename _Arg>

    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator, bool>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::

    _M_insert_unique(_Arg&& __v)



    {
      typedef pair<iterator, bool> _Res;
      pair<_Base_ptr, _Base_ptr> __res
 = _M_get_insert_unique_pos(_KeyOfValue()(__v));

      if (__res.second)
 return _Res(_M_insert_(__res.first, __res.second,
          std::forward<_Arg>(__v)),
      true);

      return _Res(iterator(static_cast<_Link_type>(__res.first)), false);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>

    template<typename _Arg>

    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::

    _M_insert_equal(_Arg&& __v)



    {
      pair<_Base_ptr, _Base_ptr> __res
 = _M_get_insert_equal_pos(_KeyOfValue()(__v));
      return _M_insert_(__res.first, __res.second, std::forward<_Arg>(__v));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr,
         typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_hint_unique_pos(const_iterator __position,
      const key_type& __k)
    {
      iterator __pos = __position._M_const_cast();
      typedef pair<_Base_ptr, _Base_ptr> _Res;


      if (__pos._M_node == _M_end())
 {
   if (size() > 0
       && _M_impl._M_key_compare(_S_key(_M_rightmost()), __k))
     return _Res(0, _M_rightmost());
   else
     return _M_get_insert_unique_pos(__k);
 }
      else if (_M_impl._M_key_compare(__k, _S_key(__pos._M_node)))
 {

   iterator __before = __pos;
   if (__pos._M_node == _M_leftmost())
     return _Res(_M_leftmost(), _M_leftmost());
   else if (_M_impl._M_key_compare(_S_key((--__before)._M_node), __k))
     {
       if (_S_right(__before._M_node) == 0)
  return _Res(0, __before._M_node);
       else
  return _Res(__pos._M_node, __pos._M_node);
     }
   else
     return _M_get_insert_unique_pos(__k);
 }
      else if (_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
 {

   iterator __after = __pos;
   if (__pos._M_node == _M_rightmost())
     return _Res(0, _M_rightmost());
   else if (_M_impl._M_key_compare(__k, _S_key((++__after)._M_node)))
     {
       if (_S_right(__pos._M_node) == 0)
  return _Res(0, __pos._M_node);
       else
  return _Res(__after._M_node, __after._M_node);
     }
   else
     return _M_get_insert_unique_pos(__k);
 }
      else

 return _Res(__pos._M_node, 0);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>

    template<typename _Arg>

    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::

    _M_insert_unique_(const_iterator __position, _Arg&& __v)



    {
      pair<_Base_ptr, _Base_ptr> __res
 = _M_get_insert_hint_unique_pos(__position, _KeyOfValue()(__v));

      if (__res.second)
 return _M_insert_(__res.first, __res.second,
     std::forward<_Arg>(__v));
      return iterator(static_cast<_Link_type>(__res.first));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr,
         typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_hint_equal_pos(const_iterator __position, const key_type& __k)
    {
      iterator __pos = __position._M_const_cast();
      typedef pair<_Base_ptr, _Base_ptr> _Res;


      if (__pos._M_node == _M_end())
 {
   if (size() > 0
       && !_M_impl._M_key_compare(__k, _S_key(_M_rightmost())))
     return _Res(0, _M_rightmost());
   else
     return _M_get_insert_equal_pos(__k);
 }
      else if (!_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
 {

   iterator __before = __pos;
   if (__pos._M_node == _M_leftmost())
     return _Res(_M_leftmost(), _M_leftmost());
   else if (!_M_impl._M_key_compare(__k, _S_key((--__before)._M_node)))
     {
       if (_S_right(__before._M_node) == 0)
  return _Res(0, __before._M_node);
       else
  return _Res(__pos._M_node, __pos._M_node);
     }
   else
     return _M_get_insert_equal_pos(__k);
 }
      else
 {

   iterator __after = __pos;
   if (__pos._M_node == _M_rightmost())
     return _Res(0, _M_rightmost());
   else if (!_M_impl._M_key_compare(_S_key((++__after)._M_node), __k))
     {
       if (_S_right(__pos._M_node) == 0)
  return _Res(0, __pos._M_node);
       else
  return _Res(__after._M_node, __after._M_node);
     }
   else
     return _Res(0, 0);
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>

    template<typename _Arg>

    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::

    _M_insert_equal_(const_iterator __position, _Arg&& __v)



    {
      pair<_Base_ptr, _Base_ptr> __res
 = _M_get_insert_hint_equal_pos(__position, _KeyOfValue()(__v));

      if (__res.second)
 return _M_insert_(__res.first, __res.second,
     std::forward<_Arg>(__v));

      return _M_insert_equal_lower(std::forward<_Arg>(__v));
    }


  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_node(_Base_ptr __x, _Base_ptr __p, _Link_type __z)
    {
      bool __insert_left = (__x != 0 || __p == _M_end()
       || _M_impl._M_key_compare(_S_key(__z),
            _S_key(__p)));

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_lower_node(_Base_ptr __p, _Link_type __z)
    {
      bool __insert_left = (__p == _M_end()
       || !_M_impl._M_key_compare(_S_key(__p),
             _S_key(__z)));

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_equal_lower_node(_Link_type __z)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = !_M_impl._M_key_compare(_S_key(__x), _S_key(__z)) ?
         _S_left(__x) : _S_right(__x);
 }
      return _M_insert_lower_node(__y, __z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    template<typename... _Args>
      pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator, bool>
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_emplace_unique(_Args&&... __args)
      {
 _Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

 try
   {
     typedef pair<iterator, bool> _Res;
     auto __res = _M_get_insert_unique_pos(_S_key(__z));
     if (__res.second)
       return _Res(_M_insert_node(__res.first, __res.second, __z), true);

     _M_destroy_node(__z);
     return _Res(iterator(static_cast<_Link_type>(__res.first)), false);
   }
 catch(...)
   {
     _M_destroy_node(__z);
     throw;
   }
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    template<typename... _Args>
      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_emplace_equal(_Args&&... __args)
      {
 _Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

 try
   {
     auto __res = _M_get_insert_equal_pos(_S_key(__z));
     return _M_insert_node(__res.first, __res.second, __z);
   }
 catch(...)
   {
     _M_destroy_node(__z);
     throw;
   }
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    template<typename... _Args>
      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_emplace_hint_unique(const_iterator __pos, _Args&&... __args)
      {
 _Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

 try
   {
     auto __res = _M_get_insert_hint_unique_pos(__pos, _S_key(__z));

     if (__res.second)
       return _M_insert_node(__res.first, __res.second, __z);

     _M_destroy_node(__z);
     return iterator(static_cast<_Link_type>(__res.first));
   }
 catch(...)
   {
     _M_destroy_node(__z);
     throw;
   }
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    template<typename... _Args>
      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_emplace_hint_equal(const_iterator __pos, _Args&&... __args)
      {
 _Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

 try
   {
     auto __res = _M_get_insert_hint_equal_pos(__pos, _S_key(__z));

     if (__res.second)
       return _M_insert_node(__res.first, __res.second, __z);

     return _M_insert_equal_lower_node(__z);
   }
 catch(...)
   {
     _M_destroy_node(__z);
     throw;
   }
      }


  template<typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
      _M_insert_unique(_II __first, _II __last)
      {
 for (; __first != __last; ++__first)
   _M_insert_unique_(end(), *__first);
      }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
      _M_insert_equal(_II __first, _II __last)
      {
 for (; __first != __last; ++__first)
   _M_insert_equal_(end(), *__first);
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase_aux(const_iterator __position)
    {
      _Link_type __y =
 static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
    (const_cast<_Base_ptr>(__position._M_node),
     this->_M_impl._M_header));
      _M_destroy_node(__y);
      --_M_impl._M_node_count;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase_aux(const_iterator __first, const_iterator __last)
    {
      if (__first == begin() && __last == end())
 clear();
      else
 while (__first != __last)
   erase(__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key& __x)
    {
      pair<iterator, iterator> __p = equal_range(__x);
      const size_type __old_size = size();
      erase(__p.first, __p.second);
      return __old_size - size();
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key* __first, const _Key* __last)
    {
      while (__first != __last)
 erase(*__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k)
    {
      iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
      return (__j == end()
       || _M_impl._M_key_compare(__k,
     _S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k) const
    {
      const_iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
      return (__j == end()
       || _M_impl._M_key_compare(__k,
     _S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    count(const _Key& __k) const
    {
      pair<const_iterator, const_iterator> __p = equal_range(__k);
      const size_type __n = std::distance(__p.first, __p.second);
      return __n;
    }

  __attribute__ ((__pure__)) unsigned int
  _Rb_tree_black_count(const _Rb_tree_node_base* __node,
                       const _Rb_tree_node_base* __root) throw ();

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    bool
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::__rb_verify() const
    {
      if (_M_impl._M_node_count == 0 || begin() == end())
 return _M_impl._M_node_count == 0 && begin() == end()
        && this->_M_impl._M_header._M_left == _M_end()
        && this->_M_impl._M_header._M_right == _M_end();

      unsigned int __len = _Rb_tree_black_count(_M_leftmost(), _M_root());
      for (const_iterator __it = begin(); __it != end(); ++__it)
 {
   _Const_Link_type __x = static_cast<_Const_Link_type>(__it._M_node);
   _Const_Link_type __L = _S_left(__x);
   _Const_Link_type __R = _S_right(__x);

   if (__x->_M_color == _S_red)
     if ((__L && __L->_M_color == _S_red)
  || (__R && __R->_M_color == _S_red))
       return false;

   if (__L && _M_impl._M_key_compare(_S_key(__x), _S_key(__L)))
     return false;
   if (__R && _M_impl._M_key_compare(_S_key(__R), _S_key(__x)))
     return false;

   if (!__L && !__R && _Rb_tree_black_count(__x, _M_root()) != __len)
     return false;
 }

      if (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root()))
 return false;
      if (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root()))
 return false;
      return true;
    }


}
# 61 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/set" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_set.h" 1 3
# 64 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_set.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 88 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_set.h" 3
  template<typename _Key, typename _Compare = std::less<_Key>,
    typename _Alloc = std::allocator<_Key> >
    class set
    {

      typedef typename _Alloc::value_type _Alloc_value_type;





    public:



      typedef _Key key_type;
      typedef _Key value_type;
      typedef _Compare key_compare;
      typedef _Compare value_compare;
      typedef _Alloc allocator_type;


    private:
      typedef typename _Alloc::template rebind<_Key>::other _Key_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,
         key_compare, _Key_alloc_type> _Rep_type;
      _Rep_type _M_t;

    public:


      typedef typename _Key_alloc_type::pointer pointer;
      typedef typename _Key_alloc_type::const_pointer const_pointer;
      typedef typename _Key_alloc_type::reference reference;
      typedef typename _Key_alloc_type::const_reference const_reference;



      typedef typename _Rep_type::const_iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;






      set()
      : _M_t() { }






      explicit
      set(const _Compare& __comp,
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Key_alloc_type(__a)) { }
# 162 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_set.h" 3
      template<typename _InputIterator>
 set(_InputIterator __first, _InputIterator __last)
 : _M_t()
 { _M_t._M_insert_unique(__first, __last); }
# 179 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_set.h" 3
      template<typename _InputIterator>
 set(_InputIterator __first, _InputIterator __last,
     const _Compare& __comp,
     const allocator_type& __a = allocator_type())
 : _M_t(__comp, _Key_alloc_type(__a))
        { _M_t._M_insert_unique(__first, __last); }
# 193 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_set.h" 3
      set(const set& __x)
      : _M_t(__x._M_t) { }
# 204 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_set.h" 3
      set(set&& __x)
      noexcept(is_nothrow_copy_constructible<_Compare>::value)
      : _M_t(std::move(__x._M_t)) { }
# 218 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_set.h" 3
      set(initializer_list<value_type> __l,
   const _Compare& __comp = _Compare(),
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Key_alloc_type(__a))
      { _M_t._M_insert_unique(__l.begin(), __l.end()); }
# 232 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_set.h" 3
      set&
      operator=(const set& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
# 247 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_set.h" 3
      set&
      operator=(set&& __x)
      {


 this->clear();
 this->swap(__x);
       return *this;
      }
# 268 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_set.h" 3
      set&
      operator=(initializer_list<value_type> __l)
      {
 this->clear();
 this->insert(__l.begin(), __l.end());
 return *this;
      }





      key_compare
      key_comp() const
      { return _M_t.key_comp(); }

      value_compare
      value_comp() const
      { return _M_t.key_comp(); }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_t.get_allocator()); }






      iterator
      begin() const noexcept
      { return _M_t.begin(); }






      iterator
      end() const noexcept
      { return _M_t.end(); }






      reverse_iterator
      rbegin() const noexcept
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() const noexcept
      { return _M_t.rend(); }







      iterator
      cbegin() const noexcept
      { return _M_t.begin(); }






      iterator
      cend() const noexcept
      { return _M_t.end(); }






      reverse_iterator
      crbegin() const noexcept
      { return _M_t.rbegin(); }






      reverse_iterator
      crend() const noexcept
      { return _M_t.rend(); }



      bool
      empty() const noexcept
      { return _M_t.empty(); }


      size_type
      size() const noexcept
      { return _M_t.size(); }


      size_type
      max_size() const noexcept
      { return _M_t.max_size(); }
# 392 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_set.h" 3
      void
      swap(set& __x)
      { _M_t.swap(__x._M_t); }
# 411 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_set.h" 3
      template<typename... _Args>
 std::pair<iterator, bool>
 emplace(_Args&&... __args)
 { return _M_t._M_emplace_unique(std::forward<_Args>(__args)...); }
# 437 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_set.h" 3
      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __pos, _Args&&... __args)
 {
   return _M_t._M_emplace_hint_unique(__pos,
          std::forward<_Args>(__args)...);
 }
# 459 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_set.h" 3
      std::pair<iterator, bool>
      insert(const value_type& __x)
      {
 std::pair<typename _Rep_type::iterator, bool> __p =
   _M_t._M_insert_unique(__x);
 return std::pair<iterator, bool>(__p.first, __p.second);
      }


      std::pair<iterator, bool>
      insert(value_type&& __x)
      {
 std::pair<typename _Rep_type::iterator, bool> __p =
   _M_t._M_insert_unique(std::move(__x));
 return std::pair<iterator, bool>(__p.first, __p.second);
      }
# 496 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_set.h" 3
      iterator
      insert(const_iterator __position, const value_type& __x)
      { return _M_t._M_insert_unique_(__position, __x); }


      iterator
      insert(const_iterator __position, value_type&& __x)
      { return _M_t._M_insert_unique_(__position, std::move(__x)); }
# 515 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_set.h" 3
      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 { _M_t._M_insert_unique(__first, __last); }
# 528 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_set.h" 3
      void
      insert(initializer_list<value_type> __l)
      { this->insert(__l.begin(), __l.end()); }
# 549 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_set.h" 3
      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(const_iterator __position)
      { return _M_t.erase(__position); }
# 580 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_set.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 601 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_set.h" 3
      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_t.erase(__first, __last); }
# 629 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_set.h" 3
      void
      clear() noexcept
      { _M_t.clear(); }
# 643 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_set.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
# 661 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_set.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
# 682 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_set.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }

      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }
# 698 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_set.h" 3
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }

      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 723 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_set.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }


      template<typename _K1, typename _C1, typename _A1>
 friend bool
 operator==(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);

      template<typename _K1, typename _C1, typename _A1>
 friend bool
 operator<(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);
    };
# 752 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_set.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator==(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 769 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_set.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<(const set<_Key, _Compare, _Alloc>& __x,
       const set<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>(const set<_Key, _Compare, _Alloc>& __x,
       const set<_Key, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline void
    swap(set<_Key, _Compare, _Alloc>& __x, set<_Key, _Compare, _Alloc>& __y)
    { __x.swap(__y); }


}
# 62 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/set" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multiset.h" 1 3
# 64 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multiset.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 90 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multiset.h" 3
  template <typename _Key, typename _Compare = std::less<_Key>,
     typename _Alloc = std::allocator<_Key> >
    class multiset
    {

      typedef typename _Alloc::value_type _Alloc_value_type;





    public:

      typedef _Key key_type;
      typedef _Key value_type;
      typedef _Compare key_compare;
      typedef _Compare value_compare;
      typedef _Alloc allocator_type;

    private:

      typedef typename _Alloc::template rebind<_Key>::other _Key_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,
         key_compare, _Key_alloc_type> _Rep_type;

      _Rep_type _M_t;

    public:
      typedef typename _Key_alloc_type::pointer pointer;
      typedef typename _Key_alloc_type::const_pointer const_pointer;
      typedef typename _Key_alloc_type::reference reference;
      typedef typename _Key_alloc_type::const_reference const_reference;



      typedef typename _Rep_type::const_iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;





      multiset()
      : _M_t() { }






      explicit
      multiset(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Key_alloc_type(__a)) { }
# 159 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multiset.h" 3
      template<typename _InputIterator>
        multiset(_InputIterator __first, _InputIterator __last)
 : _M_t()
        { _M_t._M_insert_equal(__first, __last); }
# 175 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multiset.h" 3
      template<typename _InputIterator>
        multiset(_InputIterator __first, _InputIterator __last,
   const _Compare& __comp,
   const allocator_type& __a = allocator_type())
 : _M_t(__comp, _Key_alloc_type(__a))
        { _M_t._M_insert_equal(__first, __last); }
# 189 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multiset.h" 3
      multiset(const multiset& __x)
      : _M_t(__x._M_t) { }
# 200 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multiset.h" 3
      multiset(multiset&& __x)
      noexcept(is_nothrow_copy_constructible<_Compare>::value)
      : _M_t(std::move(__x._M_t)) { }
# 214 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multiset.h" 3
      multiset(initializer_list<value_type> __l,
        const _Compare& __comp = _Compare(),
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Key_alloc_type(__a))
      { _M_t._M_insert_equal(__l.begin(), __l.end()); }
# 228 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multiset.h" 3
      multiset&
      operator=(const multiset& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
# 244 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multiset.h" 3
      multiset&
      operator=(multiset&& __x)
      {


 this->clear();
 this->swap(__x);
 return *this;
      }
# 265 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multiset.h" 3
      multiset&
      operator=(initializer_list<value_type> __l)
      {
 this->clear();
 this->insert(__l.begin(), __l.end());
 return *this;
      }





      key_compare
      key_comp() const
      { return _M_t.key_comp(); }

      value_compare
      value_comp() const
      { return _M_t.key_comp(); }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_t.get_allocator()); }






      iterator
      begin() const noexcept
      { return _M_t.begin(); }






      iterator
      end() const noexcept
      { return _M_t.end(); }






      reverse_iterator
      rbegin() const noexcept
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() const noexcept
      { return _M_t.rend(); }







      iterator
      cbegin() const noexcept
      { return _M_t.begin(); }






      iterator
      cend() const noexcept
      { return _M_t.end(); }






      reverse_iterator
      crbegin() const noexcept
      { return _M_t.rbegin(); }






      reverse_iterator
      crend() const noexcept
      { return _M_t.rend(); }



      bool
      empty() const noexcept
      { return _M_t.empty(); }


      size_type
      size() const noexcept
      { return _M_t.size(); }


      size_type
      max_size() const noexcept
      { return _M_t.max_size(); }
# 389 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multiset.h" 3
      void
      swap(multiset& __x)
      { _M_t.swap(__x._M_t); }
# 407 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multiset.h" 3
      template<typename... _Args>
 iterator
 emplace(_Args&&... __args)
 { return _M_t._M_emplace_equal(std::forward<_Args>(__args)...); }
# 433 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multiset.h" 3
      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __pos, _Args&&... __args)
 {
   return _M_t._M_emplace_hint_equal(__pos,
         std::forward<_Args>(__args)...);
 }
# 453 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multiset.h" 3
      iterator
      insert(const value_type& __x)
      { return _M_t._M_insert_equal(__x); }


      iterator
      insert(value_type&& __x)
      { return _M_t._M_insert_equal(std::move(__x)); }
# 483 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multiset.h" 3
      iterator
      insert(const_iterator __position, const value_type& __x)
      { return _M_t._M_insert_equal_(__position, __x); }


      iterator
      insert(const_iterator __position, value_type&& __x)
      { return _M_t._M_insert_equal_(__position, std::move(__x)); }
# 501 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multiset.h" 3
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_equal(__first, __last); }
# 514 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multiset.h" 3
      void
      insert(initializer_list<value_type> __l)
      { this->insert(__l.begin(), __l.end()); }
# 535 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multiset.h" 3
      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(const_iterator __position)
      { return _M_t.erase(__position); }
# 566 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multiset.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 587 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multiset.h" 3
      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_t.erase(__first, __last); }
# 615 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multiset.h" 3
      void
      clear() noexcept
      { _M_t.clear(); }
# 626 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multiset.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.count(__x); }
# 644 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multiset.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
# 665 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multiset.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }

      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }
# 681 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multiset.h" 3
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }

      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 706 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multiset.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }


      template<typename _K1, typename _C1, typename _A1>
        friend bool
        operator==(const multiset<_K1, _C1, _A1>&,
     const multiset<_K1, _C1, _A1>&);

      template<typename _K1, typename _C1, typename _A1>
        friend bool
        operator< (const multiset<_K1, _C1, _A1>&,
     const multiset<_K1, _C1, _A1>&);
    };
# 737 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multiset.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator==(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 754 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multiset.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<(const multiset<_Key, _Compare, _Alloc>& __x,
       const multiset<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>(const multiset<_Key,_Compare,_Alloc>& __x,
       const multiset<_Key,_Compare,_Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline void
    swap(multiset<_Key, _Compare, _Alloc>& __x,
  multiset<_Key, _Compare, _Alloc>& __y)
    { __x.swap(__y); }


}
# 63 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/set" 2 3
# 6 "../lib/log.h" 2






static int _file_log_level __attribute__((unused)) = -1;

extern int get_file_log_level(const char *file, int *level);
extern void add_debug_spec(const char *spec);
extern int verbose;
class output_log_prefix {
    const char *fn;
    int level;
    friend std::ostream &operator<<(std::ostream &, const output_log_prefix &);
 public:
    output_log_prefix(const char *f, int l) : fn(f), level(l) {}
};
# 48 "../lib/log.h"
template<class T> inline auto operator<<(std::ostream &out, const T &obj) ->
        decltype((void)obj.dbprint(out), out)
{ obj.dbprint(out); return out; }

template<class T> inline auto operator<<(std::ostream &out, const T *obj) ->
        decltype((void)obj->dbprint(out), out) {
    if (obj)
        obj->dbprint(out);
    else
        out << "<null>";
    return out; }

template<class T> std::ostream &operator<<(std::ostream &out, const std::vector<T> &vec) {
    const char *sep = " ";
    out << '[';
    for (auto &el : vec) {
        out << sep << el;
        sep = ", "; }
    out << (sep+1) << ']';
    return out; }

template<class T> std::ostream &operator<<(std::ostream &out, const std::set<T> &vec) {
    const char *sep = " ";
    out << '(';
    for (auto &el : vec) {
        out << sep << el;
        sep = ", "; }
    out << (sep+1) << ')';
    return out; }
# 9 "../ir/ir.h" 2
# 1 "../lib/null.h" 1





# 1 "../lib/error.h" 1






# 1 "/usr/include/boost/format.hpp" 1 3 4
# 19 "/usr/include/boost/format.hpp" 3 4
# 1 "/usr/include/boost/detail/workaround.hpp" 1 3 4
# 41 "/usr/include/boost/detail/workaround.hpp" 3 4
# 1 "/usr/include/boost/config.hpp" 1 3 4
# 26 "/usr/include/boost/config.hpp" 3 4
# 1 "/usr/include/boost/config/user.hpp" 1 3 4
# 27 "/usr/include/boost/config.hpp" 2 3 4




# 1 "/usr/include/boost/config/select_compiler_config.hpp" 1 3 4
# 32 "/usr/include/boost/config.hpp" 2 3 4



# 1 "/usr/include/boost/config/compiler/clang.hpp" 1 3 4
# 36 "/usr/include/boost/config.hpp" 2 3 4




# 1 "/usr/include/boost/config/select_stdlib_config.hpp" 1 3 4
# 18 "/usr/include/boost/config/select_stdlib_config.hpp" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 3


# 1 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/stddef.h" 1 3
# 47 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/stddef.h" 3
typedef long int ptrdiff_t;
# 117 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/stddef.h" 3
typedef struct {
  long long __clang_max_align_nonce1
      __attribute__((__aligned__(__alignof__(long long))));
  long double __clang_max_align_nonce2
      __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;
# 43 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 2 3
# 19 "/usr/include/boost/config/select_stdlib_config.hpp" 2 3 4
# 37 "/usr/include/boost/config/select_stdlib_config.hpp" 3 4
# 1 "/usr/include/boost/config/no_tr1/utility.hpp" 1 3 4
# 38 "/usr/include/boost/config/select_stdlib_config.hpp" 2 3 4
# 41 "/usr/include/boost/config.hpp" 2 3 4



# 1 "/usr/include/boost/config/stdlib/libstdcpp3.hpp" 1 3 4
# 77 "/usr/include/boost/config/stdlib/libstdcpp3.hpp" 3 4
# 1 "/usr/include/unistd.h" 1 3 4
# 27 "/usr/include/unistd.h" 3 4
extern "C" {
# 202 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix_opt.h" 1 3 4
# 203 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/environments.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/environments.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/environments.h" 2 3 4
# 207 "/usr/include/unistd.h" 2 3 4
# 226 "/usr/include/unistd.h" 3 4
# 1 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/stddef.h" 1 3 4
# 227 "/usr/include/unistd.h" 2 3 4
# 274 "/usr/include/unistd.h" 3 4
typedef __socklen_t socklen_t;
# 287 "/usr/include/unistd.h" 3 4
extern int access (const char *__name, int __type) throw () __attribute__ ((__nonnull__ (1)));




extern int euidaccess (const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));


extern int eaccess (const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));






extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;
# 334 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) throw ();
# 345 "/usr/include/unistd.h" 3 4
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     throw ();






extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;





extern ssize_t write (int __fd, const void *__buf, size_t __n) ;
# 376 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset) ;






extern ssize_t pwrite (int __fd, const void *__buf, size_t __n,
         __off_t __offset) ;
# 404 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) ;


extern ssize_t pwrite64 (int __fd, const void *__buf, size_t __n,
    __off64_t __offset) ;







extern int pipe (int __pipedes[2]) throw () ;




extern int pipe2 (int __pipedes[2], int __flags) throw () ;
# 432 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) throw ();
# 444 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     throw ();






extern int usleep (__useconds_t __useconds);
# 469 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) throw () ;




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;



extern int chdir (const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) throw () ;
# 511 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) throw () ;





extern char *get_current_dir_name (void) throw ();







extern char *getwd (char *__buf)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;




extern int dup (int __fd) throw () ;


extern int dup2 (int __fd, int __fd2) throw ();




extern int dup3 (int __fd, int __fd2, int __flags) throw ();



extern char **__environ;

extern char **environ;





extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) throw () __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     throw () __attribute__ ((__nonnull__ (2)));




extern int execv (const char *__path, char *const __argv[])
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execle (const char *__path, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execl (const char *__path, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (const char *__file, char *const __argv[])
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (const char *__file, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int execvpe (const char *__file, char *const __argv[],
      char *const __envp[])
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern int nice (int __inc) throw () ;




extern void _exit (int __status) __attribute__ ((__noreturn__));






# 1 "/usr/include/x86_64-linux-gnu/bits/confname.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 610 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (const char *__path, int __name)
     throw () __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) throw ();


extern long int sysconf (int __name) throw ();



extern size_t confstr (int __name, char *__buf, size_t __len) throw ();




extern __pid_t getpid (void) throw ();


extern __pid_t getppid (void) throw ();


extern __pid_t getpgrp (void) throw ();


extern __pid_t __getpgid (__pid_t __pid) throw ();

extern __pid_t getpgid (__pid_t __pid) throw ();






extern int setpgid (__pid_t __pid, __pid_t __pgid) throw ();
# 660 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) throw ();






extern __pid_t setsid (void) throw ();



extern __pid_t getsid (__pid_t __pid) throw ();



extern __uid_t getuid (void) throw ();


extern __uid_t geteuid (void) throw ();


extern __gid_t getgid (void) throw ();


extern __gid_t getegid (void) throw ();




extern int getgroups (int __size, __gid_t __list[]) throw () ;



extern int group_member (__gid_t __gid) throw ();






extern int setuid (__uid_t __uid) throw () ;




extern int setreuid (__uid_t __ruid, __uid_t __euid) throw () ;




extern int seteuid (__uid_t __uid) throw () ;






extern int setgid (__gid_t __gid) throw () ;




extern int setregid (__gid_t __rgid, __gid_t __egid) throw () ;




extern int setegid (__gid_t __gid) throw () ;





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     throw ();



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     throw ();



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     throw () ;



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     throw () ;






extern __pid_t fork (void) throw ();







extern __pid_t vfork (void) throw ();





extern char *ttyname (int __fd) throw ();



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) ;



extern int isatty (int __fd) throw ();





extern int ttyslot (void) throw ();




extern int link (const char *__from, const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     throw () __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (const char *__from, const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern int symlinkat (const char *__from, int __tofd,
        const char *__to) throw () __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (2, 3))) ;



extern int unlink (const char *__name) throw () __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, const char *__name, int __flag)
     throw () __attribute__ ((__nonnull__ (2)));



extern int rmdir (const char *__path) throw () __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) throw ();


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) throw ();






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (const char *__name) throw () __attribute__ ((__nonnull__ (1)));
# 871 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/getopt.h" 1 3 4
# 48 "/usr/include/getopt.h" 3 4
extern "C" {
# 57 "/usr/include/getopt.h" 3 4
extern char *optarg;
# 71 "/usr/include/getopt.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 150 "/usr/include/getopt.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       throw ();
# 185 "/usr/include/getopt.h" 3 4
}
# 872 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) throw () __attribute__ ((__nonnull__ (1)));






extern int sethostname (const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) throw () ;





extern int getdomainname (char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern int vhangup (void) throw ();


extern int revoke (const char *__file) throw () __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     throw () __attribute__ ((__nonnull__ (1)));





extern int acct (const char *__name) throw ();



extern char *getusershell (void) throw ();
extern void endusershell (void) throw ();
extern void setusershell (void) throw ();





extern int daemon (int __nochdir, int __noclose) throw () ;






extern int chroot (const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));







extern int fsync (int __fd);





extern int syncfs (int __fd) throw ();






extern long int gethostid (void);


extern void sync (void) throw ();





extern int getpagesize (void) throw () __attribute__ ((__const__));




extern int getdtablesize (void) throw ();
# 993 "/usr/include/unistd.h" 3 4
extern int truncate (const char *__file, __off_t __length)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 1005 "/usr/include/unistd.h" 3 4
extern int truncate64 (const char *__file, __off64_t __length)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 1016 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) throw () ;
# 1026 "/usr/include/unistd.h" 3 4
extern int ftruncate64 (int __fd, __off64_t __length) throw () ;
# 1037 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) throw () ;





extern void *sbrk (intptr_t __delta) throw ();
# 1058 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) throw ();
# 1081 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len) ;
# 1091 "/usr/include/unistd.h" 3 4
extern int lockf64 (int __fd, int __cmd, __off64_t __len) ;
# 1112 "/usr/include/unistd.h" 3 4
extern int fdatasync (int __fildes);







extern char *crypt (const char *__key, const char *__salt)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern void encrypt (char *__glibc_block, int __edflag)
     throw () __attribute__ ((__nonnull__ (1)));






extern void swab (const void *__restrict __from, void *__restrict __to,
    ssize_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));
# 1151 "/usr/include/unistd.h" 3 4
}
# 78 "/usr/include/boost/config/stdlib/libstdcpp3.hpp" 2 3 4
# 45 "/usr/include/boost/config.hpp" 2 3 4




# 1 "/usr/include/boost/config/select_platform_config.hpp" 1 3 4
# 50 "/usr/include/boost/config.hpp" 2 3 4



# 1 "/usr/include/boost/config/platform/linux.hpp" 1 3 4
# 15 "/usr/include/boost/config/platform/linux.hpp" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstdlib" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstdlib" 3
# 16 "/usr/include/boost/config/platform/linux.hpp" 2 3 4
# 74 "/usr/include/boost/config/platform/linux.hpp" 3 4
# 1 "/usr/include/boost/config/posix_features.hpp" 1 3 4
# 75 "/usr/include/boost/config/platform/linux.hpp" 2 3 4
# 54 "/usr/include/boost/config.hpp" 2 3 4



# 1 "/usr/include/boost/config/suffix.hpp" 1 3 4
# 35 "/usr/include/boost/config/suffix.hpp" 3
# 482 "/usr/include/boost/config/suffix.hpp" 3
namespace boost{

   __extension__ typedef long long long_long_type;
   __extension__ typedef unsigned long long ulong_long_type;




}
# 58 "/usr/include/boost/config.hpp" 2 3 4
# 42 "/usr/include/boost/detail/workaround.hpp" 2 3 4
# 20 "/usr/include/boost/format.hpp" 2 3 4



# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/locale" 1 3 4
# 37 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/locale" 3




# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 1 3
# 38 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ctime" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ctime" 3
# 58 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ctime" 3
namespace std
{
  using ::clock_t;
  using ::time_t;
  using ::tm;

  using ::clock;
  using ::difftime;
  using ::mktime;
  using ::time;
  using ::asctime;
  using ::ctime;
  using ::gmtime;
  using ::localtime;
  using ::strftime;
}
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
# 52 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
  class time_base
  {
  public:
    enum dateorder { no_order, dmy, mdy, ymd, ydm };
  };

  template<typename _CharT>
    struct __timepunct_cache : public locale::facet
    {

      static const _CharT* _S_timezones[14];

      const _CharT* _M_date_format;
      const _CharT* _M_date_era_format;
      const _CharT* _M_time_format;
      const _CharT* _M_time_era_format;
      const _CharT* _M_date_time_format;
      const _CharT* _M_date_time_era_format;
      const _CharT* _M_am;
      const _CharT* _M_pm;
      const _CharT* _M_am_pm_format;


      const _CharT* _M_day1;
      const _CharT* _M_day2;
      const _CharT* _M_day3;
      const _CharT* _M_day4;
      const _CharT* _M_day5;
      const _CharT* _M_day6;
      const _CharT* _M_day7;


      const _CharT* _M_aday1;
      const _CharT* _M_aday2;
      const _CharT* _M_aday3;
      const _CharT* _M_aday4;
      const _CharT* _M_aday5;
      const _CharT* _M_aday6;
      const _CharT* _M_aday7;


      const _CharT* _M_month01;
      const _CharT* _M_month02;
      const _CharT* _M_month03;
      const _CharT* _M_month04;
      const _CharT* _M_month05;
      const _CharT* _M_month06;
      const _CharT* _M_month07;
      const _CharT* _M_month08;
      const _CharT* _M_month09;
      const _CharT* _M_month10;
      const _CharT* _M_month11;
      const _CharT* _M_month12;


      const _CharT* _M_amonth01;
      const _CharT* _M_amonth02;
      const _CharT* _M_amonth03;
      const _CharT* _M_amonth04;
      const _CharT* _M_amonth05;
      const _CharT* _M_amonth06;
      const _CharT* _M_amonth07;
      const _CharT* _M_amonth08;
      const _CharT* _M_amonth09;
      const _CharT* _M_amonth10;
      const _CharT* _M_amonth11;
      const _CharT* _M_amonth12;

      bool _M_allocated;

      __timepunct_cache(size_t __refs = 0) : facet(__refs),
      _M_date_format(0), _M_date_era_format(0), _M_time_format(0),
      _M_time_era_format(0), _M_date_time_format(0),
      _M_date_time_era_format(0), _M_am(0), _M_pm(0),
      _M_am_pm_format(0), _M_day1(0), _M_day2(0), _M_day3(0),
      _M_day4(0), _M_day5(0), _M_day6(0), _M_day7(0),
      _M_aday1(0), _M_aday2(0), _M_aday3(0), _M_aday4(0),
      _M_aday5(0), _M_aday6(0), _M_aday7(0), _M_month01(0),
      _M_month02(0), _M_month03(0), _M_month04(0), _M_month05(0),
      _M_month06(0), _M_month07(0), _M_month08(0), _M_month09(0),
      _M_month10(0), _M_month11(0), _M_month12(0), _M_amonth01(0),
      _M_amonth02(0), _M_amonth03(0), _M_amonth04(0),
      _M_amonth05(0), _M_amonth06(0), _M_amonth07(0),
      _M_amonth08(0), _M_amonth09(0), _M_amonth10(0),
      _M_amonth11(0), _M_amonth12(0), _M_allocated(false)
      { }

      ~__timepunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __timepunct_cache&
      operator=(const __timepunct_cache&);

      explicit
      __timepunct_cache(const __timepunct_cache&);
    };

  template<typename _CharT>
    __timepunct_cache<_CharT>::~__timepunct_cache()
    {
      if (_M_allocated)
 {

 }
    }


  template<>
    const char*
    __timepunct_cache<char>::_S_timezones[14];


  template<>
    const wchar_t*
    __timepunct_cache<wchar_t>::_S_timezones[14];



  template<typename _CharT>
    const _CharT* __timepunct_cache<_CharT>::_S_timezones[14];

  template<typename _CharT>
    class __timepunct : public locale::facet
    {
    public:

      typedef _CharT __char_type;
      typedef basic_string<_CharT> __string_type;
      typedef __timepunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;
      __c_locale _M_c_locale_timepunct;
      const char* _M_name_timepunct;

    public:

      static locale::id id;

      explicit
      __timepunct(size_t __refs = 0);

      explicit
      __timepunct(__cache_type* __cache, size_t __refs = 0);
# 210 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      explicit
      __timepunct(__c_locale __cloc, const char* __s, size_t __refs = 0);



      void
      _M_put(_CharT* __s, size_t __maxlen, const _CharT* __format,
      const tm* __tm) const throw ();

      void
      _M_date_formats(const _CharT** __date) const
      {

 __date[0] = _M_data->_M_date_format;
 __date[1] = _M_data->_M_date_era_format;
      }

      void
      _M_time_formats(const _CharT** __time) const
      {

 __time[0] = _M_data->_M_time_format;
 __time[1] = _M_data->_M_time_era_format;
      }

      void
      _M_date_time_formats(const _CharT** __dt) const
      {

 __dt[0] = _M_data->_M_date_time_format;
 __dt[1] = _M_data->_M_date_time_era_format;
      }

      void
      _M_am_pm_format(const _CharT* __ampm) const
      { __ampm = _M_data->_M_am_pm_format; }

      void
      _M_am_pm(const _CharT** __ampm) const
      {
 __ampm[0] = _M_data->_M_am;
 __ampm[1] = _M_data->_M_pm;
      }

      void
      _M_days(const _CharT** __days) const
      {
 __days[0] = _M_data->_M_day1;
 __days[1] = _M_data->_M_day2;
 __days[2] = _M_data->_M_day3;
 __days[3] = _M_data->_M_day4;
 __days[4] = _M_data->_M_day5;
 __days[5] = _M_data->_M_day6;
 __days[6] = _M_data->_M_day7;
      }

      void
      _M_days_abbreviated(const _CharT** __days) const
      {
 __days[0] = _M_data->_M_aday1;
 __days[1] = _M_data->_M_aday2;
 __days[2] = _M_data->_M_aday3;
 __days[3] = _M_data->_M_aday4;
 __days[4] = _M_data->_M_aday5;
 __days[5] = _M_data->_M_aday6;
 __days[6] = _M_data->_M_aday7;
      }

      void
      _M_months(const _CharT** __months) const
      {
 __months[0] = _M_data->_M_month01;
 __months[1] = _M_data->_M_month02;
 __months[2] = _M_data->_M_month03;
 __months[3] = _M_data->_M_month04;
 __months[4] = _M_data->_M_month05;
 __months[5] = _M_data->_M_month06;
 __months[6] = _M_data->_M_month07;
 __months[7] = _M_data->_M_month08;
 __months[8] = _M_data->_M_month09;
 __months[9] = _M_data->_M_month10;
 __months[10] = _M_data->_M_month11;
 __months[11] = _M_data->_M_month12;
      }

      void
      _M_months_abbreviated(const _CharT** __months) const
      {
 __months[0] = _M_data->_M_amonth01;
 __months[1] = _M_data->_M_amonth02;
 __months[2] = _M_data->_M_amonth03;
 __months[3] = _M_data->_M_amonth04;
 __months[4] = _M_data->_M_amonth05;
 __months[5] = _M_data->_M_amonth06;
 __months[6] = _M_data->_M_amonth07;
 __months[7] = _M_data->_M_amonth08;
 __months[8] = _M_data->_M_amonth09;
 __months[9] = _M_data->_M_amonth10;
 __months[10] = _M_data->_M_amonth11;
 __months[11] = _M_data->_M_amonth12;
      }

    protected:
      virtual
      ~__timepunct();


      void
      _M_initialize_timepunct(__c_locale __cloc = 0);
    };

  template<typename _CharT>
    locale::id __timepunct<_CharT>::id;


  template<>
    void
    __timepunct<char>::_M_initialize_timepunct(__c_locale __cloc);

  template<>
    void
    __timepunct<char>::_M_put(char*, size_t, const char*, const tm*) const throw ();


  template<>
    void
    __timepunct<wchar_t>::_M_initialize_timepunct(__c_locale __cloc);

  template<>
    void
    __timepunct<wchar_t>::_M_put(wchar_t*, size_t, const wchar_t*,
     const tm*) const throw ();



}



# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/time_members.h" 1 3
# 37 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/time_members.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(size_t __refs)
    : facet(__refs), _M_data(0), _M_c_locale_timepunct(0),
      _M_name_timepunct(_S_get_c_name())
    { _M_initialize_timepunct(); }

  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(__cache_type* __cache, size_t __refs)
    : facet(__refs), _M_data(__cache), _M_c_locale_timepunct(0),
      _M_name_timepunct(_S_get_c_name())
    { _M_initialize_timepunct(); }

  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(__c_locale __cloc, const char* __s,
         size_t __refs)
    : facet(__refs), _M_data(0), _M_c_locale_timepunct(0),
      _M_name_timepunct(0)
    {
      if (__builtin_strcmp(__s, _S_get_c_name()) != 0)
 {
   const size_t __len = __builtin_strlen(__s) + 1;
   char* __tmp = new char[__len];
   __builtin_memcpy(__tmp, __s, __len);
   _M_name_timepunct = __tmp;
 }
      else
 _M_name_timepunct = _S_get_c_name();

      try
 { _M_initialize_timepunct(__cloc); }
      catch(...)
 {
   if (_M_name_timepunct != _S_get_c_name())
     delete [] _M_name_timepunct;
   throw;
 }
    }

  template<typename _CharT>
    __timepunct<_CharT>::~__timepunct()
    {
      if (_M_name_timepunct != _S_get_c_name())
 delete [] _M_name_timepunct;
      delete _M_data;
      _S_destroy_c_locale(_M_c_locale_timepunct);
    }


}
# 349 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
# 367 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _InIter>
    class time_get : public locale::facet, public time_base
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;

      typedef basic_string<_CharT> __string_type;


      static locale::id id;
# 389 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      explicit
      time_get(size_t __refs = 0)
      : facet (__refs) { }
# 406 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      dateorder
      date_order() const
      { return this->do_date_order(); }
# 430 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      iter_type
      get_time(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_time(__beg, __end, __io, __err, __tm); }
# 455 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      iter_type
      get_date(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_date(__beg, __end, __io, __err, __tm); }
# 483 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      iter_type
      get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_weekday(__beg, __end, __io, __err, __tm); }
# 512 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      iter_type
      get_monthname(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_monthname(__beg, __end, __io, __err, __tm); }
# 538 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      iter_type
      get_year(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_year(__beg, __end, __io, __err, __tm); }

    protected:

      virtual
      ~time_get() { }
# 558 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      virtual dateorder
      do_date_order() const;
# 576 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
# 595 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
# 614 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_weekday(iter_type __beg, iter_type __end, ios_base&,
       ios_base::iostate& __err, tm* __tm) const;
# 633 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_monthname(iter_type __beg, iter_type __end, ios_base&,
         ios_base::iostate& __err, tm* __tm) const;
# 652 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;


      iter_type
      _M_extract_num(iter_type __beg, iter_type __end, int& __member,
       int __min, int __max, size_t __len,
       ios_base& __io, ios_base::iostate& __err) const;


      iter_type
      _M_extract_name(iter_type __beg, iter_type __end, int& __member,
        const _CharT** __names, size_t __indexlen,
        ios_base& __io, ios_base::iostate& __err) const;


      iter_type
      _M_extract_wday_or_month(iter_type __beg, iter_type __end, int& __member,
          const _CharT** __names, size_t __indexlen,
          ios_base& __io, ios_base::iostate& __err) const;


      iter_type
      _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,
       ios_base::iostate& __err, tm* __tm,
       const _CharT* __format) const;
    };

  template<typename _CharT, typename _InIter>
    locale::id time_get<_CharT, _InIter>::id;


  template<typename _CharT, typename _InIter>
    class time_get_byname : public time_get<_CharT, _InIter>
    {
    public:

      typedef _CharT char_type;
      typedef _InIter iter_type;

      explicit
      time_get_byname(const char*, size_t __refs = 0)
      : time_get<_CharT, _InIter>(__refs) { }

    protected:
      virtual
      ~time_get_byname() { }
    };
# 714 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _OutIter>
    class time_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 735 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      explicit
      time_put(size_t __refs = 0)
      : facet(__refs) { }
# 754 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
   const _CharT* __beg, const _CharT* __end) const;
# 774 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   const tm* __tm, char __format, char __mod = 0) const
      { return this->do_put(__s, __io, __fill, __tm, __format, __mod); }

    protected:

      virtual
      ~time_put()
      { }
# 801 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
      char __format, char __mod) const;
    };

  template<typename _CharT, typename _OutIter>
    locale::id time_put<_CharT, _OutIter>::id;


  template<typename _CharT, typename _OutIter>
    class time_put_byname : public time_put<_CharT, _OutIter>
    {
    public:

      typedef _CharT char_type;
      typedef _OutIter iter_type;

      explicit
      time_put_byname(const char*, size_t __refs = 0)
      : time_put<_CharT, _OutIter>(__refs)
      { };

    protected:
      virtual
      ~time_put_byname() { }
    };
# 840 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
  class money_base
  {
  public:
    enum part { none, space, symbol, sign, value };
    struct pattern { char field[4]; };

    static const pattern _S_default_pattern;

    enum
    {
      _S_minus,
      _S_zero,
      _S_end = 11
    };



    static const char* _S_atoms;



    __attribute__ ((__const__)) static pattern
    _S_construct_pattern(char __precedes, char __space, char __posn) throw ();
  };

  template<typename _CharT, bool _Intl>
    struct __moneypunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;
      const _CharT* _M_curr_symbol;
      size_t _M_curr_symbol_size;
      const _CharT* _M_positive_sign;
      size_t _M_positive_sign_size;
      const _CharT* _M_negative_sign;
      size_t _M_negative_sign_size;
      int _M_frac_digits;
      money_base::pattern _M_pos_format;
      money_base::pattern _M_neg_format;




      _CharT _M_atoms[money_base::_S_end];

      bool _M_allocated;

      __moneypunct_cache(size_t __refs = 0) : facet(__refs),
      _M_grouping(0), _M_grouping_size(0), _M_use_grouping(false),
      _M_decimal_point(_CharT()), _M_thousands_sep(_CharT()),
      _M_curr_symbol(0), _M_curr_symbol_size(0),
      _M_positive_sign(0), _M_positive_sign_size(0),
      _M_negative_sign(0), _M_negative_sign_size(0),
      _M_frac_digits(0),
      _M_pos_format(money_base::pattern()),
      _M_neg_format(money_base::pattern()), _M_allocated(false)
      { }

      ~__moneypunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __moneypunct_cache&
      operator=(const __moneypunct_cache&);

      explicit
      __moneypunct_cache(const __moneypunct_cache&);
    };

  template<typename _CharT, bool _Intl>
    __moneypunct_cache<_CharT, _Intl>::~__moneypunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_curr_symbol;
   delete [] _M_positive_sign;
   delete [] _M_negative_sign;
 }
    }
# 933 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
  template<typename _CharT, bool _Intl>
    class moneypunct : public locale::facet, public money_base
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __moneypunct_cache<_CharT, _Intl> __cache_type;

    private:
      __cache_type* _M_data;

    public:


      static const bool intl = _Intl;

      static locale::id id;
# 962 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      explicit
      moneypunct(size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_moneypunct(); }
# 975 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      explicit
      moneypunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_moneypunct(); }
# 990 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      explicit
      moneypunct(__c_locale __cloc, const char* __s, size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_moneypunct(__cloc, __s); }
# 1004 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1017 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1047 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1060 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      string_type
      curr_symbol() const
      { return this->do_curr_symbol(); }
# 1077 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      string_type
      positive_sign() const
      { return this->do_positive_sign(); }
# 1094 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      string_type
      negative_sign() const
      { return this->do_negative_sign(); }
# 1110 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      int
      frac_digits() const
      { return this->do_frac_digits(); }
# 1146 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      pattern
      pos_format() const
      { return this->do_pos_format(); }

      pattern
      neg_format() const
      { return this->do_neg_format(); }


    protected:

      virtual
      ~moneypunct();
# 1168 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1180 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1193 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1206 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_curr_symbol() const
      { return _M_data->_M_curr_symbol; }
# 1219 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_positive_sign() const
      { return _M_data->_M_positive_sign; }
# 1232 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_negative_sign() const
      { return _M_data->_M_negative_sign; }
# 1246 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      virtual int
      do_frac_digits() const
      { return _M_data->_M_frac_digits; }
# 1260 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      virtual pattern
      do_pos_format() const
      { return _M_data->_M_pos_format; }
# 1274 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      virtual pattern
      do_neg_format() const
      { return _M_data->_M_neg_format; }


       void
       _M_initialize_moneypunct(__c_locale __cloc = 0,
    const char* __name = 0);
    };

  template<typename _CharT, bool _Intl>
    locale::id moneypunct<_CharT, _Intl>::id;

  template<typename _CharT, bool _Intl>
    const bool moneypunct<_CharT, _Intl>::intl;

  template<>
    moneypunct<char, true>::~moneypunct();

  template<>
    moneypunct<char, false>::~moneypunct();

  template<>
    void
    moneypunct<char, true>::_M_initialize_moneypunct(__c_locale, const char*);

  template<>
    void
    moneypunct<char, false>::_M_initialize_moneypunct(__c_locale, const char*);


  template<>
    moneypunct<wchar_t, true>::~moneypunct();

  template<>
    moneypunct<wchar_t, false>::~moneypunct();

  template<>
    void
    moneypunct<wchar_t, true>::_M_initialize_moneypunct(__c_locale,
       const char*);

  template<>
    void
    moneypunct<wchar_t, false>::_M_initialize_moneypunct(__c_locale,
        const char*);



  template<typename _CharT, bool _Intl>
    class moneypunct_byname : public moneypunct<_CharT, _Intl>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      static const bool intl = _Intl;

      explicit
      moneypunct_byname(const char* __s, size_t __refs = 0)
      : moneypunct<_CharT, _Intl>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_moneypunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }

    protected:
      virtual
      ~moneypunct_byname() { }
    };

  template<typename _CharT, bool _Intl>
    const bool moneypunct_byname<_CharT, _Intl>::intl;
# 1369 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _InIter>
    class money_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;
      typedef basic_string<_CharT> string_type;



      static locale::id id;
# 1391 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      explicit
      money_get(size_t __refs = 0) : facet(__refs) { }
# 1421 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
   ios_base::iostate& __err, long double& __units) const
      { return this->do_get(__s, __end, __intl, __io, __err, __units); }
# 1452 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
   ios_base::iostate& __err, string_type& __digits) const
      { return this->do_get(__s, __end, __intl, __io, __err, __digits); }

    protected:

      virtual
      ~money_get() { }
# 1475 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
      ios_base::iostate& __err, long double& __units) const;
# 1487 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
      ios_base::iostate& __err, string_type& __digits) const;
# 1498 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      template<bool _Intl>
        iter_type
        _M_extract(iter_type __s, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, string& __digits) const;
    };

  template<typename _CharT, typename _InIter>
    locale::id money_get<_CharT, _InIter>::id;
# 1520 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _OutIter>
    class money_put : public locale::facet
    {
    public:


      typedef _CharT char_type;
      typedef _OutIter iter_type;
      typedef basic_string<_CharT> string_type;



      static locale::id id;
# 1541 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      explicit
      money_put(size_t __refs = 0) : facet(__refs) { }
# 1561 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
   char_type __fill, long double __units) const
      { return this->do_put(__s, __intl, __io, __fill, __units); }
# 1584 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
   char_type __fill, const string_type& __digits) const
      { return this->do_put(__s, __intl, __io, __fill, __digits); }

    protected:

      virtual
      ~money_put() { }
# 1618 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
      long double __units) const;
# 1642 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
      const string_type& __digits) const;
# 1653 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      template<bool _Intl>
        iter_type
        _M_insert(iter_type __s, ios_base& __io, char_type __fill,
    const string_type& __digits) const;
    };

  template<typename _CharT, typename _OutIter>
    locale::id money_put<_CharT, _OutIter>::id;







  struct messages_base
  {
    typedef int catalog;
  };
# 1694 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
  template<typename _CharT>
    class messages : public locale::facet, public messages_base
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_messages;
      const char* _M_name_messages;

    public:

      static locale::id id;
# 1722 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      explicit
      messages(size_t __refs = 0);
# 1736 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      explicit
      messages(__c_locale __cloc, const char* __s, size_t __refs = 0);
# 1749 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      catalog
      open(const basic_string<char>& __s, const locale& __loc) const
      { return this->do_open(__s, __loc); }
# 1767 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      catalog
      open(const basic_string<char>&, const locale&, const char*) const;
# 1785 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      string_type
      get(catalog __c, int __set, int __msgid, const string_type& __s) const
      { return this->do_get(__c, __set, __msgid, __s); }
# 1796 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      void
      close(catalog __c) const
      { return this->do_close(__c); }

    protected:

      virtual
      ~messages();
# 1816 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      virtual catalog
      do_open(const basic_string<char>&, const locale&) const;
# 1835 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_get(catalog, int, int, const string_type& __dfault) const;






      virtual void
      do_close(catalog) const;


      char*
      _M_convert_to_char(const string_type& __msg) const
      {

 return reinterpret_cast<char*>(const_cast<_CharT*>(__msg.c_str()));
      }


      string_type
      _M_convert_from_char(char*) const
      {

 return string_type();
      }
     };

  template<typename _CharT>
    locale::id messages<_CharT>::id;


  template<>
    string
    messages<char>::do_get(catalog, int, int, const string&) const;


  template<>
    wstring
    messages<wchar_t>::do_get(catalog, int, int, const wstring&) const;



   template<typename _CharT>
    class messages_byname : public messages<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      messages_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~messages_byname()
      { }
    };


}



# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/messages_members.h" 1 3
# 36 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/messages_members.h" 3
# 1 "/usr/include/libintl.h" 1 3 4
# 34 "/usr/include/libintl.h" 3 4
extern "C" {




extern char *gettext (const char *__msgid)
     throw () __attribute__ ((__format_arg__ (1)));



extern char *dgettext (const char *__domainname, const char *__msgid)
     throw () __attribute__ ((__format_arg__ (2)));
extern char *__dgettext (const char *__domainname, const char *__msgid)
     throw () __attribute__ ((__format_arg__ (2)));



extern char *dcgettext (const char *__domainname,
   const char *__msgid, int __category)
     throw () __attribute__ ((__format_arg__ (2)));
extern char *__dcgettext (const char *__domainname,
     const char *__msgid, int __category)
     throw () __attribute__ ((__format_arg__ (2)));




extern char *ngettext (const char *__msgid1, const char *__msgid2,
         unsigned long int __n)
     throw () __attribute__ ((__format_arg__ (1))) __attribute__ ((__format_arg__ (2)));



extern char *dngettext (const char *__domainname, const char *__msgid1,
   const char *__msgid2, unsigned long int __n)
     throw () __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));



extern char *dcngettext (const char *__domainname, const char *__msgid1,
    const char *__msgid2, unsigned long int __n,
    int __category)
     throw () __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));





extern char *textdomain (const char *__domainname) throw ();



extern char *bindtextdomain (const char *__domainname,
        const char *__dirname) throw ();



extern char *bind_textdomain_codeset (const char *__domainname,
          const char *__codeset) throw ();
# 121 "/usr/include/libintl.h" 3 4
}
# 37 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8/bits/messages_members.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _CharT>
     messages<_CharT>::messages(size_t __refs)
     : facet(__refs), _M_c_locale_messages(_S_get_c_locale()),
       _M_name_messages(_S_get_c_name())
     { }

  template<typename _CharT>
     messages<_CharT>::messages(__c_locale __cloc, const char* __s,
    size_t __refs)
     : facet(__refs), _M_c_locale_messages(0), _M_name_messages(0)
     {
       if (__builtin_strcmp(__s, _S_get_c_name()) != 0)
  {
    const size_t __len = __builtin_strlen(__s) + 1;
    char* __tmp = new char[__len];
    __builtin_memcpy(__tmp, __s, __len);
    _M_name_messages = __tmp;
  }
       else
  _M_name_messages = _S_get_c_name();


       _M_c_locale_messages = _S_clone_c_locale(__cloc);
     }

  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::open(const basic_string<char>& __s, const locale& __loc,
      const char* __dir) const
    {
      bindtextdomain(__s.c_str(), __dir);
      return this->do_open(__s, __loc);
    }


  template<typename _CharT>
    messages<_CharT>::~messages()
    {
      if (_M_name_messages != _S_get_c_name())
 delete [] _M_name_messages;
      _S_destroy_c_locale(_M_c_locale_messages);
    }

  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::do_open(const basic_string<char>& __s,
         const locale&) const
    {


      textdomain(__s.c_str());
      return 0;
    }

  template<typename _CharT>
    void
    messages<_CharT>::do_close(catalog) const
    { }


   template<typename _CharT>
     messages_byname<_CharT>::messages_byname(const char* __s, size_t __refs)
     : messages<_CharT>(__refs)
     {
       if (this->_M_name_messages != locale::facet::_S_get_c_name())
  {
    delete [] this->_M_name_messages;
    if (__builtin_strcmp(__s, locale::facet::_S_get_c_name()) != 0)
      {
        const size_t __len = __builtin_strlen(__s) + 1;
        char* __tmp = new char[__len];
        __builtin_memcpy(__tmp, __s, __len);
        this->_M_name_messages = __tmp;
      }
    else
      this->_M_name_messages = locale::facet::_S_get_c_name();
  }

       if (__builtin_strcmp(__s, "C") != 0
    && __builtin_strcmp(__s, "POSIX") != 0)
  {
    this->_S_destroy_c_locale(this->_M_c_locale_messages);
    this->_S_create_c_locale(this->_M_c_locale_messages, __s);
  }
     }


}
# 1899 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 2 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/codecvt.h" 1 3
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/codecvt.h" 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  class codecvt_base
  {
  public:
    enum result
    {
      ok,
      partial,
      error,
      noconv
    };
  };
# 67 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/codecvt.h" 3
  template<typename _InternT, typename _ExternT, typename _StateT>
    class __codecvt_abstract_base
    : public locale::facet, public codecvt_base
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;
# 115 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/codecvt.h" 3
      result
      out(state_type& __state, const intern_type* __from,
   const intern_type* __from_end, const intern_type*& __from_next,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const
      {
 return this->do_out(__state, __from, __from_end, __from_next,
       __to, __to_end, __to_next);
      }
# 154 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/codecvt.h" 3
      result
      unshift(state_type& __state, extern_type* __to, extern_type* __to_end,
       extern_type*& __to_next) const
      { return this->do_unshift(__state, __to,__to_end,__to_next); }
# 195 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/codecvt.h" 3
      result
      in(state_type& __state, const extern_type* __from,
  const extern_type* __from_end, const extern_type*& __from_next,
  intern_type* __to, intern_type* __to_end,
  intern_type*& __to_next) const
      {
 return this->do_in(__state, __from, __from_end, __from_next,
      __to, __to_end, __to_next);
      }

      int
      encoding() const throw()
      { return this->do_encoding(); }

      bool
      always_noconv() const throw()
      { return this->do_always_noconv(); }

      int
      length(state_type& __state, const extern_type* __from,
      const extern_type* __end, size_t __max) const
      { return this->do_length(__state, __from, __end, __max); }

      int
      max_length() const throw()
      { return this->do_max_length(); }

    protected:
      explicit
      __codecvt_abstract_base(size_t __refs = 0) : locale::facet(__refs) { }

      virtual
      ~__codecvt_abstract_base() { }
# 236 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/codecvt.h" 3
      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const = 0;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const = 0;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const = 0;

      virtual int
      do_encoding() const throw() = 0;

      virtual bool
      do_always_noconv() const throw() = 0;

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const = 0;

      virtual int
      do_max_length() const throw() = 0;
    };
# 275 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/codecvt.h" 3
   template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt
    : public __codecvt_abstract_base<_InternT, _ExternT, _StateT>
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<_InternT, _ExternT, _StateT> (__refs),
 _M_c_locale_codecvt(0)
      { }

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt() { }

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };

  template<typename _InternT, typename _ExternT, typename _StateT>
    locale::id codecvt<_InternT, _ExternT, _StateT>::id;


  template<>
    class codecvt<char, char, mbstate_t>
    : public __codecvt_abstract_base<char, char, mbstate_t>
    {
    public:

      typedef char intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
  };



  template<>
    class codecvt<wchar_t, char, mbstate_t>
    : public __codecvt_abstract_base<wchar_t, char, mbstate_t>
    {
    public:

      typedef wchar_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };



  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname : public codecvt<_InternT, _ExternT, _StateT>
    {
    public:
      explicit
      codecvt_byname(const char* __s, size_t __refs = 0)
      : codecvt<_InternT, _ExternT, _StateT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_codecvt);
     this->_S_create_c_locale(this->_M_c_locale_codecvt, __s);
   }
      }

    protected:
      virtual
      ~codecvt_byname() { }
    };




  extern template class codecvt_byname<char, char, mbstate_t>;

  extern template
    const codecvt<char, char, mbstate_t>&
    use_facet<codecvt<char, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<char, char, mbstate_t> >(const locale&);


  extern template class codecvt_byname<wchar_t, char, mbstate_t>;

  extern template
    const codecvt<wchar_t, char, mbstate_t>&
    use_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);




}
# 1902 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 2 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.tcc" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, bool _Intl>
    struct __use_cache<__moneypunct_cache<_CharT, _Intl> >
    {
      const __moneypunct_cache<_CharT, _Intl>*
      operator() (const locale& __loc) const
      {
 const size_t __i = moneypunct<_CharT, _Intl>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __moneypunct_cache<_CharT, _Intl>* __tmp = 0;
     try
       {
  __tmp = new __moneypunct_cache<_CharT, _Intl>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<
   const __moneypunct_cache<_CharT, _Intl>*>(__caches[__i]);
      }
    };

  template<typename _CharT, bool _Intl>
    void
    __moneypunct_cache<_CharT, _Intl>::_M_cache(const locale& __loc)
    {
      _M_allocated = true;

      const moneypunct<_CharT, _Intl>& __mp =
 use_facet<moneypunct<_CharT, _Intl> >(__loc);

      _M_decimal_point = __mp.decimal_point();
      _M_thousands_sep = __mp.thousands_sep();
      _M_frac_digits = __mp.frac_digits();

      char* __grouping = 0;
      _CharT* __curr_symbol = 0;
      _CharT* __positive_sign = 0;
      _CharT* __negative_sign = 0;
      try
 {
   _M_grouping_size = __mp.grouping().size();
   __grouping = new char[_M_grouping_size];
   __mp.grouping().copy(__grouping, _M_grouping_size);
   _M_grouping = __grouping;
   _M_use_grouping = (_M_grouping_size
        && static_cast<signed char>(_M_grouping[0]) > 0
        && (_M_grouping[0]
     != __gnu_cxx::__numeric_traits<char>::__max));

   _M_curr_symbol_size = __mp.curr_symbol().size();
   __curr_symbol = new _CharT[_M_curr_symbol_size];
   __mp.curr_symbol().copy(__curr_symbol, _M_curr_symbol_size);
   _M_curr_symbol = __curr_symbol;

   _M_positive_sign_size = __mp.positive_sign().size();
   __positive_sign = new _CharT[_M_positive_sign_size];
   __mp.positive_sign().copy(__positive_sign, _M_positive_sign_size);
   _M_positive_sign = __positive_sign;

   _M_negative_sign_size = __mp.negative_sign().size();
   __negative_sign = new _CharT[_M_negative_sign_size];
   __mp.negative_sign().copy(__negative_sign, _M_negative_sign_size);
   _M_negative_sign = __negative_sign;

   _M_pos_format = __mp.pos_format();
   _M_neg_format = __mp.neg_format();

   const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
   __ct.widen(money_base::_S_atoms,
       money_base::_S_atoms + money_base::_S_end, _M_atoms);
 }
      catch(...)
 {
   delete [] __grouping;
   delete [] __curr_symbol;
   delete [] __positive_sign;
   delete [] __negative_sign;
   throw;
 }
    }



  template<typename _CharT, typename _InIter>
    template<bool _Intl>
      _InIter
      money_get<_CharT, _InIter>::
      _M_extract(iter_type __beg, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, string& __units) const
      {
 typedef char_traits<_CharT> __traits_type;
 typedef typename string_type::size_type size_type;
 typedef money_base::part part;
 typedef __moneypunct_cache<_CharT, _Intl> __cache_type;

 const locale& __loc = __io._M_getloc();
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 __use_cache<__cache_type> __uc;
 const __cache_type* __lc = __uc(__loc);
 const char_type* __lit = __lc->_M_atoms;


 bool __negative = false;

 size_type __sign_size = 0;

 const bool __mandatory_sign = (__lc->_M_positive_sign_size
           && __lc->_M_negative_sign_size);

 string __grouping_tmp;
 if (__lc->_M_use_grouping)
   __grouping_tmp.reserve(32);

 int __last_pos = 0;

 int __n = 0;

 bool __testvalid = true;

 bool __testdecfound = false;


 string __res;
 __res.reserve(32);

 const char_type* __lit_zero = __lit + money_base::_S_zero;
 const money_base::pattern __p = __lc->_M_neg_format;
 for (int __i = 0; __i < 4 && __testvalid; ++__i)
   {
     const part __which = static_cast<part>(__p.field[__i]);
     switch (__which)
       {
       case money_base::symbol:




  if (__io.flags() & ios_base::showbase || __sign_size > 1
      || __i == 0
      || (__i == 1 && (__mandatory_sign
         || (static_cast<part>(__p.field[0])
      == money_base::sign)
         || (static_cast<part>(__p.field[2])
      == money_base::space)))
      || (__i == 2 && ((static_cast<part>(__p.field[3])
          == money_base::value)
         || (__mandatory_sign
      && (static_cast<part>(__p.field[3])
          == money_base::sign)))))
    {
      const size_type __len = __lc->_M_curr_symbol_size;
      size_type __j = 0;
      for (; __beg != __end && __j < __len
      && *__beg == __lc->_M_curr_symbol[__j];
    ++__beg, ++__j);
      if (__j != __len
   && (__j || __io.flags() & ios_base::showbase))
        __testvalid = false;
    }
  break;
       case money_base::sign:

  if (__lc->_M_positive_sign_size && __beg != __end
      && *__beg == __lc->_M_positive_sign[0])
    {
      __sign_size = __lc->_M_positive_sign_size;
      ++__beg;
    }
  else if (__lc->_M_negative_sign_size && __beg != __end
    && *__beg == __lc->_M_negative_sign[0])
    {
      __negative = true;
      __sign_size = __lc->_M_negative_sign_size;
      ++__beg;
    }
  else if (__lc->_M_positive_sign_size
    && !__lc->_M_negative_sign_size)


    __negative = true;
  else if (__mandatory_sign)
    __testvalid = false;
  break;
       case money_base::value:


  for (; __beg != __end; ++__beg)
    {
      const char_type __c = *__beg;
      const char_type* __q = __traits_type::find(__lit_zero,
              10, __c);
      if (__q != 0)
        {
   __res += money_base::_S_atoms[__q - __lit];
   ++__n;
        }
      else if (__c == __lc->_M_decimal_point
        && !__testdecfound)
        {
   if (__lc->_M_frac_digits <= 0)
     break;

   __last_pos = __n;
   __n = 0;
   __testdecfound = true;
        }
      else if (__lc->_M_use_grouping
        && __c == __lc->_M_thousands_sep
        && !__testdecfound)
        {
   if (__n)
     {

       __grouping_tmp += static_cast<char>(__n);
       __n = 0;
     }
   else
     {
       __testvalid = false;
       break;
     }
        }
      else
        break;
    }
  if (__res.empty())
    __testvalid = false;
  break;
       case money_base::space:

  if (__beg != __end && __ctype.is(ctype_base::space, *__beg))
    ++__beg;
  else
    __testvalid = false;
       case money_base::none:

  if (__i != 3)
    for (; __beg != __end
    && __ctype.is(ctype_base::space, *__beg); ++__beg);
  break;
       }
   }


 if (__sign_size > 1 && __testvalid)
   {
     const char_type* __sign = __negative ? __lc->_M_negative_sign
                                          : __lc->_M_positive_sign;
     size_type __i = 1;
     for (; __beg != __end && __i < __sign_size
     && *__beg == __sign[__i]; ++__beg, ++__i);

     if (__i != __sign_size)
       __testvalid = false;
   }

 if (__testvalid)
   {

     if (__res.size() > 1)
       {
  const size_type __first = __res.find_first_not_of('0');
  const bool __only_zeros = __first == string::npos;
  if (__first)
    __res.erase(0, __only_zeros ? __res.size() - 1 : __first);
       }


     if (__negative && __res[0] != '0')
       __res.insert(__res.begin(), '-');


     if (__grouping_tmp.size())
       {

  __grouping_tmp += static_cast<char>(__testdecfound ? __last_pos
                         : __n);
  if (!std::__verify_grouping(__lc->_M_grouping,
         __lc->_M_grouping_size,
         __grouping_tmp))
    __err |= ios_base::failbit;
       }


     if (__testdecfound && __n != __lc->_M_frac_digits)
       __testvalid = false;
   }


 if (!__testvalid)
   __err |= ios_base::failbit;
 else
   __units.swap(__res);


 if (__beg == __end)
   __err |= ios_base::eofbit;
 return __beg;
      }
# 362 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
    ios_base::iostate& __err, long double& __units) const
    {
      string __str;
      __beg = __intl ? _M_extract<true>(__beg, __end, __io, __err, __str)
              : _M_extract<false>(__beg, __end, __io, __err, __str);
      std::__convert_to_v(__str.c_str(), __units, __err, _S_get_c_locale());
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
    ios_base::iostate& __err, string_type& __digits) const
    {
      typedef typename string::size_type size_type;

      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      string __str;
      __beg = __intl ? _M_extract<true>(__beg, __end, __io, __err, __str)
              : _M_extract<false>(__beg, __end, __io, __err, __str);
      const size_type __len = __str.size();
      if (__len)
 {
   __digits.resize(__len);
   __ctype.widen(__str.data(), __str.data() + __len, &__digits[0]);
 }
      return __beg;
    }

  template<typename _CharT, typename _OutIter>
    template<bool _Intl>
      _OutIter
      money_put<_CharT, _OutIter>::
      _M_insert(iter_type __s, ios_base& __io, char_type __fill,
  const string_type& __digits) const
      {
 typedef typename string_type::size_type size_type;
 typedef money_base::part part;
 typedef __moneypunct_cache<_CharT, _Intl> __cache_type;

 const locale& __loc = __io._M_getloc();
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 __use_cache<__cache_type> __uc;
 const __cache_type* __lc = __uc(__loc);
 const char_type* __lit = __lc->_M_atoms;



 const char_type* __beg = __digits.data();

 money_base::pattern __p;
 const char_type* __sign;
 size_type __sign_size;
 if (!(*__beg == __lit[money_base::_S_minus]))
   {
     __p = __lc->_M_pos_format;
     __sign = __lc->_M_positive_sign;
     __sign_size = __lc->_M_positive_sign_size;
   }
 else
   {
     __p = __lc->_M_neg_format;
     __sign = __lc->_M_negative_sign;
     __sign_size = __lc->_M_negative_sign_size;
     if (__digits.size())
       ++__beg;
   }


 size_type __len = __ctype.scan_not(ctype_base::digit, __beg,
        __beg + __digits.size()) - __beg;
 if (__len)
   {



     string_type __value;
     __value.reserve(2 * __len);



     long __paddec = __len - __lc->_M_frac_digits;
     if (__paddec > 0)
         {
  if (__lc->_M_frac_digits < 0)
    __paddec = __len;
    if (__lc->_M_grouping_size)
      {
      __value.assign(2 * __paddec, char_type());
       _CharT* __vend =
        std::__add_grouping(&__value[0], __lc->_M_thousands_sep,
       __lc->_M_grouping,
       __lc->_M_grouping_size,
       __beg, __beg + __paddec);
      __value.erase(__vend - &__value[0]);
      }
    else
    __value.assign(__beg, __paddec);
       }


     if (__lc->_M_frac_digits > 0)
       {
  __value += __lc->_M_decimal_point;
  if (__paddec >= 0)
    __value.append(__beg + __paddec, __lc->_M_frac_digits);
  else
    {

      __value.append(-__paddec, __lit[money_base::_S_zero]);
      __value.append(__beg, __len);
    }
         }


     const ios_base::fmtflags __f = __io.flags()
                                    & ios_base::adjustfield;
     __len = __value.size() + __sign_size;
     __len += ((__io.flags() & ios_base::showbase)
        ? __lc->_M_curr_symbol_size : 0);

     string_type __res;
     __res.reserve(2 * __len);

     const size_type __width = static_cast<size_type>(__io.width());
     const bool __testipad = (__f == ios_base::internal
         && __len < __width);

     for (int __i = 0; __i < 4; ++__i)
       {
  const part __which = static_cast<part>(__p.field[__i]);
  switch (__which)
    {
    case money_base::symbol:
      if (__io.flags() & ios_base::showbase)
        __res.append(__lc->_M_curr_symbol,
       __lc->_M_curr_symbol_size);
      break;
    case money_base::sign:



      if (__sign_size)
        __res += __sign[0];
      break;
    case money_base::value:
      __res += __value;
      break;
    case money_base::space:



      if (__testipad)
        __res.append(__width - __len, __fill);
      else
        __res += __fill;
      break;
    case money_base::none:
      if (__testipad)
        __res.append(__width - __len, __fill);
      break;
    }
       }


     if (__sign_size > 1)
       __res.append(__sign + 1, __sign_size - 1);


     __len = __res.size();
     if (__width > __len)
       {
  if (__f == ios_base::left)

    __res.append(__width - __len, __fill);
  else

    __res.insert(0, __width - __len, __fill);
  __len = __width;
       }


     __s = std::__write(__s, __res.data(), __len);
   }
 __io.width(0);
 return __s;
      }
# 567 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
    long double __units) const
    {
      const locale __loc = __io.getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);


      int __cs_size = 64;
      char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));


      int __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     "%.*Lf", 0, __units);

      if (__len >= __cs_size)
 {
   __cs_size = __len + 1;
   __cs = static_cast<char*>(__builtin_alloca(__cs_size));
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     "%.*Lf", 0, __units);
 }
# 599 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.tcc" 3
      string_type __digits(__len, char_type());
      __ctype.widen(__cs, __cs + __len, &__digits[0]);
      return __intl ? _M_insert<true>(__s, __io, __fill, __digits)
             : _M_insert<false>(__s, __io, __fill, __digits);
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
    const string_type& __digits) const
    { return __intl ? _M_insert<true>(__s, __io, __fill, __digits)
             : _M_insert<false>(__s, __io, __fill, __digits); }






  template<typename _CharT, typename _InIter>
    time_base::dateorder
    time_get<_CharT, _InIter>::do_date_order() const
    { return time_base::no_order; }



  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, tm* __tm,
     const _CharT* __format) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const size_t __len = char_traits<_CharT>::length(__format);

      ios_base::iostate __tmperr = ios_base::goodbit;
      size_t __i = 0;
      for (; __beg != __end && __i < __len && !__tmperr; ++__i)
 {
   if (__ctype.narrow(__format[__i], 0) == '%')
     {

       char __c = __ctype.narrow(__format[++__i], 0);
       int __mem = 0;
       if (__c == 'E' || __c == 'O')
  __c = __ctype.narrow(__format[++__i], 0);
       switch (__c)
  {
    const char* __cs;
    _CharT __wcs[10];
  case 'a':

    const char_type* __days1[7];
    __tp._M_days_abbreviated(__days1);
    __beg = _M_extract_name(__beg, __end, __tm->tm_wday, __days1,
       7, __io, __tmperr);
    break;
  case 'A':

    const char_type* __days2[7];
    __tp._M_days(__days2);
    __beg = _M_extract_name(__beg, __end, __tm->tm_wday, __days2,
       7, __io, __tmperr);
    break;
  case 'h':
  case 'b':

    const char_type* __months1[12];
    __tp._M_months_abbreviated(__months1);
    __beg = _M_extract_name(__beg, __end, __tm->tm_mon,
       __months1, 12, __io, __tmperr);
    break;
  case 'B':

    const char_type* __months2[12];
    __tp._M_months(__months2);
    __beg = _M_extract_name(__beg, __end, __tm->tm_mon,
       __months2, 12, __io, __tmperr);
    break;
  case 'c':

    const char_type* __dt[2];
    __tp._M_date_time_formats(__dt);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __dt[0]);
    break;
  case 'd':

    __beg = _M_extract_num(__beg, __end, __tm->tm_mday, 1, 31, 2,
      __io, __tmperr);
    break;
  case 'e':


    if (__ctype.is(ctype_base::space, *__beg))
      __beg = _M_extract_num(++__beg, __end, __tm->tm_mday, 1, 9,
        1, __io, __tmperr);
    else
      __beg = _M_extract_num(__beg, __end, __tm->tm_mday, 10, 31,
        2, __io, __tmperr);
    break;
  case 'D':

    __cs = "%m/%d/%y";
    __ctype.widen(__cs, __cs + 9, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'H':

    __beg = _M_extract_num(__beg, __end, __tm->tm_hour, 0, 23, 2,
      __io, __tmperr);
    break;
  case 'I':

    __beg = _M_extract_num(__beg, __end, __tm->tm_hour, 1, 12, 2,
      __io, __tmperr);
    break;
  case 'm':

    __beg = _M_extract_num(__beg, __end, __mem, 1, 12, 2,
      __io, __tmperr);
    if (!__tmperr)
      __tm->tm_mon = __mem - 1;
    break;
  case 'M':

    __beg = _M_extract_num(__beg, __end, __tm->tm_min, 0, 59, 2,
      __io, __tmperr);
    break;
  case 'n':
    if (__ctype.narrow(*__beg, 0) == '\n')
      ++__beg;
    else
      __tmperr |= ios_base::failbit;
    break;
  case 'R':

    __cs = "%H:%M";
    __ctype.widen(__cs, __cs + 6, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'S':



    __beg = _M_extract_num(__beg, __end, __tm->tm_sec, 0, 60, 2,



      __io, __tmperr);
    break;
  case 't':
    if (__ctype.narrow(*__beg, 0) == '\t')
      ++__beg;
    else
      __tmperr |= ios_base::failbit;
    break;
  case 'T':

    __cs = "%H:%M:%S";
    __ctype.widen(__cs, __cs + 9, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'x':

    const char_type* __dates[2];
    __tp._M_date_formats(__dates);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __dates[0]);
    break;
  case 'X':

    const char_type* __times[2];
    __tp._M_time_formats(__times);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __times[0]);
    break;
  case 'y':
  case 'C':

  case 'Y':




    __beg = _M_extract_num(__beg, __end, __mem, 0, 9999, 4,
      __io, __tmperr);
    if (!__tmperr)
      __tm->tm_year = __mem < 0 ? __mem + 100 : __mem - 1900;
    break;
  case 'Z':

    if (__ctype.is(ctype_base::upper, *__beg))
      {
        int __tmp;
        __beg = _M_extract_name(__beg, __end, __tmp,
           __timepunct_cache<_CharT>::_S_timezones,
           14, __io, __tmperr);


        if (__beg != __end && !__tmperr && __tmp == 0
     && (*__beg == __ctype.widen('-')
         || *__beg == __ctype.widen('+')))
   {
     __beg = _M_extract_num(__beg, __end, __tmp, 0, 23, 2,
       __io, __tmperr);
     __beg = _M_extract_num(__beg, __end, __tmp, 0, 59, 2,
       __io, __tmperr);
   }
      }
    else
      __tmperr |= ios_base::failbit;
    break;
  default:

    __tmperr |= ios_base::failbit;
  }
     }
   else
     {

       if (__format[__i] == *__beg)
  ++__beg;
       else
  __tmperr |= ios_base::failbit;
     }
 }

      if (__tmperr || __i != __len)
 __err |= ios_base::failbit;

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_num(iter_type __beg, iter_type __end, int& __member,
     int __min, int __max, size_t __len,
     ios_base& __io, ios_base::iostate& __err) const
    {
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);


      int __mult = __len == 2 ? 10 : (__len == 4 ? 1000 : 1);

      ++__min;
      size_t __i = 0;
      int __value = 0;
      for (; __beg != __end && __i < __len; ++__beg, ++__i)
 {
   const char __c = __ctype.narrow(*__beg, '*');
   if (__c >= '0' && __c <= '9')
     {
       __value = __value * 10 + (__c - '0');
       const int __valuec = __value * __mult;
       if (__valuec > __max || __valuec + __mult < __min)
  break;
       __mult /= 10;
     }
   else
     break;
 }
      if (__i == __len)
 __member = __value;

      else if (__len == 4 && __i == 2)
 __member = __value - 100;
      else
 __err |= ios_base::failbit;

      return __beg;
    }



  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_name(iter_type __beg, iter_type __end, int& __member,
      const _CharT** __names, size_t __indexlen,
      ios_base& __io, ios_base::iostate& __err) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      int* __matches = static_cast<int*>(__builtin_alloca(sizeof(int)
         * __indexlen));
      size_t __nmatches = 0;
      size_t __pos = 0;
      bool __testvalid = true;
      const char_type* __name;





      if (__beg != __end)
 {
   const char_type __c = *__beg;
   for (size_t __i1 = 0; __i1 < __indexlen; ++__i1)
     if (__c == __names[__i1][0]
  || __c == __ctype.toupper(__names[__i1][0]))
       __matches[__nmatches++] = __i1;
 }

      while (__nmatches > 1)
 {

   size_t __minlen = __traits_type::length(__names[__matches[0]]);
   for (size_t __i2 = 1; __i2 < __nmatches; ++__i2)
     __minlen = std::min(__minlen,
         __traits_type::length(__names[__matches[__i2]]));
   ++__beg, ++__pos;
   if (__pos < __minlen && __beg != __end)
     for (size_t __i3 = 0; __i3 < __nmatches;)
       {
  __name = __names[__matches[__i3]];
  if (!(__name[__pos] == *__beg))
    __matches[__i3] = __matches[--__nmatches];
  else
    ++__i3;
       }
   else
     break;
 }

      if (__nmatches == 1)
 {

   ++__beg, ++__pos;
   __name = __names[__matches[0]];
   const size_t __len = __traits_type::length(__name);
   while (__pos < __len && __beg != __end && __name[__pos] == *__beg)
     ++__beg, ++__pos;

   if (__len == __pos)
     __member = __matches[0];
   else
     __testvalid = false;
 }
      else
 __testvalid = false;
      if (!__testvalid)
 __err |= ios_base::failbit;

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_wday_or_month(iter_type __beg, iter_type __end, int& __member,
        const _CharT** __names, size_t __indexlen,
        ios_base& __io, ios_base::iostate& __err) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      int* __matches = static_cast<int*>(__builtin_alloca(2 * sizeof(int)
         * __indexlen));
      size_t __nmatches = 0;
      size_t* __matches_lengths = 0;
      size_t __pos = 0;

      if (__beg != __end)
 {
   const char_type __c = *__beg;
   for (size_t __i = 0; __i < 2 * __indexlen; ++__i)
     if (__c == __names[__i][0]
  || __c == __ctype.toupper(__names[__i][0]))
       __matches[__nmatches++] = __i;
 }

      if (__nmatches)
 {
   ++__beg, ++__pos;

   __matches_lengths
     = static_cast<size_t*>(__builtin_alloca(sizeof(size_t)
          * __nmatches));
   for (size_t __i = 0; __i < __nmatches; ++__i)
     __matches_lengths[__i]
       = __traits_type::length(__names[__matches[__i]]);
 }

      for (; __beg != __end; ++__beg, ++__pos)
 {
   size_t __nskipped = 0;
   const char_type __c = *__beg;
   for (size_t __i = 0; __i < __nmatches;)
     {
       const char_type* __name = __names[__matches[__i]];
       if (__pos >= __matches_lengths[__i])
  ++__nskipped, ++__i;
       else if (!(__name[__pos] == __c))
  {
    --__nmatches;
    __matches[__i] = __matches[__nmatches];
    __matches_lengths[__i] = __matches_lengths[__nmatches];
  }
       else
  ++__i;
     }
   if (__nskipped == __nmatches)
     break;
 }

      if ((__nmatches == 1 && __matches_lengths[0] == __pos)
   || (__nmatches == 2 && (__matches_lengths[0] == __pos
      || __matches_lengths[1] == __pos)))
 __member = (__matches[0] >= __indexlen
      ? __matches[0] - __indexlen : __matches[0]);
      else
 __err |= ios_base::failbit;

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __times[2];
      __tp._M_time_formats(__times);
      __beg = _M_extract_via_format(__beg, __end, __io, __err,
        __tm, __times[0]);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __dates[2];
      __tp._M_date_formats(__dates);
      __beg = _M_extract_via_format(__beg, __end, __io, __err,
        __tm, __dates[0]);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, tm* __tm) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const char_type* __days[14];
      __tp._M_days_abbreviated(__days);
      __tp._M_days(__days + 7);
      int __tmpwday;
      ios_base::iostate __tmperr = ios_base::goodbit;

      __beg = _M_extract_wday_or_month(__beg, __end, __tmpwday, __days, 7,
           __io, __tmperr);
      if (!__tmperr)
 __tm->tm_wday = __tmpwday;
      else
 __err |= ios_base::failbit;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
     }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_monthname(iter_type __beg, iter_type __end,
                     ios_base& __io, ios_base::iostate& __err, tm* __tm) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const char_type* __months[24];
      __tp._M_months_abbreviated(__months);
      __tp._M_months(__months + 12);
      int __tmpmon;
      ios_base::iostate __tmperr = ios_base::goodbit;

      __beg = _M_extract_wday_or_month(__beg, __end, __tmpmon, __months, 12,
           __io, __tmperr);
      if (!__tmperr)
 __tm->tm_mon = __tmpmon;
      else
 __err |= ios_base::failbit;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      int __tmpyear;
      ios_base::iostate __tmperr = ios_base::goodbit;

      __beg = _M_extract_num(__beg, __end, __tmpyear, 0, 9999, 4,
        __io, __tmperr);
      if (!__tmperr)
 __tm->tm_year = __tmpyear < 0 ? __tmpyear + 100 : __tmpyear - 1900;
      else
 __err |= ios_base::failbit;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
 const _CharT* __beg, const _CharT* __end) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      for (; __beg != __end; ++__beg)
 if (__ctype.narrow(*__beg, 0) != '%')
   {
     *__s = *__beg;
     ++__s;
   }
 else if (++__beg != __end)
   {
     char __format;
     char __mod = 0;
     const char __c = __ctype.narrow(*__beg, 0);
     if (__c != 'E' && __c != 'O')
       __format = __c;
     else if (++__beg != __end)
       {
  __mod = __c;
  __format = __ctype.narrow(*__beg, 0);
       }
     else
       break;
     __s = this->do_put(__s, __io, __fill, __tm, __format, __mod);
   }
 else
   break;
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type, const tm* __tm,
    char __format, char __mod) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      __timepunct<_CharT> const& __tp = use_facet<__timepunct<_CharT> >(__loc);



      const size_t __maxlen = 128;
      char_type __res[__maxlen];






      char_type __fmt[4];
      __fmt[0] = __ctype.widen('%');
      if (!__mod)
 {
   __fmt[1] = __format;
   __fmt[2] = char_type();
 }
      else
 {
   __fmt[1] = __mod;
   __fmt[2] = __format;
   __fmt[3] = char_type();
 }

      __tp._M_put(__res, __maxlen, __fmt, __tm);


      return std::__write(__s, __res, char_traits<char_type>::length(__res));
    }





  extern template class moneypunct<char, false>;
  extern template class moneypunct<char, true>;
  extern template class moneypunct_byname<char, false>;
  extern template class moneypunct_byname<char, true>;
  extern template class money_get<char>;
  extern template class money_put<char>;
  extern template class __timepunct<char>;
  extern template class time_put<char>;
  extern template class time_put_byname<char>;
  extern template class time_get<char>;
  extern template class time_get_byname<char>;
  extern template class messages<char>;
  extern template class messages_byname<char>;

  extern template
    const moneypunct<char, true>&
    use_facet<moneypunct<char, true> >(const locale&);

  extern template
    const moneypunct<char, false>&
    use_facet<moneypunct<char, false> >(const locale&);

  extern template
    const money_put<char>&
    use_facet<money_put<char> >(const locale&);

  extern template
    const money_get<char>&
    use_facet<money_get<char> >(const locale&);

  extern template
    const __timepunct<char>&
    use_facet<__timepunct<char> >(const locale&);

  extern template
    const time_put<char>&
    use_facet<time_put<char> >(const locale&);

  extern template
    const time_get<char>&
    use_facet<time_get<char> >(const locale&);

  extern template
    const messages<char>&
    use_facet<messages<char> >(const locale&);

  extern template
    bool
    has_facet<moneypunct<char> >(const locale&);

  extern template
    bool
    has_facet<money_put<char> >(const locale&);

  extern template
    bool
    has_facet<money_get<char> >(const locale&);

  extern template
    bool
    has_facet<__timepunct<char> >(const locale&);

  extern template
    bool
    has_facet<time_put<char> >(const locale&);

  extern template
    bool
    has_facet<time_get<char> >(const locale&);

  extern template
    bool
    has_facet<messages<char> >(const locale&);


  extern template class moneypunct<wchar_t, false>;
  extern template class moneypunct<wchar_t, true>;
  extern template class moneypunct_byname<wchar_t, false>;
  extern template class moneypunct_byname<wchar_t, true>;
  extern template class money_get<wchar_t>;
  extern template class money_put<wchar_t>;
  extern template class __timepunct<wchar_t>;
  extern template class time_put<wchar_t>;
  extern template class time_put_byname<wchar_t>;
  extern template class time_get<wchar_t>;
  extern template class time_get_byname<wchar_t>;
  extern template class messages<wchar_t>;
  extern template class messages_byname<wchar_t>;

  extern template
    const moneypunct<wchar_t, true>&
    use_facet<moneypunct<wchar_t, true> >(const locale&);

  extern template
    const moneypunct<wchar_t, false>&
    use_facet<moneypunct<wchar_t, false> >(const locale&);

  extern template
    const money_put<wchar_t>&
    use_facet<money_put<wchar_t> >(const locale&);

  extern template
    const money_get<wchar_t>&
    use_facet<money_get<wchar_t> >(const locale&);

  extern template
    const __timepunct<wchar_t>&
    use_facet<__timepunct<wchar_t> >(const locale&);

  extern template
    const time_put<wchar_t>&
    use_facet<time_put<wchar_t> >(const locale&);

  extern template
    const time_get<wchar_t>&
    use_facet<time_get<wchar_t> >(const locale&);

  extern template
    const messages<wchar_t>&
    use_facet<messages<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<moneypunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<money_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<money_get<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<__timepunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<time_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<time_get<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<messages<wchar_t> >(const locale&);




}
# 1904 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/locale_facets_nonio.h" 2 3
# 42 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/locale" 2 3
# 24 "/usr/include/boost/format.hpp" 2 3 4



# 1 "/usr/include/boost/format/detail/compat_workarounds.hpp" 1 3 4
# 33 "/usr/include/boost/format/detail/compat_workarounds.hpp" 3 4
namespace boost {
    namespace io {



        template<class Tr>
        class CompatTraits;




        template<class Alloc>
        class CompatAlloc;
    }
}



# 1 "/usr/include/boost/format/detail/config_macros.hpp" 1 3 4
# 33 "/usr/include/boost/format/detail/config_macros.hpp" 3 4
# 1 "/usr/include/boost/format/detail/workarounds_gcc-2_95.hpp" 1 3 4
# 34 "/usr/include/boost/format/detail/config_macros.hpp" 2 3 4
# 1 "/usr/include/boost/format/detail/workarounds_stlport.hpp" 1 3 4
# 35 "/usr/include/boost/format/detail/config_macros.hpp" 2 3 4
# 86 "/usr/include/boost/format/detail/config_macros.hpp" 3 4
namespace boost { namespace io { namespace detail {

    typedef ::std:: locale locale_t;



} } }
# 51 "/usr/include/boost/format/detail/compat_workarounds.hpp" 2 3 4
# 65 "/usr/include/boost/format/detail/compat_workarounds.hpp" 3 4
namespace boost {
    namespace io {


        template<class Tr>
        class CompatTraits
        {
        public:
            typedef Tr compatible_type;
        };


        template<class Alloc>
        class CompatAlloc
        {
        public:
            typedef Alloc compatible_type;
        };

    }
}
# 28 "/usr/include/boost/format.hpp" 2 3 4






# 1 "/usr/include/boost/format/format_fwd.hpp" 1 3 4
# 21 "/usr/include/boost/format/format_fwd.hpp" 3 4
namespace boost {

    template <class Ch,


        class Tr = ::std:: char_traits<Ch>, class Alloc = std::allocator<Ch> >



    class basic_format;

    typedef basic_format<char > format;



    typedef basic_format<wchar_t > wformat;


    namespace io {
        enum format_error_bits { bad_format_string_bit = 1,
                                 too_few_args_bit = 2, too_many_args_bit = 4,
                                 out_of_range_bit = 8,
                                 all_error_bits = 255, no_error_bits=0 };

    }

}
# 35 "/usr/include/boost/format.hpp" 2 3 4
# 1 "/usr/include/boost/format/internals_fwd.hpp" 1 3 4
# 20 "/usr/include/boost/format/internals_fwd.hpp" 3 4
namespace boost {
namespace io {

namespace detail {
  template<class Ch, class Tr> struct stream_format_state;
    template<class Ch, class Tr, class Alloc> struct format_item;





    template<class Ch, class Tr, class Alloc, class T>
    basic_format<Ch, Tr, Alloc>&
    modify_item_body (basic_format<Ch, Tr, Alloc>& self,
                      int itemN, T manipulator);

    template<class Ch, class Tr, class Alloc, class T>
    basic_format<Ch, Tr, Alloc>&
    bind_arg_body (basic_format<Ch, Tr, Alloc>& self,
                   int argN, const T& val);


    template<class Ch, class Tr, class T>
    void apply_manip_body (stream_format_state<Ch, Tr>& self,
                           T manipulator);


    template<class Ch, class Tr, class Alloc, class T>
    void distribute (basic_format<Ch,Tr, Alloc>& self, T x);

    template<class Ch, class Tr, class Alloc, class T>
    basic_format<Ch, Tr, Alloc>&
    feed (basic_format<Ch,Tr, Alloc>& self, T x);

}

}
}
# 36 "/usr/include/boost/format.hpp" 2 3 4


# 1 "/usr/include/boost/format/internals.hpp" 1 3 4
# 19 "/usr/include/boost/format/internals.hpp" 3 4
# 1 "/usr/include/boost/assert.hpp" 1 3 4
# 50 "/usr/include/boost/assert.hpp" 3 4
# 1 "/usr/include/assert.h" 1 3 4
# 51 "/usr/include/boost/assert.hpp" 2 3 4
# 81 "/usr/include/boost/assert.hpp" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstdlib" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstdlib" 3
# 82 "/usr/include/boost/assert.hpp" 2 3 4

# 1 "/usr/include/boost/current_function.hpp" 1 3 4
# 22 "/usr/include/boost/current_function.hpp" 3 4
namespace boost
{

namespace detail
{

inline void current_function_helper()
{
# 61 "/usr/include/boost/current_function.hpp" 3 4
}

}

}
# 84 "/usr/include/boost/assert.hpp" 2 3 4







    namespace boost
    {
      namespace assertion
      {
        namespace detail
        {
          inline void assertion_failed_msg(char const * expr, char const * msg, char const * function,
            char const * file, long line)
          {
            std::cerr
              << "***** Internal Program Error - assertion (" << expr << ") failed in "
              << function << ":\n"
              << file << '(' << line << "): " << msg << std::endl;




    std::abort();

          }
        }
      }
    }
# 20 "/usr/include/boost/format/internals.hpp" 2 3 4
# 1 "/usr/include/boost/optional.hpp" 1 3 4
# 15 "/usr/include/boost/optional.hpp" 3 4
# 1 "/usr/include/boost/optional/optional.hpp" 1 3 4
# 22 "/usr/include/boost/optional/optional.hpp" 3 4
# 1 "/usr/include/boost/assert.hpp" 1 3 4
# 50 "/usr/include/boost/assert.hpp" 3 4
# 1 "/usr/include/assert.h" 1 3 4
# 51 "/usr/include/boost/assert.hpp" 2 3 4
# 23 "/usr/include/boost/optional/optional.hpp" 2 3 4
# 1 "/usr/include/boost/type.hpp" 1 3 4








namespace boost {



  template <class T>
  struct type {};

}
# 24 "/usr/include/boost/optional/optional.hpp" 2 3 4
# 1 "/usr/include/boost/type_traits/alignment_of.hpp" 1 3 4
# 13 "/usr/include/boost/type_traits/alignment_of.hpp" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 3


# 1 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/stddef.h" 1 3
# 43 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 2 3
# 14 "/usr/include/boost/type_traits/alignment_of.hpp" 2 3 4

# 1 "/usr/include/boost/type_traits/intrinsics.hpp" 1 3 4
# 12 "/usr/include/boost/type_traits/intrinsics.hpp" 3 4
# 1 "/usr/include/boost/type_traits/config.hpp" 1 3 4
# 13 "/usr/include/boost/type_traits/intrinsics.hpp" 2 3 4
# 136 "/usr/include/boost/type_traits/intrinsics.hpp" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 3


# 1 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/stddef.h" 1 3
# 43 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 2 3
# 137 "/usr/include/boost/type_traits/intrinsics.hpp" 2 3 4
# 1 "/usr/include/boost/type_traits/is_same.hpp" 1 3 4
# 31 "/usr/include/boost/type_traits/is_same.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 10 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 3 4
# 1 "/usr/include/boost/mpl/int.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/int.hpp" 3 4
# 1 "/usr/include/boost/mpl/int_fwd.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/int_fwd.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/adl_barrier.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/aux_/adl_barrier.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/config/adl.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/aux_/config/adl.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/config/msvc.hpp" 1 3 4
# 18 "/usr/include/boost/mpl/aux_/config/adl.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/aux_/config/intel.hpp" 1 3 4
# 19 "/usr/include/boost/mpl/aux_/config/adl.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/aux_/config/gcc.hpp" 1 3 4
# 20 "/usr/include/boost/mpl/aux_/config/adl.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/aux_/config/workaround.hpp" 1 3 4
# 21 "/usr/include/boost/mpl/aux_/config/adl.hpp" 2 3 4
# 18 "/usr/include/boost/mpl/aux_/adl_barrier.hpp" 2 3 4
# 33 "/usr/include/boost/mpl/aux_/adl_barrier.hpp" 3 4
namespace mpl_ { namespace aux {} }
namespace boost { namespace mpl { using namespace mpl_;
namespace aux { using namespace mpl_::aux; }
}}
# 18 "/usr/include/boost/mpl/int_fwd.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/aux_/nttp_decl.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/aux_/nttp_decl.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/config/nttp.hpp" 1 3 4
# 18 "/usr/include/boost/mpl/aux_/nttp_decl.hpp" 2 3 4
# 19 "/usr/include/boost/mpl/int_fwd.hpp" 2 3 4

namespace mpl_ {

template< int N > struct int_;

}
namespace boost { namespace mpl { using ::mpl_::int_; } }
# 18 "/usr/include/boost/mpl/int.hpp" 2 3 4


# 1 "/usr/include/boost/mpl/aux_/integral_wrapper.hpp" 1 3 4
# 16 "/usr/include/boost/mpl/aux_/integral_wrapper.hpp" 3 4
# 1 "/usr/include/boost/mpl/integral_c_tag.hpp" 1 3 4
# 19 "/usr/include/boost/mpl/integral_c_tag.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/config/static_constant.hpp" 1 3 4
# 20 "/usr/include/boost/mpl/integral_c_tag.hpp" 2 3 4

namespace mpl_ {
struct integral_c_tag { static const int value = 0; };
}
namespace boost { namespace mpl { using ::mpl_::integral_c_tag; } }
# 17 "/usr/include/boost/mpl/aux_/integral_wrapper.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/aux_/static_cast.hpp" 1 3 4
# 18 "/usr/include/boost/mpl/aux_/integral_wrapper.hpp" 2 3 4




# 1 "/usr/include/boost/preprocessor/cat.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/cat.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 18 "/usr/include/boost/preprocessor/cat.hpp" 2 3 4
# 23 "/usr/include/boost/mpl/aux_/integral_wrapper.hpp" 2 3 4
# 40 "/usr/include/boost/mpl/aux_/integral_wrapper.hpp" 3 4
namespace mpl_ {

template< int N >
struct int_
{
    static const int value = N;





    typedef int_ type;

    typedef int value_type;
    typedef integral_c_tag tag;
# 72 "/usr/include/boost/mpl/aux_/integral_wrapper.hpp" 3 4
    typedef mpl_::int_< static_cast<int>((value + 1)) > next;
    typedef mpl_::int_< static_cast<int>((value - 1)) > prior;






    operator int() const { return static_cast<int>(this->value); }
};


template< int N >
int const mpl_::int_< N >::value;


}
# 21 "/usr/include/boost/mpl/int.hpp" 2 3 4
# 11 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/aux_/template_arity_fwd.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/aux_/template_arity_fwd.hpp" 3 4
namespace boost { namespace mpl { namespace aux {

template< typename F > struct template_arity;

}}}
# 12 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/aux_/preprocessor/params.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/aux_/preprocessor/params.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/config/preprocessor.hpp" 1 3 4
# 18 "/usr/include/boost/mpl/aux_/preprocessor/params.hpp" 2 3 4
# 45 "/usr/include/boost/mpl/aux_/preprocessor/params.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/comma_if.hpp" 1 3 4
# 15 "/usr/include/boost/preprocessor/comma_if.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/punctuation/comma_if.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/punctuation/comma_if.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 18 "/usr/include/boost/preprocessor/punctuation/comma_if.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/control/if.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/control/if.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 18 "/usr/include/boost/preprocessor/control/if.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/control/iif.hpp" 1 3 4
# 15 "/usr/include/boost/preprocessor/control/iif.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 16 "/usr/include/boost/preprocessor/control/iif.hpp" 2 3 4
# 19 "/usr/include/boost/preprocessor/control/if.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/logical/bool.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/logical/bool.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 18 "/usr/include/boost/preprocessor/logical/bool.hpp" 2 3 4
# 20 "/usr/include/boost/preprocessor/control/if.hpp" 2 3 4
# 19 "/usr/include/boost/preprocessor/punctuation/comma_if.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/facilities/empty.hpp" 1 3 4
# 20 "/usr/include/boost/preprocessor/punctuation/comma_if.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/punctuation/comma.hpp" 1 3 4
# 21 "/usr/include/boost/preprocessor/punctuation/comma_if.hpp" 2 3 4
# 16 "/usr/include/boost/preprocessor/comma_if.hpp" 2 3 4
# 46 "/usr/include/boost/mpl/aux_/preprocessor/params.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/repeat.hpp" 1 3 4
# 15 "/usr/include/boost/preprocessor/repeat.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/repetition/repeat.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/repetition/repeat.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/cat.hpp" 1 3 4
# 18 "/usr/include/boost/preprocessor/repetition/repeat.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 19 "/usr/include/boost/preprocessor/repetition/repeat.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/debug/error.hpp" 1 3 4
# 15 "/usr/include/boost/preprocessor/debug/error.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/cat.hpp" 1 3 4
# 16 "/usr/include/boost/preprocessor/debug/error.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/debug/error.hpp" 2 3 4
# 20 "/usr/include/boost/preprocessor/repetition/repeat.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/detail/auto_rec.hpp" 1 3 4
# 12 "/usr/include/boost/preprocessor/detail/auto_rec.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 13 "/usr/include/boost/preprocessor/detail/auto_rec.hpp" 2 3 4








# 1 "/usr/include/boost/preprocessor/control/iif.hpp" 1 3 4
# 22 "/usr/include/boost/preprocessor/detail/auto_rec.hpp" 2 3 4
# 21 "/usr/include/boost/preprocessor/repetition/repeat.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/tuple/eat.hpp" 1 3 4
# 18 "/usr/include/boost/preprocessor/tuple/eat.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 19 "/usr/include/boost/preprocessor/tuple/eat.hpp" 2 3 4
# 22 "/usr/include/boost/preprocessor/repetition/repeat.hpp" 2 3 4
# 16 "/usr/include/boost/preprocessor/repeat.hpp" 2 3 4
# 47 "/usr/include/boost/mpl/aux_/preprocessor/params.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/inc.hpp" 1 3 4
# 15 "/usr/include/boost/preprocessor/inc.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/arithmetic/inc.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/arithmetic/inc.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 18 "/usr/include/boost/preprocessor/arithmetic/inc.hpp" 2 3 4
# 16 "/usr/include/boost/preprocessor/inc.hpp" 2 3 4
# 48 "/usr/include/boost/mpl/aux_/preprocessor/params.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/cat.hpp" 1 3 4
# 49 "/usr/include/boost/mpl/aux_/preprocessor/params.hpp" 2 3 4
# 13 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/aux_/config/lambda.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/aux_/config/lambda.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/config/ttp.hpp" 1 3 4
# 18 "/usr/include/boost/mpl/aux_/config/lambda.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/aux_/config/ctps.hpp" 1 3 4
# 19 "/usr/include/boost/mpl/aux_/config/lambda.hpp" 2 3 4
# 14 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/aux_/config/overload_resolution.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 2 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 1 "/usr/include/boost/type_traits/integral_constant.hpp" 1 3 4
# 10 "/usr/include/boost/type_traits/integral_constant.hpp" 3 4
# 1 "/usr/include/boost/mpl/bool.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/bool.hpp" 3 4
# 1 "/usr/include/boost/mpl/bool_fwd.hpp" 1 3 4
# 19 "/usr/include/boost/mpl/bool_fwd.hpp" 3 4
namespace mpl_ {

template< bool C_ > struct bool_;


typedef bool_<true> true_;
typedef bool_<false> false_;

}

namespace boost { namespace mpl { using ::mpl_::bool_; } }
namespace boost { namespace mpl { using ::mpl_::true_; } }
namespace boost { namespace mpl { using ::mpl_::false_; } }
# 18 "/usr/include/boost/mpl/bool.hpp" 2 3 4



namespace mpl_ {

template< bool C_ > struct bool_
{
    static const bool value = C_;
    typedef integral_c_tag tag;
    typedef bool_ type;
    typedef bool value_type;
    operator bool() const { return this->value; }
};


template< bool C_ >
bool const bool_<C_>::value;


}
# 11 "/usr/include/boost/type_traits/integral_constant.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/integral_c.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/integral_c.hpp" 3 4
# 1 "/usr/include/boost/mpl/integral_c_fwd.hpp" 1 3 4
# 20 "/usr/include/boost/mpl/integral_c_fwd.hpp" 3 4
namespace mpl_ {





template< typename T, T N > struct integral_c;


}
namespace boost { namespace mpl { using ::mpl_::integral_c; } }
# 18 "/usr/include/boost/mpl/integral_c.hpp" 2 3 4
# 32 "/usr/include/boost/mpl/integral_c.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/integral_wrapper.hpp" 1 3 4
# 22 "/usr/include/boost/mpl/aux_/integral_wrapper.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/cat.hpp" 1 3 4
# 23 "/usr/include/boost/mpl/aux_/integral_wrapper.hpp" 2 3 4
# 40 "/usr/include/boost/mpl/aux_/integral_wrapper.hpp" 3 4
namespace mpl_ {

template< typename T, T N >
struct integral_c
{
    static const T value = N;





    typedef integral_c type;

    typedef T value_type;
    typedef integral_c_tag tag;
# 72 "/usr/include/boost/mpl/aux_/integral_wrapper.hpp" 3 4
    typedef integral_c< T, static_cast<T>((value + 1)) > next;
    typedef integral_c< T, static_cast<T>((value - 1)) > prior;






    operator T() const { return static_cast<T>(this->value); }
};


template< typename T, T N >
T const integral_c< T, N >::value;


}
# 33 "/usr/include/boost/mpl/integral_c.hpp" 2 3 4




namespace mpl_ {

template< bool C >
struct integral_c<bool, C>
{
    static const bool value = C;
    typedef integral_c_tag tag;
    typedef integral_c type;
    typedef bool value_type;
    operator bool() const { return this->value; }
};
}
# 12 "/usr/include/boost/type_traits/integral_constant.hpp" 2 3 4

namespace boost{




template <class T, T val>

struct integral_constant : public mpl::integral_c<T, val>
{
   typedef integral_constant<T,val> type;
};

template<> struct integral_constant<bool,true> : public mpl::true_
{







   typedef integral_constant<bool,true> type;
};
template<> struct integral_constant<bool,false> : public mpl::false_
{







   typedef integral_constant<bool,false> type;
};

typedef integral_constant<bool,true> true_type;
typedef integral_constant<bool,false> false_type;

}
# 16 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4

# 1 "/usr/include/boost/mpl/aux_/lambda_support.hpp" 1 3 4
# 18 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 32 "/usr/include/boost/type_traits/is_same.hpp" 2 3 4

namespace boost {



template< typename T, typename U > struct is_same : public ::boost::integral_constant<bool,false> { public: };
template< typename T > struct is_same< T,T > : public ::boost::integral_constant<bool,true> { public: };
# 98 "/usr/include/boost/type_traits/is_same.hpp" 3 4
}


# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 101 "/usr/include/boost/type_traits/is_same.hpp" 2 3 4
# 138 "/usr/include/boost/type_traits/intrinsics.hpp" 2 3 4
# 1 "/usr/include/boost/type_traits/is_reference.hpp" 1 3 4
# 16 "/usr/include/boost/type_traits/is_reference.hpp" 3 4
# 1 "/usr/include/boost/type_traits/is_lvalue_reference.hpp" 1 3 4
# 32 "/usr/include/boost/type_traits/is_lvalue_reference.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 33 "/usr/include/boost/type_traits/is_lvalue_reference.hpp" 2 3 4

namespace boost {





template< typename T > struct is_lvalue_reference : public ::boost::integral_constant<bool,false> { public: };
template< typename T > struct is_lvalue_reference< T& > : public ::boost::integral_constant<bool,true> { public: };
# 113 "/usr/include/boost/type_traits/is_lvalue_reference.hpp" 3 4
}


# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 116 "/usr/include/boost/type_traits/is_lvalue_reference.hpp" 2 3 4
# 17 "/usr/include/boost/type_traits/is_reference.hpp" 2 3 4
# 1 "/usr/include/boost/type_traits/is_rvalue_reference.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/is_rvalue_reference.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 16 "/usr/include/boost/type_traits/is_rvalue_reference.hpp" 2 3 4

namespace boost {

template< typename T > struct is_rvalue_reference : public ::boost::integral_constant<bool,false> { public: };

template< typename T > struct is_rvalue_reference< T&& > : public ::boost::integral_constant<bool,true> { public: };


}


# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 27 "/usr/include/boost/type_traits/is_rvalue_reference.hpp" 2 3 4
# 18 "/usr/include/boost/type_traits/is_reference.hpp" 2 3 4
# 1 "/usr/include/boost/type_traits/ice.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/ice.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/yes_no_type.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/yes_no_type.hpp" 3 4
namespace boost {
namespace type_traits {

typedef char yes_type;
struct no_type
{
   char padding[8];
};

}
}
# 15 "/usr/include/boost/type_traits/ice.hpp" 2 3 4
# 1 "/usr/include/boost/type_traits/detail/ice_or.hpp" 1 3 4
# 13 "/usr/include/boost/type_traits/detail/ice_or.hpp" 3 4
namespace boost {
namespace type_traits {

template <bool b1, bool b2, bool b3 = false, bool b4 = false, bool b5 = false, bool b6 = false, bool b7 = false>
struct ice_or;

template <bool b1, bool b2, bool b3, bool b4, bool b5, bool b6, bool b7>
struct ice_or
{
    static const bool value = true;
};

template <>
struct ice_or<false, false, false, false, false, false, false>
{
    static const bool value = false;
};

}
}
# 16 "/usr/include/boost/type_traits/ice.hpp" 2 3 4
# 1 "/usr/include/boost/type_traits/detail/ice_and.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/ice_and.hpp" 3 4
namespace boost {
namespace type_traits {

template <bool b1, bool b2, bool b3 = true, bool b4 = true, bool b5 = true, bool b6 = true, bool b7 = true>
struct ice_and;

template <bool b1, bool b2, bool b3, bool b4, bool b5, bool b6, bool b7>
struct ice_and
{
    static const bool value = false;
};

template <>
struct ice_and<true, true, true, true, true, true, true>
{
    static const bool value = true;
};

}
}
# 17 "/usr/include/boost/type_traits/ice.hpp" 2 3 4
# 1 "/usr/include/boost/type_traits/detail/ice_not.hpp" 1 3 4
# 13 "/usr/include/boost/type_traits/detail/ice_not.hpp" 3 4
namespace boost {
namespace type_traits {

template <bool b>
struct ice_not
{
    static const bool value = true;
};

template <>
struct ice_not<true>
{
    static const bool value = false;
};

}
}
# 18 "/usr/include/boost/type_traits/ice.hpp" 2 3 4
# 1 "/usr/include/boost/type_traits/detail/ice_eq.hpp" 1 3 4
# 13 "/usr/include/boost/type_traits/detail/ice_eq.hpp" 3 4
namespace boost {
namespace type_traits {

template <int b1, int b2>
struct ice_eq
{
    static const bool value = (b1 == b2);
};

template <int b1, int b2>
struct ice_ne
{
    static const bool value = (b1 != b2);
};


template <int b1, int b2> bool const ice_eq<b1,b2>::value;
template <int b1, int b2> bool const ice_ne<b1,b2>::value;


}
}
# 19 "/usr/include/boost/type_traits/ice.hpp" 2 3 4
# 19 "/usr/include/boost/type_traits/is_reference.hpp" 2 3 4


# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 22 "/usr/include/boost/type_traits/is_reference.hpp" 2 3 4

namespace boost {

namespace detail {

template <typename T>
struct is_reference_impl
{
   static const bool value = (::boost::type_traits::ice_or< ::boost::is_lvalue_reference<T>::value, ::boost::is_rvalue_reference<T>::value >::value);



};

}

template< typename T > struct is_reference : public ::boost::integral_constant<bool,::boost::detail::is_reference_impl<T>::value> { public: };

}


# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 43 "/usr/include/boost/type_traits/is_reference.hpp" 2 3 4
# 139 "/usr/include/boost/type_traits/intrinsics.hpp" 2 3 4
# 1 "/usr/include/boost/type_traits/is_volatile.hpp" 1 3 4
# 28 "/usr/include/boost/type_traits/is_volatile.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/cv_traits_impl.hpp" 1 3 4
# 23 "/usr/include/boost/type_traits/detail/cv_traits_impl.hpp" 3 4
namespace boost {
namespace detail {







template <typename T> struct cv_traits_imp {};

template <typename T>
struct cv_traits_imp<T*>
{
    static const bool is_const = false;
    static const bool is_volatile = false;
    typedef T unqualified_type;
};

template <typename T>
struct cv_traits_imp<const T*>
{
    static const bool is_const = true;
    static const bool is_volatile = false;
    typedef T unqualified_type;
};

template <typename T>
struct cv_traits_imp<volatile T*>
{
    static const bool is_const = false;
    static const bool is_volatile = true;
    typedef T unqualified_type;
};

template <typename T>
struct cv_traits_imp<const volatile T*>
{
    static const bool is_const = true;
    static const bool is_volatile = true;
    typedef T unqualified_type;
};
# 92 "/usr/include/boost/type_traits/detail/cv_traits_impl.hpp" 3 4
}
}
# 29 "/usr/include/boost/type_traits/is_volatile.hpp" 2 3 4
# 40 "/usr/include/boost/type_traits/is_volatile.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 41 "/usr/include/boost/type_traits/is_volatile.hpp" 2 3 4

namespace boost {

namespace detail{
template <class T>
struct is_volatile_rval_filter
{



   static const bool value = ::boost::detail::cv_traits_imp<T*>::is_volatile;

};





template <class T>
struct is_volatile_rval_filter<T&&>
{
   static const bool value = false;
};

}






template< typename T > struct is_volatile : public ::boost::integral_constant<bool,::boost::detail::is_volatile_rval_filter<T>::value> { public: };
template< typename T > struct is_volatile< T& > : public ::boost::integral_constant<bool,false> { public: };
# 148 "/usr/include/boost/type_traits/is_volatile.hpp" 3 4
}


# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 151 "/usr/include/boost/type_traits/is_volatile.hpp" 2 3 4
# 140 "/usr/include/boost/type_traits/intrinsics.hpp" 2 3 4
# 184 "/usr/include/boost/type_traits/intrinsics.hpp" 3 4
# 1 "/usr/include/boost/type_traits/is_abstract.hpp" 1 3 4
# 51 "/usr/include/boost/type_traits/is_abstract.hpp" 3 4
# 1 "/usr/include/boost/type_traits/intrinsics.hpp" 1 3 4
# 52 "/usr/include/boost/type_traits/is_abstract.hpp" 2 3 4
# 62 "/usr/include/boost/type_traits/is_abstract.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 63 "/usr/include/boost/type_traits/is_abstract.hpp" 2 3 4


namespace boost {
namespace detail{


template <class T>
struct is_abstract_imp
{
   static const bool value = __is_abstract(T);
};
# 141 "/usr/include/boost/type_traits/is_abstract.hpp" 3 4
}


template< typename T > struct is_abstract : public ::boost::integral_constant<bool,::boost::detail::is_abstract_imp<T>::value> { public: };




}


# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 152 "/usr/include/boost/type_traits/is_abstract.hpp" 2 3 4
# 185 "/usr/include/boost/type_traits/intrinsics.hpp" 2 3 4
# 16 "/usr/include/boost/type_traits/alignment_of.hpp" 2 3 4

# 1 "/usr/include/boost/type_traits/detail/size_t_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/size_t_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/size_t_trait_def.hpp" 2 3 4


# 1 "/usr/include/boost/mpl/size_t.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/size_t.hpp" 3 4
# 1 "/usr/include/boost/mpl/size_t_fwd.hpp" 1 3 4
# 19 "/usr/include/boost/mpl/size_t_fwd.hpp" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 3


# 1 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/stddef.h" 1 3
# 43 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 2 3
# 20 "/usr/include/boost/mpl/size_t_fwd.hpp" 2 3 4

namespace mpl_ {

template< std::size_t N > struct size_t;

}
namespace boost { namespace mpl { using ::mpl_::size_t; } }
# 18 "/usr/include/boost/mpl/size_t.hpp" 2 3 4





# 1 "/usr/include/boost/mpl/aux_/integral_wrapper.hpp" 1 3 4
# 22 "/usr/include/boost/mpl/aux_/integral_wrapper.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/cat.hpp" 1 3 4
# 23 "/usr/include/boost/mpl/aux_/integral_wrapper.hpp" 2 3 4
# 40 "/usr/include/boost/mpl/aux_/integral_wrapper.hpp" 3 4
namespace mpl_ {

template< std::size_t N >
struct size_t
{
    static const std::size_t value = N;





    typedef size_t type;

    typedef std::size_t value_type;
    typedef integral_c_tag tag;
# 72 "/usr/include/boost/mpl/aux_/integral_wrapper.hpp" 3 4
    typedef mpl_::size_t< static_cast<std::size_t>((value + 1)) > next;
    typedef mpl_::size_t< static_cast<std::size_t>((value - 1)) > prior;






    operator std::size_t() const { return static_cast<std::size_t>(this->value); }
};


template< std::size_t N >
std::size_t const mpl_::size_t< N >::value;


}
# 24 "/usr/include/boost/mpl/size_t.hpp" 2 3 4
# 18 "/usr/include/boost/type_traits/detail/size_t_trait_def.hpp" 2 3 4

# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 3


# 1 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/stddef.h" 1 3
# 43 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 2 3
# 20 "/usr/include/boost/type_traits/detail/size_t_trait_def.hpp" 2 3 4
# 18 "/usr/include/boost/type_traits/alignment_of.hpp" 2 3 4
# 27 "/usr/include/boost/type_traits/alignment_of.hpp" 3 4
namespace boost {

template <typename T> struct alignment_of;


namespace detail {





template <typename T>
struct alignment_of_hack
{
    char c;
    T t;
    alignment_of_hack();
};




template <unsigned A, unsigned S>
struct alignment_logic
{
    static const std::size_t value = A < S ? A : S;
};


template< typename T >
struct alignment_of_impl
{
# 83 "/usr/include/boost/type_traits/alignment_of.hpp" 3 4
   static const std::size_t value = __alignof(T);

};

}

template< typename T > struct alignment_of : public ::boost::integral_constant<std::size_t,::boost::detail::alignment_of_impl<T>::value> { public: };




template <typename T>
struct alignment_of<T&>
    : public alignment_of<T*>
{
};
# 109 "/usr/include/boost/type_traits/alignment_of.hpp" 3 4
template<> struct alignment_of<void> : public ::boost::integral_constant<std::size_t,0> { public: };

template<> struct alignment_of<void const> : public ::boost::integral_constant<std::size_t,0> { public: };
template<> struct alignment_of<void volatile> : public ::boost::integral_constant<std::size_t,0> { public: };
template<> struct alignment_of<void const volatile> : public ::boost::integral_constant<std::size_t,0> { public: };


}
# 125 "/usr/include/boost/type_traits/alignment_of.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/size_t_trait_undef.hpp" 1 3 4
# 126 "/usr/include/boost/type_traits/alignment_of.hpp" 2 3 4
# 25 "/usr/include/boost/optional/optional.hpp" 2 3 4
# 1 "/usr/include/boost/type_traits/has_nothrow_constructor.hpp" 1 3 4
# 12 "/usr/include/boost/type_traits/has_nothrow_constructor.hpp" 3 4
# 1 "/usr/include/boost/type_traits/has_trivial_constructor.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/has_trivial_constructor.hpp" 3 4
# 1 "/usr/include/boost/type_traits/is_pod.hpp" 1 3 4
# 13 "/usr/include/boost/type_traits/is_pod.hpp" 3 4
# 1 "/usr/include/boost/type_traits/is_void.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/is_void.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 16 "/usr/include/boost/type_traits/is_void.hpp" 2 3 4

namespace boost {





template< typename T > struct is_void : public ::boost::integral_constant<bool,false> { public: };
template<> struct is_void< void > : public ::boost::integral_constant<bool,true> { public: };


template<> struct is_void< void const > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_void< void volatile > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_void< void const volatile > : public ::boost::integral_constant<bool,true> { public: };




}


# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 37 "/usr/include/boost/type_traits/is_void.hpp" 2 3 4
# 14 "/usr/include/boost/type_traits/is_pod.hpp" 2 3 4
# 1 "/usr/include/boost/type_traits/is_scalar.hpp" 1 3 4
# 12 "/usr/include/boost/type_traits/is_scalar.hpp" 3 4
# 1 "/usr/include/boost/type_traits/is_arithmetic.hpp" 1 3 4
# 13 "/usr/include/boost/type_traits/is_arithmetic.hpp" 3 4
# 1 "/usr/include/boost/type_traits/is_integral.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/is_integral.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 16 "/usr/include/boost/type_traits/is_integral.hpp" 2 3 4

namespace boost {







template< typename T > struct is_integral : public ::boost::integral_constant<bool,false> { public: };

template<> struct is_integral< unsigned char > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< unsigned char const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< unsigned char volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< unsigned char const volatile > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_integral< unsigned short > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< unsigned short const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< unsigned short volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< unsigned short const volatile > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_integral< unsigned int > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< unsigned int const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< unsigned int volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< unsigned int const volatile > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_integral< unsigned long > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< unsigned long const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< unsigned long volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< unsigned long const volatile > : public ::boost::integral_constant<bool,true> { public: };

template<> struct is_integral< signed char > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< signed char const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< signed char volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< signed char const volatile > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_integral< signed short > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< signed short const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< signed short volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< signed short const volatile > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_integral< signed int > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< signed int const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< signed int volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< signed int const volatile > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_integral< signed long > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< signed long const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< signed long volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< signed long const volatile > : public ::boost::integral_constant<bool,true> { public: };

template<> struct is_integral< bool > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< bool const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< bool volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< bool const volatile > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_integral< char > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< char const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< char volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< char const volatile > : public ::boost::integral_constant<bool,true> { public: };





template<> struct is_integral< wchar_t > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< wchar_t const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< wchar_t volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< wchar_t const volatile > : public ::boost::integral_constant<bool,true> { public: };
# 65 "/usr/include/boost/type_traits/is_integral.hpp" 3 4
template<> struct is_integral< ::boost::ulong_long_type > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< ::boost::ulong_long_type const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< ::boost::ulong_long_type volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< ::boost::ulong_long_type const volatile > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_integral< ::boost::long_long_type > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< ::boost::long_long_type const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< ::boost::long_long_type volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< ::boost::long_long_type const volatile > : public ::boost::integral_constant<bool,true> { public: };
# 79 "/usr/include/boost/type_traits/is_integral.hpp" 3 4
}


# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 82 "/usr/include/boost/type_traits/is_integral.hpp" 2 3 4
# 14 "/usr/include/boost/type_traits/is_arithmetic.hpp" 2 3 4
# 1 "/usr/include/boost/type_traits/is_float.hpp" 1 3 4
# 13 "/usr/include/boost/type_traits/is_float.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 14 "/usr/include/boost/type_traits/is_float.hpp" 2 3 4

namespace boost {


template< typename T > struct is_float : public ::boost::integral_constant<bool,false> { public: };
template<> struct is_float< float > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_float< float const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_float< float volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_float< float const volatile > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_float< double > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_float< double const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_float< double volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_float< double const volatile > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_float< long double > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_float< long double const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_float< long double volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_float< long double const volatile > : public ::boost::integral_constant<bool,true> { public: };

}


# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 26 "/usr/include/boost/type_traits/is_float.hpp" 2 3 4
# 15 "/usr/include/boost/type_traits/is_arithmetic.hpp" 2 3 4





# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 21 "/usr/include/boost/type_traits/is_arithmetic.hpp" 2 3 4

namespace boost {


namespace detail {

template< typename T >
struct is_arithmetic_impl
{
    static const bool value = (::boost::type_traits::ice_or< ::boost::is_integral<T>::value, ::boost::is_float<T>::value >::value);




};

}






template< typename T > struct is_arithmetic : public ::boost::integral_constant<bool,::boost::detail::is_arithmetic_impl<T>::value> { public: };


}


# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 50 "/usr/include/boost/type_traits/is_arithmetic.hpp" 2 3 4
# 13 "/usr/include/boost/type_traits/is_scalar.hpp" 2 3 4
# 1 "/usr/include/boost/type_traits/is_enum.hpp" 1 3 4
# 32 "/usr/include/boost/type_traits/is_enum.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 33 "/usr/include/boost/type_traits/is_enum.hpp" 2 3 4

namespace boost {
# 181 "/usr/include/boost/type_traits/is_enum.hpp" 3 4
template< typename T > struct is_enum : public ::boost::integral_constant<bool,__is_enum(T)> { public: };



}


# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 188 "/usr/include/boost/type_traits/is_enum.hpp" 2 3 4
# 14 "/usr/include/boost/type_traits/is_scalar.hpp" 2 3 4
# 1 "/usr/include/boost/type_traits/is_pointer.hpp" 1 3 4
# 24 "/usr/include/boost/type_traits/is_pointer.hpp" 3 4
# 1 "/usr/include/boost/type_traits/is_member_pointer.hpp" 1 3 4
# 28 "/usr/include/boost/type_traits/is_member_pointer.hpp" 3 4
# 1 "/usr/include/boost/type_traits/is_member_function_pointer.hpp" 1 3 4
# 24 "/usr/include/boost/type_traits/is_member_function_pointer.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/is_mem_fun_pointer_impl.hpp" 1 3 4
# 25 "/usr/include/boost/type_traits/detail/is_mem_fun_pointer_impl.hpp" 3 4
namespace boost {
namespace type_traits {

template <typename T>
struct is_mem_fun_pointer_impl
{
    static const bool value = false;
};





template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)() > { static const bool value = true; };

template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)( ...) > { static const bool value = true; };



template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)() const > { static const bool value = true; };

template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)() volatile > { static const bool value = true; };

template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)() const volatile > { static const bool value = true; };


template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)( ...) const > { static const bool value = true; };

template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)( ...) volatile > { static const bool value = true; };

template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)( ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0) > { static const bool value = true; };

template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0 ...) > { static const bool value = true; };



template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0) const > { static const bool value = true; };

template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0) volatile > { static const bool value = true; };

template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0) const volatile > { static const bool value = true; };


template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0 ...) const > { static const bool value = true; };

template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1) > { static const bool value = true; };

template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 ...) const volatile > { static const bool value = true; };
# 776 "/usr/include/boost/type_traits/detail/is_mem_fun_pointer_impl.hpp" 3 4
}
}
# 25 "/usr/include/boost/type_traits/is_member_function_pointer.hpp" 2 3 4
# 1 "/usr/include/boost/type_traits/remove_cv.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/remove_cv.hpp" 3 4
# 1 "/usr/include/boost/type_traits/broken_compiler_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/remove_cv.hpp" 2 3 4




# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 3


# 1 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/stddef.h" 1 3
# 43 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 2 3
# 20 "/usr/include/boost/type_traits/remove_cv.hpp" 2 3 4






# 1 "/usr/include/boost/type_traits/detail/type_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/type_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/type_trait_def.hpp" 2 3 4
# 27 "/usr/include/boost/type_traits/remove_cv.hpp" 2 3 4

namespace boost {



namespace detail{

template <class T>
struct rvalue_ref_filter_rem_cv
{
   typedef typename boost::detail::cv_traits_imp<T*>::unqualified_type type;
};






template <class T>
struct rvalue_ref_filter_rem_cv<T&&>
{
   typedef T&& type;
};


}



template< typename T > struct remove_cv { public: typedef typename boost::detail::rvalue_ref_filter_rem_cv<T>::type type; };
template< typename T > struct remove_cv<T&> { public: typedef T& type; };

template< typename T, std::size_t N > struct remove_cv<T const[N]> { public: typedef T type[N]; };
template< typename T, std::size_t N > struct remove_cv<T volatile[N]> { public: typedef T type[N]; };
template< typename T, std::size_t N > struct remove_cv<T const volatile[N]> { public: typedef T type[N]; };
# 80 "/usr/include/boost/type_traits/remove_cv.hpp" 3 4
}


# 1 "/usr/include/boost/type_traits/detail/type_trait_undef.hpp" 1 3 4
# 83 "/usr/include/boost/type_traits/remove_cv.hpp" 2 3 4
# 26 "/usr/include/boost/type_traits/is_member_function_pointer.hpp" 2 3 4
# 36 "/usr/include/boost/type_traits/is_member_function_pointer.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 37 "/usr/include/boost/type_traits/is_member_function_pointer.hpp" 2 3 4

namespace boost {





template< typename T > struct is_member_function_pointer : public ::boost::integral_constant<bool,::boost::type_traits::is_mem_fun_pointer_impl<typename remove_cv<T>::type>::value> { public: };
# 132 "/usr/include/boost/type_traits/is_member_function_pointer.hpp" 3 4
}


# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 135 "/usr/include/boost/type_traits/is_member_function_pointer.hpp" 2 3 4
# 29 "/usr/include/boost/type_traits/is_member_pointer.hpp" 2 3 4
# 39 "/usr/include/boost/type_traits/is_member_pointer.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 40 "/usr/include/boost/type_traits/is_member_pointer.hpp" 2 3 4

namespace boost {
# 50 "/usr/include/boost/type_traits/is_member_pointer.hpp" 3 4
template< typename T > struct is_member_pointer : public ::boost::integral_constant<bool,::boost::is_member_function_pointer<T>::value> { public: };
template< typename T, typename U > struct is_member_pointer< U T::* > : public ::boost::integral_constant<bool,true> { public: };


template< typename T, typename U > struct is_member_pointer< U T::*const > : public ::boost::integral_constant<bool,true> { public: };
template< typename T, typename U > struct is_member_pointer< U T::*volatile > : public ::boost::integral_constant<bool,true> { public: };
template< typename T, typename U > struct is_member_pointer< U T::*const volatile > : public ::boost::integral_constant<bool,true> { public: };
# 112 "/usr/include/boost/type_traits/is_member_pointer.hpp" 3 4
}


# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 115 "/usr/include/boost/type_traits/is_member_pointer.hpp" 2 3 4
# 25 "/usr/include/boost/type_traits/is_pointer.hpp" 2 3 4
# 41 "/usr/include/boost/type_traits/is_pointer.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 42 "/usr/include/boost/type_traits/is_pointer.hpp" 2 3 4

namespace boost {





namespace detail {

template< typename T > struct is_pointer_helper
{
    static const bool value = false;
};
# 63 "/usr/include/boost/type_traits/is_pointer.hpp" 3 4
template< typename T > struct is_pointer_helper<T*> { static const bool value = true; };



template< typename T >
struct is_pointer_impl
{
# 80 "/usr/include/boost/type_traits/is_pointer.hpp" 3 4
    static const bool value = (::boost::type_traits::ice_and< ::boost::detail::is_pointer_helper<typename remove_cv<T>::type>::value , ::boost::type_traits::ice_not< ::boost::is_member_pointer<T>::value >::value >::value);
# 89 "/usr/include/boost/type_traits/is_pointer.hpp" 3 4
};

}

template< typename T > struct is_pointer : public ::boost::integral_constant<bool,::boost::detail::is_pointer_impl<T>::value> { public: };
# 158 "/usr/include/boost/type_traits/is_pointer.hpp" 3 4
}


# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 161 "/usr/include/boost/type_traits/is_pointer.hpp" 2 3 4
# 15 "/usr/include/boost/type_traits/is_scalar.hpp" 2 3 4





# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 21 "/usr/include/boost/type_traits/is_scalar.hpp" 2 3 4

namespace boost {

namespace detail {

template <typename T>
struct is_scalar_impl
{
   static const bool value = (::boost::type_traits::ice_or< ::boost::is_arithmetic<T>::value, ::boost::is_enum<T>::value, ::boost::is_pointer<T>::value, ::boost::is_member_pointer<T>::value >::value);






};



template <> struct is_scalar_impl<void>{ static const bool value = false; };

template <> struct is_scalar_impl<void const>{ static const bool value = false; };
template <> struct is_scalar_impl<void volatile>{ static const bool value = false; };
template <> struct is_scalar_impl<void const volatile>{ static const bool value = false; };


}

template< typename T > struct is_scalar : public ::boost::integral_constant<bool,::boost::detail::is_scalar_impl<T>::value> { public: };

}


# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 54 "/usr/include/boost/type_traits/is_scalar.hpp" 2 3 4
# 15 "/usr/include/boost/type_traits/is_pod.hpp" 2 3 4



# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 3


# 1 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/stddef.h" 1 3
# 43 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 2 3
# 19 "/usr/include/boost/type_traits/is_pod.hpp" 2 3 4


# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 22 "/usr/include/boost/type_traits/is_pod.hpp" 2 3 4







namespace boost {


template< typename T > struct is_POD;

namespace detail {



template <typename T> struct is_pod_impl
{
    static const bool value = (::boost::type_traits::ice_or< ::boost::is_scalar<T>::value, ::boost::is_void<T>::value, __is_pod(T) >::value);






};


template <typename T, std::size_t sz>
struct is_pod_impl<T[sz]>
    : public is_pod_impl<T>
{
};
# 124 "/usr/include/boost/type_traits/is_pod.hpp" 3 4
template<> struct is_pod_impl< void > { public: static const bool value = (true); };


template<> struct is_pod_impl< void const > { public: static const bool value = (true); };
template<> struct is_pod_impl< void volatile > { public: static const bool value = (true); };
template<> struct is_pod_impl< void const volatile > { public: static const bool value = (true); };


}

template< typename T > struct is_pod : public ::boost::integral_constant<bool,::boost::detail::is_pod_impl<T>::value> { public: };


template< typename T > struct is_POD : public ::boost::integral_constant<bool,::boost::is_pod<T>::value> { public: };

}


# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 142 "/usr/include/boost/type_traits/is_pod.hpp" 2 3 4
# 15 "/usr/include/boost/type_traits/has_trivial_constructor.hpp" 2 3 4



# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 19 "/usr/include/boost/type_traits/has_trivial_constructor.hpp" 2 3 4

namespace boost {

namespace detail {

template <typename T>
struct has_trivial_ctor_impl
{

   static const bool value = (::boost::type_traits::ice_or< ::boost::is_pod<T>::value, __has_trivial_constructor(T) >::value);
# 40 "/usr/include/boost/type_traits/has_trivial_constructor.hpp" 3 4
};

}

template< typename T > struct has_trivial_constructor : public ::boost::integral_constant<bool,::boost::detail::has_trivial_ctor_impl<T>::value> { public: };
template< typename T > struct has_trivial_default_constructor : public ::boost::integral_constant<bool,::boost::detail::has_trivial_ctor_impl<T>::value> { public: };

}


# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 50 "/usr/include/boost/type_traits/has_trivial_constructor.hpp" 2 3 4
# 13 "/usr/include/boost/type_traits/has_nothrow_constructor.hpp" 2 3 4


# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 16 "/usr/include/boost/type_traits/has_nothrow_constructor.hpp" 2 3 4

namespace boost {

namespace detail{

template <class T>
struct has_nothrow_constructor_imp{

   static const bool value = __has_nothrow_constructor(T);



};

}

template< typename T > struct has_nothrow_constructor : public ::boost::integral_constant<bool,::boost::detail::has_nothrow_constructor_imp<T>::value> { public: };
template< typename T > struct has_nothrow_default_constructor : public ::boost::integral_constant<bool,::boost::detail::has_nothrow_constructor_imp<T>::value> { public: };

template<> struct has_nothrow_constructor< void > : public ::boost::integral_constant<bool,false> { public: };

template<> struct has_nothrow_constructor< void const > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_nothrow_constructor< void const volatile > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_nothrow_constructor< void volatile > : public ::boost::integral_constant<bool,false> { public: };


template<> struct has_nothrow_default_constructor< void > : public ::boost::integral_constant<bool,false> { public: };

template<> struct has_nothrow_default_constructor< void const > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_nothrow_default_constructor< void const volatile > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_nothrow_default_constructor< void volatile > : public ::boost::integral_constant<bool,false> { public: };


}


# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 52 "/usr/include/boost/type_traits/has_nothrow_constructor.hpp" 2 3 4
# 26 "/usr/include/boost/optional/optional.hpp" 2 3 4
# 1 "/usr/include/boost/type_traits/type_with_alignment.hpp" 1 3 4
# 11 "/usr/include/boost/type_traits/type_with_alignment.hpp" 3 4
# 1 "/usr/include/boost/mpl/if.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/if.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/value_wknd.hpp" 1 3 4
# 18 "/usr/include/boost/mpl/aux_/value_wknd.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/config/integral.hpp" 1 3 4
# 19 "/usr/include/boost/mpl/aux_/value_wknd.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/aux_/config/eti.hpp" 1 3 4
# 20 "/usr/include/boost/mpl/aux_/value_wknd.hpp" 2 3 4
# 73 "/usr/include/boost/mpl/aux_/value_wknd.hpp" 3 4
namespace boost { namespace mpl { namespace aux {

template< typename T > struct value_type_wknd
{
    typedef typename T::value_type type;
};
# 87 "/usr/include/boost/mpl/aux_/value_wknd.hpp" 3 4
}}}
# 18 "/usr/include/boost/mpl/if.hpp" 2 3 4

# 1 "/usr/include/boost/mpl/aux_/na_spec.hpp" 1 3 4
# 18 "/usr/include/boost/mpl/aux_/na_spec.hpp" 3 4
# 1 "/usr/include/boost/mpl/lambda_fwd.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/lambda_fwd.hpp" 3 4
# 1 "/usr/include/boost/mpl/void_fwd.hpp" 1 3 4
# 19 "/usr/include/boost/mpl/void_fwd.hpp" 3 4
namespace mpl_ {

struct void_;

}
namespace boost { namespace mpl { using ::mpl_::void_; } }
# 18 "/usr/include/boost/mpl/lambda_fwd.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/aux_/na.hpp" 1 3 4
# 18 "/usr/include/boost/mpl/aux_/na.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/na_fwd.hpp" 1 3 4
# 19 "/usr/include/boost/mpl/aux_/na_fwd.hpp" 3 4
namespace mpl_ {


struct na
{
    typedef na type;
    enum { value = 0 };
};

}
namespace boost { namespace mpl { using ::mpl_::na; } }
# 19 "/usr/include/boost/mpl/aux_/na.hpp" 2 3 4



namespace boost { namespace mpl {

template< typename T >
struct is_na
    : false_
{



};

template<>
struct is_na<na>
    : true_
{



};

template< typename T >
struct is_not_na
    : true_
{



};

template<>
struct is_not_na<na>
    : false_
{



};


template< typename T, typename U > struct if_na
{
    typedef T type;
};

template< typename U > struct if_na<na,U>
{
    typedef U type;
};
# 93 "/usr/include/boost/mpl/aux_/na.hpp" 3 4
}}
# 19 "/usr/include/boost/mpl/lambda_fwd.hpp" 2 3 4





# 1 "/usr/include/boost/mpl/aux_/lambda_arity_param.hpp" 1 3 4
# 25 "/usr/include/boost/mpl/lambda_fwd.hpp" 2 3 4


namespace boost { namespace mpl {

template<
      typename T = na
    , typename Tag = void_
    , typename Arity = int_< aux::template_arity<T>::value >


    >
struct lambda;

}}
# 19 "/usr/include/boost/mpl/aux_/na_spec.hpp" 2 3 4



# 1 "/usr/include/boost/mpl/aux_/arity.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/aux_/arity.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/config/dtp.hpp" 1 3 4
# 18 "/usr/include/boost/mpl/aux_/arity.hpp" 2 3 4
# 23 "/usr/include/boost/mpl/aux_/na_spec.hpp" 2 3 4




# 1 "/usr/include/boost/mpl/aux_/preprocessor/enum.hpp" 1 3 4
# 45 "/usr/include/boost/mpl/aux_/preprocessor/enum.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/comma_if.hpp" 1 3 4
# 46 "/usr/include/boost/mpl/aux_/preprocessor/enum.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/repeat.hpp" 1 3 4
# 47 "/usr/include/boost/mpl/aux_/preprocessor/enum.hpp" 2 3 4
# 28 "/usr/include/boost/mpl/aux_/na_spec.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 3 4
# 1 "/usr/include/boost/mpl/limits/arity.hpp" 1 3 4
# 18 "/usr/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2 3 4



# 1 "/usr/include/boost/preprocessor/comma_if.hpp" 1 3 4
# 22 "/usr/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/logical/and.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/logical/and.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 18 "/usr/include/boost/preprocessor/logical/and.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/logical/bool.hpp" 1 3 4
# 19 "/usr/include/boost/preprocessor/logical/and.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/logical/bitand.hpp" 1 3 4
# 15 "/usr/include/boost/preprocessor/logical/bitand.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 16 "/usr/include/boost/preprocessor/logical/bitand.hpp" 2 3 4
# 20 "/usr/include/boost/preprocessor/logical/and.hpp" 2 3 4
# 23 "/usr/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/identity.hpp" 1 3 4
# 15 "/usr/include/boost/preprocessor/identity.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/facilities/identity.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/facilities/identity.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/facilities/empty.hpp" 1 3 4
# 18 "/usr/include/boost/preprocessor/facilities/identity.hpp" 2 3 4
# 16 "/usr/include/boost/preprocessor/identity.hpp" 2 3 4
# 24 "/usr/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/empty.hpp" 1 3 4
# 15 "/usr/include/boost/preprocessor/empty.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/facilities/empty.hpp" 1 3 4
# 16 "/usr/include/boost/preprocessor/empty.hpp" 2 3 4
# 25 "/usr/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2 3 4
# 66 "/usr/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/arithmetic/add.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/arithmetic/add.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/arithmetic/dec.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/arithmetic/dec.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 18 "/usr/include/boost/preprocessor/arithmetic/dec.hpp" 2 3 4
# 18 "/usr/include/boost/preprocessor/arithmetic/add.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/arithmetic/inc.hpp" 1 3 4
# 19 "/usr/include/boost/preprocessor/arithmetic/add.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 20 "/usr/include/boost/preprocessor/arithmetic/add.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/control/while.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/control/while.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/cat.hpp" 1 3 4
# 18 "/usr/include/boost/preprocessor/control/while.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 19 "/usr/include/boost/preprocessor/control/while.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/debug/error.hpp" 1 3 4
# 20 "/usr/include/boost/preprocessor/control/while.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/detail/auto_rec.hpp" 1 3 4
# 12 "/usr/include/boost/preprocessor/detail/auto_rec.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 13 "/usr/include/boost/preprocessor/detail/auto_rec.hpp" 2 3 4
# 21 "/usr/include/boost/preprocessor/control/while.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/list/fold_left.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/list/fold_left.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/cat.hpp" 1 3 4
# 18 "/usr/include/boost/preprocessor/list/fold_left.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/control/while.hpp" 1 3 4
# 19 "/usr/include/boost/preprocessor/list/fold_left.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/debug/error.hpp" 1 3 4
# 20 "/usr/include/boost/preprocessor/list/fold_left.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/detail/auto_rec.hpp" 1 3 4
# 12 "/usr/include/boost/preprocessor/detail/auto_rec.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 13 "/usr/include/boost/preprocessor/detail/auto_rec.hpp" 2 3 4
# 21 "/usr/include/boost/preprocessor/list/fold_left.hpp" 2 3 4
# 41 "/usr/include/boost/preprocessor/list/fold_left.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/list/detail/fold_left.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/list/detail/fold_left.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/control/expr_iif.hpp" 1 3 4
# 15 "/usr/include/boost/preprocessor/control/expr_iif.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 16 "/usr/include/boost/preprocessor/control/expr_iif.hpp" 2 3 4
# 18 "/usr/include/boost/preprocessor/list/detail/fold_left.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/control/iif.hpp" 1 3 4
# 19 "/usr/include/boost/preprocessor/list/detail/fold_left.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/list/adt.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/list/adt.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 18 "/usr/include/boost/preprocessor/list/adt.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/detail/is_binary.hpp" 1 3 4
# 15 "/usr/include/boost/preprocessor/detail/is_binary.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 16 "/usr/include/boost/preprocessor/detail/is_binary.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/detail/check.hpp" 1 3 4
# 15 "/usr/include/boost/preprocessor/detail/check.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/cat.hpp" 1 3 4
# 16 "/usr/include/boost/preprocessor/detail/check.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/detail/check.hpp" 2 3 4
# 17 "/usr/include/boost/preprocessor/detail/is_binary.hpp" 2 3 4
# 19 "/usr/include/boost/preprocessor/list/adt.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/logical/compl.hpp" 1 3 4
# 15 "/usr/include/boost/preprocessor/logical/compl.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 16 "/usr/include/boost/preprocessor/logical/compl.hpp" 2 3 4
# 20 "/usr/include/boost/preprocessor/list/adt.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/tuple/eat.hpp" 1 3 4
# 21 "/usr/include/boost/preprocessor/list/adt.hpp" 2 3 4
# 20 "/usr/include/boost/preprocessor/list/detail/fold_left.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/tuple/eat.hpp" 1 3 4
# 21 "/usr/include/boost/preprocessor/list/detail/fold_left.hpp" 2 3 4
# 42 "/usr/include/boost/preprocessor/list/fold_left.hpp" 2 3 4
# 22 "/usr/include/boost/preprocessor/control/while.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/list/fold_right.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/list/fold_right.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/cat.hpp" 1 3 4
# 18 "/usr/include/boost/preprocessor/list/fold_right.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/control/while.hpp" 1 3 4
# 19 "/usr/include/boost/preprocessor/list/fold_right.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/debug/error.hpp" 1 3 4
# 20 "/usr/include/boost/preprocessor/list/fold_right.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/detail/auto_rec.hpp" 1 3 4
# 12 "/usr/include/boost/preprocessor/detail/auto_rec.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 13 "/usr/include/boost/preprocessor/detail/auto_rec.hpp" 2 3 4
# 21 "/usr/include/boost/preprocessor/list/fold_right.hpp" 2 3 4
# 37 "/usr/include/boost/preprocessor/list/fold_right.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/list/detail/fold_right.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/list/detail/fold_right.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/list/fold_left.hpp" 1 3 4
# 18 "/usr/include/boost/preprocessor/list/detail/fold_right.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/list/reverse.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/list/reverse.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 18 "/usr/include/boost/preprocessor/list/reverse.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/list/fold_left.hpp" 1 3 4
# 19 "/usr/include/boost/preprocessor/list/reverse.hpp" 2 3 4
# 19 "/usr/include/boost/preprocessor/list/detail/fold_right.hpp" 2 3 4
# 38 "/usr/include/boost/preprocessor/list/fold_right.hpp" 2 3 4
# 23 "/usr/include/boost/preprocessor/control/while.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/logical/bitand.hpp" 1 3 4
# 24 "/usr/include/boost/preprocessor/control/while.hpp" 2 3 4
# 48 "/usr/include/boost/preprocessor/control/while.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/control/detail/while.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/control/detail/while.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/control/iif.hpp" 1 3 4
# 18 "/usr/include/boost/preprocessor/control/detail/while.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/logical/bool.hpp" 1 3 4
# 19 "/usr/include/boost/preprocessor/control/detail/while.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/tuple/eat.hpp" 1 3 4
# 20 "/usr/include/boost/preprocessor/control/detail/while.hpp" 2 3 4
# 49 "/usr/include/boost/preprocessor/control/while.hpp" 2 3 4
# 21 "/usr/include/boost/preprocessor/arithmetic/add.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/tuple/elem.hpp" 1 3 4
# 18 "/usr/include/boost/preprocessor/tuple/elem.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/cat.hpp" 1 3 4
# 19 "/usr/include/boost/preprocessor/tuple/elem.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 20 "/usr/include/boost/preprocessor/tuple/elem.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/facilities/overload.hpp" 1 3 4
# 16 "/usr/include/boost/preprocessor/facilities/overload.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/cat.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/facilities/overload.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/variadic/size.hpp" 1 3 4
# 16 "/usr/include/boost/preprocessor/variadic/size.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/cat.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/variadic/size.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 18 "/usr/include/boost/preprocessor/variadic/size.hpp" 2 3 4
# 18 "/usr/include/boost/preprocessor/facilities/overload.hpp" 2 3 4
# 21 "/usr/include/boost/preprocessor/tuple/elem.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/tuple/rem.hpp" 1 3 4
# 16 "/usr/include/boost/preprocessor/tuple/rem.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/cat.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/tuple/rem.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 18 "/usr/include/boost/preprocessor/tuple/rem.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/facilities/overload.hpp" 1 3 4
# 19 "/usr/include/boost/preprocessor/tuple/rem.hpp" 2 3 4
# 22 "/usr/include/boost/preprocessor/tuple/elem.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/variadic/elem.hpp" 1 3 4
# 16 "/usr/include/boost/preprocessor/variadic/elem.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/cat.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/variadic/elem.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 18 "/usr/include/boost/preprocessor/variadic/elem.hpp" 2 3 4
# 23 "/usr/include/boost/preprocessor/tuple/elem.hpp" 2 3 4
# 22 "/usr/include/boost/preprocessor/arithmetic/add.hpp" 2 3 4
# 67 "/usr/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/arithmetic/sub.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/arithmetic/sub.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/arithmetic/dec.hpp" 1 3 4
# 18 "/usr/include/boost/preprocessor/arithmetic/sub.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 19 "/usr/include/boost/preprocessor/arithmetic/sub.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/control/while.hpp" 1 3 4
# 20 "/usr/include/boost/preprocessor/arithmetic/sub.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/tuple/elem.hpp" 1 3 4
# 21 "/usr/include/boost/preprocessor/arithmetic/sub.hpp" 2 3 4
# 68 "/usr/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/inc.hpp" 1 3 4
# 69 "/usr/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/tuple/elem.hpp" 1 3 4
# 70 "/usr/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/repeat.hpp" 1 3 4
# 71 "/usr/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/cat.hpp" 1 3 4
# 72 "/usr/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2 3 4
# 29 "/usr/include/boost/mpl/aux_/na_spec.hpp" 2 3 4
# 20 "/usr/include/boost/mpl/if.hpp" 2 3 4





namespace boost { namespace mpl {



template<
      bool C
    , typename T1
    , typename T2
    >
struct if_c
{
    typedef T1 type;
};

template<
      typename T1
    , typename T2
    >
struct if_c<false,T1,T2>
{
    typedef T2 type;
};



template<
      typename T1 = na
    , typename T2 = na
    , typename T3 = na
    >
struct if_
{
 private:

    typedef if_c<



          static_cast<bool>(T1::value)

        , T2
        , T3
        > almost_type_;

 public:
    typedef typename almost_type_::type type;


};
# 131 "/usr/include/boost/mpl/if.hpp" 3 4
template<> struct if_< na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 =na , typename T5 =na > struct apply : if_< T1 , T2 , T3 > { }; }; template< typename Tag > struct lambda< if_< na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef if_< na , na , na > result_; typedef if_< na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< if_< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< if_< na , na , na > > : int_<-1> { }; }

}}
# 12 "/usr/include/boost/type_traits/type_with_alignment.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/list/for_each_i.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/list/for_each_i.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/arithmetic/inc.hpp" 1 3 4
# 18 "/usr/include/boost/preprocessor/list/for_each_i.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 19 "/usr/include/boost/preprocessor/list/for_each_i.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/list/adt.hpp" 1 3 4
# 20 "/usr/include/boost/preprocessor/list/for_each_i.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/repetition/for.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/repetition/for.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/cat.hpp" 1 3 4
# 18 "/usr/include/boost/preprocessor/repetition/for.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/debug/error.hpp" 1 3 4
# 19 "/usr/include/boost/preprocessor/repetition/for.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/detail/auto_rec.hpp" 1 3 4
# 12 "/usr/include/boost/preprocessor/detail/auto_rec.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 13 "/usr/include/boost/preprocessor/detail/auto_rec.hpp" 2 3 4
# 20 "/usr/include/boost/preprocessor/repetition/for.hpp" 2 3 4
# 42 "/usr/include/boost/preprocessor/repetition/for.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/repetition/detail/for.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/repetition/detail/for.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/control/expr_iif.hpp" 1 3 4
# 18 "/usr/include/boost/preprocessor/repetition/detail/for.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/control/iif.hpp" 1 3 4
# 19 "/usr/include/boost/preprocessor/repetition/detail/for.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/logical/bool.hpp" 1 3 4
# 20 "/usr/include/boost/preprocessor/repetition/detail/for.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/tuple/eat.hpp" 1 3 4
# 21 "/usr/include/boost/preprocessor/repetition/detail/for.hpp" 2 3 4
# 43 "/usr/include/boost/preprocessor/repetition/for.hpp" 2 3 4
# 21 "/usr/include/boost/preprocessor/list/for_each_i.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/tuple/elem.hpp" 1 3 4
# 22 "/usr/include/boost/preprocessor/list/for_each_i.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/tuple/rem.hpp" 1 3 4
# 23 "/usr/include/boost/preprocessor/list/for_each_i.hpp" 2 3 4
# 13 "/usr/include/boost/type_traits/type_with_alignment.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/tuple/to_list.hpp" 1 3 4
# 18 "/usr/include/boost/preprocessor/tuple/to_list.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/cat.hpp" 1 3 4
# 19 "/usr/include/boost/preprocessor/tuple/to_list.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 20 "/usr/include/boost/preprocessor/tuple/to_list.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/facilities/overload.hpp" 1 3 4
# 21 "/usr/include/boost/preprocessor/tuple/to_list.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/variadic/size.hpp" 1 3 4
# 22 "/usr/include/boost/preprocessor/tuple/to_list.hpp" 2 3 4
# 14 "/usr/include/boost/type_traits/type_with_alignment.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/cat.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/type_with_alignment.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/list/transform.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/list/transform.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 18 "/usr/include/boost/preprocessor/list/transform.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/list/fold_right.hpp" 1 3 4
# 19 "/usr/include/boost/preprocessor/list/transform.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/tuple/elem.hpp" 1 3 4
# 20 "/usr/include/boost/preprocessor/list/transform.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/tuple/rem.hpp" 1 3 4
# 21 "/usr/include/boost/preprocessor/list/transform.hpp" 2 3 4
# 16 "/usr/include/boost/type_traits/type_with_alignment.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/list/append.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/list/append.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 18 "/usr/include/boost/preprocessor/list/append.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/list/fold_right.hpp" 1 3 4
# 19 "/usr/include/boost/preprocessor/list/append.hpp" 2 3 4
# 17 "/usr/include/boost/type_traits/type_with_alignment.hpp" 2 3 4


# 1 "/usr/include/boost/static_assert.hpp" 1 3 4
# 20 "/usr/include/boost/type_traits/type_with_alignment.hpp" 2 3 4



# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 24 "/usr/include/boost/type_traits/type_with_alignment.hpp" 2 3 4

# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 3


# 1 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/stddef.h" 1 3
# 43 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 2 3
# 26 "/usr/include/boost/type_traits/type_with_alignment.hpp" 2 3 4






namespace boost {



namespace detail {

class alignment_dummy;
typedef void (*function_ptr)();
typedef int (alignment_dummy::*member_ptr);
typedef int (alignment_dummy::*member_function_ptr)();
# 101 "/usr/include/boost/type_traits/type_with_alignment.hpp" 3 4
template <bool found, std::size_t target, class TestType>
struct lower_alignment_helper
{
    typedef char type;
    enum { value = true };
};

template <std::size_t target, class TestType>
struct lower_alignment_helper<false,target,TestType>
{
    enum { value = (alignment_of<TestType>::value == target) };
    typedef typename mpl::if_c<value, TestType, char>::type type;
};
# 127 "/usr/include/boost/type_traits/type_with_alignment.hpp" 3 4
template <typename T>
struct has_one_T
{
  T data;
};

template <std::size_t target>
union lower_alignment
{
    enum { found0 = false };

    typename lower_alignment_helper< found0,target,char >::type t0; enum { found1 = lower_alignment_helper<found0,target,char >::value }; typename lower_alignment_helper< found1,target,short >::type t1; enum { found2 = lower_alignment_helper<found1,target,short >::value }; typename lower_alignment_helper< found2,target,int >::type t2; enum { found3 = lower_alignment_helper<found2,target,int >::value }; typename lower_alignment_helper< found3,target,long >::type t3; enum { found4 = lower_alignment_helper<found3,target,long >::value }; typename lower_alignment_helper< found4,target,::boost::long_long_type >::type t4; enum { found5 = lower_alignment_helper<found4,target,::boost::long_long_type >::value }; typename lower_alignment_helper< found5,target,float >::type t5; enum { found6 = lower_alignment_helper<found5,target,float >::value }; typename lower_alignment_helper< found6,target,double >::type t6; enum { found7 = lower_alignment_helper<found6,target,double >::value }; typename lower_alignment_helper< found7,target,long double >::type t7; enum { found8 = lower_alignment_helper<found7,target,long double >::value }; typename lower_alignment_helper< found8,target,void* >::type t8; enum { found9 = lower_alignment_helper<found8,target,void* >::value }; typename lower_alignment_helper< found9,target,function_ptr >::type t9; enum { found10 = lower_alignment_helper<found9,target,function_ptr >::value }; typename lower_alignment_helper< found10,target,member_ptr >::type t10; enum { found11 = lower_alignment_helper<found10,target,member_ptr >::value }; typename lower_alignment_helper< found11,target,member_function_ptr >::type t11; enum { found12 = lower_alignment_helper<found11,target,member_function_ptr >::value }; typename lower_alignment_helper< found12,target,boost::detail::has_one_T< char > >::type t12; enum { found13 = lower_alignment_helper<found12,target,boost::detail::has_one_T< char > >::value }; typename lower_alignment_helper< found13,target,boost::detail::has_one_T< short > >::type t13; enum { found14 = lower_alignment_helper<found13,target,boost::detail::has_one_T< short > >::value }; typename lower_alignment_helper< found14,target,boost::detail::has_one_T< int > >::type t14; enum { found15 = lower_alignment_helper<found14,target,boost::detail::has_one_T< int > >::value }; typename lower_alignment_helper< found15,target,boost::detail::has_one_T< long > >::type t15; enum { found16 = lower_alignment_helper<found15,target,boost::detail::has_one_T< long > >::value }; typename lower_alignment_helper< found16,target,boost::detail::has_one_T< ::boost::long_long_type > >::type t16; enum { found17 = lower_alignment_helper<found16,target,boost::detail::has_one_T< ::boost::long_long_type > >::value }; typename lower_alignment_helper< found17,target,boost::detail::has_one_T< float > >::type t17; enum { found18 = lower_alignment_helper<found17,target,boost::detail::has_one_T< float > >::value }; typename lower_alignment_helper< found18,target,boost::detail::has_one_T< double > >::type t18; enum { found19 = lower_alignment_helper<found18,target,boost::detail::has_one_T< double > >::value }; typename lower_alignment_helper< found19,target,boost::detail::has_one_T< long double > >::type t19; enum { found20 = lower_alignment_helper<found19,target,boost::detail::has_one_T< long double > >::value }; typename lower_alignment_helper< found20,target,boost::detail::has_one_T< void* > >::type t20; enum { found21 = lower_alignment_helper<found20,target,boost::detail::has_one_T< void* > >::value }; typename lower_alignment_helper< found21,target,boost::detail::has_one_T< function_ptr > >::type t21; enum { found22 = lower_alignment_helper<found21,target,boost::detail::has_one_T< function_ptr > >::value }; typename lower_alignment_helper< found22,target,boost::detail::has_one_T< member_ptr > >::type t22; enum { found23 = lower_alignment_helper<found22,target,boost::detail::has_one_T< member_ptr > >::value }; typename lower_alignment_helper< found23,target,boost::detail::has_one_T< member_function_ptr > >::type t23; enum { found24 = lower_alignment_helper<found23,target,boost::detail::has_one_T< member_function_ptr > >::value };




};

union max_align
{
    char t0; short t1; int t2; long t3; ::boost::long_long_type t4; float t5; double t6; long double t7; void* t8; function_ptr t9; member_ptr t10; member_function_ptr t11; boost::detail::has_one_T< char > t12; boost::detail::has_one_T< short > t13; boost::detail::has_one_T< int > t14; boost::detail::has_one_T< long > t15; boost::detail::has_one_T< ::boost::long_long_type > t16; boost::detail::has_one_T< float > t17; boost::detail::has_one_T< double > t18; boost::detail::has_one_T< long double > t19; boost::detail::has_one_T< void* > t20; boost::detail::has_one_T< function_ptr > t21; boost::detail::has_one_T< member_ptr > t22; boost::detail::has_one_T< member_function_ptr > t23;




};
# 161 "/usr/include/boost/type_traits/type_with_alignment.hpp" 3 4
template<std::size_t TAlign, std::size_t Align>
struct is_aligned
{
    static const bool value = (TAlign >= Align) & (TAlign % Align == 0);


};
# 180 "/usr/include/boost/type_traits/type_with_alignment.hpp" 3 4
}


template<std::size_t Align>
struct is_pod< ::boost::detail::lower_alignment<Align> >
{
        static const std::size_t value = true;
};




namespace detail{

template <std::size_t Align>
class type_with_alignment_imp
{
    typedef ::boost::detail::lower_alignment<Align> t1;
    typedef typename mpl::if_c<
          ::boost::detail::is_aligned< ::boost::alignment_of<t1>::value,Align >::value
        , t1
        , ::boost::detail::max_align
        >::type align_t;

    static const std::size_t found = alignment_of<align_t>::value;

    static_assert(found >= Align, "found >= Align");
    static_assert(found % Align == 0, "found % Align == 0");

 public:
    typedef align_t type;
};

}

template <std::size_t Align>
class type_with_alignment
  : public ::boost::detail::type_with_alignment_imp<Align>
{
};


namespace align {
struct __attribute__((__aligned__(2))) a2 {};
struct __attribute__((__aligned__(4))) a4 {};
struct __attribute__((__aligned__(8))) a8 {};
struct __attribute__((__aligned__(16))) a16 {};
struct __attribute__((__aligned__(32))) a32 {};
struct __attribute__((__aligned__(64))) a64 {};
struct __attribute__((__aligned__(128))) a128 {};
}

template<> class type_with_alignment<1> { public: typedef char type; };
template<> class type_with_alignment<2> { public: typedef align::a2 type; };
template<> class type_with_alignment<4> { public: typedef align::a4 type; };
template<> class type_with_alignment<8> { public: typedef align::a8 type; };
template<> class type_with_alignment<16> { public: typedef align::a16 type; };
template<> class type_with_alignment<32> { public: typedef align::a32 type; };
template<> class type_with_alignment<64> { public: typedef align::a64 type; };
template<> class type_with_alignment<128> { public: typedef align::a128 type; };

namespace detail {
template<> struct is_pod_impl< ::boost::align::a2 > { public: static const bool value = (true); };
template<> struct is_pod_impl< ::boost::align::a4 > { public: static const bool value = (true); };
template<> struct is_pod_impl< ::boost::align::a8 > { public: static const bool value = (true); };
template<> struct is_pod_impl< ::boost::align::a16 > { public: static const bool value = (true); };
template<> struct is_pod_impl< ::boost::align::a32 > { public: static const bool value = (true); };
template<> struct is_pod_impl< ::boost::align::a64 > { public: static const bool value = (true); };
template<> struct is_pod_impl< ::boost::align::a128 > { public: static const bool value = (true); };
}
# 389 "/usr/include/boost/type_traits/type_with_alignment.hpp" 3 4
}






# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 396 "/usr/include/boost/type_traits/type_with_alignment.hpp" 2 3 4
# 27 "/usr/include/boost/optional/optional.hpp" 2 3 4
# 1 "/usr/include/boost/type_traits/remove_reference.hpp" 1 3 4
# 21 "/usr/include/boost/type_traits/remove_reference.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/type_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/type_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/type_trait_def.hpp" 2 3 4
# 22 "/usr/include/boost/type_traits/remove_reference.hpp" 2 3 4

namespace boost {



namespace detail{




template <class T>
struct remove_rvalue_ref
{
   typedef T type;
};

template <class T>
struct remove_rvalue_ref<T&&>
{
   typedef T type;
};


}

template< typename T > struct remove_reference { public: typedef typename boost::detail::remove_rvalue_ref<T>::type type; };
template< typename T > struct remove_reference<T&> { public: typedef T type; };
# 66 "/usr/include/boost/type_traits/remove_reference.hpp" 3 4
}


# 1 "/usr/include/boost/type_traits/detail/type_trait_undef.hpp" 1 3 4
# 69 "/usr/include/boost/type_traits/remove_reference.hpp" 2 3 4
# 28 "/usr/include/boost/optional/optional.hpp" 2 3 4



# 1 "/usr/include/boost/mpl/not.hpp" 1 3 4
# 19 "/usr/include/boost/mpl/not.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/nested_type_wknd.hpp" 1 3 4
# 25 "/usr/include/boost/mpl/aux_/nested_type_wknd.hpp" 3 4
namespace boost { namespace mpl { namespace aux {
template< typename T > struct nested_type_wknd
    : T::type
{
};
}}}
# 20 "/usr/include/boost/mpl/not.hpp" 2 3 4



namespace boost { namespace mpl {

namespace aux {

template< long C_ >
struct not_impl
    : bool_<!C_>
{
};

}


template<
      typename T = na
    >
struct not_
    : aux::not_impl<
          ::boost::mpl::aux::nested_type_wknd<T>::value
        >
{

};

template<> struct not_< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : not_< T1 > { }; }; template< typename Tag > struct lambda< not_< na > , Tag , int_<-1> > { typedef false_ is_le; typedef not_< na > result_; typedef not_< na > type; }; namespace aux { template< typename T1 > struct template_arity< not_< T1 > > : int_<1> { }; template<> struct template_arity< not_< na > > : int_<-1> { }; }

}}
# 32 "/usr/include/boost/optional/optional.hpp" 2 3 4
# 1 "/usr/include/boost/detail/reference_content.hpp" 1 3 4
# 20 "/usr/include/boost/detail/reference_content.hpp" 3 4
# 1 "/usr/include/boost/type_traits/has_nothrow_copy.hpp" 1 3 4
# 12 "/usr/include/boost/type_traits/has_nothrow_copy.hpp" 3 4
# 1 "/usr/include/boost/type_traits/has_trivial_copy.hpp" 1 3 4
# 21 "/usr/include/boost/type_traits/has_trivial_copy.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 22 "/usr/include/boost/type_traits/has_trivial_copy.hpp" 2 3 4

namespace boost {

namespace detail {

template <typename T>
struct has_trivial_copy_impl
{

   static const bool value = (__has_trivial_copy(T) && !is_reference<T>::value && !is_volatile<T>::value);







};

}

template< typename T > struct has_trivial_copy : public ::boost::integral_constant<bool,::boost::detail::has_trivial_copy_impl<T>::value> { public: };
template< typename T > struct has_trivial_copy_constructor : public ::boost::integral_constant<bool,::boost::detail::has_trivial_copy_impl<T>::value> { public: };

template<> struct has_trivial_copy< void > : public ::boost::integral_constant<bool,false> { public: };

template<> struct has_trivial_copy< void const > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_trivial_copy< void const volatile > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_trivial_copy< void volatile > : public ::boost::integral_constant<bool,false> { public: };


template<> struct has_trivial_copy_constructor< void > : public ::boost::integral_constant<bool,false> { public: };

template<> struct has_trivial_copy_constructor< void const > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_trivial_copy_constructor< void const volatile > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_trivial_copy_constructor< void volatile > : public ::boost::integral_constant<bool,false> { public: };


}


# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 63 "/usr/include/boost/type_traits/has_trivial_copy.hpp" 2 3 4
# 13 "/usr/include/boost/type_traits/has_nothrow_copy.hpp" 2 3 4


# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 16 "/usr/include/boost/type_traits/has_nothrow_copy.hpp" 2 3 4

namespace boost {

namespace detail{

template <class T>
struct has_nothrow_copy_imp{

   static const bool value = (__has_nothrow_copy(T) && !is_volatile<T>::value && !is_reference<T>::value);



};

}

template< typename T > struct has_nothrow_copy : public ::boost::integral_constant<bool,::boost::detail::has_nothrow_copy_imp<T>::value> { public: };
template< typename T > struct has_nothrow_copy_constructor : public ::boost::integral_constant<bool,::boost::detail::has_nothrow_copy_imp<T>::value> { public: };

template<> struct has_nothrow_copy< void > : public ::boost::integral_constant<bool,false> { public: };

template<> struct has_nothrow_copy< void const > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_nothrow_copy< void const volatile > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_nothrow_copy< void volatile > : public ::boost::integral_constant<bool,false> { public: };


template<> struct has_nothrow_copy_constructor< void > : public ::boost::integral_constant<bool,false> { public: };

template<> struct has_nothrow_copy_constructor< void const > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_nothrow_copy_constructor< void const volatile > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_nothrow_copy_constructor< void volatile > : public ::boost::integral_constant<bool,false> { public: };


}


# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 52 "/usr/include/boost/type_traits/has_nothrow_copy.hpp" 2 3 4
# 21 "/usr/include/boost/detail/reference_content.hpp" 2 3 4





# 1 "/usr/include/boost/mpl/void.hpp" 1 3 4
# 23 "/usr/include/boost/mpl/void.hpp" 3 4
namespace mpl_ {





struct void_ { typedef void_ type; };

}

namespace boost { namespace mpl {

template< typename T >
struct is_void_
    : false_
{



};

template<>
struct is_void_<void_>
    : true_
{



};

template< typename T >
struct is_not_void_
    : true_
{



};

template<>
struct is_not_void_<void_>
    : false_
{



};

template<> struct is_void_< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : is_void_< T1 > { }; }; template< typename Tag > struct lambda< is_void_< na > , Tag , int_<-1> > { typedef false_ is_le; typedef is_void_< na > result_; typedef is_void_< na > type; }; namespace aux { template< typename T1 > struct template_arity< is_void_< T1 > > : int_<1> { }; template<> struct template_arity< is_void_< na > > : int_<-1> { }; }
template<> struct is_not_void_< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : is_not_void_< T1 > { }; }; template< typename Tag > struct lambda< is_not_void_< na > , Tag , int_<-1> > { typedef false_ is_le; typedef is_not_void_< na > result_; typedef is_not_void_< na > type; }; namespace aux { template< typename T1 > struct template_arity< is_not_void_< T1 > > : int_<1> { }; template<> struct template_arity< is_not_void_< na > > : int_<-1> { }; }

}}
# 27 "/usr/include/boost/detail/reference_content.hpp" 2 3 4

namespace boost {

namespace detail {






template <typename RefT>
class reference_content
{
private:

    RefT content_;

public:

    ~reference_content()
    {
    }

    reference_content(RefT r)
        : content_( r )
    {
    }

    reference_content(const reference_content& operand)
        : content_( operand.content_ )
    {
    }

private:

    reference_content& operator=(const reference_content&);

public:

    RefT get() const
    {
        return content_;
    }

};







template <typename T = mpl::void_> struct make_reference_content;



template <typename T>
struct make_reference_content
{
    typedef T type;
};

template <typename T>
struct make_reference_content< T& >
{
    typedef reference_content<T&> type;
};
# 109 "/usr/include/boost/detail/reference_content.hpp" 3 4
template <>
struct make_reference_content< mpl::void_ >
{
    template <typename T>
    struct apply
        : make_reference_content<T>
    {
    };

    typedef mpl::void_ type;
};

}







template <typename T>
struct has_nothrow_copy<
      ::boost::detail::reference_content< T& >
    >
    : mpl::true_
{
};



}
# 33 "/usr/include/boost/optional/optional.hpp" 2 3 4
# 1 "/usr/include/boost/none.hpp" 1 3 4
# 15 "/usr/include/boost/none.hpp" 3 4
# 1 "/usr/include/boost/none_t.hpp" 1 3 4
# 15 "/usr/include/boost/none_t.hpp" 3 4
namespace boost {

namespace detail { struct none_helper{}; }

typedef int detail::none_helper::*none_t ;

}
# 16 "/usr/include/boost/none.hpp" 2 3 4





namespace boost {

none_t const none = (static_cast<none_t>(0)) ;

}
# 34 "/usr/include/boost/optional/optional.hpp" 2 3 4
# 1 "/usr/include/boost/utility/swap.hpp" 1 3 4
# 25 "/usr/include/boost/utility/swap.hpp" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 3


# 1 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/stddef.h" 1 3
# 43 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 2 3
# 26 "/usr/include/boost/utility/swap.hpp" 2 3 4

namespace boost_swap_impl
{
  template<class T>
  void swap_impl(T& left, T& right)
  {
    using namespace std;
    swap(left,right);
  }

  template<class T, std::size_t N>
  void swap_impl(T (& left)[N], T (& right)[N])
  {
    for (std::size_t i = 0; i < N; ++i)
    {
      ::boost_swap_impl::swap_impl(left[i], right[i]);
    }
  }
}

namespace boost
{
  template<class T1, class T2>
  void swap(T1& left, T2& right)
  {
    ::boost_swap_impl::swap_impl(left, right);
  }
}
# 35 "/usr/include/boost/optional/optional.hpp" 2 3 4
# 1 "/usr/include/boost/utility/addressof.hpp" 1 3 4
# 18 "/usr/include/boost/utility/addressof.hpp" 3 4
namespace boost
{

namespace detail
{

template<class T> struct addr_impl_ref
{
    T & v_;

    inline addr_impl_ref( T & v ): v_( v ) {}
    inline operator T& () const { return v_; }

private:
    addr_impl_ref & operator=(const addr_impl_ref &);
};

template<class T> struct addressof_impl
{
    static inline T * f( T & v, long )
    {
        return reinterpret_cast<T*>(
            &const_cast<char&>(reinterpret_cast<const volatile char &>(v)));
    }

    static inline T * f( T * v, int )
    {
        return v;
    }
};

}

template<class T> T * addressof( T & v )
{






    return boost::detail::addressof_impl<T>::f( boost::detail::addr_impl_ref<T>( v ), 0 );


}
# 100 "/usr/include/boost/utility/addressof.hpp" 3 4
}
# 36 "/usr/include/boost/optional/optional.hpp" 2 3 4
# 1 "/usr/include/boost/utility/compare_pointees.hpp" 1 3 4
# 17 "/usr/include/boost/utility/compare_pointees.hpp" 3 4
namespace boost {
# 28 "/usr/include/boost/utility/compare_pointees.hpp" 3 4
template<class OptionalPointee>
inline
bool equal_pointees ( OptionalPointee const& x, OptionalPointee const& y )
{
  return (!x) != (!y) ? false : ( !x ? true : (*x) == (*y) ) ;
}

template<class OptionalPointee>
struct equal_pointees_t : std::binary_function<OptionalPointee,OptionalPointee,bool>
{
  bool operator() ( OptionalPointee const& x, OptionalPointee const& y ) const
    { return equal_pointees(x,y) ; }
} ;
# 51 "/usr/include/boost/utility/compare_pointees.hpp" 3 4
template<class OptionalPointee>
inline
bool less_pointees ( OptionalPointee const& x, OptionalPointee const& y )
{
  return !y ? false : ( !x ? true : (*x) < (*y) ) ;
}

template<class OptionalPointee>
struct less_pointees_t : std::binary_function<OptionalPointee,OptionalPointee,bool>
{
  bool operator() ( OptionalPointee const& x, OptionalPointee const& y ) const
    { return less_pointees(x,y) ; }
} ;

}
# 37 "/usr/include/boost/optional/optional.hpp" 2 3 4
# 1 "/usr/include/boost/utility/in_place_factory.hpp" 1 3 4
# 16 "/usr/include/boost/utility/in_place_factory.hpp" 3 4
# 1 "/usr/include/boost/utility/detail/in_place_factory_prefix.hpp" 1 3 4
# 17 "/usr/include/boost/utility/detail/in_place_factory_prefix.hpp" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 3


# 1 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/stddef.h" 1 3
# 43 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 2 3
# 18 "/usr/include/boost/utility/detail/in_place_factory_prefix.hpp" 2 3 4

# 1 "/usr/include/boost/preprocessor/cat.hpp" 1 3 4
# 20 "/usr/include/boost/utility/detail/in_place_factory_prefix.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/punctuation/paren.hpp" 1 3 4
# 21 "/usr/include/boost/utility/detail/in_place_factory_prefix.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/iteration/iterate.hpp" 1 3 4
# 15 "/usr/include/boost/preprocessor/iteration/iterate.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/arithmetic/dec.hpp" 1 3 4
# 16 "/usr/include/boost/preprocessor/iteration/iterate.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/arithmetic/inc.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/iteration/iterate.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/array/elem.hpp" 1 3 4
# 15 "/usr/include/boost/preprocessor/array/elem.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/array/data.hpp" 1 3 4
# 15 "/usr/include/boost/preprocessor/array/data.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 16 "/usr/include/boost/preprocessor/array/data.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/tuple/elem.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/array/data.hpp" 2 3 4
# 16 "/usr/include/boost/preprocessor/array/elem.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/array/size.hpp" 1 3 4
# 15 "/usr/include/boost/preprocessor/array/size.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 16 "/usr/include/boost/preprocessor/array/size.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/tuple/elem.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/array/size.hpp" 2 3 4
# 17 "/usr/include/boost/preprocessor/array/elem.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 18 "/usr/include/boost/preprocessor/array/elem.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/tuple/elem.hpp" 1 3 4
# 19 "/usr/include/boost/preprocessor/array/elem.hpp" 2 3 4
# 18 "/usr/include/boost/preprocessor/iteration/iterate.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/array/size.hpp" 1 3 4
# 19 "/usr/include/boost/preprocessor/iteration/iterate.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/cat.hpp" 1 3 4
# 20 "/usr/include/boost/preprocessor/iteration/iterate.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/slot/slot.hpp" 1 3 4
# 15 "/usr/include/boost/preprocessor/slot/slot.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/cat.hpp" 1 3 4
# 16 "/usr/include/boost/preprocessor/slot/slot.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/slot/detail/def.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/slot/slot.hpp" 2 3 4
# 21 "/usr/include/boost/preprocessor/iteration/iterate.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/tuple/elem.hpp" 1 3 4
# 22 "/usr/include/boost/preprocessor/iteration/iterate.hpp" 2 3 4
# 22 "/usr/include/boost/utility/detail/in_place_factory_prefix.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/repetition/repeat.hpp" 1 3 4
# 23 "/usr/include/boost/utility/detail/in_place_factory_prefix.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/repetition/enum.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/repetition/enum.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/cat.hpp" 1 3 4
# 18 "/usr/include/boost/preprocessor/repetition/enum.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 19 "/usr/include/boost/preprocessor/repetition/enum.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/debug/error.hpp" 1 3 4
# 20 "/usr/include/boost/preprocessor/repetition/enum.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/detail/auto_rec.hpp" 1 3 4
# 12 "/usr/include/boost/preprocessor/detail/auto_rec.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 13 "/usr/include/boost/preprocessor/detail/auto_rec.hpp" 2 3 4
# 21 "/usr/include/boost/preprocessor/repetition/enum.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/punctuation/comma_if.hpp" 1 3 4
# 22 "/usr/include/boost/preprocessor/repetition/enum.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/repetition/repeat.hpp" 1 3 4
# 23 "/usr/include/boost/preprocessor/repetition/enum.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/tuple/elem.hpp" 1 3 4
# 24 "/usr/include/boost/preprocessor/repetition/enum.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/tuple/rem.hpp" 1 3 4
# 25 "/usr/include/boost/preprocessor/repetition/enum.hpp" 2 3 4
# 24 "/usr/include/boost/utility/detail/in_place_factory_prefix.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/repetition/enum_params.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/repetition/enum_params.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 18 "/usr/include/boost/preprocessor/repetition/enum_params.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/punctuation/comma_if.hpp" 1 3 4
# 19 "/usr/include/boost/preprocessor/repetition/enum_params.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/repetition/repeat.hpp" 1 3 4
# 20 "/usr/include/boost/preprocessor/repetition/enum_params.hpp" 2 3 4
# 25 "/usr/include/boost/utility/detail/in_place_factory_prefix.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/repetition/enum_binary_params.hpp" 1 3 4
# 15 "/usr/include/boost/preprocessor/repetition/enum_binary_params.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/cat.hpp" 1 3 4
# 16 "/usr/include/boost/preprocessor/repetition/enum_binary_params.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/repetition/enum_binary_params.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/punctuation/comma_if.hpp" 1 3 4
# 18 "/usr/include/boost/preprocessor/repetition/enum_binary_params.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/repetition/repeat.hpp" 1 3 4
# 19 "/usr/include/boost/preprocessor/repetition/enum_binary_params.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/tuple/elem.hpp" 1 3 4
# 20 "/usr/include/boost/preprocessor/repetition/enum_binary_params.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/tuple/rem.hpp" 1 3 4
# 21 "/usr/include/boost/preprocessor/repetition/enum_binary_params.hpp" 2 3 4
# 26 "/usr/include/boost/utility/detail/in_place_factory_prefix.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/repetition/enum_trailing_params.hpp" 1 3 4
# 15 "/usr/include/boost/preprocessor/repetition/enum_trailing_params.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 16 "/usr/include/boost/preprocessor/repetition/enum_trailing_params.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/repetition/repeat.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/repetition/enum_trailing_params.hpp" 2 3 4
# 27 "/usr/include/boost/utility/detail/in_place_factory_prefix.hpp" 2 3 4
# 17 "/usr/include/boost/utility/in_place_factory.hpp" 2 3 4

namespace boost {

class in_place_factory_base {} ;




# 1 "/usr/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 1 3 4
# 12 "/usr/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/slot/detail/shared.hpp" 1 3 4
# 13 "/usr/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp" 2 3 4
# 18 "/usr/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3 4

# 1 "/usr/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 1 3 4
# 12 "/usr/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/slot/detail/shared.hpp" 1 3 4
# 13 "/usr/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp" 2 3 4
# 20 "/usr/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3 4
# 47 "/usr/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 3 4
# 1 "/usr/include/boost/utility/in_place_factory.hpp" 1 3 4
# 37 "/usr/include/boost/utility/in_place_factory.hpp" 3 4
class in_place_factory0
  :
  public in_place_factory_base
{
public:

  explicit in_place_factory0
      ( )



  {}

  template<class T>
  void* apply(void* address
                                            ) const
  {
    return new(address) T( );
  }

  template<class T>
  void* apply(void* address, std::size_t n
                                            ) const
  {
    for(char* next = address = this->template apply<T>(address);
        !! --n;)
      this->template apply<T>(next = next+sizeof(T));
    return address;
  }


};
# 79 "/usr/include/boost/utility/in_place_factory.hpp" 3 4
inline in_place_factory0 in_place()
{
  return in_place_factory0();
}
# 48 "/usr/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3 4




# 1 "/usr/include/boost/utility/in_place_factory.hpp" 1 3 4
# 35 "/usr/include/boost/utility/in_place_factory.hpp" 3 4
template< class A0 >

class in_place_factory1
  :
  public in_place_factory_base
{
public:

  explicit in_place_factory1
      ( A0 const& a0 )

    : m_a0 ( a0 )

  {}

  template<class T>
  void* apply(void* address
                                            ) const
  {
    return new(address) T( m_a0 );
  }

  template<class T>
  void* apply(void* address, std::size_t n
                                            ) const
  {
    for(char* next = address = this->template apply<T>(address);
        !! --n;)
      this->template apply<T>(next = next+sizeof(T));
    return address;
  }

  A0 const& m_a0;
};


template< class A0 >
inline in_place_factory1< A0 >
in_place( A0 const& a0 )
{
  return in_place_factory1< A0 >
      ( a0 );
}
# 53 "/usr/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3 4




# 1 "/usr/include/boost/utility/in_place_factory.hpp" 1 3 4
# 35 "/usr/include/boost/utility/in_place_factory.hpp" 3 4
template< class A0 , class A1 >

class in_place_factory2
  :
  public in_place_factory_base
{
public:

  explicit in_place_factory2
      ( A0 const& a0 , A1 const& a1 )

    : m_a0 ( a0 ) , m_a1 ( a1 )

  {}

  template<class T>
  void* apply(void* address
                                            ) const
  {
    return new(address) T( m_a0 , m_a1 );
  }

  template<class T>
  void* apply(void* address, std::size_t n
                                            ) const
  {
    for(char* next = address = this->template apply<T>(address);
        !! --n;)
      this->template apply<T>(next = next+sizeof(T));
    return address;
  }

  A0 const& m_a0; A1 const& m_a1;
};


template< class A0 , class A1 >
inline in_place_factory2< A0 , A1 >
in_place( A0 const& a0 , A1 const& a1 )
{
  return in_place_factory2< A0 , A1 >
      ( a0 , a1 );
}
# 58 "/usr/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3 4




# 1 "/usr/include/boost/utility/in_place_factory.hpp" 1 3 4
# 35 "/usr/include/boost/utility/in_place_factory.hpp" 3 4
template< class A0 , class A1 , class A2 >

class in_place_factory3
  :
  public in_place_factory_base
{
public:

  explicit in_place_factory3
      ( A0 const& a0 , A1 const& a1 , A2 const& a2 )

    : m_a0 ( a0 ) , m_a1 ( a1 ) , m_a2 ( a2 )

  {}

  template<class T>
  void* apply(void* address
                                            ) const
  {
    return new(address) T( m_a0 , m_a1 , m_a2 );
  }

  template<class T>
  void* apply(void* address, std::size_t n
                                            ) const
  {
    for(char* next = address = this->template apply<T>(address);
        !! --n;)
      this->template apply<T>(next = next+sizeof(T));
    return address;
  }

  A0 const& m_a0; A1 const& m_a1; A2 const& m_a2;
};


template< class A0 , class A1 , class A2 >
inline in_place_factory3< A0 , A1 , A2 >
in_place( A0 const& a0 , A1 const& a1 , A2 const& a2 )
{
  return in_place_factory3< A0 , A1 , A2 >
      ( a0 , a1 , a2 );
}
# 63 "/usr/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3 4




# 1 "/usr/include/boost/utility/in_place_factory.hpp" 1 3 4
# 35 "/usr/include/boost/utility/in_place_factory.hpp" 3 4
template< class A0 , class A1 , class A2 , class A3 >

class in_place_factory4
  :
  public in_place_factory_base
{
public:

  explicit in_place_factory4
      ( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 )

    : m_a0 ( a0 ) , m_a1 ( a1 ) , m_a2 ( a2 ) , m_a3 ( a3 )

  {}

  template<class T>
  void* apply(void* address
                                            ) const
  {
    return new(address) T( m_a0 , m_a1 , m_a2 , m_a3 );
  }

  template<class T>
  void* apply(void* address, std::size_t n
                                            ) const
  {
    for(char* next = address = this->template apply<T>(address);
        !! --n;)
      this->template apply<T>(next = next+sizeof(T));
    return address;
  }

  A0 const& m_a0; A1 const& m_a1; A2 const& m_a2; A3 const& m_a3;
};


template< class A0 , class A1 , class A2 , class A3 >
inline in_place_factory4< A0 , A1 , A2 , A3 >
in_place( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 )
{
  return in_place_factory4< A0 , A1 , A2 , A3 >
      ( a0 , a1 , a2 , a3 );
}
# 68 "/usr/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3 4




# 1 "/usr/include/boost/utility/in_place_factory.hpp" 1 3 4
# 35 "/usr/include/boost/utility/in_place_factory.hpp" 3 4
template< class A0 , class A1 , class A2 , class A3 , class A4 >

class in_place_factory5
  :
  public in_place_factory_base
{
public:

  explicit in_place_factory5
      ( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 )

    : m_a0 ( a0 ) , m_a1 ( a1 ) , m_a2 ( a2 ) , m_a3 ( a3 ) , m_a4 ( a4 )

  {}

  template<class T>
  void* apply(void* address
                                            ) const
  {
    return new(address) T( m_a0 , m_a1 , m_a2 , m_a3 , m_a4 );
  }

  template<class T>
  void* apply(void* address, std::size_t n
                                            ) const
  {
    for(char* next = address = this->template apply<T>(address);
        !! --n;)
      this->template apply<T>(next = next+sizeof(T));
    return address;
  }

  A0 const& m_a0; A1 const& m_a1; A2 const& m_a2; A3 const& m_a3; A4 const& m_a4;
};


template< class A0 , class A1 , class A2 , class A3 , class A4 >
inline in_place_factory5< A0 , A1 , A2 , A3 , A4 >
in_place( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 )
{
  return in_place_factory5< A0 , A1 , A2 , A3 , A4 >
      ( a0 , a1 , a2 , a3 , a4 );
}
# 73 "/usr/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3 4




# 1 "/usr/include/boost/utility/in_place_factory.hpp" 1 3 4
# 35 "/usr/include/boost/utility/in_place_factory.hpp" 3 4
template< class A0 , class A1 , class A2 , class A3 , class A4 , class A5 >

class in_place_factory6
  :
  public in_place_factory_base
{
public:

  explicit in_place_factory6
      ( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 )

    : m_a0 ( a0 ) , m_a1 ( a1 ) , m_a2 ( a2 ) , m_a3 ( a3 ) , m_a4 ( a4 ) , m_a5 ( a5 )

  {}

  template<class T>
  void* apply(void* address
                                            ) const
  {
    return new(address) T( m_a0 , m_a1 , m_a2 , m_a3 , m_a4 , m_a5 );
  }

  template<class T>
  void* apply(void* address, std::size_t n
                                            ) const
  {
    for(char* next = address = this->template apply<T>(address);
        !! --n;)
      this->template apply<T>(next = next+sizeof(T));
    return address;
  }

  A0 const& m_a0; A1 const& m_a1; A2 const& m_a2; A3 const& m_a3; A4 const& m_a4; A5 const& m_a5;
};


template< class A0 , class A1 , class A2 , class A3 , class A4 , class A5 >
inline in_place_factory6< A0 , A1 , A2 , A3 , A4 , A5 >
in_place( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 )
{
  return in_place_factory6< A0 , A1 , A2 , A3 , A4 , A5 >
      ( a0 , a1 , a2 , a3 , a4 , a5 );
}
# 78 "/usr/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3 4




# 1 "/usr/include/boost/utility/in_place_factory.hpp" 1 3 4
# 35 "/usr/include/boost/utility/in_place_factory.hpp" 3 4
template< class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 >

class in_place_factory7
  :
  public in_place_factory_base
{
public:

  explicit in_place_factory7
      ( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 )

    : m_a0 ( a0 ) , m_a1 ( a1 ) , m_a2 ( a2 ) , m_a3 ( a3 ) , m_a4 ( a4 ) , m_a5 ( a5 ) , m_a6 ( a6 )

  {}

  template<class T>
  void* apply(void* address
                                            ) const
  {
    return new(address) T( m_a0 , m_a1 , m_a2 , m_a3 , m_a4 , m_a5 , m_a6 );
  }

  template<class T>
  void* apply(void* address, std::size_t n
                                            ) const
  {
    for(char* next = address = this->template apply<T>(address);
        !! --n;)
      this->template apply<T>(next = next+sizeof(T));
    return address;
  }

  A0 const& m_a0; A1 const& m_a1; A2 const& m_a2; A3 const& m_a3; A4 const& m_a4; A5 const& m_a5; A6 const& m_a6;
};


template< class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 >
inline in_place_factory7< A0 , A1 , A2 , A3 , A4 , A5 , A6 >
in_place( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 )
{
  return in_place_factory7< A0 , A1 , A2 , A3 , A4 , A5 , A6 >
      ( a0 , a1 , a2 , a3 , a4 , a5 , a6 );
}
# 83 "/usr/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3 4




# 1 "/usr/include/boost/utility/in_place_factory.hpp" 1 3 4
# 35 "/usr/include/boost/utility/in_place_factory.hpp" 3 4
template< class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 >

class in_place_factory8
  :
  public in_place_factory_base
{
public:

  explicit in_place_factory8
      ( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 )

    : m_a0 ( a0 ) , m_a1 ( a1 ) , m_a2 ( a2 ) , m_a3 ( a3 ) , m_a4 ( a4 ) , m_a5 ( a5 ) , m_a6 ( a6 ) , m_a7 ( a7 )

  {}

  template<class T>
  void* apply(void* address
                                            ) const
  {
    return new(address) T( m_a0 , m_a1 , m_a2 , m_a3 , m_a4 , m_a5 , m_a6 , m_a7 );
  }

  template<class T>
  void* apply(void* address, std::size_t n
                                            ) const
  {
    for(char* next = address = this->template apply<T>(address);
        !! --n;)
      this->template apply<T>(next = next+sizeof(T));
    return address;
  }

  A0 const& m_a0; A1 const& m_a1; A2 const& m_a2; A3 const& m_a3; A4 const& m_a4; A5 const& m_a5; A6 const& m_a6; A7 const& m_a7;
};


template< class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 >
inline in_place_factory8< A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 >
in_place( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 )
{
  return in_place_factory8< A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 >
      ( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 );
}
# 88 "/usr/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3 4




# 1 "/usr/include/boost/utility/in_place_factory.hpp" 1 3 4
# 35 "/usr/include/boost/utility/in_place_factory.hpp" 3 4
template< class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 >

class in_place_factory9
  :
  public in_place_factory_base
{
public:

  explicit in_place_factory9
      ( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8 )

    : m_a0 ( a0 ) , m_a1 ( a1 ) , m_a2 ( a2 ) , m_a3 ( a3 ) , m_a4 ( a4 ) , m_a5 ( a5 ) , m_a6 ( a6 ) , m_a7 ( a7 ) , m_a8 ( a8 )

  {}

  template<class T>
  void* apply(void* address
                                            ) const
  {
    return new(address) T( m_a0 , m_a1 , m_a2 , m_a3 , m_a4 , m_a5 , m_a6 , m_a7 , m_a8 );
  }

  template<class T>
  void* apply(void* address, std::size_t n
                                            ) const
  {
    for(char* next = address = this->template apply<T>(address);
        !! --n;)
      this->template apply<T>(next = next+sizeof(T));
    return address;
  }

  A0 const& m_a0; A1 const& m_a1; A2 const& m_a2; A3 const& m_a3; A4 const& m_a4; A5 const& m_a5; A6 const& m_a6; A7 const& m_a7; A8 const& m_a8;
};


template< class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 >
inline in_place_factory9< A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 >
in_place( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8 )
{
  return in_place_factory9< A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 >
      ( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 );
}
# 93 "/usr/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3 4




# 1 "/usr/include/boost/utility/in_place_factory.hpp" 1 3 4
# 35 "/usr/include/boost/utility/in_place_factory.hpp" 3 4
template< class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 >

class in_place_factory10
  :
  public in_place_factory_base
{
public:

  explicit in_place_factory10
      ( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8 , A9 const& a9 )

    : m_a0 ( a0 ) , m_a1 ( a1 ) , m_a2 ( a2 ) , m_a3 ( a3 ) , m_a4 ( a4 ) , m_a5 ( a5 ) , m_a6 ( a6 ) , m_a7 ( a7 ) , m_a8 ( a8 ) , m_a9 ( a9 )

  {}

  template<class T>
  void* apply(void* address
                                            ) const
  {
    return new(address) T( m_a0 , m_a1 , m_a2 , m_a3 , m_a4 , m_a5 , m_a6 , m_a7 , m_a8 , m_a9 );
  }

  template<class T>
  void* apply(void* address, std::size_t n
                                            ) const
  {
    for(char* next = address = this->template apply<T>(address);
        !! --n;)
      this->template apply<T>(next = next+sizeof(T));
    return address;
  }

  A0 const& m_a0; A1 const& m_a1; A2 const& m_a2; A3 const& m_a3; A4 const& m_a4; A5 const& m_a5; A6 const& m_a6; A7 const& m_a7; A8 const& m_a8; A9 const& m_a9;
};


template< class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 >
inline in_place_factory10< A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 >
in_place( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8 , A9 const& a9 )
{
  return in_place_factory10< A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 >
      ( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 );
}
# 98 "/usr/include/boost/preprocessor/iteration/detail/iter/forward1.hpp" 2 3 4
# 25 "/usr/include/boost/utility/in_place_factory.hpp" 2 3 4

}


# 1 "/usr/include/boost/utility/detail/in_place_factory_suffix.hpp" 1 3 4
# 29 "/usr/include/boost/utility/in_place_factory.hpp" 2 3 4
# 38 "/usr/include/boost/optional/optional.hpp" 2 3 4

# 1 "/usr/include/boost/optional/optional_fwd.hpp" 1 3 4
# 18 "/usr/include/boost/optional/optional_fwd.hpp" 3 4
namespace boost {

template<class T> class optional ;

template<class T> void swap ( optional<T>& , optional<T>& ) ;

template<class T> struct optional_swap_should_use_default_constructor ;

}
# 40 "/usr/include/boost/optional/optional.hpp" 2 3 4
# 99 "/usr/include/boost/optional/optional.hpp" 3 4
namespace boost_optional_detail
{
  template <class T, class Factory>
  inline void construct(Factory const& factory, void* address)
  {
    factory.template apply<T>(address);
  }
}


namespace boost {

class in_place_factory_base ;
class typed_in_place_factory_base ;


template<class T> void swap ( optional<T>& x, optional<T>& y );

namespace optional_detail {





template <class T>
class aligned_storage
{

    union


    __attribute__((may_alias))

    dummy_u
    {
        char data[ sizeof(T) ];
        typename type_with_alignment<
          ::boost::alignment_of<T>::value >::type aligner_;
    } dummy_ ;

  public:


    void const* address() const { return &dummy_; }
    void * address() { return &dummy_; }




} ;

template<class T>
struct types_when_isnt_ref
{
  typedef T const& reference_const_type ;
  typedef T & reference_type ;
  typedef T const* pointer_const_type ;
  typedef T * pointer_type ;
  typedef T const& argument_type ;
} ;
template<class T>
struct types_when_is_ref
{
  typedef typename remove_reference<T>::type raw_type ;

  typedef raw_type& reference_const_type ;
  typedef raw_type& reference_type ;
  typedef raw_type* pointer_const_type ;
  typedef raw_type* pointer_type ;
  typedef raw_type& argument_type ;
} ;

struct optional_tag {} ;

template<class T>
class optional_base : public optional_tag
{
  private :

    typedef

    typename

    ::boost::detail::make_reference_content<T>::type internal_type ;

    typedef aligned_storage<internal_type> storage_type ;

    typedef types_when_isnt_ref<T> types_when_not_ref ;
    typedef types_when_is_ref<T> types_when_ref ;

    typedef optional_base<T> this_type ;

  protected :

    typedef T value_type ;

    typedef mpl::true_ is_reference_tag ;
    typedef mpl::false_ is_not_reference_tag ;

    typedef typename is_reference<T>::type is_reference_predicate ;

  public:
    typedef typename mpl::if_<is_reference_predicate,types_when_ref,types_when_not_ref>::type types ;

  protected:
    typedef bool (this_type::*unspecified_bool_type)() const;

    typedef typename types::reference_type reference_type ;
    typedef typename types::reference_const_type reference_const_type ;
    typedef typename types::pointer_type pointer_type ;
    typedef typename types::pointer_const_type pointer_const_type ;
    typedef typename types::argument_type argument_type ;



    optional_base()
      :
      m_initialized(false) {}



    optional_base ( none_t )
      :
      m_initialized(false) {}



    optional_base ( argument_type val )
      :
      m_initialized(false)
    {
      construct(val);
    }



    optional_base ( bool cond, argument_type val )
      :
      m_initialized(false)
    {
      if ( cond )
        construct(val);
    }



    optional_base ( optional_base const& rhs )
      :
      m_initialized(false)
    {
      if ( rhs.is_initialized() )
        construct(rhs.get_impl());
    }





    template<class Expr>
    explicit optional_base ( Expr const& expr, Expr const* tag )
      :
      m_initialized(false)
    {
      construct(expr,tag);
    }




    ~optional_base() { destroy() ; }


    void assign ( optional_base const& rhs )
    {
      if (is_initialized())
      {
        if ( rhs.is_initialized() )
             assign_value(rhs.get_impl(), is_reference_predicate() );
        else destroy();
      }
      else
      {
        if ( rhs.is_initialized() )
          construct(rhs.get_impl());
      }
    }


    template<class U>
    void assign ( optional<U> const& rhs )
    {
      if (is_initialized())
      {
        if ( rhs.is_initialized() )
             assign_value(static_cast<value_type>(rhs.get()), is_reference_predicate() );
        else destroy();
      }
      else
      {
        if ( rhs.is_initialized() )
          construct(static_cast<value_type>(rhs.get()));
      }
    }


    void assign ( argument_type val )
    {
      if (is_initialized())
           assign_value(val, is_reference_predicate() );
      else construct(val);
    }



    void assign ( none_t ) { destroy(); }


    template<class Expr>
    void assign_expr ( Expr const& expr, Expr const* tag )
      {
        if (is_initialized())
             assign_expr_to_initialized(expr,tag);
        else construct(expr,tag);
      }


  public :



    void reset() { destroy(); }


    void reset ( argument_type val ) { assign(val); }




    pointer_const_type get_ptr() const { return m_initialized ? get_ptr_impl() : 0 ; }
    pointer_type get_ptr() { return m_initialized ? get_ptr_impl() : 0 ; }

    bool is_initialized() const { return m_initialized ; }

  protected :

    void construct ( argument_type val )
     {
       new (m_storage.address()) internal_type(val) ;
       m_initialized = true ;
     }



    template<class Expr>
    void construct ( Expr const& factory, in_place_factory_base const* )
     {
       static_assert(::boost::mpl::not_<is_reference_predicate>::value, "::boost::mpl::not_<is_reference_predicate>::value") ;
       boost_optional_detail::construct<value_type>(factory, m_storage.address());
       m_initialized = true ;
     }


    template<class Expr>
    void construct ( Expr const& factory, typed_in_place_factory_base const* )
     {
       static_assert(::boost::mpl::not_<is_reference_predicate>::value, "::boost::mpl::not_<is_reference_predicate>::value") ;
       factory.apply(m_storage.address()) ;
       m_initialized = true ;
     }

    template<class Expr>
    void assign_expr_to_initialized ( Expr const& factory, in_place_factory_base const* tag )
     {
       destroy();
       construct(factory,tag);
     }


    template<class Expr>
    void assign_expr_to_initialized ( Expr const& factory, typed_in_place_factory_base const* tag )
     {
       destroy();
       construct(factory,tag);
     }






    template<class Expr>
    void construct ( Expr const& expr, void const* )
     {
       new (m_storage.address()) internal_type(expr) ;
       m_initialized = true ;
     }





    template<class Expr>
    void assign_expr_to_initialized ( Expr const& expr, void const* )
     {
       assign_value(expr, is_reference_predicate());
     }
# 433 "/usr/include/boost/optional/optional.hpp" 3 4
    void assign_value ( argument_type val, is_not_reference_tag ) { get_impl() = val; }
    void assign_value ( argument_type val, is_reference_tag ) { construct(val); }

    void destroy()
    {
      if ( m_initialized )
        destroy_impl(is_reference_predicate()) ;
    }

    unspecified_bool_type safe_bool() const { return m_initialized ? &this_type::is_initialized : 0 ; }

    reference_const_type get_impl() const { return dereference(get_object(), is_reference_predicate() ) ; }
    reference_type get_impl() { return dereference(get_object(), is_reference_predicate() ) ; }

    pointer_const_type get_ptr_impl() const { return cast_ptr(get_object(), is_reference_predicate() ) ; }
    pointer_type get_ptr_impl() { return cast_ptr(get_object(), is_reference_predicate() ) ; }

  private :




    internal_type const* get_object() const
    {
        union { void const* ap_pvoid; internal_type const* as_ptype; } caster = { m_storage.address() };
        return caster.as_ptype;
    }
    internal_type * get_object()
    {
        union { void* ap_pvoid; internal_type* as_ptype; } caster = { m_storage.address() };
        return caster.as_ptype;
    }






    reference_const_type dereference( internal_type const* p, is_not_reference_tag ) const { return *p ; }
    reference_type dereference( internal_type* p, is_not_reference_tag ) { return *p ; }
    reference_const_type dereference( internal_type const* p, is_reference_tag ) const { return p->get() ; }
    reference_type dereference( internal_type* p, is_reference_tag ) { return p->get() ; }




    void destroy_impl ( is_not_reference_tag ) { get_ptr_impl()->T::~T() ; m_initialized = false ; }


    void destroy_impl ( is_reference_tag ) { m_initialized = false ; }




    pointer_const_type cast_ptr( internal_type const* p, is_not_reference_tag ) const { return p ; }
    pointer_type cast_ptr( internal_type * p, is_not_reference_tag ) { return p ; }
    pointer_const_type cast_ptr( internal_type const* p, is_reference_tag ) const { return &p->get() ; }
    pointer_type cast_ptr( internal_type * p, is_reference_tag ) { return &p->get() ; }

    bool m_initialized ;
    storage_type m_storage ;
} ;

}

template<class T>
class optional : public optional_detail::optional_base<T>
{
    typedef optional_detail::optional_base<T> base ;

    typedef typename base::unspecified_bool_type unspecified_bool_type ;

  public :

    typedef optional<T> this_type ;

    typedef typename base::value_type value_type ;
    typedef typename base::reference_type reference_type ;
    typedef typename base::reference_const_type reference_const_type ;
    typedef typename base::pointer_type pointer_type ;
    typedef typename base::pointer_const_type pointer_const_type ;
    typedef typename base::argument_type argument_type ;



    optional() : base() {}



    optional( none_t none_ ) : base(none_) {}



    optional ( argument_type val ) : base(val) {}



    optional ( bool cond, argument_type val ) : base(cond,val) {}







    template<class U>
    explicit optional ( optional<U> const& rhs )
      :
      base()
    {
      if ( rhs.is_initialized() )
        this->construct(rhs.get());
    }
# 558 "/usr/include/boost/optional/optional.hpp" 3 4
    template<class Expr>
    explicit optional ( Expr const& expr ) : base(expr,boost::addressof(expr)) {}




    optional ( optional const& rhs ) : base( static_cast<base const&>(rhs) ) {}


    ~optional() {}




    template<class Expr>
    optional& operator= ( Expr const& expr )
      {
        this->assign_expr(expr,boost::addressof(expr));
        return *this ;
      }







    template<class U>
    optional& operator= ( optional<U> const& rhs )
      {
        this->assign(rhs);
        return *this ;
      }





    optional& operator= ( optional const& rhs )
      {
        this->assign( static_cast<base const&>(rhs) ) ;
        return *this ;
      }



    optional& operator= ( argument_type val )
      {
        this->assign( val ) ;
        return *this ;
      }




    optional& operator= ( none_t none_ )
      {
        this->assign( none_ ) ;
        return *this ;
      }

    void swap( optional & arg )
      {

        using boost::swap;
        swap(*this, arg);
      }





    reference_const_type get() const { ((this->is_initialized()) ? static_cast<void> (0) : __assert_fail ("this->is_initialized()", "/usr/include/boost/optional/optional.hpp", 630, __PRETTY_FUNCTION__)) ; return this->get_impl(); }
    reference_type get() { ((this->is_initialized()) ? static_cast<void> (0) : __assert_fail ("this->is_initialized()", "/usr/include/boost/optional/optional.hpp", 631, __PRETTY_FUNCTION__)) ; return this->get_impl(); }


    reference_const_type get_value_or ( reference_const_type v ) const { return this->is_initialized() ? get() : v ; }
    reference_type get_value_or ( reference_type v ) { return this->is_initialized() ? get() : v ; }




    pointer_const_type operator->() const { ((this->is_initialized()) ? static_cast<void> (0) : __assert_fail ("this->is_initialized()", "/usr/include/boost/optional/optional.hpp", 640, __PRETTY_FUNCTION__)) ; return this->get_ptr_impl() ; }
    pointer_type operator->() { ((this->is_initialized()) ? static_cast<void> (0) : __assert_fail ("this->is_initialized()", "/usr/include/boost/optional/optional.hpp", 641, __PRETTY_FUNCTION__)) ; return this->get_ptr_impl() ; }




    reference_const_type operator *() const { return this->get() ; }
    reference_type operator *() { return this->get() ; }



    operator unspecified_bool_type() const { return this->safe_bool() ; }



    bool operator!() const { return !this->is_initialized() ; }
} ;


template<class T>
inline
optional<T> make_optional ( T const& v )
{
  return optional<T>(v);
}


template<class T>
inline
optional<T> make_optional ( bool cond, T const& v )
{
  return optional<T>(cond,v);
}



template<class T>
inline
typename optional<T>::reference_const_type
get ( optional<T> const& opt )
{
  return opt.get() ;
}

template<class T>
inline
typename optional<T>::reference_type
get ( optional<T>& opt )
{
  return opt.get() ;
}



template<class T>
inline
typename optional<T>::pointer_const_type
get ( optional<T> const* opt )
{
  return opt->get_ptr() ;
}

template<class T>
inline
typename optional<T>::pointer_type
get ( optional<T>* opt )
{
  return opt->get_ptr() ;
}



template<class T>
inline
typename optional<T>::reference_const_type
get_optional_value_or ( optional<T> const& opt, typename optional<T>::reference_const_type v )
{
  return opt.get_value_or(v) ;
}

template<class T>
inline
typename optional<T>::reference_type
get_optional_value_or ( optional<T>& opt, typename optional<T>::reference_type v )
{
  return opt.get_value_or(v) ;
}



template<class T>
inline
typename optional<T>::pointer_const_type
get_pointer ( optional<T> const& opt )
{
  return opt.get_ptr() ;
}

template<class T>
inline
typename optional<T>::pointer_type
get_pointer ( optional<T>& opt )
{
  return opt.get_ptr() ;
}
# 754 "/usr/include/boost/optional/optional.hpp" 3 4
template<class T>
inline
bool operator == ( optional<T> const& x, optional<T> const& y )
{ return equal_pointees(x,y); }

template<class T>
inline
bool operator < ( optional<T> const& x, optional<T> const& y )
{ return less_pointees(x,y); }

template<class T>
inline
bool operator != ( optional<T> const& x, optional<T> const& y )
{ return !( x == y ) ; }

template<class T>
inline
bool operator > ( optional<T> const& x, optional<T> const& y )
{ return y < x ; }

template<class T>
inline
bool operator <= ( optional<T> const& x, optional<T> const& y )
{ return !( y < x ) ; }

template<class T>
inline
bool operator >= ( optional<T> const& x, optional<T> const& y )
{ return !( x < y ) ; }





template<class T>
inline
bool operator == ( optional<T> const& x, T const& y )
{ return equal_pointees(x, optional<T>(y)); }

template<class T>
inline
bool operator < ( optional<T> const& x, T const& y )
{ return less_pointees(x, optional<T>(y)); }

template<class T>
inline
bool operator != ( optional<T> const& x, T const& y )
{ return !( x == y ) ; }

template<class T>
inline
bool operator > ( optional<T> const& x, T const& y )
{ return y < x ; }

template<class T>
inline
bool operator <= ( optional<T> const& x, T const& y )
{ return !( y < x ) ; }

template<class T>
inline
bool operator >= ( optional<T> const& x, T const& y )
{ return !( x < y ) ; }





template<class T>
inline
bool operator == ( T const& x, optional<T> const& y )
{ return equal_pointees( optional<T>(x), y ); }

template<class T>
inline
bool operator < ( T const& x, optional<T> const& y )
{ return less_pointees( optional<T>(x), y ); }

template<class T>
inline
bool operator != ( T const& x, optional<T> const& y )
{ return !( x == y ) ; }

template<class T>
inline
bool operator > ( T const& x, optional<T> const& y )
{ return y < x ; }

template<class T>
inline
bool operator <= ( T const& x, optional<T> const& y )
{ return !( y < x ) ; }

template<class T>
inline
bool operator >= ( T const& x, optional<T> const& y )
{ return !( x < y ) ; }






template<class T>
inline
bool operator == ( optional<T> const& x, none_t )
{ return equal_pointees(x, optional<T>() ); }

template<class T>
inline
bool operator < ( optional<T> const& x, none_t )
{ return less_pointees(x,optional<T>() ); }

template<class T>
inline
bool operator != ( optional<T> const& x, none_t y )
{ return !( x == y ) ; }

template<class T>
inline
bool operator > ( optional<T> const& x, none_t y )
{ return y < x ; }

template<class T>
inline
bool operator <= ( optional<T> const& x, none_t y )
{ return !( y < x ) ; }

template<class T>
inline
bool operator >= ( optional<T> const& x, none_t y )
{ return !( x < y ) ; }





template<class T>
inline
bool operator == ( none_t , optional<T> const& y )
{ return equal_pointees(optional<T>() ,y); }

template<class T>
inline
bool operator < ( none_t , optional<T> const& y )
{ return less_pointees(optional<T>() ,y); }

template<class T>
inline
bool operator != ( none_t x, optional<T> const& y )
{ return !( x == y ) ; }

template<class T>
inline
bool operator > ( none_t x, optional<T> const& y )
{ return y < x ; }

template<class T>
inline
bool operator <= ( none_t x, optional<T> const& y )
{ return !( y < x ) ; }

template<class T>
inline
bool operator >= ( none_t x, optional<T> const& y )
{ return !( x < y ) ; }

namespace optional_detail {

template<bool use_default_constructor> struct swap_selector;

template<>
struct swap_selector<true>
{
    template<class T>
    static void optional_swap ( optional<T>& x, optional<T>& y )
    {
        const bool hasX = !!x;
        const bool hasY = !!y;

        if ( !hasX && !hasY )
            return;

        if( !hasX )
            x = boost::in_place();
        else if ( !hasY )
            y = boost::in_place();


        boost::swap(x.get(),y.get());

        if( !hasX )
            y = boost::none ;
        else if( !hasY )
            x = boost::none ;
    }
};

template<>
struct swap_selector<false>
{
    template<class T>
    static void optional_swap ( optional<T>& x, optional<T>& y )
    {
        const bool hasX = !!x;
        const bool hasY = !!y;

        if ( !hasX && hasY )
        {
            x = y.get();
            y = boost::none ;
        }
        else if ( hasX && !hasY )
        {
            y = x.get();
            x = boost::none ;
        }
        else if ( hasX && hasY )
        {

            boost::swap(x.get(),y.get());
        }
    }
};

}

template<class T>
struct optional_swap_should_use_default_constructor : has_nothrow_default_constructor<T> {} ;

template<class T> inline void swap ( optional<T>& x, optional<T>& y )
{
    optional_detail::swap_selector<optional_swap_should_use_default_constructor<T>::value>::optional_swap(x, y);
}

}
# 16 "/usr/include/boost/optional.hpp" 2 3 4
# 21 "/usr/include/boost/format/internals.hpp" 2 3 4
# 1 "/usr/include/boost/limits.hpp" 1 3 4
# 22 "/usr/include/boost/format/internals.hpp" 2 3 4

# 1 "/usr/include/boost/format/alt_sstream.hpp" 1 3 4
# 20 "/usr/include/boost/format/alt_sstream.hpp" 3 4
# 1 "/usr/include/boost/utility/base_from_member.hpp" 1 3 4
# 13 "/usr/include/boost/utility/base_from_member.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/arithmetic/inc.hpp" 1 3 4
# 14 "/usr/include/boost/utility/base_from_member.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/repetition/enum_binary_params.hpp" 1 3 4
# 15 "/usr/include/boost/utility/base_from_member.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/repetition/enum_params.hpp" 1 3 4
# 16 "/usr/include/boost/utility/base_from_member.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/repetition/repeat_from_to.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/repetition/repeat_from_to.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/arithmetic/add.hpp" 1 3 4
# 18 "/usr/include/boost/preprocessor/repetition/repeat_from_to.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/arithmetic/sub.hpp" 1 3 4
# 19 "/usr/include/boost/preprocessor/repetition/repeat_from_to.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/cat.hpp" 1 3 4
# 20 "/usr/include/boost/preprocessor/repetition/repeat_from_to.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 21 "/usr/include/boost/preprocessor/repetition/repeat_from_to.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/control/while.hpp" 1 3 4
# 22 "/usr/include/boost/preprocessor/repetition/repeat_from_to.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/debug/error.hpp" 1 3 4
# 23 "/usr/include/boost/preprocessor/repetition/repeat_from_to.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/detail/auto_rec.hpp" 1 3 4
# 12 "/usr/include/boost/preprocessor/detail/auto_rec.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 13 "/usr/include/boost/preprocessor/detail/auto_rec.hpp" 2 3 4
# 24 "/usr/include/boost/preprocessor/repetition/repeat_from_to.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/repetition/repeat.hpp" 1 3 4
# 25 "/usr/include/boost/preprocessor/repetition/repeat_from_to.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/tuple/elem.hpp" 1 3 4
# 26 "/usr/include/boost/preprocessor/repetition/repeat_from_to.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/tuple/rem.hpp" 1 3 4
# 27 "/usr/include/boost/preprocessor/repetition/repeat_from_to.hpp" 2 3 4
# 17 "/usr/include/boost/utility/base_from_member.hpp" 2 3 4
# 53 "/usr/include/boost/utility/base_from_member.hpp" 3 4
namespace boost
{
# 65 "/usr/include/boost/utility/base_from_member.hpp" 3 4
template < typename MemberType, int UniqueID = 0 >
class base_from_member
{
protected:
    MemberType member;

    base_from_member()
        : member()
        {}

    template < typename T0 > explicit base_from_member( T0 x0 ) : member( x0 ) {} template < typename T0 , typename T1 > explicit base_from_member( T0 x0 , T1 x1 ) : member( x0 , x1 ) {} template < typename T0 , typename T1 , typename T2 > explicit base_from_member( T0 x0 , T1 x1 , T2 x2 ) : member( x0 , x1 , x2 ) {} template < typename T0 , typename T1 , typename T2 , typename T3 > explicit base_from_member( T0 x0 , T1 x1 , T2 x2 , T3 x3 ) : member( x0 , x1 , x2 , x3 ) {} template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 > explicit base_from_member( T0 x0 , T1 x1 , T2 x2 , T3 x3 , T4 x4 ) : member( x0 , x1 , x2 , x3 , x4 ) {} template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > explicit base_from_member( T0 x0 , T1 x1 , T2 x2 , T3 x3 , T4 x4 , T5 x5 ) : member( x0 , x1 , x2 , x3 , x4 , x5 ) {} template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > explicit base_from_member( T0 x0 , T1 x1 , T2 x2 , T3 x3 , T4 x4 , T5 x5 , T6 x6 ) : member( x0 , x1 , x2 , x3 , x4 , x5 , x6 ) {} template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > explicit base_from_member( T0 x0 , T1 x1 , T2 x2 , T3 x3 , T4 x4 , T5 x5 , T6 x6 , T7 x7 ) : member( x0 , x1 , x2 , x3 , x4 , x5 , x6 , x7 ) {} template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > explicit base_from_member( T0 x0 , T1 x1 , T2 x2 , T3 x3 , T4 x4 , T5 x5 , T6 x6 , T7 x7 , T8 x8 ) : member( x0 , x1 , x2 , x3 , x4 , x5 , x6 , x7 , x8 ) {} template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > explicit base_from_member( T0 x0 , T1 x1 , T2 x2 , T3 x3 , T4 x4 , T5 x5 , T6 x6 , T7 x7 , T8 x8 , T9 x9 ) : member( x0 , x1 , x2 , x3 , x4 , x5 , x6 , x7 , x8 , x9 ) {}


};

}
# 21 "/usr/include/boost/format/alt_sstream.hpp" 2 3 4
# 1 "/usr/include/boost/shared_ptr.hpp" 1 3 4
# 17 "/usr/include/boost/shared_ptr.hpp" 3 4
# 1 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 1 3 4
# 27 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 3 4
# 1 "/usr/include/boost/config/no_tr1/memory.hpp" 1 3 4
# 21 "/usr/include/boost/config/no_tr1/memory.hpp" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/memory" 1 3 4
# 47 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/memory" 3
# 67 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/memory" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_raw_storage_iter.h" 1 3
# 59 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_raw_storage_iter.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{






  template <class _OutputIterator, class _Tp>
    class raw_storage_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _OutputIterator _M_iter;

    public:
      explicit
      raw_storage_iterator(_OutputIterator __x)
      : _M_iter(__x) {}

      raw_storage_iterator&
      operator*() { return *this; }

      raw_storage_iterator&
      operator=(const _Tp& __element)
      {
 std::_Construct(std::__addressof(*_M_iter), __element);
 return *this;
      }

      raw_storage_iterator<_OutputIterator, _Tp>&
      operator++()
      {
 ++_M_iter;
 return *this;
      }

      raw_storage_iterator<_OutputIterator, _Tp>
      operator++(int)
      {
 raw_storage_iterator<_OutputIterator, _Tp> __tmp = *this;
 ++_M_iter;
 return __tmp;
      }
    };


}
# 68 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/memory" 2 3






# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ext/concurrence.h" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ext/concurrence.h" 3







namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{







  enum _Lock_policy { _S_single, _S_mutex, _S_atomic };



  static const _Lock_policy __default_lock_policy =



  _S_atomic;
# 67 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ext/concurrence.h" 3
  class __concurrence_lock_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_lock_error"; }
  };

  class __concurrence_unlock_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_unlock_error"; }
  };

  class __concurrence_broadcast_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_broadcast_error"; }
  };

  class __concurrence_wait_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_wait_error"; }
  };


  inline void
  __throw_concurrence_lock_error()
  { (throw (__concurrence_lock_error())); }

  inline void
  __throw_concurrence_unlock_error()
  { (throw (__concurrence_unlock_error())); }


  inline void
  __throw_concurrence_broadcast_error()
  { (throw (__concurrence_broadcast_error())); }

  inline void
  __throw_concurrence_wait_error()
  { (throw (__concurrence_wait_error())); }


  class __mutex
  {
  private:

    __gthread_mutex_t _M_mutex = { { 0, 0, 0, 0, 0, 0, 0, { 0, 0 } } };




    __mutex(const __mutex&);
    __mutex& operator=(const __mutex&);

  public:
    __mutex()
    {




    }
# 147 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ext/concurrence.h" 3
    void lock()
    {

      if (__gthread_active_p())
 {
   if (__gthread_mutex_lock(&_M_mutex) != 0)
     __throw_concurrence_lock_error();
 }

    }

    void unlock()
    {

      if (__gthread_active_p())
 {
   if (__gthread_mutex_unlock(&_M_mutex) != 0)
     __throw_concurrence_unlock_error();
 }

    }

    __gthread_mutex_t* gthread_mutex(void)
      { return &_M_mutex; }
  };

  class __recursive_mutex
  {
  private:

    __gthread_recursive_mutex_t _M_mutex = { { 0, 0, 0, 0, PTHREAD_MUTEX_RECURSIVE_NP, 0, 0, { 0, 0 } } };




    __recursive_mutex(const __recursive_mutex&);
    __recursive_mutex& operator=(const __recursive_mutex&);

  public:
    __recursive_mutex()
    {




    }
# 202 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ext/concurrence.h" 3
    void lock()
    {

      if (__gthread_active_p())
 {
   if (__gthread_recursive_mutex_lock(&_M_mutex) != 0)
     __throw_concurrence_lock_error();
 }

    }

    void unlock()
    {

      if (__gthread_active_p())
 {
   if (__gthread_recursive_mutex_unlock(&_M_mutex) != 0)
     __throw_concurrence_unlock_error();
 }

    }

    __gthread_recursive_mutex_t* gthread_recursive_mutex(void)
    { return &_M_mutex; }
  };




  class __scoped_lock
  {
  public:
    typedef __mutex __mutex_type;

  private:
    __mutex_type& _M_device;

    __scoped_lock(const __scoped_lock&);
    __scoped_lock& operator=(const __scoped_lock&);

  public:
    explicit __scoped_lock(__mutex_type& __name) : _M_device(__name)
    { _M_device.lock(); }

    ~__scoped_lock() throw()
    { _M_device.unlock(); }
  };


  class __cond
  {
  private:

    __gthread_cond_t _M_cond = { { 0, 0, 0, 0, 0, (void *) 0, 0, 0 } };




    __cond(const __cond&);
    __cond& operator=(const __cond&);

  public:
    __cond()
    {




    }
# 280 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ext/concurrence.h" 3
    void broadcast()
    {

      if (__gthread_active_p())
 {
   if (__gthread_cond_broadcast(&_M_cond) != 0)
     __throw_concurrence_broadcast_error();
 }

    }

    void wait(__mutex *mutex)
    {

      {
   if (__gthread_cond_wait(&_M_cond, mutex->gthread_mutex()) != 0)
     __throw_concurrence_wait_error();
      }

    }

    void wait_recursive(__recursive_mutex *mutex)
    {

      {
   if (__gthread_cond_wait_recursive(&_M_cond,
         mutex->gthread_recursive_mutex())
       != 0)
     __throw_concurrence_wait_error();
      }

    }
  };



}
# 75 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/memory" 2 3






# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h" 1 3
# 39 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 49 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unique_ptr.h" 3
  template<typename> class auto_ptr;



  template<typename _Tp>
    struct default_delete
    {
      constexpr default_delete() noexcept = default;

      template<typename _Up, typename = typename
        enable_if<is_convertible<_Up*, _Tp*>::value>::type>
        default_delete(const default_delete<_Up>&) noexcept { }

      void
      operator()(_Tp* __ptr) const
      {
 static_assert(sizeof(_Tp)>0,
        "can't delete pointer to incomplete type");
 delete __ptr;
      }
    };




  template<typename _Tp>
    struct default_delete<_Tp[]>
    {
    private:
      template<typename _Up>
 using __remove_cv = typename remove_cv<_Up>::type;


      template<typename _Up>
 using __is_derived_Tp
   = __and_< is_base_of<_Tp, _Up>,
      __not_<is_same<__remove_cv<_Tp>, __remove_cv<_Up>>> >;

    public:
      constexpr default_delete() noexcept = default;

      template<typename _Up, typename = typename
        enable_if<!__is_derived_Tp<_Up>::value>::type>
        default_delete(const default_delete<_Up[]>&) noexcept { }

      void
      operator()(_Tp* __ptr) const
      {
 static_assert(sizeof(_Tp)>0,
        "can't delete pointer to incomplete type");
 delete [] __ptr;
      }

      template<typename _Up>
 typename enable_if<__is_derived_Tp<_Up>::value>::type
 operator()(_Up*) const = delete;
    };


  template <typename _Tp, typename _Dp = default_delete<_Tp> >
    class unique_ptr
    {

      class _Pointer
      {
 template<typename _Up>
   static typename _Up::pointer __test(typename _Up::pointer*);

 template<typename _Up>
   static _Tp* __test(...);

 typedef typename remove_reference<_Dp>::type _Del;

      public:
 typedef decltype(__test<_Del>(0)) type;
      };

      typedef std::tuple<typename _Pointer::type, _Dp> __tuple_type;
      __tuple_type _M_t;

    public:
      typedef typename _Pointer::type pointer;
      typedef _Tp element_type;
      typedef _Dp deleter_type;


      constexpr unique_ptr() noexcept
      : _M_t()
      { static_assert(!is_pointer<deleter_type>::value,
       "constructed with null function pointer deleter"); }

      explicit
      unique_ptr(pointer __p) noexcept
      : _M_t(__p, deleter_type())
      { static_assert(!is_pointer<deleter_type>::value,
       "constructed with null function pointer deleter"); }

      unique_ptr(pointer __p,
   typename conditional<is_reference<deleter_type>::value,
     deleter_type, const deleter_type&>::type __d) noexcept
      : _M_t(__p, __d) { }

      unique_ptr(pointer __p,
   typename remove_reference<deleter_type>::type&& __d) noexcept
      : _M_t(std::move(__p), std::move(__d))
      { static_assert(!std::is_reference<deleter_type>::value,
        "rvalue deleter bound to reference"); }

      constexpr unique_ptr(nullptr_t) noexcept : unique_ptr() { }


      unique_ptr(unique_ptr&& __u) noexcept
      : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }

      template<typename _Up, typename _Ep, typename = _Require<
        is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>,
        __not_<is_array<_Up>>,
        typename conditional<is_reference<_Dp>::value,
        is_same<_Ep, _Dp>,
        is_convertible<_Ep, _Dp>>::type>>
 unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
 : _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))
 { }


      template<typename _Up, typename = _Require<
        is_convertible<_Up*, _Tp*>, is_same<_Dp, default_delete<_Tp>>>>
 unique_ptr(auto_ptr<_Up>&& __u) noexcept;



      ~unique_ptr() noexcept
      {
 auto& __ptr = std::get<0>(_M_t);
 if (__ptr != nullptr)
   get_deleter()(__ptr);
 __ptr = pointer();
      }


      unique_ptr&
      operator=(unique_ptr&& __u) noexcept
      {
 reset(__u.release());
 get_deleter() = std::forward<deleter_type>(__u.get_deleter());
 return *this;
      }

      template<typename _Up, typename _Ep>
 typename enable_if< __and_<
   is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>,
   __not_<is_array<_Up>>
   >::value,
   unique_ptr&>::type
 operator=(unique_ptr<_Up, _Ep>&& __u) noexcept
 {
   reset(__u.release());
   get_deleter() = std::forward<_Ep>(__u.get_deleter());
   return *this;
 }

      unique_ptr&
      operator=(nullptr_t) noexcept
      {
 reset();
 return *this;
      }


      typename add_lvalue_reference<element_type>::type
      operator*() const
      {
                                          ;
 return *get();
      }

      pointer
      operator->() const noexcept
      {
                                          ;
 return get();
      }

      pointer
      get() const noexcept
      { return std::get<0>(_M_t); }

      deleter_type&
      get_deleter() noexcept
      { return std::get<1>(_M_t); }

      const deleter_type&
      get_deleter() const noexcept
      { return std::get<1>(_M_t); }

      explicit operator bool() const noexcept
      { return get() == pointer() ? false : true; }


      pointer
      release() noexcept
      {
 pointer __p = get();
 std::get<0>(_M_t) = pointer();
 return __p;
      }

      void
      reset(pointer __p = pointer()) noexcept
      {
 using std::swap;
 swap(std::get<0>(_M_t), __p);
 if (__p != pointer())
   get_deleter()(__p);
      }

      void
      swap(unique_ptr& __u) noexcept
      {
 using std::swap;
 swap(_M_t, __u._M_t);
      }


      unique_ptr(const unique_ptr&) = delete;
      unique_ptr& operator=(const unique_ptr&) = delete;
  };





  template<typename _Tp, typename _Dp>
    class unique_ptr<_Tp[], _Dp>
    {

      class _Pointer
      {
 template<typename _Up>
   static typename _Up::pointer __test(typename _Up::pointer*);

 template<typename _Up>
   static _Tp* __test(...);

 typedef typename remove_reference<_Dp>::type _Del;

      public:
 typedef decltype(__test<_Del>(0)) type;
      };

      typedef std::tuple<typename _Pointer::type, _Dp> __tuple_type;
      __tuple_type _M_t;

      template<typename _Up>
 using __remove_cv = typename remove_cv<_Up>::type;


      template<typename _Up>
 using __is_derived_Tp
   = __and_< is_base_of<_Tp, _Up>,
      __not_<is_same<__remove_cv<_Tp>, __remove_cv<_Up>>> >;

      template<typename _Up, typename _Ep,
        typename _Tp_pointer = typename _Pointer::type,
        typename _Up_pointer = typename unique_ptr<_Up, _Ep>::pointer>
 using __safe_conversion = __and_<
     is_convertible<_Up_pointer, _Tp_pointer>,
     is_array<_Up>,
     __or_<__not_<is_pointer<_Up_pointer>>,
    __not_<is_pointer<_Tp_pointer>>,
    __not_<__is_derived_Tp<typename remove_extent<_Up>::type>>
     >
   >;

    public:
      typedef typename _Pointer::type pointer;
      typedef _Tp element_type;
      typedef _Dp deleter_type;


      constexpr unique_ptr() noexcept
      : _M_t()
      { static_assert(!std::is_pointer<deleter_type>::value,
        "constructed with null function pointer deleter"); }

      explicit
      unique_ptr(pointer __p) noexcept
      : _M_t(__p, deleter_type())
      { static_assert(!is_pointer<deleter_type>::value,
        "constructed with null function pointer deleter"); }

      template<typename _Up, typename = _Require<is_pointer<pointer>,
        is_convertible<_Up*, pointer>, __is_derived_Tp<_Up>>>
 explicit
 unique_ptr(_Up* __p) = delete;

      unique_ptr(pointer __p,
   typename conditional<is_reference<deleter_type>::value,
       deleter_type, const deleter_type&>::type __d) noexcept
      : _M_t(__p, __d) { }

      unique_ptr(pointer __p, typename
   remove_reference<deleter_type>::type&& __d) noexcept
      : _M_t(std::move(__p), std::move(__d))
      { static_assert(!is_reference<deleter_type>::value,
        "rvalue deleter bound to reference"); }


      unique_ptr(unique_ptr&& __u) noexcept
      : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }

      constexpr unique_ptr(nullptr_t) noexcept : unique_ptr() { }

      template<typename _Up, typename _Ep,
        typename = _Require<__safe_conversion<_Up, _Ep>,
   typename conditional<is_reference<_Dp>::value,
          is_same<_Ep, _Dp>,
          is_convertible<_Ep, _Dp>>::type
        >>
 unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
 : _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))
 { }


      ~unique_ptr()
      {
 auto& __ptr = std::get<0>(_M_t);
 if (__ptr != nullptr)
   get_deleter()(__ptr);
 __ptr = pointer();
      }


      unique_ptr&
      operator=(unique_ptr&& __u) noexcept
      {
 reset(__u.release());
 get_deleter() = std::forward<deleter_type>(__u.get_deleter());
 return *this;
      }

      template<typename _Up, typename _Ep>
 typename
 enable_if<__safe_conversion<_Up, _Ep>::value, unique_ptr&>::type
 operator=(unique_ptr<_Up, _Ep>&& __u) noexcept
 {
   reset(__u.release());
   get_deleter() = std::forward<_Ep>(__u.get_deleter());
   return *this;
 }

      unique_ptr&
      operator=(nullptr_t) noexcept
      {
 reset();
 return *this;
      }


      typename std::add_lvalue_reference<element_type>::type
      operator[](size_t __i) const
      {
                                          ;
 return get()[__i];
      }

      pointer
      get() const noexcept
      { return std::get<0>(_M_t); }

      deleter_type&
      get_deleter() noexcept
      { return std::get<1>(_M_t); }

      const deleter_type&
      get_deleter() const noexcept
      { return std::get<1>(_M_t); }

      explicit operator bool() const noexcept
      { return get() == pointer() ? false : true; }


      pointer
      release() noexcept
      {
 pointer __p = get();
 std::get<0>(_M_t) = pointer();
 return __p;
      }

      void
      reset() noexcept
      { reset(pointer()); }

      void
      reset(pointer __p) noexcept
      {
 using std::swap;
 swap(std::get<0>(_M_t), __p);
 if (__p != nullptr)
   get_deleter()(__p);
      }

      template<typename _Up, typename = _Require<is_pointer<pointer>,
        is_convertible<_Up*, pointer>, __is_derived_Tp<_Up>>>
 void reset(_Up*) = delete;

      void
      swap(unique_ptr& __u) noexcept
      {
 using std::swap;
 swap(_M_t, __u._M_t);
      }


      unique_ptr(const unique_ptr&) = delete;
      unique_ptr& operator=(const unique_ptr&) = delete;


      template<typename _Up, typename = _Require<is_pointer<pointer>,
        is_convertible<_Up*, pointer>, __is_derived_Tp<_Up>>>
 unique_ptr(_Up*, typename
     conditional<is_reference<deleter_type>::value,
     deleter_type, const deleter_type&>::type) = delete;

      template<typename _Up, typename = _Require<is_pointer<pointer>,
        is_convertible<_Up*, pointer>, __is_derived_Tp<_Up>>>
 unique_ptr(_Up*, typename
     remove_reference<deleter_type>::type&&) = delete;
    };

  template<typename _Tp, typename _Dp>
    inline void
    swap(unique_ptr<_Tp, _Dp>& __x,
  unique_ptr<_Tp, _Dp>& __y) noexcept
    { __x.swap(__y); }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator==(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return __x.get() == __y.get(); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator==(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept
    { return !__x; }

  template<typename _Tp, typename _Dp>
    inline bool
    operator==(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept
    { return !__x; }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator!=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return __x.get() != __y.get(); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator!=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept
    { return (bool)__x; }

  template<typename _Tp, typename _Dp>
    inline bool
    operator!=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept
    { return (bool)__x; }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator<(const unique_ptr<_Tp, _Dp>& __x,
       const unique_ptr<_Up, _Ep>& __y)
    {
      typedef typename
 std::common_type<typename unique_ptr<_Tp, _Dp>::pointer,
                  typename unique_ptr<_Up, _Ep>::pointer>::type _CT;
      return std::less<_CT>()(__x.get(), __y.get());
    }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),
         nullptr); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,
         __x.get()); }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator<=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return !(__y < __x); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return !(nullptr < __x); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return !(__x < nullptr); }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator>(const unique_ptr<_Tp, _Dp>& __x,
       const unique_ptr<_Up, _Ep>& __y)
    { return (__y < __x); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,
         __x.get()); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),
         nullptr); }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator>=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return !(__x < __y); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return !(__x < nullptr); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return !(nullptr < __x); }


  template<typename _Tp, typename _Dp>
    struct hash<unique_ptr<_Tp, _Dp>>
    : public __hash_base<size_t, unique_ptr<_Tp, _Dp>>
    {
      size_t
      operator()(const unique_ptr<_Tp, _Dp>& __u) const noexcept
      {
 typedef unique_ptr<_Tp, _Dp> _UP;
 return std::hash<typename _UP::pointer>()(__u.get());
      }
    };




}
# 82 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/memory" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/shared_ptr.h" 1 3
# 52 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/shared_ptr.h" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/shared_ptr_base.h" 1 3
# 52 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/shared_ptr_base.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename> class auto_ptr;






  class bad_weak_ptr : public std::exception
  {
  public:
    virtual char const*
    what() const noexcept;

    virtual ~bad_weak_ptr() noexcept;
  };


  inline void
  __throw_bad_weak_ptr()
  { (throw (bad_weak_ptr())); }

  using __gnu_cxx::_Lock_policy;
  using __gnu_cxx::__default_lock_policy;
  using __gnu_cxx::_S_single;
  using __gnu_cxx::_S_mutex;
  using __gnu_cxx::_S_atomic;


  template<_Lock_policy _Lp>
    class _Mutex_base
    {
    protected:

      enum { _S_need_barriers = 0 };
    };

  template<>
    class _Mutex_base<_S_mutex>
    : public __gnu_cxx::__mutex
    {
    protected:



      enum { _S_need_barriers = 1 };
    };

  template<_Lock_policy _Lp = __default_lock_policy>
    class _Sp_counted_base
    : public _Mutex_base<_Lp>
    {
    public:
      _Sp_counted_base() noexcept
      : _M_use_count(1), _M_weak_count(1) { }

      virtual
      ~_Sp_counted_base() noexcept
      { }



      virtual void
      _M_dispose() noexcept = 0;


      virtual void
      _M_destroy() noexcept
      { delete this; }

      virtual void*
      _M_get_deleter(const std::type_info&) = 0;

      void
      _M_add_ref_copy()
      { __gnu_cxx::__atomic_add_dispatch(&_M_use_count, 1); }

      void
      _M_add_ref_lock();

      void
      _M_release() noexcept
      {

                                                              ;
 if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == 1)
   {
                                                                 ;
     _M_dispose();




     if (_Mutex_base<_Lp>::_S_need_barriers)
       {
         __asm __volatile ("":::"memory");
         __asm __volatile ("":::"memory");
       }


                                                                   ;
     if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count,
             -1) == 1)
              {
                                                                      ;
         _M_destroy();
              }
   }
      }

      void
      _M_weak_add_ref() noexcept
      { __gnu_cxx::__atomic_add_dispatch(&_M_weak_count, 1); }

      void
      _M_weak_release() noexcept
      {

                                                               ;
 if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count, -1) == 1)
   {
                                                                  ;
     if (_Mutex_base<_Lp>::_S_need_barriers)
       {


         __asm __volatile ("":::"memory");
         __asm __volatile ("":::"memory");
       }
     _M_destroy();
   }
      }

      long
      _M_get_use_count() const noexcept
      {


        return __atomic_load_n(&_M_use_count, 0);
      }

    private:
      _Sp_counted_base(_Sp_counted_base const&) = delete;
      _Sp_counted_base& operator=(_Sp_counted_base const&) = delete;

      _Atomic_word _M_use_count;
      _Atomic_word _M_weak_count;
    };

  template<>
    inline void
    _Sp_counted_base<_S_single>::
    _M_add_ref_lock()
    {
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, 1) == 0)
 {
   _M_use_count = 0;
   __throw_bad_weak_ptr();
 }
    }

  template<>
    inline void
    _Sp_counted_base<_S_mutex>::
    _M_add_ref_lock()
    {
      __gnu_cxx::__scoped_lock sentry(*this);
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, 1) == 0)
 {
   _M_use_count = 0;
   __throw_bad_weak_ptr();
 }
    }

  template<>
    inline void
    _Sp_counted_base<_S_atomic>::
    _M_add_ref_lock()
    {

      _Atomic_word __count = _M_get_use_count();
      do
 {
   if (__count == 0)
     __throw_bad_weak_ptr();


 }
      while (!__atomic_compare_exchange_n(&_M_use_count, &__count, __count + 1,
       true, 4,
       0));
    }



  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>
    class __shared_ptr;

  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>
    class __weak_ptr;

  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>
    class __enable_shared_from_this;

  template<typename _Tp>
    class shared_ptr;

  template<typename _Tp>
    class weak_ptr;

  template<typename _Tp>
    struct owner_less;

  template<typename _Tp>
    class enable_shared_from_this;

  template<_Lock_policy _Lp = __default_lock_policy>
    class __weak_count;

  template<_Lock_policy _Lp = __default_lock_policy>
    class __shared_count;



  template<typename _Ptr, _Lock_policy _Lp>
    class _Sp_counted_ptr final : public _Sp_counted_base<_Lp>
    {
    public:
      explicit
      _Sp_counted_ptr(_Ptr __p)
      : _M_ptr(__p) { }

      virtual void
      _M_dispose() noexcept
      { delete _M_ptr; }

      virtual void
      _M_destroy() noexcept
      { delete this; }

      virtual void*
      _M_get_deleter(const std::type_info&)
      { return 0; }

      _Sp_counted_ptr(const _Sp_counted_ptr&) = delete;
      _Sp_counted_ptr& operator=(const _Sp_counted_ptr&) = delete;

    protected:
      _Ptr _M_ptr;
    };

  template<>
    inline void
    _Sp_counted_ptr<nullptr_t, _S_single>::_M_dispose() noexcept { }

  template<>
    inline void
    _Sp_counted_ptr<nullptr_t, _S_mutex>::_M_dispose() noexcept { }

  template<>
    inline void
    _Sp_counted_ptr<nullptr_t, _S_atomic>::_M_dispose() noexcept { }


  template<typename _Ptr, typename _Deleter, typename _Alloc, _Lock_policy _Lp>
    class _Sp_counted_deleter final : public _Sp_counted_base<_Lp>
    {



      struct _My_Deleter
      : public _Alloc
      {
 _Deleter _M_del;
 _My_Deleter(_Deleter __d, const _Alloc& __a)
 : _Alloc(__a), _M_del(__d) { }
      };

    public:

      _Sp_counted_deleter(_Ptr __p, _Deleter __d)
      : _M_ptr(__p), _M_del(__d, _Alloc()) { }


      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a)
      : _M_ptr(__p), _M_del(__d, __a) { }

      ~_Sp_counted_deleter() noexcept { }

      virtual void
      _M_dispose() noexcept
      { _M_del._M_del(_M_ptr); }

      virtual void
      _M_destroy() noexcept
      {
 typedef typename allocator_traits<_Alloc>::template
   rebind_traits<_Sp_counted_deleter> _Alloc_traits;
 typename _Alloc_traits::allocator_type __a(_M_del);
 _Alloc_traits::destroy(__a, this);
 _Alloc_traits::deallocate(__a, this, 1);
      }

      virtual void*
      _M_get_deleter(const std::type_info& __ti)
      {

        return __ti == typeid(_Deleter) ? &_M_del._M_del : 0;



      }

    protected:
      _Ptr _M_ptr;
      _My_Deleter _M_del;
    };



  struct _Sp_make_shared_tag { };

  template<typename _Tp, typename _Alloc, _Lock_policy _Lp>
    class _Sp_counted_ptr_inplace final : public _Sp_counted_base<_Lp>
    {



      struct _Impl
      : public _Alloc
      {
 _Impl(_Alloc __a) : _Alloc(__a), _M_ptr() { }
 _Tp* _M_ptr;
      };

    public:
      template<typename... _Args>
 _Sp_counted_ptr_inplace(_Alloc __a, _Args&&... __args)
 : _M_impl(__a)
 {
   _M_impl._M_ptr = static_cast<_Tp*>(static_cast<void*>(&_M_storage));


   allocator_traits<_Alloc>::construct(__a, _M_impl._M_ptr,
       std::forward<_Args>(__args)...);
 }

      ~_Sp_counted_ptr_inplace() noexcept { }

      virtual void
      _M_dispose() noexcept
      { allocator_traits<_Alloc>::destroy(_M_impl, _M_impl._M_ptr); }


      virtual void
      _M_destroy() noexcept
      {
 typedef typename allocator_traits<_Alloc>::template
   rebind_traits<_Sp_counted_ptr_inplace> _Alloc_traits;
 typename _Alloc_traits::allocator_type __a(_M_impl);
 _Alloc_traits::destroy(__a, this);
 _Alloc_traits::deallocate(__a, this, 1);
      }


      virtual void*
      _M_get_deleter(const std::type_info& __ti) noexcept
      {

 return __ti == typeid(_Sp_make_shared_tag)
        ? static_cast<void*>(&_M_storage)
        : 0;



      }

    private:
      _Impl _M_impl;
      typename aligned_storage<sizeof(_Tp), alignment_of<_Tp>::value>::type
 _M_storage;
    };

  template<_Lock_policy _Lp>
    class __shared_count
    {
    public:
      constexpr __shared_count() noexcept : _M_pi(0)
      { }

      template<typename _Ptr>
        explicit
 __shared_count(_Ptr __p) : _M_pi(0)
 {
   try
     {
       _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
     }
   catch(...)
     {
       delete __p;
       throw;
     }
 }

      template<typename _Ptr, typename _Deleter>
 __shared_count(_Ptr __p, _Deleter __d)
 : __shared_count(__p, std::move(__d), allocator<int>())
 { }

      template<typename _Ptr, typename _Deleter, typename _Alloc>
 __shared_count(_Ptr __p, _Deleter __d, _Alloc __a) : _M_pi(0)
 {
   typedef _Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp> _Sp_cd_type;
   typedef typename allocator_traits<_Alloc>::template
     rebind_traits<_Sp_cd_type> _Alloc_traits;
   typename _Alloc_traits::allocator_type __a2(__a);
   _Sp_cd_type* __mem = 0;
   try
     {
       __mem = _Alloc_traits::allocate(__a2, 1);
       _Alloc_traits::construct(__a2, __mem,
    __p, std::move(__d), std::move(__a));
       _M_pi = __mem;
     }
   catch(...)
     {
       __d(__p);
       if (__mem)
         _Alloc_traits::deallocate(__a2, __mem, 1);
       throw;
     }
 }

      template<typename _Tp, typename _Alloc, typename... _Args>
 __shared_count(_Sp_make_shared_tag, _Tp*, const _Alloc& __a,
         _Args&&... __args)
 : _M_pi(0)
 {
   typedef _Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp> _Sp_cp_type;
   typedef typename allocator_traits<_Alloc>::template
     rebind_traits<_Sp_cp_type> _Alloc_traits;
   typename _Alloc_traits::allocator_type __a2(__a);
   _Sp_cp_type* __mem = _Alloc_traits::allocate(__a2, 1);
   try
     {
       _Alloc_traits::construct(__a2, __mem, std::move(__a),
      std::forward<_Args>(__args)...);
       _M_pi = __mem;
     }
   catch(...)
     {
       _Alloc_traits::deallocate(__a2, __mem, 1);
       throw;
     }
 }



      template<typename _Tp>
        explicit
 __shared_count(std::auto_ptr<_Tp>&& __r);



      template<typename _Tp, typename _Del>
        explicit
 __shared_count(std::unique_ptr<_Tp, _Del>&& __r) : _M_pi(0)
 {
   using _Ptr = typename unique_ptr<_Tp, _Del>::pointer;
   using _Del2 = typename conditional<is_reference<_Del>::value,
       reference_wrapper<typename remove_reference<_Del>::type>,
       _Del>::type;
   using _Sp_cd_type
     = _Sp_counted_deleter<_Ptr, _Del2, allocator<void>, _Lp>;
   using _Alloc = allocator<_Sp_cd_type>;
   using _Alloc_traits = allocator_traits<_Alloc>;
   _Alloc __a;
   _Sp_cd_type* __mem = _Alloc_traits::allocate(__a, 1);
   _Alloc_traits::construct(__a, __mem, __r.release(),
       __r.get_deleter());
   _M_pi = __mem;
 }


      explicit __shared_count(const __weak_count<_Lp>& __r);

      ~__shared_count() noexcept
      {
 if (_M_pi != nullptr)
   _M_pi->_M_release();
      }

      __shared_count(const __shared_count& __r) noexcept
      : _M_pi(__r._M_pi)
      {
 if (_M_pi != 0)
   _M_pi->_M_add_ref_copy();
      }

      __shared_count&
      operator=(const __shared_count& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 if (__tmp != _M_pi)
   {
     if (__tmp != 0)
       __tmp->_M_add_ref_copy();
     if (_M_pi != 0)
       _M_pi->_M_release();
     _M_pi = __tmp;
   }
 return *this;
      }

      void
      _M_swap(__shared_count& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 __r._M_pi = _M_pi;
 _M_pi = __tmp;
      }

      long
      _M_get_use_count() const noexcept
      { return _M_pi != 0 ? _M_pi->_M_get_use_count() : 0; }

      bool
      _M_unique() const noexcept
      { return this->_M_get_use_count() == 1; }

      void*
      _M_get_deleter(const std::type_info& __ti) const noexcept
      { return _M_pi ? _M_pi->_M_get_deleter(__ti) : 0; }

      bool
      _M_less(const __shared_count& __rhs) const noexcept
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }

      bool
      _M_less(const __weak_count<_Lp>& __rhs) const noexcept
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }


      friend inline bool
      operator==(const __shared_count& __a, const __shared_count& __b) noexcept
      { return __a._M_pi == __b._M_pi; }

    private:
      friend class __weak_count<_Lp>;

      _Sp_counted_base<_Lp>* _M_pi;
    };


  template<_Lock_policy _Lp>
    class __weak_count
    {
    public:
      constexpr __weak_count() noexcept : _M_pi(0)
      { }

      __weak_count(const __shared_count<_Lp>& __r) noexcept
      : _M_pi(__r._M_pi)
      {
 if (_M_pi != 0)
   _M_pi->_M_weak_add_ref();
      }

      __weak_count(const __weak_count<_Lp>& __r) noexcept
      : _M_pi(__r._M_pi)
      {
 if (_M_pi != 0)
   _M_pi->_M_weak_add_ref();
      }

      ~__weak_count() noexcept
      {
 if (_M_pi != 0)
   _M_pi->_M_weak_release();
      }

      __weak_count<_Lp>&
      operator=(const __shared_count<_Lp>& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 if (__tmp != 0)
   __tmp->_M_weak_add_ref();
 if (_M_pi != 0)
   _M_pi->_M_weak_release();
 _M_pi = __tmp;
 return *this;
      }

      __weak_count<_Lp>&
      operator=(const __weak_count<_Lp>& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 if (__tmp != 0)
   __tmp->_M_weak_add_ref();
 if (_M_pi != 0)
   _M_pi->_M_weak_release();
 _M_pi = __tmp;
 return *this;
      }

      void
      _M_swap(__weak_count<_Lp>& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 __r._M_pi = _M_pi;
 _M_pi = __tmp;
      }

      long
      _M_get_use_count() const noexcept
      { return _M_pi != 0 ? _M_pi->_M_get_use_count() : 0; }

      bool
      _M_less(const __weak_count& __rhs) const noexcept
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }

      bool
      _M_less(const __shared_count<_Lp>& __rhs) const noexcept
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }


      friend inline bool
      operator==(const __weak_count& __a, const __weak_count& __b) noexcept
      { return __a._M_pi == __b._M_pi; }

    private:
      friend class __shared_count<_Lp>;

      _Sp_counted_base<_Lp>* _M_pi;
    };


  template<_Lock_policy _Lp>
    inline __shared_count<_Lp>:: __shared_count(const __weak_count<_Lp>& __r)
    : _M_pi(__r._M_pi)
    {
      if (_M_pi != 0)
 _M_pi->_M_add_ref_lock();
      else
 __throw_bad_weak_ptr();
    }





  template<_Lock_policy _Lp, typename _Tp1, typename _Tp2>
    void
    __enable_shared_from_this_helper(const __shared_count<_Lp>&,
         const __enable_shared_from_this<_Tp1,
         _Lp>*, const _Tp2*) noexcept;


  template<typename _Tp1, typename _Tp2>
    void
    __enable_shared_from_this_helper(const __shared_count<>&,
         const enable_shared_from_this<_Tp1>*,
         const _Tp2*) noexcept;

  template<_Lock_policy _Lp>
    inline void
    __enable_shared_from_this_helper(const __shared_count<_Lp>&, ...) noexcept
    { }


  template<typename _Tp, _Lock_policy _Lp>
    class __shared_ptr
    {
    public:
      typedef _Tp element_type;

      constexpr __shared_ptr() noexcept
      : _M_ptr(0), _M_refcount()
      { }

      template<typename _Tp1>
 explicit __shared_ptr(_Tp1* __p)
        : _M_ptr(__p), _M_refcount(__p)
 {

   static_assert( sizeof(_Tp1) > 0, "incomplete type" );
   __enable_shared_from_this_helper(_M_refcount, __p, __p);
 }

      template<typename _Tp1, typename _Deleter>
 __shared_ptr(_Tp1* __p, _Deleter __d)
 : _M_ptr(__p), _M_refcount(__p, __d)
 {


   __enable_shared_from_this_helper(_M_refcount, __p, __p);
 }

      template<typename _Tp1, typename _Deleter, typename _Alloc>
 __shared_ptr(_Tp1* __p, _Deleter __d, _Alloc __a)
 : _M_ptr(__p), _M_refcount(__p, __d, std::move(__a))
 {


   __enable_shared_from_this_helper(_M_refcount, __p, __p);
 }

      template<typename _Deleter>
 __shared_ptr(nullptr_t __p, _Deleter __d)
 : _M_ptr(0), _M_refcount(__p, __d)
 { }

      template<typename _Deleter, typename _Alloc>
        __shared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a)
 : _M_ptr(0), _M_refcount(__p, __d, std::move(__a))
 { }

      template<typename _Tp1>
 __shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, _Tp* __p) noexcept
 : _M_ptr(__p), _M_refcount(__r._M_refcount)
 { }

      __shared_ptr(const __shared_ptr&) noexcept = default;
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;

      template<typename _Tp1, typename = typename
        std::enable_if<std::is_convertible<_Tp1*, _Tp*>::value>::type>
 __shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
 : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)
 { }

      __shared_ptr(__shared_ptr&& __r) noexcept
      : _M_ptr(__r._M_ptr), _M_refcount()
      {
 _M_refcount._M_swap(__r._M_refcount);
 __r._M_ptr = 0;
      }

      template<typename _Tp1, typename = typename
        std::enable_if<std::is_convertible<_Tp1*, _Tp*>::value>::type>
 __shared_ptr(__shared_ptr<_Tp1, _Lp>&& __r) noexcept
 : _M_ptr(__r._M_ptr), _M_refcount()
 {
   _M_refcount._M_swap(__r._M_refcount);
   __r._M_ptr = 0;
 }

      template<typename _Tp1>
 explicit __shared_ptr(const __weak_ptr<_Tp1, _Lp>& __r)
 : _M_refcount(__r._M_refcount)
 {




   _M_ptr = __r._M_ptr;
 }


      template<typename _Tp1, typename _Del>
 __shared_ptr(std::unique_ptr<_Tp1, _Del>&& __r)
 : _M_ptr(__r.get()), _M_refcount()
 {

   auto __tmp = __r.get();
   _M_refcount = __shared_count<_Lp>(std::move(__r));
   __enable_shared_from_this_helper(_M_refcount, __tmp, __tmp);
 }



      template<typename _Tp1>
 __shared_ptr(std::auto_ptr<_Tp1>&& __r);



      constexpr __shared_ptr(nullptr_t) noexcept
      : _M_ptr(0), _M_refcount()
      { }

      template<typename _Tp1>
 __shared_ptr&
 operator=(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
 {
   _M_ptr = __r._M_ptr;
   _M_refcount = __r._M_refcount;
   return *this;
 }


      template<typename _Tp1>
 __shared_ptr&
 operator=(std::auto_ptr<_Tp1>&& __r)
 {
   __shared_ptr(std::move(__r)).swap(*this);
   return *this;
 }


      __shared_ptr&
      operator=(__shared_ptr&& __r) noexcept
      {
 __shared_ptr(std::move(__r)).swap(*this);
 return *this;
      }

      template<class _Tp1>
 __shared_ptr&
 operator=(__shared_ptr<_Tp1, _Lp>&& __r) noexcept
 {
   __shared_ptr(std::move(__r)).swap(*this);
   return *this;
 }

      template<typename _Tp1, typename _Del>
 __shared_ptr&
 operator=(std::unique_ptr<_Tp1, _Del>&& __r)
 {
   __shared_ptr(std::move(__r)).swap(*this);
   return *this;
 }

      void
      reset() noexcept
      { __shared_ptr().swap(*this); }

      template<typename _Tp1>
 void
 reset(_Tp1* __p)
 {

                                                   ;
   __shared_ptr(__p).swap(*this);
 }

      template<typename _Tp1, typename _Deleter>
 void
 reset(_Tp1* __p, _Deleter __d)
 { __shared_ptr(__p, __d).swap(*this); }

      template<typename _Tp1, typename _Deleter, typename _Alloc>
 void
        reset(_Tp1* __p, _Deleter __d, _Alloc __a)
        { __shared_ptr(__p, __d, std::move(__a)).swap(*this); }


      typename std::add_lvalue_reference<_Tp>::type
      operator*() const noexcept
      {
                                   ;
 return *_M_ptr;
      }

      _Tp*
      operator->() const noexcept
      {
                                   ;
 return _M_ptr;
      }

      _Tp*
      get() const noexcept
      { return _M_ptr; }

      explicit operator bool() const
      { return _M_ptr == 0 ? false : true; }

      bool
      unique() const noexcept
      { return _M_refcount._M_unique(); }

      long
      use_count() const noexcept
      { return _M_refcount._M_get_use_count(); }

      void
      swap(__shared_ptr<_Tp, _Lp>& __other) noexcept
      {
 std::swap(_M_ptr, __other._M_ptr);
 _M_refcount._M_swap(__other._M_refcount);
      }

      template<typename _Tp1>
 bool
 owner_before(__shared_ptr<_Tp1, _Lp> const& __rhs) const
 { return _M_refcount._M_less(__rhs._M_refcount); }

      template<typename _Tp1>
 bool
 owner_before(__weak_ptr<_Tp1, _Lp> const& __rhs) const
 { return _M_refcount._M_less(__rhs._M_refcount); }


    protected:

      template<typename _Alloc, typename... _Args>
 __shared_ptr(_Sp_make_shared_tag __tag, const _Alloc& __a,
       _Args&&... __args)
 : _M_ptr(), _M_refcount(__tag, (_Tp*)0, __a,
    std::forward<_Args>(__args)...)
 {


   void* __p = _M_refcount._M_get_deleter(typeid(__tag));
   _M_ptr = static_cast<_Tp*>(__p);
   __enable_shared_from_this_helper(_M_refcount, _M_ptr, _M_ptr);
 }
# 1005 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/shared_ptr_base.h" 3
      template<typename _Tp1, _Lock_policy _Lp1, typename _Alloc,
        typename... _Args>
 friend __shared_ptr<_Tp1, _Lp1>
 __allocate_shared(const _Alloc& __a, _Args&&... __args);

    private:
      void*
      _M_get_deleter(const std::type_info& __ti) const noexcept
      { return _M_refcount._M_get_deleter(__ti); }

      template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;
      template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;

      template<typename _Del, typename _Tp1, _Lock_policy _Lp1>
 friend _Del* get_deleter(const __shared_ptr<_Tp1, _Lp1>&) noexcept;

      _Tp* _M_ptr;
      __shared_count<_Lp> _M_refcount;
    };



  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator==(const __shared_ptr<_Tp1, _Lp>& __a,
        const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return __a.get() == __b.get(); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator==(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return !__a; }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator==(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return !__a; }

  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator!=(const __shared_ptr<_Tp1, _Lp>& __a,
        const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return __a.get() != __b.get(); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator!=(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return (bool)__a; }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator!=(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return (bool)__a; }

  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator<(const __shared_ptr<_Tp1, _Lp>& __a,
       const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    {
      typedef typename std::common_type<_Tp1*, _Tp2*>::type _CT;
      return std::less<_CT>()(__a.get(), __b.get());
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator<(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return std::less<_Tp*>()(__a.get(), nullptr); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator<(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return std::less<_Tp*>()(nullptr, __a.get()); }

  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator<=(const __shared_ptr<_Tp1, _Lp>& __a,
        const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return !(__b < __a); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator<=(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return !(nullptr < __a); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator<=(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return !(__a < nullptr); }

  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator>(const __shared_ptr<_Tp1, _Lp>& __a,
       const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return (__b < __a); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator>(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return std::less<_Tp*>()(nullptr, __a.get()); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator>(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return std::less<_Tp*>()(__a.get(), nullptr); }

  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator>=(const __shared_ptr<_Tp1, _Lp>& __a,
        const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return !(__a < __b); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator>=(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return !(__a < nullptr); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator>=(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return !(nullptr < __a); }

  template<typename _Sp>
    struct _Sp_less : public binary_function<_Sp, _Sp, bool>
    {
      bool
      operator()(const _Sp& __lhs, const _Sp& __rhs) const noexcept
      {
 typedef typename _Sp::element_type element_type;
 return std::less<element_type*>()(__lhs.get(), __rhs.get());
      }
    };

  template<typename _Tp, _Lock_policy _Lp>
    struct less<__shared_ptr<_Tp, _Lp>>
    : public _Sp_less<__shared_ptr<_Tp, _Lp>>
    { };


  template<typename _Tp, _Lock_policy _Lp>
    inline void
    swap(__shared_ptr<_Tp, _Lp>& __a, __shared_ptr<_Tp, _Lp>& __b) noexcept
    { __a.swap(__b); }
# 1155 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/shared_ptr_base.h" 3
  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    static_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
    { return __shared_ptr<_Tp, _Lp>(__r, static_cast<_Tp*>(__r.get())); }






  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    const_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
    { return __shared_ptr<_Tp, _Lp>(__r, const_cast<_Tp*>(__r.get())); }






  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    dynamic_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
    {
      if (_Tp* __p = dynamic_cast<_Tp*>(__r.get()))
 return __shared_ptr<_Tp, _Lp>(__r, __p);
      return __shared_ptr<_Tp, _Lp>();
    }


  template<typename _Tp, _Lock_policy _Lp>
    class __weak_ptr
    {
    public:
      typedef _Tp element_type;

      constexpr __weak_ptr() noexcept
      : _M_ptr(0), _M_refcount()
      { }

      __weak_ptr(const __weak_ptr&) noexcept = default;
      __weak_ptr& operator=(const __weak_ptr&) noexcept = default;
      ~__weak_ptr() = default;
# 1213 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/shared_ptr_base.h" 3
      template<typename _Tp1, typename = typename
        std::enable_if<std::is_convertible<_Tp1*, _Tp*>::value>::type>
 __weak_ptr(const __weak_ptr<_Tp1, _Lp>& __r) noexcept
 : _M_refcount(__r._M_refcount)
        { _M_ptr = __r.lock().get(); }

      template<typename _Tp1, typename = typename
        std::enable_if<std::is_convertible<_Tp1*, _Tp*>::value>::type>
 __weak_ptr(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
 : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)
 { }

      template<typename _Tp1>
 __weak_ptr&
 operator=(const __weak_ptr<_Tp1, _Lp>& __r) noexcept
 {
   _M_ptr = __r.lock().get();
   _M_refcount = __r._M_refcount;
   return *this;
 }

      template<typename _Tp1>
 __weak_ptr&
 operator=(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
 {
   _M_ptr = __r._M_ptr;
   _M_refcount = __r._M_refcount;
   return *this;
 }

      __shared_ptr<_Tp, _Lp>
      lock() const noexcept
      {


 if (expired())
   return __shared_ptr<element_type, _Lp>();

 try
   {
     return __shared_ptr<element_type, _Lp>(*this);
   }
 catch(const bad_weak_ptr&)
   {



     return __shared_ptr<element_type, _Lp>();
   }







      }

      long
      use_count() const noexcept
      { return _M_refcount._M_get_use_count(); }

      bool
      expired() const noexcept
      { return _M_refcount._M_get_use_count() == 0; }

      template<typename _Tp1>
 bool
 owner_before(const __shared_ptr<_Tp1, _Lp>& __rhs) const
 { return _M_refcount._M_less(__rhs._M_refcount); }

      template<typename _Tp1>
 bool
 owner_before(const __weak_ptr<_Tp1, _Lp>& __rhs) const
 { return _M_refcount._M_less(__rhs._M_refcount); }

      void
      reset() noexcept
      { __weak_ptr().swap(*this); }

      void
      swap(__weak_ptr& __s) noexcept
      {
 std::swap(_M_ptr, __s._M_ptr);
 _M_refcount._M_swap(__s._M_refcount);
      }

    private:

      void
      _M_assign(_Tp* __ptr, const __shared_count<_Lp>& __refcount) noexcept
      {
 _M_ptr = __ptr;
 _M_refcount = __refcount;
      }

      template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;
      template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;
      friend class __enable_shared_from_this<_Tp, _Lp>;
      friend class enable_shared_from_this<_Tp>;

      _Tp* _M_ptr;
      __weak_count<_Lp> _M_refcount;
    };


  template<typename _Tp, _Lock_policy _Lp>
    inline void
    swap(__weak_ptr<_Tp, _Lp>& __a, __weak_ptr<_Tp, _Lp>& __b) noexcept
    { __a.swap(__b); }

  template<typename _Tp, typename _Tp1>
    struct _Sp_owner_less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __lhs, const _Tp& __rhs) const
      { return __lhs.owner_before(__rhs); }

      bool
      operator()(const _Tp& __lhs, const _Tp1& __rhs) const
      { return __lhs.owner_before(__rhs); }

      bool
      operator()(const _Tp1& __lhs, const _Tp& __rhs) const
      { return __lhs.owner_before(__rhs); }
    };

  template<typename _Tp, _Lock_policy _Lp>
    struct owner_less<__shared_ptr<_Tp, _Lp>>
    : public _Sp_owner_less<__shared_ptr<_Tp, _Lp>, __weak_ptr<_Tp, _Lp>>
    { };

  template<typename _Tp, _Lock_policy _Lp>
    struct owner_less<__weak_ptr<_Tp, _Lp>>
    : public _Sp_owner_less<__weak_ptr<_Tp, _Lp>, __shared_ptr<_Tp, _Lp>>
    { };


  template<typename _Tp, _Lock_policy _Lp>
    class __enable_shared_from_this
    {
    protected:
      constexpr __enable_shared_from_this() noexcept { }

      __enable_shared_from_this(const __enable_shared_from_this&) noexcept { }

      __enable_shared_from_this&
      operator=(const __enable_shared_from_this&) noexcept
      { return *this; }

      ~__enable_shared_from_this() { }

    public:
      __shared_ptr<_Tp, _Lp>
      shared_from_this()
      { return __shared_ptr<_Tp, _Lp>(this->_M_weak_this); }

      __shared_ptr<const _Tp, _Lp>
      shared_from_this() const
      { return __shared_ptr<const _Tp, _Lp>(this->_M_weak_this); }

    private:
      template<typename _Tp1>
 void
 _M_weak_assign(_Tp1* __p, const __shared_count<_Lp>& __n) const noexcept
 { _M_weak_this._M_assign(__p, __n); }

      template<typename _Tp1>
 friend void
 __enable_shared_from_this_helper(const __shared_count<_Lp>& __pn,
      const __enable_shared_from_this* __pe,
      const _Tp1* __px) noexcept
 {
   if (__pe != 0)
     __pe->_M_weak_assign(const_cast<_Tp1*>(__px), __pn);
 }

      mutable __weak_ptr<_Tp, _Lp> _M_weak_this;
    };


  template<typename _Tp, _Lock_policy _Lp, typename _Alloc, typename... _Args>
    inline __shared_ptr<_Tp, _Lp>
    __allocate_shared(const _Alloc& __a, _Args&&... __args)
    {
      return __shared_ptr<_Tp, _Lp>(_Sp_make_shared_tag(), __a,
        std::forward<_Args>(__args)...);
    }

  template<typename _Tp, _Lock_policy _Lp, typename... _Args>
    inline __shared_ptr<_Tp, _Lp>
    __make_shared(_Args&&... __args)
    {
      typedef typename std::remove_const<_Tp>::type _Tp_nc;
      return std::__allocate_shared<_Tp, _Lp>(std::allocator<_Tp_nc>(),
           std::forward<_Args>(__args)...);
    }


  template<typename _Tp, _Lock_policy _Lp>
    struct hash<__shared_ptr<_Tp, _Lp>>
    : public __hash_base<size_t, __shared_ptr<_Tp, _Lp>>
    {
      size_t
      operator()(const __shared_ptr<_Tp, _Lp>& __s) const noexcept
      { return std::hash<_Tp*>()(__s.get()); }
    };


}
# 53 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/shared_ptr.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
# 64 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/shared_ptr.h" 3
  template<typename _Ch, typename _Tr, typename _Tp, _Lock_policy _Lp>
    inline std::basic_ostream<_Ch, _Tr>&
    operator<<(std::basic_ostream<_Ch, _Tr>& __os,
        const __shared_ptr<_Tp, _Lp>& __p)
    {
      __os << __p.get();
      return __os;
    }


  template<typename _Del, typename _Tp, _Lock_policy _Lp>
    inline _Del*
    get_deleter(const __shared_ptr<_Tp, _Lp>& __p) noexcept
    {

      return static_cast<_Del*>(__p._M_get_deleter(typeid(_Del)));



    }
# 92 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/shared_ptr.h" 3
  template<typename _Tp>
    class shared_ptr : public __shared_ptr<_Tp>
    {
    public:




      constexpr shared_ptr() noexcept
      : __shared_ptr<_Tp>() { }

      shared_ptr(const shared_ptr&) noexcept = default;







      template<typename _Tp1>
 explicit shared_ptr(_Tp1* __p)
        : __shared_ptr<_Tp>(__p) { }
# 128 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/shared_ptr.h" 3
      template<typename _Tp1, typename _Deleter>
 shared_ptr(_Tp1* __p, _Deleter __d)
        : __shared_ptr<_Tp>(__p, __d) { }
# 145 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/shared_ptr.h" 3
      template<typename _Deleter>
 shared_ptr(nullptr_t __p, _Deleter __d)
        : __shared_ptr<_Tp>(__p, __d) { }
# 164 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/shared_ptr.h" 3
      template<typename _Tp1, typename _Deleter, typename _Alloc>
 shared_ptr(_Tp1* __p, _Deleter __d, _Alloc __a)
 : __shared_ptr<_Tp>(__p, __d, std::move(__a)) { }
# 183 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/shared_ptr.h" 3
      template<typename _Deleter, typename _Alloc>
 shared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a)
 : __shared_ptr<_Tp>(__p, __d, std::move(__a)) { }
# 205 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/shared_ptr.h" 3
      template<typename _Tp1>
 shared_ptr(const shared_ptr<_Tp1>& __r, _Tp* __p) noexcept
 : __shared_ptr<_Tp>(__r, __p) { }
# 216 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/shared_ptr.h" 3
      template<typename _Tp1, typename = typename
        std::enable_if<std::is_convertible<_Tp1*, _Tp*>::value>::type>
 shared_ptr(const shared_ptr<_Tp1>& __r) noexcept
        : __shared_ptr<_Tp>(__r) { }






      shared_ptr(shared_ptr&& __r) noexcept
      : __shared_ptr<_Tp>(std::move(__r)) { }






      template<typename _Tp1, typename = typename
        std::enable_if<std::is_convertible<_Tp1*, _Tp*>::value>::type>
 shared_ptr(shared_ptr<_Tp1>&& __r) noexcept
 : __shared_ptr<_Tp>(std::move(__r)) { }
# 247 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/shared_ptr.h" 3
      template<typename _Tp1>
 explicit shared_ptr(const weak_ptr<_Tp1>& __r)
 : __shared_ptr<_Tp>(__r) { }


      template<typename _Tp1>
 shared_ptr(std::auto_ptr<_Tp1>&& __r);


      template<typename _Tp1, typename _Del>
 shared_ptr(std::unique_ptr<_Tp1, _Del>&& __r)
 : __shared_ptr<_Tp>(std::move(__r)) { }






      constexpr shared_ptr(nullptr_t __p) noexcept
      : __shared_ptr<_Tp>(__p) { }

      shared_ptr& operator=(const shared_ptr&) noexcept = default;

      template<typename _Tp1>
 shared_ptr&
 operator=(const shared_ptr<_Tp1>& __r) noexcept
 {
   this->__shared_ptr<_Tp>::operator=(__r);
   return *this;
 }


      template<typename _Tp1>
 shared_ptr&
 operator=(std::auto_ptr<_Tp1>&& __r)
 {
   this->__shared_ptr<_Tp>::operator=(std::move(__r));
   return *this;
 }


      shared_ptr&
      operator=(shared_ptr&& __r) noexcept
      {
 this->__shared_ptr<_Tp>::operator=(std::move(__r));
 return *this;
      }

      template<class _Tp1>
 shared_ptr&
 operator=(shared_ptr<_Tp1>&& __r) noexcept
 {
   this->__shared_ptr<_Tp>::operator=(std::move(__r));
   return *this;
 }

      template<typename _Tp1, typename _Del>
 shared_ptr&
 operator=(std::unique_ptr<_Tp1, _Del>&& __r)
 {
   this->__shared_ptr<_Tp>::operator=(std::move(__r));
   return *this;
 }

    private:

      template<typename _Alloc, typename... _Args>
 shared_ptr(_Sp_make_shared_tag __tag, const _Alloc& __a,
     _Args&&... __args)
 : __shared_ptr<_Tp>(__tag, __a, std::forward<_Args>(__args)...)
 { }

      template<typename _Tp1, typename _Alloc, typename... _Args>
 friend shared_ptr<_Tp1>
 allocate_shared(const _Alloc& __a, _Args&&... __args);
    };


  template<typename _Tp1, typename _Tp2>
    inline bool
    operator==(const shared_ptr<_Tp1>& __a,
        const shared_ptr<_Tp2>& __b) noexcept
    { return __a.get() == __b.get(); }

  template<typename _Tp>
    inline bool
    operator==(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return !__a; }

  template<typename _Tp>
    inline bool
    operator==(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return !__a; }

  template<typename _Tp1, typename _Tp2>
    inline bool
    operator!=(const shared_ptr<_Tp1>& __a,
        const shared_ptr<_Tp2>& __b) noexcept
    { return __a.get() != __b.get(); }

  template<typename _Tp>
    inline bool
    operator!=(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return (bool)__a; }

  template<typename _Tp>
    inline bool
    operator!=(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return (bool)__a; }

  template<typename _Tp1, typename _Tp2>
    inline bool
    operator<(const shared_ptr<_Tp1>& __a,
       const shared_ptr<_Tp2>& __b) noexcept
    {
      typedef typename std::common_type<_Tp1*, _Tp2*>::type _CT;
      return std::less<_CT>()(__a.get(), __b.get());
    }

  template<typename _Tp>
    inline bool
    operator<(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return std::less<_Tp*>()(__a.get(), nullptr); }

  template<typename _Tp>
    inline bool
    operator<(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return std::less<_Tp*>()(nullptr, __a.get()); }

  template<typename _Tp1, typename _Tp2>
    inline bool
    operator<=(const shared_ptr<_Tp1>& __a,
        const shared_ptr<_Tp2>& __b) noexcept
    { return !(__b < __a); }

  template<typename _Tp>
    inline bool
    operator<=(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return !(nullptr < __a); }

  template<typename _Tp>
    inline bool
    operator<=(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return !(__a < nullptr); }

  template<typename _Tp1, typename _Tp2>
    inline bool
    operator>(const shared_ptr<_Tp1>& __a,
       const shared_ptr<_Tp2>& __b) noexcept
    { return (__b < __a); }

  template<typename _Tp>
    inline bool
    operator>(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return std::less<_Tp*>()(nullptr, __a.get()); }

  template<typename _Tp>
    inline bool
    operator>(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return std::less<_Tp*>()(__a.get(), nullptr); }

  template<typename _Tp1, typename _Tp2>
    inline bool
    operator>=(const shared_ptr<_Tp1>& __a,
        const shared_ptr<_Tp2>& __b) noexcept
    { return !(__a < __b); }

  template<typename _Tp>
    inline bool
    operator>=(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return !(__a < nullptr); }

  template<typename _Tp>
    inline bool
    operator>=(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return !(nullptr < __a); }

  template<typename _Tp>
    struct less<shared_ptr<_Tp>> : public _Sp_less<shared_ptr<_Tp>>
    { };


  template<typename _Tp>
    inline void
    swap(shared_ptr<_Tp>& __a, shared_ptr<_Tp>& __b) noexcept
    { __a.swap(__b); }


  template<typename _Tp, typename _Tp1>
    inline shared_ptr<_Tp>
    static_pointer_cast(const shared_ptr<_Tp1>& __r) noexcept
    { return shared_ptr<_Tp>(__r, static_cast<_Tp*>(__r.get())); }

  template<typename _Tp, typename _Tp1>
    inline shared_ptr<_Tp>
    const_pointer_cast(const shared_ptr<_Tp1>& __r) noexcept
    { return shared_ptr<_Tp>(__r, const_cast<_Tp*>(__r.get())); }

  template<typename _Tp, typename _Tp1>
    inline shared_ptr<_Tp>
    dynamic_pointer_cast(const shared_ptr<_Tp1>& __r) noexcept
    {
      if (_Tp* __p = dynamic_cast<_Tp*>(__r.get()))
 return shared_ptr<_Tp>(__r, __p);
      return shared_ptr<_Tp>();
    }







  template<typename _Tp>
    class weak_ptr : public __weak_ptr<_Tp>
    {
    public:
      constexpr weak_ptr() noexcept
      : __weak_ptr<_Tp>() { }

      template<typename _Tp1, typename = typename
        std::enable_if<std::is_convertible<_Tp1*, _Tp*>::value>::type>
 weak_ptr(const weak_ptr<_Tp1>& __r) noexcept
 : __weak_ptr<_Tp>(__r) { }

      template<typename _Tp1, typename = typename
        std::enable_if<std::is_convertible<_Tp1*, _Tp*>::value>::type>
 weak_ptr(const shared_ptr<_Tp1>& __r) noexcept
 : __weak_ptr<_Tp>(__r) { }

      template<typename _Tp1>
 weak_ptr&
 operator=(const weak_ptr<_Tp1>& __r) noexcept
 {
   this->__weak_ptr<_Tp>::operator=(__r);
   return *this;
 }

      template<typename _Tp1>
 weak_ptr&
 operator=(const shared_ptr<_Tp1>& __r) noexcept
 {
   this->__weak_ptr<_Tp>::operator=(__r);
   return *this;
 }

      shared_ptr<_Tp>
      lock() const noexcept
      {

 if (this->expired())
   return shared_ptr<_Tp>();

 try
   {
     return shared_ptr<_Tp>(*this);
   }
 catch(const bad_weak_ptr&)
   {
     return shared_ptr<_Tp>();
   }



      }
    };


  template<typename _Tp>
    inline void
    swap(weak_ptr<_Tp>& __a, weak_ptr<_Tp>& __b) noexcept
    { __a.swap(__b); }



  template<typename _Tp>
    struct owner_less;


  template<typename _Tp>
    struct owner_less<shared_ptr<_Tp>>
    : public _Sp_owner_less<shared_ptr<_Tp>, weak_ptr<_Tp>>
    { };


  template<typename _Tp>
    struct owner_less<weak_ptr<_Tp>>
    : public _Sp_owner_less<weak_ptr<_Tp>, shared_ptr<_Tp>>
    { };




  template<typename _Tp>
    class enable_shared_from_this
    {
    protected:
      constexpr enable_shared_from_this() noexcept { }

      enable_shared_from_this(const enable_shared_from_this&) noexcept { }

      enable_shared_from_this&
      operator=(const enable_shared_from_this&) noexcept
      { return *this; }

      ~enable_shared_from_this() { }

    public:
      shared_ptr<_Tp>
      shared_from_this()
      { return shared_ptr<_Tp>(this->_M_weak_this); }

      shared_ptr<const _Tp>
      shared_from_this() const
      { return shared_ptr<const _Tp>(this->_M_weak_this); }

    private:
      template<typename _Tp1>
 void
 _M_weak_assign(_Tp1* __p, const __shared_count<>& __n) const noexcept
 { _M_weak_this._M_assign(__p, __n); }

      template<typename _Tp1>
 friend void
 __enable_shared_from_this_helper(const __shared_count<>& __pn,
      const enable_shared_from_this* __pe,
      const _Tp1* __px) noexcept
 {
   if (__pe != 0)
     __pe->_M_weak_assign(const_cast<_Tp1*>(__px), __pn);
 }

      mutable weak_ptr<_Tp> _M_weak_this;
    };
# 593 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/shared_ptr.h" 3
  template<typename _Tp, typename _Alloc, typename... _Args>
    inline shared_ptr<_Tp>
    allocate_shared(const _Alloc& __a, _Args&&... __args)
    {
      return shared_ptr<_Tp>(_Sp_make_shared_tag(), __a,
        std::forward<_Args>(__args)...);
    }
# 608 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/shared_ptr.h" 3
  template<typename _Tp, typename... _Args>
    inline shared_ptr<_Tp>
    make_shared(_Args&&... __args)
    {
      typedef typename std::remove_const<_Tp>::type _Tp_nc;
      return std::allocate_shared<_Tp>(std::allocator<_Tp_nc>(),
           std::forward<_Args>(__args)...);
    }


  template<typename _Tp>
    struct hash<shared_ptr<_Tp>>
    : public __hash_base<size_t, shared_ptr<_Tp>>
    {
      size_t
      operator()(const shared_ptr<_Tp>& __s) const noexcept
      { return std::hash<_Tp*>()(__s.get()); }
    };




}
# 83 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/memory" 2 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/backward/auto_ptr.h" 1 3
# 36 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/backward/auto_ptr.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 47 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/backward/auto_ptr.h" 3
  template<typename _Tp1>
    struct auto_ptr_ref
    {
      _Tp1* _M_ptr;

      explicit
      auto_ptr_ref(_Tp1* __p): _M_ptr(__p) { }
    } ;
# 86 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/backward/auto_ptr.h" 3
  template<typename _Tp>
    class auto_ptr
    {
    private:
      _Tp* _M_ptr;

    public:

      typedef _Tp element_type;







      explicit
      auto_ptr(element_type* __p = 0) throw() : _M_ptr(__p) { }
# 112 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/backward/auto_ptr.h" 3
      auto_ptr(auto_ptr& __a) throw() : _M_ptr(__a.release()) { }
# 124 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/backward/auto_ptr.h" 3
      template<typename _Tp1>
        auto_ptr(auto_ptr<_Tp1>& __a) throw() : _M_ptr(__a.release()) { }
# 135 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/backward/auto_ptr.h" 3
      auto_ptr&
      operator=(auto_ptr& __a) throw()
      {
 reset(__a.release());
 return *this;
      }
# 152 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/backward/auto_ptr.h" 3
      template<typename _Tp1>
        auto_ptr&
        operator=(auto_ptr<_Tp1>& __a) throw()
        {
   reset(__a.release());
   return *this;
 }
# 170 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/backward/auto_ptr.h" 3
      ~auto_ptr() { delete _M_ptr; }
# 180 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/backward/auto_ptr.h" 3
      element_type&
      operator*() const throw()
      {
                                   ;
 return *_M_ptr;
      }







      element_type*
      operator->() const throw()
      {
                                   ;
 return _M_ptr;
      }
# 210 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/backward/auto_ptr.h" 3
      element_type*
      get() const throw() { return _M_ptr; }
# 224 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/backward/auto_ptr.h" 3
      element_type*
      release() throw()
      {
 element_type* __tmp = _M_ptr;
 _M_ptr = 0;
 return __tmp;
      }
# 239 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/backward/auto_ptr.h" 3
      void
      reset(element_type* __p = 0) throw()
      {
 if (__p != _M_ptr)
   {
     delete _M_ptr;
     _M_ptr = __p;
   }
      }
# 260 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/backward/auto_ptr.h" 3
      auto_ptr(auto_ptr_ref<element_type> __ref) throw()
      : _M_ptr(__ref._M_ptr) { }

      auto_ptr&
      operator=(auto_ptr_ref<element_type> __ref) throw()
      {
 if (__ref._M_ptr != this->get())
   {
     delete _M_ptr;
     _M_ptr = __ref._M_ptr;
   }
 return *this;
      }

      template<typename _Tp1>
        operator auto_ptr_ref<_Tp1>() throw()
        { return auto_ptr_ref<_Tp1>(this->release()); }

      template<typename _Tp1>
        operator auto_ptr<_Tp1>() throw()
        { return auto_ptr<_Tp1>(this->release()); }
    } ;



  template<>
    class auto_ptr<void>
    {
    public:
      typedef void element_type;
    } ;


  template<_Lock_policy _Lp>
  template<typename _Tp>
    inline
    __shared_count<_Lp>::__shared_count(std::auto_ptr<_Tp>&& __r)
    : _M_pi(new _Sp_counted_ptr<_Tp*, _Lp>(__r.get()))
    { __r.release(); }

  template<typename _Tp, _Lock_policy _Lp>
  template<typename _Tp1>
    inline
    __shared_ptr<_Tp, _Lp>::__shared_ptr(std::auto_ptr<_Tp1>&& __r)
    : _M_ptr(__r.get()), _M_refcount()
    {

      static_assert( sizeof(_Tp1) > 0, "incomplete type" );
      _Tp1* __tmp = __r.get();
      _M_refcount = __shared_count<_Lp>(std::move(__r));
      __enable_shared_from_this_helper(_M_refcount, __tmp, __tmp);
    }

  template<typename _Tp>
  template<typename _Tp1>
    inline
    shared_ptr<_Tp>::shared_ptr(std::auto_ptr<_Tp1>&& __r)
    : __shared_ptr<_Tp>(std::move(__r)) { }

  template<typename _Tp, typename _Dp>
  template<typename _Up, typename>
    inline
    unique_ptr<_Tp, _Dp>::unique_ptr(auto_ptr<_Up>&& __u) noexcept
    : _M_t(__u.release(), deleter_type()) { }



}
# 85 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/memory" 2 3
# 22 "/usr/include/boost/config/no_tr1/memory.hpp" 2 3 4
# 28 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 2 3 4

# 1 "/usr/include/boost/assert.hpp" 1 3 4
# 50 "/usr/include/boost/assert.hpp" 3 4
# 1 "/usr/include/assert.h" 1 3 4
# 51 "/usr/include/boost/assert.hpp" 2 3 4
# 30 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 2 3 4
# 1 "/usr/include/boost/checked_delete.hpp" 1 3 4
# 24 "/usr/include/boost/checked_delete.hpp" 3 4
namespace boost
{



template<class T> inline void checked_delete(T * x)
{

    typedef char type_must_be_complete[ sizeof(T)? 1: -1 ];
    (void) sizeof(type_must_be_complete);
    delete x;
}

template<class T> inline void checked_array_delete(T * x)
{
    typedef char type_must_be_complete[ sizeof(T)? 1: -1 ];
    (void) sizeof(type_must_be_complete);
    delete [] x;
}

template<class T> struct checked_deleter
{
    typedef void result_type;
    typedef T * argument_type;

    void operator()(T * x) const
    {

        boost::checked_delete(x);
    }
};

template<class T> struct checked_array_deleter
{
    typedef void result_type;
    typedef T * argument_type;

    void operator()(T * x) const
    {
        boost::checked_array_delete(x);
    }
};

}
# 31 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 2 3 4
# 1 "/usr/include/boost/throw_exception.hpp" 1 3 4
# 5 "/usr/include/boost/throw_exception.hpp" 3
# 29 "/usr/include/boost/throw_exception.hpp" 3
# 1 "/usr/include/boost/exception/detail/attribute_noreturn.hpp" 1 3 4
# 30 "/usr/include/boost/throw_exception.hpp" 2 3
# 43 "/usr/include/boost/throw_exception.hpp" 3
# 1 "/usr/include/boost/exception/exception.hpp" 1 3 4
# 10 "/usr/include/boost/exception/exception.hpp" 3





namespace
boost
    {
    namespace
    exception_detail
        {
        template <class T>
        class
        refcount_ptr
            {
            public:

            refcount_ptr():
                px_(0)
                {
                }

            ~refcount_ptr()
                {
                release();
                }

            refcount_ptr( refcount_ptr const & x ):
                px_(x.px_)
                {
                add_ref();
                }

            refcount_ptr &
            operator=( refcount_ptr const & x )
                {
                adopt(x.px_);
                return *this;
                }

            void
            adopt( T * px )
                {
                release();
                px_=px;
                add_ref();
                }

            T *
            get() const
                {
                return px_;
                }

            private:

            T * px_;

            void
            add_ref()
                {
                if( px_ )
                    px_->add_ref();
                }

            void
            release()
                {
                if( px_ && px_->release() )
                    px_=0;
                }
            };
        }



    template <class Tag,class T>
    class error_info;

    typedef error_info<struct throw_function_,char const *> throw_function;
    typedef error_info<struct throw_file_,char const *> throw_file;
    typedef error_info<struct throw_line_,int> throw_line;

    template <>
    class
    error_info<throw_function_,char const *>
        {
        public:
        typedef char const * value_type;
        value_type v_;
        explicit
        error_info( value_type v ):
            v_(v)
            {
            }
        };

    template <>
    class
    error_info<throw_file_,char const *>
        {
        public:
        typedef char const * value_type;
        value_type v_;
        explicit
        error_info( value_type v ):
            v_(v)
            {
            }
        };

    template <>
    class
    error_info<throw_line_,int>
        {
        public:
        typedef int value_type;
        value_type v_;
        explicit
        error_info( value_type v ):
            v_(v)
            {
            }
        };



#pragma GCC visibility push (default)


 class exception;


#pragma GCC visibility pop



 template <class T>
    class shared_ptr;

    namespace
    exception_detail
        {
        class error_info_base;
        struct type_info_;

        struct
        error_info_container
            {
            virtual char const * diagnostic_information( char const * ) const = 0;
            virtual shared_ptr<error_info_base> get( type_info_ const & ) const = 0;
            virtual void set( shared_ptr<error_info_base> const &, type_info_ const & ) = 0;
            virtual void add_ref() const = 0;
            virtual bool release() const = 0;
            virtual refcount_ptr<exception_detail::error_info_container> clone() const = 0;

            protected:

            ~error_info_container() throw()
                {
                }
            };

        template <class>
        struct get_info;

        template <>
        struct get_info<throw_function>;

        template <>
        struct get_info<throw_file>;

        template <>
        struct get_info<throw_line>;

        char const * get_diagnostic_information( exception const &, char const * );

        void copy_boost_exception( exception *, exception const * );

        template <class E,class Tag,class T>
        E const & set_info( E const &, error_info<Tag,T> const & );

        template <class E>
        E const & set_info( E const &, throw_function const & );

        template <class E>
        E const & set_info( E const &, throw_file const & );

        template <class E>
        E const & set_info( E const &, throw_line const & );
        }



#pragma GCC visibility push (default)


 class
    exception
        {
        protected:

        exception():
            throw_function_(0),
            throw_file_(0),
            throw_line_(-1)
            {
            }
# 231 "/usr/include/boost/exception/exception.hpp" 3
        virtual ~exception() throw()

            = 0

            ;




        private:

        template <class E>
        friend E const & exception_detail::set_info( E const &, throw_function const & );

        template <class E>
        friend E const & exception_detail::set_info( E const &, throw_file const & );

        template <class E>
        friend E const & exception_detail::set_info( E const &, throw_line const & );

        template <class E,class Tag,class T>
        friend E const & exception_detail::set_info( E const &, error_info<Tag,T> const & );

        friend char const * exception_detail::get_diagnostic_information( exception const &, char const * );

        template <class>
        friend struct exception_detail::get_info;
        friend struct exception_detail::get_info<throw_function>;
        friend struct exception_detail::get_info<throw_file>;
        friend struct exception_detail::get_info<throw_line>;
        friend void exception_detail::copy_boost_exception( exception *, exception const * );

        mutable exception_detail::refcount_ptr<exception_detail::error_info_container> data_;
        mutable char const * throw_function_;
        mutable char const * throw_file_;
        mutable int throw_line_;
        };


#pragma GCC visibility pop



 inline
    exception::
    ~exception() throw()
        {
        }

    namespace
    exception_detail
        {
        template <class E>
        E const &
        set_info( E const & x, throw_function const & y )
            {
            x.throw_function_=y.v_;
            return x;
            }

        template <class E>
        E const &
        set_info( E const & x, throw_file const & y )
            {
            x.throw_file_=y.v_;
            return x;
            }

        template <class E>
        E const &
        set_info( E const & x, throw_line const & y )
            {
            x.throw_line_=y.v_;
            return x;
            }
        }



    namespace
    exception_detail
        {


#pragma GCC visibility push (default)


 template <class T>
        struct
        error_info_injector:
            public T,
            public exception
            {
            explicit
            error_info_injector( T const & x ):
                T(x)
                {
                }

            ~error_info_injector() throw()
                {
                }
            };


#pragma GCC visibility pop



 struct large_size { char c[256]; };
        large_size dispatch_boost_exception( exception const * );

        struct small_size { };
        small_size dispatch_boost_exception( void const * );

        template <class,int>
        struct enable_error_info_helper;

        template <class T>
        struct
        enable_error_info_helper<T,sizeof(large_size)>
            {
            typedef T type;
            };

        template <class T>
        struct
        enable_error_info_helper<T,sizeof(small_size)>
            {
            typedef error_info_injector<T> type;
            };

        template <class T>
        struct
        enable_error_info_return_type
            {
            typedef typename enable_error_info_helper<T,sizeof(exception_detail::dispatch_boost_exception(static_cast<T *>(0)))>::type type;
            };
        }

    template <class T>
    inline
    typename
    exception_detail::enable_error_info_return_type<T>::type
    enable_error_info( T const & x )
        {
        typedef typename exception_detail::enable_error_info_return_type<T>::type rt;
        return rt(x);
        }



    namespace
    exception_detail
        {


#pragma GCC visibility push (default)


 class
        clone_base
            {
            public:

            virtual clone_base const * clone() const = 0;
            virtual void rethrow() const = 0;

            virtual
            ~clone_base() throw()
                {
                }
            };


#pragma GCC visibility pop



 inline
        void
        copy_boost_exception( exception * a, exception const * b )
            {
            refcount_ptr<error_info_container> data;
            if( error_info_container * d=b->data_.get() )
                data = d->clone();
            a->throw_file_ = b->throw_file_;
            a->throw_line_ = b->throw_line_;
            a->throw_function_ = b->throw_function_;
            a->data_ = data;
            }

        inline
        void
        copy_boost_exception( void *, void const * )
            {
            }

        template <class T>
        class
        clone_impl:
            public T,
            public virtual clone_base
            {
            struct clone_tag { };
            clone_impl( clone_impl const & x, clone_tag ):
                T(x)
                {
                copy_boost_exception(this,&x);
                }

            public:

            explicit
            clone_impl( T const & x ):
                T(x)
                {
                copy_boost_exception(this,&x);
                }

            ~clone_impl() throw()
                {
                }

            private:

            clone_base const *
            clone() const
                {
                return new clone_impl(*this,clone_tag());
                }

            void
            rethrow() const
                {
                throw*this;
                }
            };
        }

    template <class T>
    inline
    exception_detail::clone_impl<T>
    enable_current_exception( T const & x )
        {
        return exception_detail::clone_impl<T>(x);
        }
    }
# 44 "/usr/include/boost/throw_exception.hpp" 2 3






namespace boost
{






inline void throw_exception_assert_compatibility( std::exception const & ) { }

template<class E> __attribute__((__noreturn__)) inline void throw_exception( E const & e )
{


    throw_exception_assert_compatibility(e);


    throw enable_current_exception(enable_error_info(e));



}




    namespace
    exception_detail
    {
        template <class E>
        __attribute__((__noreturn__))
        void
        throw_exception_( E const & x, char const * current_function, char const * file, int line )
        {
            boost::throw_exception(
                set_info(
                    set_info(
                        set_info(
                            enable_error_info(x),
                            throw_function(current_function)),
                        throw_file(file)),
                    throw_line(line)));
        }
    }

}
# 32 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 2 3 4
# 1 "/usr/include/boost/smart_ptr/detail/shared_count.hpp" 1 3 4
# 28 "/usr/include/boost/smart_ptr/detail/shared_count.hpp" 3 4
# 1 "/usr/include/boost/smart_ptr/bad_weak_ptr.hpp" 1 3 4
# 26 "/usr/include/boost/smart_ptr/bad_weak_ptr.hpp" 3 4
namespace boost
{
# 39 "/usr/include/boost/smart_ptr/bad_weak_ptr.hpp" 3 4
class bad_weak_ptr: public std::exception
{
public:

    virtual char const * what() const throw()
    {
        return "tr1::bad_weak_ptr";
    }
};





}
# 29 "/usr/include/boost/smart_ptr/detail/shared_count.hpp" 2 3 4
# 1 "/usr/include/boost/smart_ptr/detail/sp_counted_base.hpp" 1 3 4
# 21 "/usr/include/boost/smart_ptr/detail/sp_counted_base.hpp" 3 4
# 1 "/usr/include/boost/smart_ptr/detail/sp_has_sync.hpp" 1 3 4
# 22 "/usr/include/boost/smart_ptr/detail/sp_counted_base.hpp" 2 3 4
# 39 "/usr/include/boost/smart_ptr/detail/sp_counted_base.hpp" 3 4
# 1 "/usr/include/boost/smart_ptr/detail/sp_counted_base_gcc_x86.hpp" 1 3 4
# 27 "/usr/include/boost/smart_ptr/detail/sp_counted_base_gcc_x86.hpp" 3 4
# 1 "/usr/include/boost/detail/sp_typeinfo.hpp" 1 3 4
# 111 "/usr/include/boost/detail/sp_typeinfo.hpp" 3 4
namespace boost
{

namespace detail
{







typedef std::type_info sp_typeinfo;



}

}
# 28 "/usr/include/boost/smart_ptr/detail/sp_counted_base_gcc_x86.hpp" 2 3 4

namespace boost
{

namespace detail
{

inline int atomic_exchange_and_add( int * pw, int dv )
{




    int r;

    __asm__ __volatile__
    (
        "lock\n\t"
        "xadd %1, %0":
        "=m"( *pw ), "=r"( r ):
        "m"( *pw ), "1"( dv ):
        "memory", "cc"
    );

    return r;
}

inline void atomic_increment( int * pw )
{


    __asm__
    (
        "lock\n\t"
        "incl %0":
        "=m"( *pw ):
        "m"( *pw ):
        "cc"
    );
}

inline int atomic_conditional_increment( int * pw )
{




    int rv, tmp;

    __asm__
    (
        "movl %0, %%eax\n\t"
        "0:\n\t"
        "test %%eax, %%eax\n\t"
        "je 1f\n\t"
        "movl %%eax, %2\n\t"
        "incl %2\n\t"
        "lock\n\t"
        "cmpxchgl %2, %0\n\t"
        "jne 0b\n\t"
        "1:":
        "=m"( *pw ), "=&a"( rv ), "=&r"( tmp ):
        "m"( *pw ):
        "cc"
    );

    return rv;
}

class sp_counted_base
{
private:

    sp_counted_base( sp_counted_base const & );
    sp_counted_base & operator= ( sp_counted_base const & );

    int use_count_;
    int weak_count_;

public:

    sp_counted_base(): use_count_( 1 ), weak_count_( 1 )
    {
    }

    virtual ~sp_counted_base()
    {
    }




    virtual void dispose() = 0;



    virtual void destroy()
    {
        delete this;
    }

    virtual void * get_deleter( sp_typeinfo const & ti ) = 0;
    virtual void * get_untyped_deleter() = 0;

    void add_ref_copy()
    {
        atomic_increment( &use_count_ );
    }

    bool add_ref_lock()
    {
        return atomic_conditional_increment( &use_count_ ) != 0;
    }

    void release()
    {
        if( atomic_exchange_and_add( &use_count_, -1 ) == 1 )
        {
            dispose();
            weak_release();
        }
    }

    void weak_add_ref()
    {
        atomic_increment( &weak_count_ );
    }

    void weak_release()
    {
        if( atomic_exchange_and_add( &weak_count_, -1 ) == 1 )
        {
            destroy();
        }
    }

    long use_count() const
    {
        return static_cast<int const volatile &>( use_count_ );
    }
};

}

}
# 40 "/usr/include/boost/smart_ptr/detail/sp_counted_base.hpp" 2 3 4
# 30 "/usr/include/boost/smart_ptr/detail/shared_count.hpp" 2 3 4
# 1 "/usr/include/boost/smart_ptr/detail/sp_counted_impl.hpp" 1 3 4
# 38 "/usr/include/boost/smart_ptr/detail/sp_counted_impl.hpp" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 3


# 1 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/stddef.h" 1 3
# 43 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 2 3
# 39 "/usr/include/boost/smart_ptr/detail/sp_counted_impl.hpp" 2 3 4

namespace boost
{
# 50 "/usr/include/boost/smart_ptr/detail/sp_counted_impl.hpp" 3 4
namespace detail
{

template<class X> class sp_counted_impl_p: public sp_counted_base
{
private:

    X * px_;

    sp_counted_impl_p( sp_counted_impl_p const & );
    sp_counted_impl_p & operator= ( sp_counted_impl_p const & );

    typedef sp_counted_impl_p<X> this_type;

public:

    explicit sp_counted_impl_p( X * px ): px_( px )
    {



    }

    virtual void dispose()
    {



        boost::checked_delete( px_ );
    }

    virtual void * get_deleter( detail::sp_typeinfo const & )
    {
        return 0;
    }

    virtual void * get_untyped_deleter()
    {
        return 0;
    }
# 118 "/usr/include/boost/smart_ptr/detail/sp_counted_impl.hpp" 3 4
};
# 127 "/usr/include/boost/smart_ptr/detail/sp_counted_impl.hpp" 3 4
template<class P, class D> class sp_counted_impl_pd: public sp_counted_base
{
private:

    P ptr;
    D del;

    sp_counted_impl_pd( sp_counted_impl_pd const & );
    sp_counted_impl_pd & operator= ( sp_counted_impl_pd const & );

    typedef sp_counted_impl_pd<P, D> this_type;

public:



    sp_counted_impl_pd( P p, D & d ): ptr( p ), del( d )
    {
    }

    sp_counted_impl_pd( P p ): ptr( p ), del()
    {
    }

    virtual void dispose()
    {
        del( ptr );
    }

    virtual void * get_deleter( detail::sp_typeinfo const & ti )
    {
        return ti == typeid(D)? &reinterpret_cast<char&>( del ): 0;
    }

    virtual void * get_untyped_deleter()
    {
        return &reinterpret_cast<char&>( del );
    }
# 193 "/usr/include/boost/smart_ptr/detail/sp_counted_impl.hpp" 3 4
};

template<class P, class D, class A> class sp_counted_impl_pda: public sp_counted_base
{
private:

    P p_;
    D d_;
    A a_;

    sp_counted_impl_pda( sp_counted_impl_pda const & );
    sp_counted_impl_pda & operator= ( sp_counted_impl_pda const & );

    typedef sp_counted_impl_pda<P, D, A> this_type;

public:



    sp_counted_impl_pda( P p, D & d, A a ): p_( p ), d_( d ), a_( a )
    {
    }

    sp_counted_impl_pda( P p, A a ): p_( p ), d_(), a_( a )
    {
    }

    virtual void dispose()
    {
        d_( p_ );
    }

    virtual void destroy()
    {
        typedef typename A::template rebind< this_type >::other A2;

        A2 a2( a_ );

        this->~this_type();
        a2.deallocate( this, 1 );
    }

    virtual void * get_deleter( detail::sp_typeinfo const & ti )
    {
        return ti == typeid(D)? &reinterpret_cast<char&>( d_ ): 0;
    }

    virtual void * get_untyped_deleter()
    {
        return &reinterpret_cast<char&>( d_ );
    }
};





}

}
# 31 "/usr/include/boost/smart_ptr/detail/shared_count.hpp" 2 3 4
# 47 "/usr/include/boost/smart_ptr/detail/shared_count.hpp" 3 4
namespace boost
{

namespace detail
{
# 60 "/usr/include/boost/smart_ptr/detail/shared_count.hpp" 3 4
struct sp_nothrow_tag {};

template< class D > struct sp_inplace_tag
{
};
# 98 "/usr/include/boost/smart_ptr/detail/shared_count.hpp" 3 4
class weak_count;

class shared_count
{
private:

    sp_counted_base * pi_;





    friend class weak_count;

public:

    shared_count(): pi_(0)



    {
    }

    template<class Y> explicit shared_count( Y * p ): pi_( 0 )



    {


        try
        {
            pi_ = new sp_counted_impl_p<Y>( p );
        }
        catch(...)
        {
            boost::checked_delete( p );
            throw;
        }
# 149 "/usr/include/boost/smart_ptr/detail/shared_count.hpp" 3 4
    }




    template<class P, class D> shared_count( P p, D d ): pi_(0)




    {





        try
        {
            pi_ = new sp_counted_impl_pd<P, D>(p, d);
        }
        catch(...)
        {
            d(p);
            throw;
        }
# 186 "/usr/include/boost/smart_ptr/detail/shared_count.hpp" 3 4
    }



    template< class P, class D > shared_count( P p, sp_inplace_tag<D> ): pi_( 0 )



    {


        try
        {
            pi_ = new sp_counted_impl_pd< P, D >( p );
        }
        catch( ... )
        {
            D::operator_fn( p );
            throw;
        }
# 218 "/usr/include/boost/smart_ptr/detail/shared_count.hpp" 3 4
    }



    template<class P, class D, class A> shared_count( P p, D d, A a ): pi_( 0 )



    {
        typedef sp_counted_impl_pda<P, D, A> impl_type;
        typedef typename A::template rebind< impl_type >::other A2;

        A2 a2( a );



        try
        {
            pi_ = a2.allocate( 1, static_cast< impl_type* >( 0 ) );
            new( static_cast< void* >( pi_ ) ) impl_type( p, d, a );
        }
        catch(...)
        {
            d( p );

            if( pi_ != 0 )
            {
                a2.deallocate( static_cast< impl_type* >( pi_ ), 1 );
            }

            throw;
        }
# 266 "/usr/include/boost/smart_ptr/detail/shared_count.hpp" 3 4
    }



    template< class P, class D, class A > shared_count( P p, sp_inplace_tag< D >, A a ): pi_( 0 )



    {
        typedef sp_counted_impl_pda< P, D, A > impl_type;
        typedef typename A::template rebind< impl_type >::other A2;

        A2 a2( a );



        try
        {
            pi_ = a2.allocate( 1, static_cast< impl_type* >( 0 ) );
            new( static_cast< void* >( pi_ ) ) impl_type( p, a );
        }
        catch(...)
        {
            D::operator_fn( p );

            if( pi_ != 0 )
            {
                a2.deallocate( static_cast< impl_type* >( pi_ ), 1 );
            }

            throw;
        }
# 314 "/usr/include/boost/smart_ptr/detail/shared_count.hpp" 3 4
    }







    template<class Y>
    explicit shared_count( std::auto_ptr<Y> & r ): pi_( new sp_counted_impl_p<Y>( r.get() ) )



    {
# 337 "/usr/include/boost/smart_ptr/detail/shared_count.hpp" 3 4
        r.release();
    }
# 369 "/usr/include/boost/smart_ptr/detail/shared_count.hpp" 3 4
    ~shared_count()
    {
        if( pi_ != 0 ) pi_->release();



    }

    shared_count(shared_count const & r): pi_(r.pi_)



    {
        if( pi_ != 0 ) pi_->add_ref_copy();
    }



    shared_count(shared_count && r): pi_(r.pi_)



    {
        r.pi_ = 0;
    }



    explicit shared_count(weak_count const & r);
    shared_count( weak_count const & r, sp_nothrow_tag );

    shared_count & operator= (shared_count const & r)
    {
        sp_counted_base * tmp = r.pi_;

        if( tmp != pi_ )
        {
            if( tmp != 0 ) tmp->add_ref_copy();
            if( pi_ != 0 ) pi_->release();
            pi_ = tmp;
        }

        return *this;
    }

    void swap(shared_count & r)
    {
        sp_counted_base * tmp = r.pi_;
        r.pi_ = pi_;
        pi_ = tmp;
    }

    long use_count() const
    {
        return pi_ != 0? pi_->use_count(): 0;
    }

    bool unique() const
    {
        return use_count() == 1;
    }

    bool empty() const
    {
        return pi_ == 0;
    }

    friend inline bool operator==(shared_count const & a, shared_count const & b)
    {
        return a.pi_ == b.pi_;
    }

    friend inline bool operator<(shared_count const & a, shared_count const & b)
    {
        return std::less<sp_counted_base *>()( a.pi_, b.pi_ );
    }

    void * get_deleter( sp_typeinfo const & ti ) const
    {
        return pi_? pi_->get_deleter( ti ): 0;
    }

    void * get_untyped_deleter() const
    {
        return pi_? pi_->get_untyped_deleter(): 0;
    }
};


class weak_count
{
private:

    sp_counted_base * pi_;





    friend class shared_count;

public:

    weak_count(): pi_(0)



    {
    }

    weak_count(shared_count const & r): pi_(r.pi_)



    {
        if(pi_ != 0) pi_->weak_add_ref();
    }

    weak_count(weak_count const & r): pi_(r.pi_)



    {
        if(pi_ != 0) pi_->weak_add_ref();
    }





    weak_count(weak_count && r): pi_(r.pi_)



    {
        r.pi_ = 0;
    }



    ~weak_count()
    {
        if(pi_ != 0) pi_->weak_release();



    }

    weak_count & operator= (shared_count const & r)
    {
        sp_counted_base * tmp = r.pi_;

        if( tmp != pi_ )
        {
            if(tmp != 0) tmp->weak_add_ref();
            if(pi_ != 0) pi_->weak_release();
            pi_ = tmp;
        }

        return *this;
    }

    weak_count & operator= (weak_count const & r)
    {
        sp_counted_base * tmp = r.pi_;

        if( tmp != pi_ )
        {
            if(tmp != 0) tmp->weak_add_ref();
            if(pi_ != 0) pi_->weak_release();
            pi_ = tmp;
        }

        return *this;
    }

    void swap(weak_count & r)
    {
        sp_counted_base * tmp = r.pi_;
        r.pi_ = pi_;
        pi_ = tmp;
    }

    long use_count() const
    {
        return pi_ != 0? pi_->use_count(): 0;
    }

    bool empty() const
    {
        return pi_ == 0;
    }

    friend inline bool operator==(weak_count const & a, weak_count const & b)
    {
        return a.pi_ == b.pi_;
    }

    friend inline bool operator<(weak_count const & a, weak_count const & b)
    {
        return std::less<sp_counted_base *>()(a.pi_, b.pi_);
    }
};

inline shared_count::shared_count( weak_count const & r ): pi_( r.pi_ )



{
    if( pi_ == 0 || !pi_->add_ref_lock() )
    {
        boost::throw_exception( boost::bad_weak_ptr() );
    }
}

inline shared_count::shared_count( weak_count const & r, sp_nothrow_tag ): pi_( r.pi_ )



{
    if( pi_ != 0 && !pi_->add_ref_lock() )
    {
        pi_ = 0;
    }
}

}

}
# 33 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 2 3 4

# 1 "/usr/include/boost/smart_ptr/detail/sp_convertible.hpp" 1 3 4
# 34 "/usr/include/boost/smart_ptr/detail/sp_convertible.hpp" 3 4
namespace boost
{

namespace detail
{

template< class Y, class T > struct sp_convertible
{
    typedef char (&yes) [1];
    typedef char (&no) [2];

    static yes f( T* );
    static no f( ... );

    enum _vt { value = sizeof( (f)( static_cast<Y*>(0) ) ) == sizeof(yes) };
};

template< class Y, class T > struct sp_convertible< Y, T[] >
{
    enum _vt { value = false };
};

template< class Y, class T > struct sp_convertible< Y[], T[] >
{
    enum _vt { value = sp_convertible< Y[1], T[1] >::value };
};

template< class Y, std::size_t N, class T > struct sp_convertible< Y[N], T[] >
{
    enum _vt { value = sp_convertible< Y[1], T[1] >::value };
};

struct sp_empty
{
};

template< bool > struct sp_enable_if_convertible_impl;

template<> struct sp_enable_if_convertible_impl<true>
{
    typedef sp_empty type;
};

template<> struct sp_enable_if_convertible_impl<false>
{
};

template< class Y, class T > struct sp_enable_if_convertible: public sp_enable_if_convertible_impl< sp_convertible< Y, T >::value >
{
};

}

}
# 35 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 2 3 4
# 1 "/usr/include/boost/smart_ptr/detail/sp_nullptr_t.hpp" 1 3 4
# 19 "/usr/include/boost/smart_ptr/detail/sp_nullptr_t.hpp" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 3


# 1 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/stddef.h" 1 3
# 43 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 2 3
# 20 "/usr/include/boost/smart_ptr/detail/sp_nullptr_t.hpp" 2 3 4



namespace boost
{

namespace detail
{



    typedef decltype(nullptr) sp_nullptr_t;







}

}
# 36 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 2 3 4


# 1 "/usr/include/boost/smart_ptr/detail/spinlock_pool.hpp" 1 3 4
# 25 "/usr/include/boost/smart_ptr/detail/spinlock_pool.hpp" 3 4
# 1 "/usr/include/boost/smart_ptr/detail/spinlock.hpp" 1 3 4
# 41 "/usr/include/boost/smart_ptr/detail/spinlock.hpp" 3 4
# 1 "/usr/include/boost/smart_ptr/detail/spinlock_sync.hpp" 1 3 4
# 18 "/usr/include/boost/smart_ptr/detail/spinlock_sync.hpp" 3 4
# 1 "/usr/include/boost/smart_ptr/detail/yield_k.hpp" 1 3 4
# 91 "/usr/include/boost/smart_ptr/detail/yield_k.hpp" 3 4
namespace boost
{

namespace detail
{

inline void yield( unsigned k )
{
    if( k < 4 )
    {
    }

    else if( k < 16 )
    {
        __asm__ __volatile__( "rep; nop" : : : "memory" );
    }

    else if( k < 32 || k & 1 )
    {
        sched_yield();
    }
    else
    {

        struct timespec rqtp = { 0, 0 };




        rqtp.tv_sec = 0;
        rqtp.tv_nsec = 1000;

        nanosleep( &rqtp, 0 );
    }
}

}

}
# 19 "/usr/include/boost/smart_ptr/detail/spinlock_sync.hpp" 2 3 4





namespace boost
{

namespace detail
{

class spinlock
{
public:

    int v_;

public:

    bool try_lock()
    {
        int r = __sync_lock_test_and_set( &v_, 1 );
        return r == 0;
    }

    void lock()
    {
        for( unsigned k = 0; !try_lock(); ++k )
        {
            boost::detail::yield( k );
        }
    }

    void unlock()
    {
        __sync_lock_release( &v_ );
    }

public:

    class scoped_lock
    {
    private:

        spinlock & sp_;

        scoped_lock( scoped_lock const & );
        scoped_lock & operator=( scoped_lock const & );

    public:

        explicit scoped_lock( spinlock & sp ): sp_( sp )
        {
            sp.lock();
        }

        ~scoped_lock()
        {
            sp_.unlock();
        }
    };
};

}
}
# 42 "/usr/include/boost/smart_ptr/detail/spinlock.hpp" 2 3 4
# 26 "/usr/include/boost/smart_ptr/detail/spinlock_pool.hpp" 2 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 3


# 1 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/stddef.h" 1 3
# 43 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 2 3
# 27 "/usr/include/boost/smart_ptr/detail/spinlock_pool.hpp" 2 3 4

namespace boost
{

namespace detail
{

template< int I > class spinlock_pool
{
private:

    static spinlock pool_[ 41 ];

public:

    static spinlock & spinlock_for( void const * pv )
    {



        std::size_t i = reinterpret_cast< std::size_t >( pv ) % 41;

        return pool_[ i ];
    }

    class scoped_lock
    {
    private:

        spinlock & sp_;

        scoped_lock( scoped_lock const & );
        scoped_lock & operator=( scoped_lock const & );

    public:

        explicit scoped_lock( void const * pv ): sp_( spinlock_for( pv ) )
        {
            sp_.lock();
        }

        ~scoped_lock()
        {
            sp_.unlock();
        }
    };
};

template< int I > spinlock spinlock_pool< I >::pool_[ 41 ] =
{
    {0}, {0}, {0}, {0}, {0},
    {0}, {0}, {0}, {0}, {0},
    {0}, {0}, {0}, {0}, {0},
    {0}, {0}, {0}, {0}, {0},
    {0}, {0}, {0}, {0}, {0},
    {0}, {0}, {0}, {0}, {0},
    {0}, {0}, {0}, {0}, {0},
    {0}, {0}, {0}, {0}, {0},
    {0}
};

}
}
# 39 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 2 3 4
# 1 "/usr/include/boost/memory_order.hpp" 1 3 4
# 21 "/usr/include/boost/memory_order.hpp" 3 4
namespace boost
{
# 41 "/usr/include/boost/memory_order.hpp" 3 4
enum memory_order
{
    memory_order_relaxed = 0,
    memory_order_acquire = 1,
    memory_order_release = 2,
    memory_order_acq_rel = 3,
    memory_order_seq_cst = 7,
    memory_order_consume = 8
};

}
# 40 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 3


# 1 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/stddef.h" 1 3
# 43 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/cstddef" 2 3
# 46 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 2 3 4
# 55 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 3 4
namespace boost
{

template<class T> class shared_ptr;
template<class T> class weak_ptr;
template<class T> class enable_shared_from_this;
class enable_shared_from_raw;

namespace detail
{



template< class T > struct sp_element
{
    typedef T type;
};



template< class T > struct sp_element< T[] >
{
    typedef T type;
};



template< class T, std::size_t N > struct sp_element< T[N] >
{
    typedef T type;
};







template< class T > struct sp_dereference
{
    typedef T & type;
};

template<> struct sp_dereference< void >
{
    typedef void type;
};



template<> struct sp_dereference< void const >
{
    typedef void type;
};

template<> struct sp_dereference< void volatile >
{
    typedef void type;
};

template<> struct sp_dereference< void const volatile >
{
    typedef void type;
};





template< class T > struct sp_dereference< T[] >
{
    typedef void type;
};



template< class T, std::size_t N > struct sp_dereference< T[N] >
{
    typedef void type;
};







template< class T > struct sp_member_access
{
    typedef T * type;
};



template< class T > struct sp_member_access< T[] >
{
    typedef void type;
};



template< class T, std::size_t N > struct sp_member_access< T[N] >
{
    typedef void type;
};







template< class T > struct sp_array_access
{
    typedef void type;
};



template< class T > struct sp_array_access< T[] >
{
    typedef T & type;
};



template< class T, std::size_t N > struct sp_array_access< T[N] >
{
    typedef T & type;
};







template< class T > struct sp_extent
{
    enum _vt { value = 0 };
};



template< class T, std::size_t N > struct sp_extent< T[N] >
{
    enum _vt { value = N };
};





template< class X, class Y, class T > inline void sp_enable_shared_from_this( boost::shared_ptr<X> const * ppx, Y const * py, boost::enable_shared_from_this< T > const * pe )
{
    if( pe != 0 )
    {
        pe->_internal_accept_owner( ppx, const_cast< Y* >( py ) );
    }
}

template< class X, class Y > inline void sp_enable_shared_from_this( boost::shared_ptr<X> * ppx, Y const * py, boost::enable_shared_from_raw const * pe );
# 233 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 3 4
inline void sp_enable_shared_from_this( ... )
{
}







template< class T, class R > struct sp_enable_if_auto_ptr
{
};

template< class T, class R > struct sp_enable_if_auto_ptr< std::auto_ptr< T >, R >
{
    typedef R type;
};





template< class Y, class T > inline void sp_assert_convertible()
{



    typedef char tmp[ sp_convertible< Y, T >::value? 1: -1 ];
    (void)sizeof( tmp );







}



template< class T, class Y > inline void sp_pointer_construct( boost::shared_ptr< T > * ppx, Y * p, boost::detail::shared_count & pn )
{
    boost::detail::shared_count( p ).swap( pn );
    boost::detail::sp_enable_shared_from_this( ppx, p, p );
}



template< class T, class Y > inline void sp_pointer_construct( boost::shared_ptr< T[] > * , Y * p, boost::detail::shared_count & pn )
{
    sp_assert_convertible< Y[], T[] >();
    boost::detail::shared_count( p, boost::checked_array_deleter< T >() ).swap( pn );
}

template< class T, std::size_t N, class Y > inline void sp_pointer_construct( boost::shared_ptr< T[N] > * , Y * p, boost::detail::shared_count & pn )
{
    sp_assert_convertible< Y[N], T[N] >();
    boost::detail::shared_count( p, boost::checked_array_deleter< T >() ).swap( pn );
}





template< class T, class Y > inline void sp_deleter_construct( boost::shared_ptr< T > * ppx, Y * p )
{
    boost::detail::sp_enable_shared_from_this( ppx, p, p );
}



template< class T, class Y > inline void sp_deleter_construct( boost::shared_ptr< T[] > * , Y * )
{
    sp_assert_convertible< Y[], T[] >();
}

template< class T, std::size_t N, class Y > inline void sp_deleter_construct( boost::shared_ptr< T[N] > * , Y * )
{
    sp_assert_convertible< Y[N], T[N] >();
}



}
# 328 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 3 4
template<class T> class shared_ptr
{
private:


    typedef shared_ptr<T> this_type;

public:

    typedef typename boost::detail::sp_element< T >::type element_type;

    shared_ptr() noexcept : px( 0 ), pn()
    {
    }



    shared_ptr( boost::detail::sp_nullptr_t ) noexcept : px( 0 ), pn()
    {
    }



    template<class Y>
    explicit shared_ptr( Y * p ): px( p ), pn()
    {
        boost::detail::sp_pointer_construct( this, p, pn );
    }







    template<class Y, class D> shared_ptr( Y * p, D d ): px( p ), pn( p, d )
    {
        boost::detail::sp_deleter_construct( this, p );
    }



    template<class D> shared_ptr( boost::detail::sp_nullptr_t p, D d ): px( p ), pn( p, d )
    {
    }





    template<class Y, class D, class A> shared_ptr( Y * p, D d, A a ): px( p ), pn( p, d, a )
    {
        boost::detail::sp_deleter_construct( this, p );
    }



    template<class D, class A> shared_ptr( boost::detail::sp_nullptr_t p, D d, A a ): px( p ), pn( p, d, a )
    {
    }
# 397 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 3 4
    shared_ptr( shared_ptr const & r ) noexcept : px( r.px ), pn( r.pn )
    {
    }



    template<class Y>
    explicit shared_ptr( weak_ptr<Y> const & r ): pn( r.pn )
    {
        boost::detail::sp_assert_convertible< Y, T >();


        px = r.px;
    }

    template<class Y>
    shared_ptr( weak_ptr<Y> const & r, boost::detail::sp_nothrow_tag )
    noexcept : px( 0 ), pn( r.pn, boost::detail::sp_nothrow_tag() )
    {
        if( !pn.empty() )
        {
            px = r.px;
        }
    }

    template<class Y>


    shared_ptr( shared_ptr<Y> const & r, typename boost::detail::sp_enable_if_convertible<Y,T>::type = boost::detail::sp_empty() )






    noexcept : px( r.px ), pn( r.pn )
    {
        boost::detail::sp_assert_convertible< Y, T >();
    }


    template< class Y >
    shared_ptr( shared_ptr<Y> const & r, element_type * p ) noexcept : px( p ), pn( r.pn )
    {
    }



    template<class Y>
    explicit shared_ptr( std::auto_ptr<Y> & r ): px(r.get()), pn()
    {
        boost::detail::sp_assert_convertible< Y, T >();

        Y * tmp = r.get();
        pn = boost::detail::shared_count( r );

        boost::detail::sp_deleter_construct( this, tmp );
    }



    template<class Y>
    shared_ptr( std::auto_ptr<Y> && r ): px(r.get()), pn()
    {
        boost::detail::sp_assert_convertible< Y, T >();

        Y * tmp = r.get();
        pn = boost::detail::shared_count( r );

        boost::detail::sp_deleter_construct( this, tmp );
    }
# 505 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 3 4
    shared_ptr & operator=( shared_ptr const & r ) noexcept
    {
        this_type(r).swap(*this);
        return *this;
    }



    template<class Y>
    shared_ptr & operator=(shared_ptr<Y> const & r) noexcept
    {
        this_type(r).swap(*this);
        return *this;
    }





    template<class Y>
    shared_ptr & operator=( std::auto_ptr<Y> & r )
    {
        this_type( r ).swap( *this );
        return *this;
    }



    template<class Y>
    shared_ptr & operator=( std::auto_ptr<Y> && r )
    {
        this_type( static_cast< std::auto_ptr<Y> && >( r ) ).swap( *this );
        return *this;
    }
# 568 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 3 4
    shared_ptr( shared_ptr && r ) noexcept : px( r.px ), pn()
    {
        pn.swap( r.pn );
        r.px = 0;
    }

    template<class Y>


    shared_ptr( shared_ptr<Y> && r, typename boost::detail::sp_enable_if_convertible<Y,T>::type = boost::detail::sp_empty() )






    noexcept : px( r.px ), pn()
    {
        boost::detail::sp_assert_convertible< Y, T >();

        pn.swap( r.pn );
        r.px = 0;
    }

    shared_ptr & operator=( shared_ptr && r ) noexcept
    {
        this_type( static_cast< shared_ptr && >( r ) ).swap( *this );
        return *this;
    }

    template<class Y>
    shared_ptr & operator=( shared_ptr<Y> && r ) noexcept
    {
        this_type( static_cast< shared_ptr<Y> && >( r ) ).swap( *this );
        return *this;
    }





    shared_ptr & operator=( boost::detail::sp_nullptr_t ) noexcept
    {
        this_type().swap(*this);
        return *this;
    }



    void reset() noexcept
    {
        this_type().swap(*this);
    }

    template<class Y> void reset( Y * p )
    {
        ((p == 0 || p != px) ? static_cast<void> (0) : __assert_fail ("p == 0 || p != px", "/usr/include/boost/smart_ptr/shared_ptr.hpp", 624, __PRETTY_FUNCTION__));
        this_type( p ).swap( *this );
    }

    template<class Y, class D> void reset( Y * p, D d )
    {
        this_type( p, d ).swap( *this );
    }

    template<class Y, class D, class A> void reset( Y * p, D d, A a )
    {
        this_type( p, d, a ).swap( *this );
    }

    template<class Y> void reset( shared_ptr<Y> const & r, element_type * p )
    {
        this_type( r, p ).swap( *this );
    }


    typename boost::detail::sp_dereference< T >::type operator* () const
    {
        ((px != 0) ? static_cast<void> (0) : __assert_fail ("px != 0", "/usr/include/boost/smart_ptr/shared_ptr.hpp", 646, __PRETTY_FUNCTION__));
        return *px;
    }


    typename boost::detail::sp_member_access< T >::type operator-> () const
    {
        ((px != 0) ? static_cast<void> (0) : __assert_fail ("px != 0", "/usr/include/boost/smart_ptr/shared_ptr.hpp", 653, __PRETTY_FUNCTION__));
        return px;
    }


    typename boost::detail::sp_array_access< T >::type operator[] ( std::ptrdiff_t i ) const
    {
        ((px != 0) ? static_cast<void> (0) : __assert_fail ("px != 0", "/usr/include/boost/smart_ptr/shared_ptr.hpp", 660, __PRETTY_FUNCTION__));
        ((i >= 0 && ( i < boost::detail::sp_extent< T >::value || boost::detail::sp_extent< T >::value == 0 )) ? static_cast<void> (0) : __assert_fail ("i >= 0 && ( i < boost::detail::sp_extent< T >::value || boost::detail::sp_extent< T >::value == 0 )", "/usr/include/boost/smart_ptr/shared_ptr.hpp", 661, __PRETTY_FUNCTION__));

        return px[ i ];
    }

    element_type * get() const noexcept
    {
        return px;
    }



# 1 "/usr/include/boost/smart_ptr/detail/operator_bool.hpp" 1 3 4
# 11 "/usr/include/boost/smart_ptr/detail/operator_bool.hpp" 3 4
    explicit operator bool () const noexcept
    {
        return px != 0;
    }
# 60 "/usr/include/boost/smart_ptr/detail/operator_bool.hpp" 3 4
    bool operator! () const noexcept
    {
        return px == 0;
    }
# 673 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 2 3 4

    bool unique() const noexcept
    {
        return pn.unique();
    }

    long use_count() const noexcept
    {
        return pn.use_count();
    }

    void swap( shared_ptr & other ) noexcept
    {
        std::swap(px, other.px);
        pn.swap(other.pn);
    }

    template<class Y> bool owner_before( shared_ptr<Y> const & rhs ) const noexcept
    {
        return pn < rhs.pn;
    }

    template<class Y> bool owner_before( weak_ptr<Y> const & rhs ) const noexcept
    {
        return pn < rhs.pn;
    }

    void * _internal_get_deleter( boost::detail::sp_typeinfo const & ti ) const noexcept
    {
        return pn.get_deleter( ti );
    }

    void * _internal_get_untyped_deleter() const noexcept
    {
        return pn.get_untyped_deleter();
    }

    bool _internal_equiv( shared_ptr const & r ) const noexcept
    {
        return px == r.px && pn == r.pn;
    }






private:

    template<class Y> friend class shared_ptr;
    template<class Y> friend class weak_ptr;




    element_type * px;
    boost::detail::shared_count pn;

};

template<class T, class U> inline bool operator==(shared_ptr<T> const & a, shared_ptr<U> const & b) noexcept
{
    return a.get() == b.get();
}

template<class T, class U> inline bool operator!=(shared_ptr<T> const & a, shared_ptr<U> const & b) noexcept
{
    return a.get() != b.get();
}
# 756 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 3 4
template<class T> inline bool operator==( shared_ptr<T> const & p, boost::detail::sp_nullptr_t ) noexcept
{
    return p.get() == 0;
}

template<class T> inline bool operator==( boost::detail::sp_nullptr_t, shared_ptr<T> const & p ) noexcept
{
    return p.get() == 0;
}

template<class T> inline bool operator!=( shared_ptr<T> const & p, boost::detail::sp_nullptr_t ) noexcept
{
    return p.get() != 0;
}

template<class T> inline bool operator!=( boost::detail::sp_nullptr_t, shared_ptr<T> const & p ) noexcept
{
    return p.get() != 0;
}



template<class T, class U> inline bool operator<(shared_ptr<T> const & a, shared_ptr<U> const & b) noexcept
{
    return a.owner_before( b );
}

template<class T> inline void swap(shared_ptr<T> & a, shared_ptr<T> & b) noexcept
{
    a.swap(b);
}

template<class T, class U> shared_ptr<T> static_pointer_cast( shared_ptr<U> const & r ) noexcept
{
    (void) static_cast< T* >( static_cast< U* >( 0 ) );

    typedef typename shared_ptr<T>::element_type E;

    E * p = static_cast< E* >( r.get() );
    return shared_ptr<T>( r, p );
}

template<class T, class U> shared_ptr<T> const_pointer_cast( shared_ptr<U> const & r ) noexcept
{
    (void) const_cast< T* >( static_cast< U* >( 0 ) );

    typedef typename shared_ptr<T>::element_type E;

    E * p = const_cast< E* >( r.get() );
    return shared_ptr<T>( r, p );
}

template<class T, class U> shared_ptr<T> dynamic_pointer_cast( shared_ptr<U> const & r ) noexcept
{
    (void) dynamic_cast< T* >( static_cast< U* >( 0 ) );

    typedef typename shared_ptr<T>::element_type E;

    E * p = dynamic_cast< E* >( r.get() );
    return p? shared_ptr<T>( r, p ): shared_ptr<T>();
}

template<class T, class U> shared_ptr<T> reinterpret_pointer_cast( shared_ptr<U> const & r ) noexcept
{
    (void) reinterpret_cast< T* >( static_cast< U* >( 0 ) );

    typedef typename shared_ptr<T>::element_type E;

    E * p = reinterpret_cast< E* >( r.get() );
    return shared_ptr<T>( r, p );
}



template<class T> inline typename shared_ptr<T>::element_type * get_pointer(shared_ptr<T> const & p) noexcept
{
    return p.get();
}
# 857 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 3 4
template<class E, class T, class Y> std::basic_ostream<E, T> & operator<< (std::basic_ostream<E, T> & os, shared_ptr<Y> const & p)

{
    os << p.get();
    return os;
}
# 872 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 3 4
namespace detail
{
# 890 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 3 4
template<class D, class T> D * basic_get_deleter( shared_ptr<T> const & p ) noexcept
{
    return static_cast<D *>( p._internal_get_deleter(typeid(D)) );
}



class esft2_deleter_wrapper
{
private:

    shared_ptr<void> deleter_;

public:

    esft2_deleter_wrapper()
    {
    }

    template< class T > void set_deleter( shared_ptr<T> const & deleter )
    {
        deleter_ = deleter;
    }

    template<typename D> D* get_deleter() const noexcept
    {
        return boost::detail::basic_get_deleter<D>( deleter_ );
    }

    template< class T> void operator()( T* )
    {
        ((deleter_.use_count() <= 1) ? static_cast<void> (0) : __assert_fail ("deleter_.use_count() <= 1", "/usr/include/boost/smart_ptr/shared_ptr.hpp", 921, __PRETTY_FUNCTION__));
        deleter_.reset();
    }
};

}

template<class D, class T> D * get_deleter( shared_ptr<T> const & p ) noexcept
{
    D *del = boost::detail::basic_get_deleter<D>(p);

    if(del == 0)
    {
        boost::detail::esft2_deleter_wrapper *del_wrapper = boost::detail::basic_get_deleter<boost::detail::esft2_deleter_wrapper>(p);


        if(del_wrapper) del = del_wrapper->::boost::detail::esft2_deleter_wrapper::get_deleter<D>();
    }

    return del;
}





template<class T> inline bool atomic_is_lock_free( shared_ptr<T> const * ) noexcept
{
    return false;
}

template<class T> shared_ptr<T> atomic_load( shared_ptr<T> const * p )
{
    boost::detail::spinlock_pool<2>::scoped_lock lock( p );
    return *p;
}

template<class T> inline shared_ptr<T> atomic_load_explicit( shared_ptr<T> const * p, memory_order )
{
    return atomic_load( p );
}

template<class T> void atomic_store( shared_ptr<T> * p, shared_ptr<T> r )
{
    boost::detail::spinlock_pool<2>::scoped_lock lock( p );
    p->swap( r );
}

template<class T> inline void atomic_store_explicit( shared_ptr<T> * p, shared_ptr<T> r, memory_order )
{
    atomic_store( p, r );
}

template<class T> shared_ptr<T> atomic_exchange( shared_ptr<T> * p, shared_ptr<T> r )
{
    boost::detail::spinlock & sp = boost::detail::spinlock_pool<2>::spinlock_for( p );

    sp.lock();
    p->swap( r );
    sp.unlock();

    return r;
}

template<class T> shared_ptr<T> atomic_exchange_explicit( shared_ptr<T> * p, shared_ptr<T> r, memory_order )
{
    return atomic_exchange( p, r );
}

template<class T> bool atomic_compare_exchange( shared_ptr<T> * p, shared_ptr<T> * v, shared_ptr<T> w )
{
    boost::detail::spinlock & sp = boost::detail::spinlock_pool<2>::spinlock_for( p );

    sp.lock();

    if( p->_internal_equiv( *v ) )
    {
        p->swap( w );

        sp.unlock();

        return true;
    }
    else
    {
        shared_ptr<T> tmp( *p );

        sp.unlock();

        tmp.swap( *v );
        return false;
    }
}

template<class T> inline bool atomic_compare_exchange_explicit( shared_ptr<T> * p, shared_ptr<T> * v, shared_ptr<T> w, memory_order , memory_order )
{
    return atomic_compare_exchange( p, v, w );
}





template< class T > struct hash;

template< class T > std::size_t hash_value( boost::shared_ptr<T> const & p ) noexcept
{
    return boost::hash< T* >()( p.get() );
}

}
# 18 "/usr/include/boost/shared_ptr.hpp" 2 3 4
# 22 "/usr/include/boost/format/alt_sstream.hpp" 2 3 4
# 1 "/usr/include/boost/assert.hpp" 1 3 4
# 50 "/usr/include/boost/assert.hpp" 3 4
# 1 "/usr/include/assert.h" 1 3 4
# 51 "/usr/include/boost/assert.hpp" 2 3 4
# 23 "/usr/include/boost/format/alt_sstream.hpp" 2 3 4

namespace boost {
    namespace io {

        template<class Ch, class Tr=::std::char_traits<Ch>,
                 class Alloc=::std::allocator<Ch> >
        class basic_altstringbuf;

        template<class Ch, class Tr =::std::char_traits<Ch>,
                 class Alloc=::std::allocator<Ch> >
        class basic_oaltstringstream;


        template<class Ch, class Tr, class Alloc>
        class basic_altstringbuf
            : public ::std::basic_streambuf<Ch, Tr>
        {
            typedef ::std::basic_streambuf<Ch, Tr> streambuf_t;
            typedef typename CompatAlloc<Alloc>::compatible_type compat_allocator_type;
            typedef typename CompatTraits<Tr>::compatible_type compat_traits_type;
        public:
            typedef Ch char_type;
            typedef Tr traits_type;
            typedef typename compat_traits_type::int_type int_type;
            typedef typename compat_traits_type::pos_type pos_type;
            typedef typename compat_traits_type::off_type off_type;
            typedef Alloc allocator_type;
            typedef ::std::basic_string<Ch, Tr, Alloc> string_type;
            typedef typename string_type::size_type size_type;

            typedef ::std::streamsize streamsize;


            explicit basic_altstringbuf(std::ios_base::openmode mode
                                        = std::ios_base::in | std::ios_base::out)
                : putend_(__null), is_allocated_(false), mode_(mode)
                {}
            explicit basic_altstringbuf(const string_type& s,
                                        ::std::ios_base::openmode mode
                                        = ::std::ios_base::in | ::std::ios_base::out)
                : putend_(__null), is_allocated_(false), mode_(mode)
                { dealloc(); str(s); }
            virtual ~basic_altstringbuf()
                { dealloc(); }
            using streambuf_t::pbase;
            using streambuf_t::pptr;
            using streambuf_t::epptr;
            using streambuf_t::eback;
            using streambuf_t::gptr;
            using streambuf_t::egptr;

            void clear_buffer();
            void str(const string_type& s);


            Ch * begin() const;
            size_type size() const;
            size_type cur_size() const;
            Ch * pend() const
                { return ((putend_ < pptr()) ? pptr() : putend_); }
            size_type pcount() const
                { return static_cast<size_type>( pptr() - pbase()) ;}


            string_type str() const
                { return string_type(begin(), size()); }
            string_type cur_str() const
                { return string_type(begin(), cur_size()); }
        protected:
            explicit basic_altstringbuf (basic_altstringbuf * s,
                                         ::std::ios_base::openmode mode
                                         = ::std::ios_base::in | ::std::ios_base::out)
                : putend_(__null), is_allocated_(false), mode_(mode)
                { dealloc(); str(s); }

            virtual pos_type seekoff(off_type off, ::std::ios_base::seekdir way,
                                     ::std::ios_base::openmode which
                                     = ::std::ios_base::in | ::std::ios_base::out);
            virtual pos_type seekpos (pos_type pos,
                                      ::std::ios_base::openmode which
                                      = ::std::ios_base::in | ::std::ios_base::out);
            virtual int_type underflow();
            virtual int_type pbackfail(int_type meta = compat_traits_type::eof());
            virtual int_type overflow(int_type meta = compat_traits_type::eof());
            void dealloc();
        private:
            enum { alloc_min = 256};

            Ch *putend_;
            bool is_allocated_;
            ::std::ios_base::openmode mode_;
            compat_allocator_type alloc_;
        };



        template <class Ch, class Tr, class Alloc>
        class basic_oaltstringstream
            : private base_from_member< shared_ptr< basic_altstringbuf< Ch, Tr, Alloc> > >,
              public ::std::basic_ostream<Ch, Tr>
        {
            class No_Op {

            public:
                template<class T>
                const T & operator()(const T & arg) { return arg; }
            };
            typedef ::std::basic_ostream<Ch, Tr> stream_t;
            typedef boost::base_from_member<boost::shared_ptr<
                basic_altstringbuf<Ch,Tr, Alloc> > >
                pbase_type;
            typedef ::std::basic_string<Ch, Tr, Alloc> string_type;
            typedef typename string_type::size_type size_type;
            typedef basic_altstringbuf<Ch, Tr, Alloc> stringbuf_t;
        public:
            typedef Alloc allocator_type;
            basic_oaltstringstream()
                : pbase_type(new stringbuf_t), stream_t(rdbuf())
                { }
            basic_oaltstringstream(::boost::shared_ptr<stringbuf_t> buf)
                : pbase_type(buf), stream_t(rdbuf())
                { }
            basic_oaltstringstream(stringbuf_t * buf)
                : pbase_type(buf, No_Op() ), stream_t(rdbuf())
                { }
            stringbuf_t * rdbuf() const
                { return pbase_type::member.get(); }
            void clear_buffer()
                { rdbuf()->clear_buffer(); }


            Ch * begin() const
                { return rdbuf()->begin(); }
            size_type size() const
                { return rdbuf()->size(); }
            size_type cur_size() const
                { return rdbuf()->cur_size(); }


            string_type str() const
                { return rdbuf()->str(); }
            string_type cur_str() const
                { return rdbuf()->cur_str(); }
            void str(const string_type& s)
                { rdbuf()->str(s); }
        };

    }
}


# 1 "/usr/include/boost/format/alt_sstream_impl.hpp" 1 3 4
# 16 "/usr/include/boost/format/alt_sstream_impl.hpp" 3 4
namespace boost {
    namespace io {


        template<class Ch, class Tr, class Alloc>
        void basic_altstringbuf<Ch, Tr, Alloc>::
        clear_buffer () {
            const Ch * p = pptr();
            const Ch * b = pbase();
            if(p != __null && p != b) {
                seekpos(0, ::std::ios_base::out);
            }
            p = gptr();
            b = eback();
            if(p != __null && p != b) {
                seekpos(0, ::std::ios_base::in);
            }
        }

        template<class Ch, class Tr, class Alloc>
        void basic_altstringbuf<Ch, Tr, Alloc>::
        str (const string_type& s) {
            size_type sz=s.size();
            if(sz != 0 && mode_ & (::std::ios_base::in | ::std::ios_base::out) ) {




                Ch *new_ptr = alloc_.allocate(sz, is_allocated_? eback() : 0);


                dealloc();
                sz = s.copy(new_ptr, sz);
                putend_ = new_ptr + sz;
                if(mode_ & ::std::ios_base::in)
                    streambuf_t::setg(new_ptr, new_ptr, new_ptr + sz);
                if(mode_ & ::std::ios_base::out) {
                    streambuf_t::setp(new_ptr, new_ptr + sz);
                    if(mode_ & (::std::ios_base::app | ::std::ios_base::ate))
                        streambuf_t::pbump(static_cast<int>(sz));
                    if(gptr() == __null)
                        streambuf_t::setg(new_ptr, __null, new_ptr);
                }
                is_allocated_ = true;
            }
            else
                dealloc();
        }
        template<class Ch, class Tr, class Alloc>
        Ch* basic_altstringbuf<Ch, Tr, Alloc>::
        begin () const {
            if(mode_ & ::std::ios_base::out && pptr() != __null)
                return pbase();
            else if(mode_ & ::std::ios_base::in && gptr() != __null)
                return eback();
            return __null;
        }

        template<class Ch, class Tr, class Alloc>
        typename std::basic_string<Ch,Tr,Alloc>::size_type
        basic_altstringbuf<Ch, Tr, Alloc>::
        size () const {
            if(mode_ & ::std::ios_base::out && pptr())
                return static_cast<size_type>(pend() - pbase());
            else if(mode_ & ::std::ios_base::in && gptr())
                return static_cast<size_type>(egptr() - eback());
            else
                return 0;
        }

        template<class Ch, class Tr, class Alloc>
        typename std::basic_string<Ch,Tr,Alloc>::size_type
        basic_altstringbuf<Ch, Tr, Alloc>::
        cur_size () const {
            if(mode_ & ::std::ios_base::out && pptr())
                return static_cast<streamsize>( pptr() - pbase());
            else if(mode_ & ::std::ios_base::in && gptr())
                return static_cast<streamsize>( gptr() - eback());
            else
                return 0;
        }

        template<class Ch, class Tr, class Alloc>
        typename basic_altstringbuf<Ch, Tr, Alloc>::pos_type
        basic_altstringbuf<Ch, Tr, Alloc>::
        seekoff (off_type off, ::std::ios_base::seekdir way, ::std::ios_base::openmode which) {
            if(pptr() != __null && putend_ < pptr())
                putend_ = pptr();
            if(which & ::std::ios_base::in && gptr() != __null) {

                if(way == ::std::ios_base::end)
                    off += static_cast<off_type>(putend_ - gptr());
                else if(way == ::std::ios_base::beg)
                    off += static_cast<off_type>(eback() - gptr());
                else if(way != ::std::ios_base::cur || (which & ::std::ios_base::out) )

                    return pos_type(off_type(-1));
                if(eback() <= off+gptr() && off+gptr() <= putend_ ) {

                    streambuf_t::gbump(static_cast<int>(off));
                    if(which & ::std::ios_base::out && pptr() != __null)

                        streambuf_t::pbump(static_cast<int>(gptr()-pptr()));
                }
                else
                    off = off_type(-1);
            }
            else if(which & ::std::ios_base::out && pptr() != __null) {

                if(way == ::std::ios_base::end)
                    off += static_cast<off_type>(putend_ - pptr());
                else if(way == ::std::ios_base::beg)
                    off += static_cast<off_type>(pbase() - pptr());
                else if(way != ::std::ios_base::beg)
                    return pos_type(off_type(-1));
                if(pbase() <= off+pptr() && off+pptr() <= putend_)

                    streambuf_t::pbump(static_cast<int>(off));
                else
                    off = off_type(-1);
            }
            else
                off = off_type(-1);
            return (pos_type(off));
        }



        template<class Ch, class Tr, class Alloc>
        typename basic_altstringbuf<Ch, Tr, Alloc>::pos_type
        basic_altstringbuf<Ch, Tr, Alloc>::
        seekpos (pos_type pos, ::std::ios_base::openmode which) {
            off_type off = off_type(pos);
            if(pptr() != __null && putend_ < pptr())
                putend_ = pptr();
            if(off != off_type(-1)) {
                if(which & ::std::ios_base::in && gptr() != __null) {

                    if(0 <= off && off <= putend_ - eback()) {
                        streambuf_t::gbump(static_cast<int>(eback() - gptr() + off));
                        if(which & ::std::ios_base::out && pptr() != __null) {

                            streambuf_t::pbump(static_cast<int>(gptr()-pptr()));
                        }
                    }
                    else
                        off = off_type(-1);
                }
                else if(which & ::std::ios_base::out && pptr() != __null) {

                    if(0 <= off && off <= putend_ - eback())
                        streambuf_t::pbump(static_cast<int>(eback() - pptr() + off));
                    else
                        off = off_type(-1);
                }
                else
                    off = off_type(-1);
                return (pos_type(off));
            }
            else {
                ((0) ? static_cast<void> (0) : __assert_fail ("0", "/usr/include/boost/format/alt_sstream_impl.hpp", 176, __PRETTY_FUNCTION__));
                return pos_type(off_type(-1));
            }
        }



        template<class Ch, class Tr, class Alloc>
        typename basic_altstringbuf<Ch, Tr, Alloc>::int_type
        basic_altstringbuf<Ch, Tr, Alloc>::
        underflow () {
            if(gptr() == __null)
                return (compat_traits_type::eof());
            else if(gptr() < egptr())
                return (compat_traits_type::to_int_type(*gptr()));
            else if(mode_ & ::std::ios_base::in && pptr() != __null
                    && (gptr() < pptr() || gptr() < putend_) )
                {
                    if(putend_ < pptr())
                        putend_ = pptr();
                    streambuf_t::setg(eback(), gptr(), putend_);
                    return (compat_traits_type::to_int_type(*gptr()));
                }
            else
                return (compat_traits_type::eof());
        }



        template<class Ch, class Tr, class Alloc>
        typename basic_altstringbuf<Ch, Tr, Alloc>::int_type
        basic_altstringbuf<Ch, Tr, Alloc>::
        pbackfail (int_type meta) {
            if(gptr() != __null && (eback() < gptr())
               && (mode_ & (::std::ios_base::out)
                   || compat_traits_type::eq_int_type(compat_traits_type::eof(), meta)
                   || compat_traits_type::eq(compat_traits_type::to_char_type(meta), gptr()[-1]) ) ) {
                streambuf_t::gbump(-1);
                if(!compat_traits_type::eq_int_type(compat_traits_type::eof(), meta))

                    *gptr() = compat_traits_type::to_char_type(meta);
                return (compat_traits_type::not_eof(meta));
            }
            else
                return (compat_traits_type::eof());
        }



        template<class Ch, class Tr, class Alloc>
        typename basic_altstringbuf<Ch, Tr, Alloc>::int_type
        basic_altstringbuf<Ch, Tr, Alloc>::
        overflow (int_type meta) {




            if(compat_traits_type::eq_int_type(compat_traits_type::eof(), meta))
                return compat_traits_type::not_eof(meta);
            else if(pptr() != __null && pptr() < epptr()) {
                streambuf_t::sputc(compat_traits_type::to_char_type(meta));
                return meta;
            }
            else if(! (mode_ & ::std::ios_base::out))

                return compat_traits_type::eof();
            else {
                std::size_t prev_size = pptr() == __null ? 0 : epptr() - eback();
                std::size_t new_size = prev_size;

                std::size_t add_size = new_size / 2;
                if(add_size < alloc_min)
                    add_size = alloc_min;
                Ch * newptr = __null, *oldptr = eback();


                while (0 < add_size && ((std::numeric_limits<std::size_t>::max)()
                                        - add_size < new_size) )
                    add_size /= 2;
                if(0 < add_size) {
                    new_size += add_size;




                    newptr = alloc_.allocate(new_size, is_allocated_? oldptr : 0);

                }

                if(0 < prev_size)
                    compat_traits_type::copy(newptr, oldptr, prev_size);
                if(is_allocated_)
                    alloc_.deallocate(oldptr, prev_size);
                is_allocated_=true;

                if(prev_size == 0) {
                    putend_ = newptr;
                    streambuf_t::setp(newptr, newptr + new_size);
                    if(mode_ & ::std::ios_base::in)
                        streambuf_t::setg(newptr, newptr, newptr + 1);
                    else
                        streambuf_t::setg(newptr, 0, newptr);
                }
                else {
                    putend_ = putend_ - oldptr + newptr;
                    int pptr_count = static_cast<int>(pptr()-pbase());
                    int gptr_count = static_cast<int>(gptr()-eback());
                    streambuf_t::setp(pbase() - oldptr + newptr, newptr + new_size);
                    streambuf_t::pbump(pptr_count);
                    if(mode_ & ::std::ios_base::in)
                        streambuf_t::setg(newptr, newptr + gptr_count, pptr() + 1);
                    else
                        streambuf_t::setg(newptr, 0, newptr);
                }
                streambuf_t::sputc(compat_traits_type::to_char_type(meta));
                return meta;
            }



        }


        template<class Ch, class Tr, class Alloc>
        void basic_altstringbuf<Ch, Tr, Alloc>:: dealloc() {
            if(is_allocated_)
                alloc_.deallocate(eback(), (pptr() != __null ? epptr() : egptr()) - eback());
            is_allocated_ = false;
            streambuf_t::setg(0, 0, 0);
            streambuf_t::setp(0, 0);
            putend_ = __null;
        }

    }
}
# 174 "/usr/include/boost/format/alt_sstream.hpp" 2 3 4
# 24 "/usr/include/boost/format/internals.hpp" 2 3 4

namespace boost {
namespace io {
namespace detail {





    template<class Ch, class Tr>
    struct stream_format_state
    {
        typedef ::std:: basic_ios<Ch, Tr> basic_ios;

        stream_format_state(Ch fill) { reset(fill); }


        void reset(Ch fill);
        void set_by_stream(const basic_ios& os);
        void apply_on(basic_ios & os,
                      boost::io::detail::locale_t * loc_default = 0) const;
        template<class T>
        void apply_manip(T manipulator)
            { apply_manip_body<Ch, Tr, T>( *this, manipulator) ; }


        std::streamsize width_;
        std::streamsize precision_;
        Ch fill_;
        std::ios_base::fmtflags flags_;
        std::ios_base::iostate rdstate_;
        std::ios_base::iostate exceptions_;
        boost::optional<boost::io::detail::locale_t> loc_;
    };





    template<class Ch, class Tr, class Alloc>
    struct format_item
    {
        enum pad_values { zeropad = 1, spacepad =2, centered=4, tabulation = 8 };



        enum arg_values { argN_no_posit = -1,
                          argN_tabulation = -2,
                          argN_ignored = -3
        };
        typedef ::std:: basic_ios<Ch, Tr> basic_ios;
        typedef detail::stream_format_state<Ch, Tr> stream_format_state;
        typedef ::std::basic_string<Ch, Tr, Alloc> string_type;

        format_item(Ch fill) :argN_(argN_no_posit), fmtstate_(fill),
                              truncate_(max_streamsize()), pad_scheme_(0) {}
        void reset(Ch fill);
        void compute_states();

        static std::streamsize max_streamsize() {
            return (std::numeric_limits<std::streamsize>::max)();
        }


        int argN_;

        string_type res_;
        string_type appendix_;

        stream_format_state fmtstate_;

        std::streamsize truncate_;
        unsigned int pad_scheme_;
    };






    template<class Ch, class Tr>
    void stream_format_state<Ch,Tr>:: apply_on (basic_ios & os,
                      boost::io::detail::locale_t * loc_default) const {

        if(width_ != -1)
            os.width(width_);
        if(precision_ != -1)
            os.precision(precision_);
        if(fill_ != 0)
            os.fill(fill_);
        os.flags(flags_);
        os.clear(rdstate_);
        os.exceptions(exceptions_);

        if(loc_)
            os.imbue(loc_.get());
        else if(loc_default)
            os.imbue(*loc_default);



    }

    template<class Ch, class Tr>
    void stream_format_state<Ch,Tr>:: set_by_stream(const basic_ios& os) {

        flags_ = os.flags();
        width_ = os.width();
        precision_ = os.precision();
        fill_ = os.fill();
        rdstate_ = os.rdstate();
        exceptions_ = os.exceptions();
    }


    template<class Ch, class Tr, class T>
    void apply_manip_body( stream_format_state<Ch, Tr>& self,
                           T manipulator) {

        basic_oaltstringstream<Ch, Tr> ss;
        self.apply_on( ss );
        ss << manipulator;
        self.set_by_stream( ss );
    }

    template<class Ch, class Tr> inline
    void stream_format_state<Ch,Tr>:: reset(Ch fill) {

        width_=0; precision_=6;
        fill_=fill;
        flags_ = std::ios_base::dec | std::ios_base::skipws;

        exceptions_ = std::ios_base::goodbit;
        rdstate_ = std::ios_base::goodbit;
    }




    template<class Ch, class Tr, class Alloc>
    void format_item<Ch, Tr, Alloc>::
    reset (Ch fill) {
        argN_=argN_no_posit; truncate_ = max_streamsize(); pad_scheme_ =0;
        res_.resize(0); appendix_.resize(0);
        fmtstate_.reset(fill);
    }

    template<class Ch, class Tr, class Alloc>
    void format_item<Ch, Tr, Alloc>::
    compute_states() {


        if(pad_scheme_ & zeropad) {

            if(fmtstate_.flags_ & std::ios_base::left) {
              ((!(fmtstate_.flags_ &(std::ios_base::adjustfield ^std::ios_base::left))) ? static_cast<void> (0) : __assert_fail ("!(fmtstate_.flags_ &(std::ios_base::adjustfield ^std::ios_base::left))", "/usr/include/boost/format/internals.hpp", 179, __PRETTY_FUNCTION__));

              pad_scheme_ = pad_scheme_ & (~zeropad);
            }
            else {
                pad_scheme_ &= ~spacepad;
                fmtstate_.fill_='0';
                fmtstate_.flags_ = (fmtstate_.flags_ & ~std::ios_base::adjustfield)
                    | std::ios_base::internal;

            }
        }
        if(pad_scheme_ & spacepad) {
            if(fmtstate_.flags_ & std::ios_base::showpos)
                pad_scheme_ &= ~spacepad;
        }
    }


} } }
# 39 "/usr/include/boost/format.hpp" 2 3 4


# 1 "/usr/include/boost/format/format_class.hpp" 1 3 4
# 27 "/usr/include/boost/format/format_class.hpp" 3 4
namespace boost {

    template<class Ch, class Tr, class Alloc>
    class basic_format
    {
        typedef typename io::CompatTraits<Tr>::compatible_type compat_traits;
    public:
        typedef Ch CharT;
        typedef std::basic_string<Ch, Tr, Alloc> string_type;
        typedef typename string_type::size_type size_type;
        typedef io::detail::format_item<Ch, Tr, Alloc> format_item_t;
        typedef io::basic_altstringbuf<Ch, Tr, Alloc> internal_streambuf_t;


        explicit basic_format(const Ch* str=__null);
        explicit basic_format(const string_type& s);
        basic_format(const basic_format& x);
        basic_format& operator= (const basic_format& x);
        void swap(basic_format& x);


        explicit basic_format(const Ch* str, const std::locale & loc);
        explicit basic_format(const string_type& s, const std::locale & loc);

        io::detail::locale_t getloc() const;

        basic_format& clear();
        basic_format& clear_binds();
        basic_format& parse(const string_type&);


        size_type size() const;
        string_type str() const;


        template<class T>
        basic_format& operator%(const T& x)
            { return io::detail::feed<CharT, Tr, Alloc, const T&>(*this,x); }


        template<class T> basic_format& operator%(T& x)
            { return io::detail::feed<CharT, Tr, Alloc, T&>(*this,x); }





        basic_format& operator%(const int& x)
            { return io::detail::feed<CharT, Tr, Alloc, const int&>(*this,x); }


        basic_format& operator%(int& x)
            { return io::detail::feed<CharT, Tr, Alloc, int&>(*this,x); }




        int expected_args() const
            { return num_args_; }

        int bound_args() const;

        int fed_args() const;

        int cur_arg() const;

        int remaining_args() const;



        template<class T>
        basic_format& bind_arg(int argN, const T& val)
            { return io::detail::bind_arg_body(*this, argN, val); }
        basic_format& clear_bind(int argN);
        template<class T>
        basic_format& modify_item(int itemN, T manipulator)
            { return io::detail::modify_item_body<Ch,Tr, Alloc, T> (*this, itemN, manipulator);}


        unsigned char exceptions() const;
        unsigned char exceptions(unsigned char newexcept);
# 116 "/usr/include/boost/format/format_class.hpp" 3 4
        template<class Ch2, class Tr2, class Alloc2>
        friend std::basic_ostream<Ch2, Tr2> &
        operator<<( std::basic_ostream<Ch2, Tr2> & ,
                    const basic_format<Ch2, Tr2, Alloc2>& );







        template<class Ch2, class Tr2, class Alloc2, class T>
        friend basic_format<Ch2, Tr2, Alloc2>&
        io::detail::feed (basic_format<Ch2, Tr2, Alloc2>&, T);

        template<class Ch2, class Tr2, class Alloc2, class T> friend
        void io::detail::distribute (basic_format<Ch2, Tr2, Alloc2>&, T);

        template<class Ch2, class Tr2, class Alloc2, class T> friend
        basic_format<Ch2, Tr2, Alloc2>&
        io::detail::modify_item_body (basic_format<Ch2, Tr2, Alloc2>&, int, T);

        template<class Ch2, class Tr2, class Alloc2, class T> friend
        basic_format<Ch2, Tr2, Alloc2>&
        io::detail::bind_arg_body (basic_format<Ch2, Tr2, Alloc2>&, int, const T&);

    private:

        typedef io::detail::stream_format_state<Ch, Tr> stream_format_state;

        enum style_values { ordered = 1,
                             special_needs = 4 };

        void make_or_reuse_data(std::size_t nbitems);


        std::vector<format_item_t> items_;
        std::vector<bool> bound_;

        int style_;
        int cur_arg_;
        int num_args_;
        mutable bool dumped_;
        string_type prefix_;
        unsigned char exceptions_;
        internal_streambuf_t buf_;
        boost::optional<io::detail::locale_t> loc_;
    };

}
# 42 "/usr/include/boost/format.hpp" 2 3 4


# 1 "/usr/include/boost/format/exceptions.hpp" 1 3 4
# 23 "/usr/include/boost/format/exceptions.hpp" 3 4
namespace boost {

    namespace io {



        class format_error : public std::exception
        {
        public:
            format_error() {}
            virtual const char *what() const throw() {
                return "boost::format_error: "
                    "format generic failure";
            }
        };

        class bad_format_string : public format_error
        {
            std::size_t pos_, next_;
        public:
            bad_format_string(std::size_t pos, std::size_t size)
                : pos_(pos), next_(size) {}
            std::size_t get_pos() const { return pos_; }
            std::size_t get_next() const { return next_; }
            virtual const char *what() const throw() {
                return "boost::bad_format_string: format-string is ill-formed";
            }
        };

        class too_few_args : public format_error
        {
            std::size_t cur_, expected_;
        public:
            too_few_args(std::size_t cur, std::size_t expected)
                : cur_(cur), expected_(expected) {}
            std::size_t get_cur() const { return cur_; }
            std::size_t get_expected() const { return expected_; }
            virtual const char *what() const throw() {
                return "boost::too_few_args: "
                    "format-string referred to more arguments than were passed";
            }
        };

        class too_many_args : public format_error
        {
            std::size_t cur_, expected_;
        public:
            too_many_args(std::size_t cur, std::size_t expected)
                : cur_(cur), expected_(expected) {}
            std::size_t get_cur() const { return cur_; }
            std::size_t get_expected() const { return expected_; }
            virtual const char *what() const throw() {
                return "boost::too_many_args: "
                    "format-string referred to less arguments than were passed";
            }
        };


        class out_of_range : public format_error
        {
            int index_, beg_, end_;
        public:
            out_of_range(int index, int beg, int end)
                : index_(index), beg_(beg), end_(end) {}
            int get_index() const { return index_; }
            int get_beg() const { return beg_; }
            int get_end() const { return end_; }
            virtual const char *what() const throw() {
                return "boost::out_of_range: "
                    "tried to refer to an argument (or item) number which"
                    " is out of range, according to the format string";
            }
        };


    }

}
# 45 "/usr/include/boost/format.hpp" 2 3 4


# 1 "/usr/include/boost/format/format_implementation.hpp" 1 3 4
# 19 "/usr/include/boost/format/format_implementation.hpp" 3 4
# 1 "/usr/include/boost/assert.hpp" 1 3 4
# 50 "/usr/include/boost/assert.hpp" 3 4
# 1 "/usr/include/assert.h" 1 3 4
# 51 "/usr/include/boost/assert.hpp" 2 3 4
# 20 "/usr/include/boost/format/format_implementation.hpp" 2 3 4



namespace boost {



    template< class Ch, class Tr, class Alloc>
    basic_format<Ch, Tr, Alloc>:: basic_format(const Ch* s)
        : style_(0), cur_arg_(0), num_args_(0), dumped_(false),
          exceptions_(io::all_error_bits)
    {
        if( s)
            parse( s );
    }


    template< class Ch, class Tr, class Alloc>
    basic_format<Ch, Tr, Alloc>:: basic_format(const Ch* s, const std::locale & loc)
        : style_(0), cur_arg_(0), num_args_(0), dumped_(false),
          exceptions_(io::all_error_bits), loc_(loc)
    {
        if(s) parse( s );
    }

    template< class Ch, class Tr, class Alloc>
    basic_format<Ch, Tr, Alloc>:: basic_format(const string_type& s, const std::locale & loc)
        : style_(0), cur_arg_(0), num_args_(0), dumped_(false),
          exceptions_(io::all_error_bits), loc_(loc)
    {
        parse(s);
    }

    template< class Ch, class Tr, class Alloc>
    io::detail::locale_t basic_format<Ch, Tr, Alloc>::
    getloc() const {
        return loc_ ? loc_.get() : io::detail::locale_t();
    }

    template< class Ch, class Tr, class Alloc>
    basic_format<Ch, Tr, Alloc>:: basic_format(const string_type& s)
        : style_(0), cur_arg_(0), num_args_(0), dumped_(false),
          exceptions_(io::all_error_bits)
    {
        parse(s);
    }

    template< class Ch, class Tr, class Alloc>
    basic_format<Ch, Tr, Alloc>:: basic_format(const basic_format& x)
        : items_(x.items_), bound_(x.bound_), style_(x.style_),
          cur_arg_(x.cur_arg_), num_args_(x.num_args_), dumped_(x.dumped_),
          prefix_(x.prefix_), exceptions_(x.exceptions_), loc_(x.loc_)
    {
    }

    template< class Ch, class Tr, class Alloc>
    basic_format<Ch, Tr, Alloc>& basic_format<Ch, Tr, Alloc>::
    operator= (const basic_format& x) {
        if(this == &x)
            return *this;
        (basic_format<Ch, Tr, Alloc>(x)).swap(*this);
        return *this;
    }
    template< class Ch, class Tr, class Alloc>
    void basic_format<Ch, Tr, Alloc>::
    swap (basic_format & x) {
        std::swap(exceptions_, x.exceptions_);
        std::swap(style_, x.style_);
        std::swap(cur_arg_, x.cur_arg_);
        std::swap(num_args_, x.num_args_);
        std::swap(dumped_, x.dumped_);

        items_.swap(x.items_);
        prefix_.swap(x.prefix_);
        bound_.swap(x.bound_);
    }

    template< class Ch, class Tr, class Alloc>
    unsigned char basic_format<Ch,Tr, Alloc>:: exceptions() const {
        return exceptions_;
    }

    template< class Ch, class Tr, class Alloc>
    unsigned char basic_format<Ch,Tr, Alloc>:: exceptions(unsigned char newexcept) {
        unsigned char swp = exceptions_;
        exceptions_ = newexcept;
        return swp;
    }

    template<class Ch, class Tr, class Alloc>
    void basic_format<Ch, Tr, Alloc>::
    make_or_reuse_data (std::size_t nbitems) {

        Ch fill = ( std::use_facet< std::ctype<Ch> >(getloc()) ). widen(' ');



        if(items_.size() == 0)
            items_.assign( nbitems, format_item_t(fill) );
        else {
            if(nbitems>items_.size())
                items_.resize(nbitems, format_item_t(fill));
            bound_.resize(0);
            for(std::size_t i=0; i < nbitems; ++i)
                items_[i].reset(fill);
        }
        prefix_.resize(0);
    }

    template< class Ch, class Tr, class Alloc>
    basic_format<Ch,Tr, Alloc>& basic_format<Ch,Tr, Alloc>::
    clear () {



        ((bound_.size()==0 || num_args_ == static_cast<int>(bound_.size())) ? static_cast<void> (0) : __assert_fail ("bound_.size()==0 || num_args_ == static_cast<int>(bound_.size())", "/usr/include/boost/format/format_implementation.hpp", 135, __PRETTY_FUNCTION__));

        for(unsigned long i=0; i<items_.size(); ++i) {

            if( bound_.size()==0 || items_[i].argN_<0 || !bound_[ items_[i].argN_ ] )
                items_[i].res_.resize(0);
        }
        cur_arg_=0; dumped_=false;

        if(bound_.size() != 0) {
            for(; cur_arg_ < num_args_ && bound_[cur_arg_]; ++cur_arg_)
                {}
        }
        return *this;
    }

    template< class Ch, class Tr, class Alloc>
    basic_format<Ch,Tr, Alloc>& basic_format<Ch,Tr, Alloc>::
    clear_binds () {

        bound_.resize(0);
        clear();
        return *this;
    }

    template< class Ch, class Tr, class Alloc>
    basic_format<Ch,Tr, Alloc>& basic_format<Ch,Tr, Alloc>::
    clear_bind (int argN) {

        if(argN<1 || argN > num_args_ || bound_.size()==0 || !bound_[argN-1] ) {
            if( exceptions() & io::out_of_range_bit)
                boost::throw_exception(io::out_of_range(argN, 1, num_args_+1 ) );
            else return *this;
        }
        bound_[argN-1]=false;
        clear();
        return *this;
    }

    template< class Ch, class Tr, class Alloc>
    int basic_format<Ch,Tr, Alloc>::
    bound_args() const {
        if(bound_.size()==0)
            return 0;
        int n=0;
        for(int i=0; i<num_args_ ; ++i)
            if(bound_[i])
                ++n;
        return n;
    }

    template< class Ch, class Tr, class Alloc>
    int basic_format<Ch,Tr, Alloc>::
    fed_args() const {
        if(bound_.size()==0)
            return cur_arg_;
        int n=0;
        for(int i=0; i<cur_arg_ ; ++i)
            if(!bound_[i])
                ++n;
        return n;
    }

    template< class Ch, class Tr, class Alloc>
    int basic_format<Ch,Tr, Alloc>::
    cur_arg() const {
      return cur_arg_+1; }

    template< class Ch, class Tr, class Alloc>
    int basic_format<Ch,Tr, Alloc>::
    remaining_args() const {
        if(bound_.size()==0)
            return num_args_-cur_arg_;
        int n=0;
        for(int i=cur_arg_; i<num_args_ ; ++i)
            if(!bound_[i])
                ++n;
        return n;
    }

    template< class Ch, class Tr, class Alloc>
    typename basic_format<Ch, Tr, Alloc>::string_type
    basic_format<Ch,Tr, Alloc>::
    str () const {
        if(items_.size()==0)
            return prefix_;
        if( cur_arg_ < num_args_)
            if( exceptions() & io::too_few_args_bit )

                boost::throw_exception(io::too_few_args(cur_arg_, num_args_));

        unsigned long i;
        string_type res;
        res.reserve(size());
        res += prefix_;
        for(i=0; i < items_.size(); ++i) {
            const format_item_t& item = items_[i];
            res += item.res_;
            if( item.argN_ == format_item_t::argN_tabulation) {
                ((item.pad_scheme_ & format_item_t::tabulation) ? static_cast<void> (0) : __assert_fail ("item.pad_scheme_ & format_item_t::tabulation", "/usr/include/boost/format/format_implementation.hpp", 234, __PRETTY_FUNCTION__));
                if( static_cast<size_type>(item.fmtstate_.width_) > res.size() )
                    res.append( static_cast<size_type>(item.fmtstate_.width_) - res.size(),
                                        item.fmtstate_.fill_ );
            }
            res += item.appendix_;
        }
        dumped_=true;
        return res;
    }
    template< class Ch, class Tr, class Alloc>
    typename std::basic_string<Ch, Tr, Alloc>::size_type basic_format<Ch,Tr, Alloc>::
    size () const {







        using std::max;
        size_type sz = prefix_.size();
        unsigned long i;
        for(i=0; i < items_.size(); ++i) {
            const format_item_t& item = items_[i];
            sz += item.res_.size();
            if( item.argN_ == format_item_t::argN_tabulation)
                sz = max (sz,
                                        static_cast<size_type>(item.fmtstate_.width_) );
            sz += item.appendix_.size();
        }
        return sz;



    }

namespace io {
namespace detail {

    template<class Ch, class Tr, class Alloc, class T>
    basic_format<Ch, Tr, Alloc>&
    bind_arg_body (basic_format<Ch, Tr, Alloc>& self, int argN, const T& val) {


        if(self.dumped_)
            self.clear();
        if(argN<1 || argN > self.num_args_) {
            if( self.exceptions() & io::out_of_range_bit )
                boost::throw_exception(io::out_of_range(argN, 1, self.num_args_+1 ) );
            else return self;
        }
        if(self.bound_.size()==0)
            self.bound_.assign(self.num_args_,false);
        else
            ((self.num_args_ == static_cast<signed int>(self.bound_.size())) ? static_cast<void> (0) : __assert_fail ("self.num_args_ == static_cast<signed int>(self.bound_.size())", "/usr/include/boost/format/format_implementation.hpp", 289, __PRETTY_FUNCTION__));
        int o_cur_arg = self.cur_arg_;
        self.cur_arg_ = argN-1;

        self.bound_[self.cur_arg_]=false;
        self.operator%(val);



        self.cur_arg_ = o_cur_arg;
        self.bound_[argN-1]=true;
        if(self.cur_arg_ == argN-1 ) {

            while(self.cur_arg_ < self.num_args_ && self.bound_[self.cur_arg_])
                ++self.cur_arg_;
        }

        ((self.cur_arg_ >= self.num_args_ || ! self.bound_[self.cur_arg_]) ? static_cast<void> (0) : __assert_fail ("self.cur_arg_ >= self.num_args_ || ! self.bound_[self.cur_arg_]", "/usr/include/boost/format/format_implementation.hpp", 306, __PRETTY_FUNCTION__));
        return self;
    }

    template<class Ch, class Tr, class Alloc, class T> basic_format<Ch, Tr, Alloc>&
    modify_item_body (basic_format<Ch, Tr, Alloc>& self, int itemN, T manipulator) {


        if(itemN<1 || itemN > static_cast<signed int>(self.items_.size() )) {
            if( self.exceptions() & io::out_of_range_bit )
                boost::throw_exception(io::out_of_range(itemN, 1, static_cast<int>(self.items_.size()) ));
            else return self;
        }
        self.items_[itemN-1].fmtstate_. template apply_manip<T> ( manipulator );
        return self;
    }

}
}
}
# 48 "/usr/include/boost/format.hpp" 2 3 4
# 1 "/usr/include/boost/format/group.hpp" 1 3 4
# 29 "/usr/include/boost/format/group.hpp" 3 4
namespace boost {
namespace io {


namespace detail {



struct group0
{
    group0() {}
};

template <class Ch, class Tr>
inline
::std:: basic_ostream<Ch, Tr>&
operator << ( ::std:: basic_ostream<Ch, Tr>& os,
             const group0& )
{
   return os;
}

template <class T1>
struct group1
{
    T1 a1_;
    group1(T1 a1)
      : a1_(a1)
      {}
private:
   group1& operator=(const group1&);
};

template <class Ch, class Tr, class T1>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group1<T1>& x)
{
   os << x.a1_;
   return os;
}




template <class T1,class T2>
struct group2
{
    T1 a1_;
    T2 a2_;
    group2(T1 a1,T2 a2)
      : a1_(a1),a2_(a2)
      {}
private:
   group2& operator=(const group2&);
};

template <class Ch, class Tr, class T1,class T2>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group2<T1,T2>& x)
{
   os << x.a1_<< x.a2_;
   return os;
}

template <class T1,class T2,class T3>
struct group3
{
    T1 a1_;
    T2 a2_;
    T3 a3_;
    group3(T1 a1,T2 a2,T3 a3)
      : a1_(a1),a2_(a2),a3_(a3)
      {}
private:
   group3& operator=(const group3&);
};

template <class Ch, class Tr, class T1,class T2,class T3>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group3<T1,T2,T3>& x)
{
   os << x.a1_<< x.a2_<< x.a3_;
   return os;
}

template <class T1,class T2,class T3,class T4>
struct group4
{
    T1 a1_;
    T2 a2_;
    T3 a3_;
    T4 a4_;
    group4(T1 a1,T2 a2,T3 a3,T4 a4)
      : a1_(a1),a2_(a2),a3_(a3),a4_(a4)
      {}
private:
   group4& operator=(const group4&);
};

template <class Ch, class Tr, class T1,class T2,class T3,class T4>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group4<T1,T2,T3,T4>& x)
{
   os << x.a1_<< x.a2_<< x.a3_<< x.a4_;
   return os;
}

template <class T1,class T2,class T3,class T4,class T5>
struct group5
{
    T1 a1_;
    T2 a2_;
    T3 a3_;
    T4 a4_;
    T5 a5_;
    group5(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5)
      : a1_(a1),a2_(a2),a3_(a3),a4_(a4),a5_(a5)
      {}
};

template <class Ch, class Tr, class T1,class T2,class T3,class T4,class T5>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group5<T1,T2,T3,T4,T5>& x)
{
   os << x.a1_<< x.a2_<< x.a3_<< x.a4_<< x.a5_;
   return os;
}

template <class T1,class T2,class T3,class T4,class T5,class T6>
struct group6
{
    T1 a1_;
    T2 a2_;
    T3 a3_;
    T4 a4_;
    T5 a5_;
    T6 a6_;
    group6(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6)
      : a1_(a1),a2_(a2),a3_(a3),a4_(a4),a5_(a5),a6_(a6)
      {}
};

template <class Ch, class Tr, class T1,class T2,class T3,class T4,class T5,class T6>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group6<T1,T2,T3,T4,T5,T6>& x)
{
   os << x.a1_<< x.a2_<< x.a3_<< x.a4_<< x.a5_<< x.a6_;
   return os;
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7>
struct group7
{
    T1 a1_;
    T2 a2_;
    T3 a3_;
    T4 a4_;
    T5 a5_;
    T6 a6_;
    T7 a7_;
    group7(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7)
      : a1_(a1),a2_(a2),a3_(a3),a4_(a4),a5_(a5),a6_(a6),a7_(a7)
      {}
};

template <class Ch, class Tr, class T1,class T2,class T3,class T4,class T5,class T6,class T7>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group7<T1,T2,T3,T4,T5,T6,T7>& x)
{
   os << x.a1_<< x.a2_<< x.a3_<< x.a4_<< x.a5_<< x.a6_<< x.a7_;
   return os;
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8>
struct group8
{
    T1 a1_;
    T2 a2_;
    T3 a3_;
    T4 a4_;
    T5 a5_;
    T6 a6_;
    T7 a7_;
    T8 a8_;
    group8(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7,T8 a8)
      : a1_(a1),a2_(a2),a3_(a3),a4_(a4),a5_(a5),a6_(a6),a7_(a7),a8_(a8)
      {}
};

template <class Ch, class Tr, class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group8<T1,T2,T3,T4,T5,T6,T7,T8>& x)
{
   os << x.a1_<< x.a2_<< x.a3_<< x.a4_<< x.a5_<< x.a6_<< x.a7_<< x.a8_;
   return os;
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9>
struct group9
{
    T1 a1_;
    T2 a2_;
    T3 a3_;
    T4 a4_;
    T5 a5_;
    T6 a6_;
    T7 a7_;
    T8 a8_;
    T9 a9_;
    group9(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7,T8 a8,T9 a9)
      : a1_(a1),a2_(a2),a3_(a3),a4_(a4),a5_(a5),a6_(a6),a7_(a7),a8_(a8),a9_(a9)
      {}
};

template <class Ch, class Tr, class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group9<T1,T2,T3,T4,T5,T6,T7,T8,T9>& x)
{
   os << x.a1_<< x.a2_<< x.a3_<< x.a4_<< x.a5_<< x.a6_<< x.a7_<< x.a8_<< x.a9_;
   return os;
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9,class T10>
struct group10
{
    T1 a1_;
    T2 a2_;
    T3 a3_;
    T4 a4_;
    T5 a5_;
    T6 a6_;
    T7 a7_;
    T8 a8_;
    T9 a9_;
    T10 a10_;
    group10(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7,T8 a8,T9 a9,T10 a10)
      : a1_(a1),a2_(a2),a3_(a3),a4_(a4),a5_(a5),a6_(a6),a7_(a7),a8_(a8),a9_(a9),a10_(a10)
      {}
};

template <class Ch, class Tr, class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9,class T10>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group10<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10>& x)
{
   os << x.a1_<< x.a2_<< x.a3_<< x.a4_<< x.a5_<< x.a6_<< x.a7_<< x.a8_<< x.a9_<< x.a10_;
   return os;
}




template <class T1,class T2>
inline
group1<T1>
group_head( group2<T1,T2> const& x)
{
   return group1<T1> (x.a1_);
}

template <class T1,class T2>
inline
group1<T2>
group_last( group2<T1,T2> const& x)
{
   return group1<T2> (x.a2_);
}



template <class T1,class T2,class T3>
inline
group2<T1,T2>
group_head( group3<T1,T2,T3> const& x)
{
   return group2<T1,T2> (x.a1_,x.a2_);
}

template <class T1,class T2,class T3>
inline
group1<T3>
group_last( group3<T1,T2,T3> const& x)
{
   return group1<T3> (x.a3_);
}



template <class T1,class T2,class T3,class T4>
inline
group3<T1,T2,T3>
group_head( group4<T1,T2,T3,T4> const& x)
{
   return group3<T1,T2,T3> (x.a1_,x.a2_,x.a3_);
}

template <class T1,class T2,class T3,class T4>
inline
group1<T4>
group_last( group4<T1,T2,T3,T4> const& x)
{
   return group1<T4> (x.a4_);
}



template <class T1,class T2,class T3,class T4,class T5>
inline
group4<T1,T2,T3,T4>
group_head( group5<T1,T2,T3,T4,T5> const& x)
{
   return group4<T1,T2,T3,T4> (x.a1_,x.a2_,x.a3_,x.a4_);
}

template <class T1,class T2,class T3,class T4,class T5>
inline
group1<T5>
group_last( group5<T1,T2,T3,T4,T5> const& x)
{
   return group1<T5> (x.a5_);
}



template <class T1,class T2,class T3,class T4,class T5,class T6>
inline
group5<T1,T2,T3,T4,T5>
group_head( group6<T1,T2,T3,T4,T5,T6> const& x)
{
   return group5<T1,T2,T3,T4,T5> (x.a1_,x.a2_,x.a3_,x.a4_,x.a5_);
}

template <class T1,class T2,class T3,class T4,class T5,class T6>
inline
group1<T6>
group_last( group6<T1,T2,T3,T4,T5,T6> const& x)
{
   return group1<T6> (x.a6_);
}



template <class T1,class T2,class T3,class T4,class T5,class T6,class T7>
inline
group6<T1,T2,T3,T4,T5,T6>
group_head( group7<T1,T2,T3,T4,T5,T6,T7> const& x)
{
   return group6<T1,T2,T3,T4,T5,T6> (x.a1_,x.a2_,x.a3_,x.a4_,x.a5_,x.a6_);
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7>
inline
group1<T7>
group_last( group7<T1,T2,T3,T4,T5,T6,T7> const& x)
{
   return group1<T7> (x.a7_);
}



template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8>
inline
group7<T1,T2,T3,T4,T5,T6,T7>
group_head( group8<T1,T2,T3,T4,T5,T6,T7,T8> const& x)
{
   return group7<T1,T2,T3,T4,T5,T6,T7> (x.a1_,x.a2_,x.a3_,x.a4_,x.a5_,x.a6_,x.a7_);
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8>
inline
group1<T8>
group_last( group8<T1,T2,T3,T4,T5,T6,T7,T8> const& x)
{
   return group1<T8> (x.a8_);
}



template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9>
inline
group8<T1,T2,T3,T4,T5,T6,T7,T8>
group_head( group9<T1,T2,T3,T4,T5,T6,T7,T8,T9> const& x)
{
   return group8<T1,T2,T3,T4,T5,T6,T7,T8> (x.a1_,x.a2_,x.a3_,x.a4_,x.a5_,x.a6_,x.a7_,x.a8_);
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9>
inline
group1<T9>
group_last( group9<T1,T2,T3,T4,T5,T6,T7,T8,T9> const& x)
{
   return group1<T9> (x.a9_);
}



template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9,class T10>
inline
group9<T1,T2,T3,T4,T5,T6,T7,T8,T9>
group_head( group10<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10> const& x)
{
   return group9<T1,T2,T3,T4,T5,T6,T7,T8,T9> (x.a1_,x.a2_,x.a3_,x.a4_,x.a5_,x.a6_,x.a7_,x.a8_,x.a9_);
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9,class T10>
inline
group1<T10>
group_last( group10<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10> const& x)
{
   return group1<T10> (x.a10_);
}





}






inline detail::group1< detail::group0 >
group() { return detail::group1< detail::group0 > ( detail::group0() ); }

template <class T1, class Var>
inline
detail::group1< detail::group2<T1, Var const&> >
  group(T1 a1, Var const& var)
{
   return detail::group1< detail::group2<T1, Var const&> >
                   ( detail::group2<T1, Var const&>
                        (a1, var)
                  );
}

template <class T1,class T2, class Var>
inline
detail::group1< detail::group3<T1,T2, Var const&> >
  group(T1 a1,T2 a2, Var const& var)
{
   return detail::group1< detail::group3<T1,T2, Var const&> >
                   ( detail::group3<T1,T2, Var const&>
                        (a1,a2, var)
                  );
}

template <class T1,class T2,class T3, class Var>
inline
detail::group1< detail::group4<T1,T2,T3, Var const&> >
  group(T1 a1,T2 a2,T3 a3, Var const& var)
{
   return detail::group1< detail::group4<T1,T2,T3, Var const&> >
                   ( detail::group4<T1,T2,T3, Var const&>
                        (a1,a2,a3, var)
                  );
}

template <class T1,class T2,class T3,class T4, class Var>
inline
detail::group1< detail::group5<T1,T2,T3,T4, Var const&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4, Var const& var)
{
   return detail::group1< detail::group5<T1,T2,T3,T4, Var const&> >
                   ( detail::group5<T1,T2,T3,T4, Var const&>
                        (a1,a2,a3,a4, var)
                  );
}

template <class T1,class T2,class T3,class T4,class T5, class Var>
inline
detail::group1< detail::group6<T1,T2,T3,T4,T5, Var const&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5, Var const& var)
{
   return detail::group1< detail::group6<T1,T2,T3,T4,T5, Var const&> >
                   ( detail::group6<T1,T2,T3,T4,T5, Var const&>
                        (a1,a2,a3,a4,a5, var)
                  );
}

template <class T1,class T2,class T3,class T4,class T5,class T6, class Var>
inline
detail::group1< detail::group7<T1,T2,T3,T4,T5,T6, Var const&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6, Var const& var)
{
   return detail::group1< detail::group7<T1,T2,T3,T4,T5,T6, Var const&> >
                   ( detail::group7<T1,T2,T3,T4,T5,T6, Var const&>
                        (a1,a2,a3,a4,a5,a6, var)
                  );
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7, class Var>
inline
detail::group1< detail::group8<T1,T2,T3,T4,T5,T6,T7, Var const&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7, Var const& var)
{
   return detail::group1< detail::group8<T1,T2,T3,T4,T5,T6,T7, Var const&> >
                   ( detail::group8<T1,T2,T3,T4,T5,T6,T7, Var const&>
                        (a1,a2,a3,a4,a5,a6,a7, var)
                  );
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8, class Var>
inline
detail::group1< detail::group9<T1,T2,T3,T4,T5,T6,T7,T8, Var const&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7,T8 a8, Var const& var)
{
   return detail::group1< detail::group9<T1,T2,T3,T4,T5,T6,T7,T8, Var const&> >
                   ( detail::group9<T1,T2,T3,T4,T5,T6,T7,T8, Var const&>
                        (a1,a2,a3,a4,a5,a6,a7,a8, var)
                  );
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9, class Var>
inline
detail::group1< detail::group10<T1,T2,T3,T4,T5,T6,T7,T8,T9, Var const&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7,T8 a8,T9 a9, Var const& var)
{
   return detail::group1< detail::group10<T1,T2,T3,T4,T5,T6,T7,T8,T9, Var const&> >
                   ( detail::group10<T1,T2,T3,T4,T5,T6,T7,T8,T9, Var const&>
                        (a1,a2,a3,a4,a5,a6,a7,a8,a9, var)
                  );
}




template <class T1, class Var>
inline
detail::group1< detail::group2<T1, Var&> >
  group(T1 a1, Var& var)
{
   return detail::group1< detail::group2<T1, Var&> >
                   ( detail::group2<T1, Var&>
                        (a1, var)
                  );
}

template <class T1,class T2, class Var>
inline
detail::group1< detail::group3<T1,T2, Var&> >
  group(T1 a1,T2 a2, Var& var)
{
   return detail::group1< detail::group3<T1,T2, Var&> >
                   ( detail::group3<T1,T2, Var&>
                        (a1,a2, var)
                  );
}

template <class T1,class T2,class T3, class Var>
inline
detail::group1< detail::group4<T1,T2,T3, Var&> >
  group(T1 a1,T2 a2,T3 a3, Var& var)
{
   return detail::group1< detail::group4<T1,T2,T3, Var&> >
                   ( detail::group4<T1,T2,T3, Var&>
                        (a1,a2,a3, var)
                  );
}

template <class T1,class T2,class T3,class T4, class Var>
inline
detail::group1< detail::group5<T1,T2,T3,T4, Var&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4, Var& var)
{
   return detail::group1< detail::group5<T1,T2,T3,T4, Var&> >
                   ( detail::group5<T1,T2,T3,T4, Var&>
                        (a1,a2,a3,a4, var)
                  );
}

template <class T1,class T2,class T3,class T4,class T5, class Var>
inline
detail::group1< detail::group6<T1,T2,T3,T4,T5, Var&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5, Var& var)
{
   return detail::group1< detail::group6<T1,T2,T3,T4,T5, Var&> >
                   ( detail::group6<T1,T2,T3,T4,T5, Var&>
                        (a1,a2,a3,a4,a5, var)
                  );
}

template <class T1,class T2,class T3,class T4,class T5,class T6, class Var>
inline
detail::group1< detail::group7<T1,T2,T3,T4,T5,T6, Var&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6, Var& var)
{
   return detail::group1< detail::group7<T1,T2,T3,T4,T5,T6, Var&> >
                   ( detail::group7<T1,T2,T3,T4,T5,T6, Var&>
                        (a1,a2,a3,a4,a5,a6, var)
                  );
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7, class Var>
inline
detail::group1< detail::group8<T1,T2,T3,T4,T5,T6,T7, Var&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7, Var& var)
{
   return detail::group1< detail::group8<T1,T2,T3,T4,T5,T6,T7, Var&> >
                   ( detail::group8<T1,T2,T3,T4,T5,T6,T7, Var&>
                        (a1,a2,a3,a4,a5,a6,a7, var)
                  );
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8, class Var>
inline
detail::group1< detail::group9<T1,T2,T3,T4,T5,T6,T7,T8, Var&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7,T8 a8, Var& var)
{
   return detail::group1< detail::group9<T1,T2,T3,T4,T5,T6,T7,T8, Var&> >
                   ( detail::group9<T1,T2,T3,T4,T5,T6,T7,T8, Var&>
                        (a1,a2,a3,a4,a5,a6,a7,a8, var)
                  );
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9, class Var>
inline
detail::group1< detail::group10<T1,T2,T3,T4,T5,T6,T7,T8,T9, Var&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7,T8 a8,T9 a9, Var& var)
{
   return detail::group1< detail::group10<T1,T2,T3,T4,T5,T6,T7,T8,T9, Var&> >
                   ( detail::group10<T1,T2,T3,T4,T5,T6,T7,T8,T9, Var&>
                        (a1,a2,a3,a4,a5,a6,a7,a8,a9, var)
                  );
}





}

}
# 49 "/usr/include/boost/format.hpp" 2 3 4
# 1 "/usr/include/boost/format/feed_args.hpp" 1 3 4
# 18 "/usr/include/boost/format/feed_args.hpp" 3 4
# 1 "/usr/include/boost/assert.hpp" 1 3 4
# 50 "/usr/include/boost/assert.hpp" 3 4
# 1 "/usr/include/assert.h" 1 3 4
# 51 "/usr/include/boost/assert.hpp" 2 3 4
# 19 "/usr/include/boost/format/feed_args.hpp" 2 3 4




# 1 "/usr/include/boost/format/detail/msvc_disambiguater.hpp" 1 3 4
# 24 "/usr/include/boost/format/feed_args.hpp" 2 3 4

namespace boost {
namespace io {
namespace detail {

    template<class Ch, class Tr, class Alloc>
    void mk_str( std::basic_string<Ch,Tr, Alloc> & res,
                 const Ch * beg,
                 typename std::basic_string<Ch,Tr,Alloc>::size_type size,
                 std::streamsize w,
                 const Ch fill_char,
                 std::ios_base::fmtflags f,
                 const Ch prefix_space,
                 bool center)


    {
        typedef typename std::basic_string<Ch,Tr,Alloc>::size_type size_type;
        res.resize(0);
        if(w<=0 || static_cast<size_type>(w) <=size) {

            res.reserve(size + !!prefix_space);
            if(prefix_space)
              res.append(1, prefix_space);
            if (size)
              res.append(beg, size);
        }
        else {
            std::streamsize n=static_cast<std::streamsize>(w-size-!!prefix_space);
            std::streamsize n_after = 0, n_before = 0;
            res.reserve(static_cast<size_type>(w));
            if(center)
                n_after = n/2, n_before = n - n_after;
            else
                if(f & std::ios_base::left)
                    n_after = n;
                else
                    n_before = n;

            if(n_before) res.append(static_cast<size_type>(n_before), fill_char);
            if(prefix_space)
              res.append(1, prefix_space);
            if (size)
              res.append(beg, size);
            if(n_after) res.append(static_cast<size_type>(n_after), fill_char);
        }
    }
# 89 "/usr/include/boost/format/feed_args.hpp" 3 4
    template< class Ch, class Tr, class T> inline
    void put_head (::std:: basic_ostream<Ch, Tr> &, const T& ) {
    }

    template< class Ch, class Tr, class T> inline
    void put_head( ::std:: basic_ostream<Ch, Tr> & os, const group1<T>& x ) {
        os << group_head(x.a1_);
    }

    template< class Ch, class Tr, class T> inline
    void put_last( ::std:: basic_ostream<Ch, Tr> & os, const T& x ) {
        os << x ;
    }

    template< class Ch, class Tr, class T> inline
    void put_last( ::std:: basic_ostream<Ch, Tr> & os, const group1<T>& x ) {
        os << group_last(x.a1_);
    }


    template< class Ch, class Tr, class T> inline
    void put_head( ::std:: basic_ostream<Ch, Tr> &, T& ) {
    }

    template< class Ch, class Tr, class T> inline
    void put_last( ::std:: basic_ostream<Ch, Tr> & os, T& x) {
        os << x ;
    }




    template< class Ch, class Tr, class Alloc, class T>
    void put( T x,
              const format_item<Ch, Tr, Alloc>& specs,
              typename basic_format<Ch, Tr, Alloc>::string_type& res,
              typename basic_format<Ch, Tr, Alloc>::internal_streambuf_t & buf,
              io::detail::locale_t *loc_p = __null)
    {
# 138 "/usr/include/boost/format/feed_args.hpp" 3 4
        typedef typename basic_format<Ch, Tr, Alloc>::string_type string_type;
        typedef typename basic_format<Ch, Tr, Alloc>::format_item_t format_item_t;
        typedef typename string_type::size_type size_type;

        basic_oaltstringstream<Ch, Tr, Alloc> oss( &buf);
        specs.fmtstate_.apply_on(oss, loc_p);


        put_head( oss, x );



        const std::ios_base::fmtflags fl=oss.flags();
        const bool internal = (fl & std::ios_base::internal) != 0;
        const std::streamsize w = oss.width();
        const bool two_stepped_padding= internal && (w!=0);

        res.resize(0);
        if(! two_stepped_padding) {
            if(w>0)
                oss.width(0);
            put_last( oss, x);
            const Ch * res_beg = buf.pbase();
            Ch prefix_space = 0;
            if(specs.pad_scheme_ & format_item_t::spacepad)
                if(buf.pcount()== 0 ||
                   (res_beg[0] !=oss.widen('+') && res_beg[0] !=oss.widen('-') ))
                    prefix_space = oss.widen(' ');
            size_type res_size = (std::min)(
                static_cast<size_type>(specs.truncate_ - !!prefix_space),
                buf.pcount() );
            mk_str(res, res_beg, res_size, w, oss.fill(), fl,
                   prefix_space, (specs.pad_scheme_ & format_item_t::centered) !=0 );
        }
        else {



            put_last( oss, x);
            const Ch * res_beg = buf.pbase();
            size_type res_size = buf.pcount();
            bool prefix_space=false;
            if(specs.pad_scheme_ & format_item_t::spacepad)
                if(buf.pcount()== 0 ||
                   (res_beg[0] !=oss.widen('+') && res_beg[0] !=oss.widen('-') ))
                    prefix_space = true;
            if(res_size == static_cast<size_type>(w) && w<=specs.truncate_ && !prefix_space) {

                res.assign(res_beg, res_size);
            }
            else {



                res.assign(res_beg, res_size);
                res_beg=__null;


                buf.clear_buffer();
                basic_oaltstringstream<Ch, Tr, Alloc> oss2( &buf);
                specs.fmtstate_.apply_on(oss2, loc_p);
                put_head( oss2, x );

                oss2.width(0);
                if(prefix_space)
                    oss2 << ' ';
                put_last(oss2, x );
                if(buf.pcount()==0 && specs.pad_scheme_ & format_item_t::spacepad) {
                    prefix_space =true;
                    oss2 << ' ';
                }

                const Ch * tmp_beg = buf.pbase();
                size_type tmp_size = (std::min)(static_cast<size_type>(specs.truncate_),
                                                buf.pcount() );


                if(static_cast<size_type>(w) <= tmp_size) {

                        res.assign(tmp_beg, tmp_size);
                }
                else {

                    size_type sz = (std::min)(res_size + (prefix_space ? 1 : 0), tmp_size);
                    size_type i = prefix_space;
                    for(; i<sz && tmp_beg[i] == res[i - (prefix_space ? 1 : 0)]; ++i) {}
                    if(i>=tmp_size) i=prefix_space;
                    res.assign(tmp_beg, i);
                                        std::streamsize d = w - static_cast<std::streamsize>(tmp_size);
                                        ((d>0) ? static_cast<void> (0) : __assert_fail ("d>0", "/usr/include/boost/format/feed_args.hpp", 227, __PRETTY_FUNCTION__));
                    res.append(static_cast<size_type>( d ), oss2.fill());
                    res.append(tmp_beg+i, tmp_size-i);
                    ((i+(tmp_size-i)+(std::max)(d,(std::streamsize)0) == static_cast<size_type>(w)) ? static_cast<void> (0) : __assert_fail ("i+(tmp_size-i)+(std::max)(d,(std::streamsize)0) == static_cast<size_type>(w)", "/usr/include/boost/format/feed_args.hpp", 231, __PRETTY_FUNCTION__));

                    ((res.size() == static_cast<size_type>(w)) ? static_cast<void> (0) : __assert_fail ("res.size() == static_cast<size_type>(w)", "/usr/include/boost/format/feed_args.hpp", 232, __PRETTY_FUNCTION__));
                }
            }
        }
        buf.clear_buffer();



    }


    template< class Ch, class Tr, class Alloc, class T>
    void distribute (basic_format<Ch,Tr, Alloc>& self, T x) {

        if(self.cur_arg_ >= self.num_args_) {
            if( self.exceptions() & too_many_args_bit )
                boost::throw_exception(too_many_args(self.cur_arg_, self.num_args_));
            else return;
        }
        for(unsigned long i=0; i < self.items_.size(); ++i) {
            if(self.items_[i].argN_ == self.cur_arg_) {
                put<Ch, Tr, Alloc, T> (x, self.items_[i], self.items_[i].res_,
                                self.buf_, boost::get_pointer(self.loc_) );
            }
        }
    }

    template<class Ch, class Tr, class Alloc, class T>
    basic_format<Ch, Tr, Alloc>&
    feed (basic_format<Ch,Tr, Alloc>& self, T x) {
        if(self.dumped_) self.clear();
        distribute<Ch, Tr, Alloc, T> (self, x);
        ++self.cur_arg_;
        if(self.bound_.size() != 0) {
                while( self.cur_arg_ < self.num_args_ && self.bound_[self.cur_arg_] )
                    ++self.cur_arg_;
        }
        return self;
    }

}
}
}
# 50 "/usr/include/boost/format.hpp" 2 3 4
# 1 "/usr/include/boost/format/parsing.hpp" 1 3 4
# 21 "/usr/include/boost/format/parsing.hpp" 3 4
# 1 "/usr/include/boost/assert.hpp" 1 3 4
# 50 "/usr/include/boost/assert.hpp" 3 4
# 1 "/usr/include/assert.h" 1 3 4
# 51 "/usr/include/boost/assert.hpp" 2 3 4
# 22 "/usr/include/boost/format/parsing.hpp" 2 3 4


namespace boost {
namespace io {
namespace detail {
# 35 "/usr/include/boost/format/parsing.hpp" 3 4
    template<class T>
    const T& const_or_not(const T& x) {
        return x;
    }


    template<class Ch, class Facet> inline
    char wrap_narrow(const Facet& fac, Ch c, char deflt) {
        return const_or_not(fac).narrow(c, deflt);
    }

    template<class Ch, class Facet> inline
    bool wrap_isdigit(const Facet& fac, Ch c) {

        return fac.is(std::ctype<Ch>::digit, c);





    }

    template<class Iter, class Facet>
    Iter wrap_scan_notdigit(const Facet & fac, Iter beg, Iter end) {
        using namespace std;
        for( ; beg!=end && wrap_isdigit(fac, *beg); ++beg) ;
        return beg;
    }






    template<class Res, class Iter, class Facet>
    Iter str2int (const Iter & start, const Iter & last, Res & res,
                 const Facet& fac)
    {
        using namespace std;
        Iter it;
        res=0;
        for(it=start; it != last && wrap_isdigit(fac, *it); ++it ) {
            char cur_ch = wrap_narrow(fac, *it, 0);
            res *= 10;
            res += cur_ch - '0';
        }
        return it;
    }






    template<class Iter, class Facet>
    Iter skip_asterisk(Iter start, Iter last, const Facet& fac)
    {
        using namespace std;
        ++ start;
        start = wrap_scan_notdigit(fac, start, last);
        if(start!=last && *start== const_or_not(fac).widen( '$') )
            ++start;
        return start;
    }





    inline void maybe_throw_exception(unsigned char exceptions,
                                      std::size_t pos, std::size_t size)
    {
        if(exceptions & io::bad_format_string_bit)
            boost::throw_exception(io::bad_format_string(pos, size) );
    }
# 122 "/usr/include/boost/format/parsing.hpp" 3 4
    template<class Ch, class Tr, class Alloc, class Iter, class Facet>
    bool parse_printf_directive(Iter & start, const Iter& last,
                                detail::format_item<Ch, Tr, Alloc> * fpar,
                                const Facet& fac,
                                std::size_t offset, unsigned char exceptions)
    {
        typedef typename basic_format<Ch, Tr, Alloc>::format_item_t format_item_t;

        fpar->argN_ = format_item_t::argN_no_posit;
        bool precision_set = false;
        bool in_brackets=false;
        Iter start0 = start;
        std::size_t fstring_size = last-start0+offset;

        if(start>= last) {
                maybe_throw_exception(exceptions, start-start0 + offset, fstring_size);
                return false;
        }

        if(*start== const_or_not(fac).widen( '|')) {
            in_brackets=true;
            if( ++start >= last ) {
                maybe_throw_exception(exceptions, start-start0 + offset, fstring_size);
                return false;
            }
        }


        if(*start== const_or_not(fac).widen( '0'))
            goto parse_flags;


        if(wrap_isdigit(fac, *start)) {
            int n;
            start = str2int(start, last, n, fac);
            if( start >= last ) {
                maybe_throw_exception(exceptions, start-start0+offset, fstring_size);
                return false;
            }


            if( *start == const_or_not(fac).widen( '%') ) {
                fpar->argN_ = n-1;
                ++start;
                if( in_brackets)
                    maybe_throw_exception(exceptions, start-start0+offset, fstring_size);

                else
                    return true;
            }

            if ( *start== const_or_not(fac).widen( '$') ) {
                fpar->argN_ = n-1;
                ++start;
            }
            else {

                fpar->fmtstate_.width_ = n;
                fpar->argN_ = format_item_t::argN_no_posit;
                goto parse_precision;
            }
        }

      parse_flags:

        while ( start != last) {

            switch ( wrap_narrow(fac, *start, 0)) {
            case '\'' : break;
            case 'l':
            case 'h':
                break;
            case '-':
                fpar->fmtstate_.flags_ |= std::ios_base::left;
                break;
            case '=':
                fpar->pad_scheme_ |= format_item_t::centered;
                break;
            case '_':
                fpar->fmtstate_.flags_ |= std::ios_base::internal;
                break;
            case ' ':
                fpar->pad_scheme_ |= format_item_t::spacepad;
                break;
            case '+':
                fpar->fmtstate_.flags_ |= std::ios_base::showpos;
                break;
            case '0':
                fpar->pad_scheme_ |= format_item_t::zeropad;


                break;
            case '#':
                fpar->fmtstate_.flags_ |= std::ios_base::showpoint | std::ios_base::showbase;
                break;
            default:
                goto parse_width;
            }
            ++start;
        }

        if( start>=last) {
            maybe_throw_exception(exceptions, start-start0+offset, fstring_size);
            return true;
        }
      parse_width:


        if(*start == const_or_not(fac).widen( '*') )
            start = skip_asterisk(start, last, fac);
        if(start!=last && wrap_isdigit(fac, *start))
            start = str2int(start, last, fpar->fmtstate_.width_, fac);

      parse_precision:
        if( start>= last) {
            maybe_throw_exception(exceptions, start-start0+offset, fstring_size);
            return true;
        }

        if (*start== const_or_not(fac).widen( '.')) {
            ++start;
            if(start != last && *start == const_or_not(fac).widen( '*') )
                start = skip_asterisk(start, last, fac);
            if(start != last && wrap_isdigit(fac, *start)) {
                start = str2int(start, last, fpar->fmtstate_.precision_, fac);
                precision_set = true;
            }
            else
                fpar->fmtstate_.precision_ =0;
        }


        while( start != last && ( *start== const_or_not(fac).widen( 'l')
                                  || *start== const_or_not(fac).widen( 'L')
                                  || *start== const_or_not(fac).widen( 'h')) )
            ++start;
        if( start>=last) {
            maybe_throw_exception(exceptions, start-start0+offset, fstring_size);
            return true;
        }

        if( in_brackets && *start== const_or_not(fac).widen( '|') ) {
            ++start;
            return true;
        }
        switch ( wrap_narrow(fac, *start, 0) ) {
        case 'X':
            fpar->fmtstate_.flags_ |= std::ios_base::uppercase;
        case 'p':
        case 'x':
            fpar->fmtstate_.flags_ &= ~std::ios_base::basefield;
            fpar->fmtstate_.flags_ |= std::ios_base::hex;
            break;

        case 'o':
            fpar->fmtstate_.flags_ &= ~std::ios_base::basefield;
            fpar->fmtstate_.flags_ |= std::ios_base::oct;
            break;

        case 'E':
            fpar->fmtstate_.flags_ |= std::ios_base::uppercase;
        case 'e':
            fpar->fmtstate_.flags_ &= ~std::ios_base::floatfield;
            fpar->fmtstate_.flags_ |= std::ios_base::scientific;

            fpar->fmtstate_.flags_ &= ~std::ios_base::basefield;
            fpar->fmtstate_.flags_ |= std::ios_base::dec;
            break;

        case 'f':
            fpar->fmtstate_.flags_ &= ~std::ios_base::floatfield;
            fpar->fmtstate_.flags_ |= std::ios_base::fixed;
        case 'u':
        case 'd':
        case 'i':
            fpar->fmtstate_.flags_ &= ~std::ios_base::basefield;
            fpar->fmtstate_.flags_ |= std::ios_base::dec;
            break;

        case 'T':
            ++start;
            if( start >= last)
                maybe_throw_exception(exceptions, start-start0+offset, fstring_size);
            else
                fpar->fmtstate_.fill_ = *start;
            fpar->pad_scheme_ |= format_item_t::tabulation;
            fpar->argN_ = format_item_t::argN_tabulation;
            break;
        case 't':
            fpar->fmtstate_.fill_ = const_or_not(fac).widen( ' ');
            fpar->pad_scheme_ |= format_item_t::tabulation;
            fpar->argN_ = format_item_t::argN_tabulation;
            break;

        case 'G':
            fpar->fmtstate_.flags_ |= std::ios_base::uppercase;
            break;
        case 'g':
            fpar->fmtstate_.flags_ &= ~std::ios_base::basefield;
            fpar->fmtstate_.flags_ |= std::ios_base::dec;


            fpar->fmtstate_.flags_ &= ~std::ios_base::floatfield;
            break;

        case 'C':
        case 'c':
            fpar->truncate_ = 1;
            break;
        case 'S':
        case 's':
            if(precision_set)
                fpar->truncate_ = fpar->fmtstate_.precision_;
            fpar->fmtstate_.precision_ = 6;
            break;
        case 'n' :
            fpar->argN_ = format_item_t::argN_ignored;
            break;
        default:
            maybe_throw_exception(exceptions, start-start0+offset, fstring_size);
        }
        ++start;

        if( in_brackets ) {
            if( start != last && *start== const_or_not(fac).widen( '|') ) {
                ++start;
                return true;
            }
            else maybe_throw_exception(exceptions, start-start0+offset, fstring_size);
        }
        return true;
    }


    template<class String, class Facet>
    int upper_bound_from_fstring(const String& buf,
                                 const typename String::value_type arg_mark,
                                 const Facet& fac,
                                 unsigned char exceptions)
    {


        using namespace boost::io;
        typename String::size_type i1=0;
        int num_items=0;
        while( (i1=buf.find(arg_mark,i1)) != String::npos ) {
            if( i1+1 >= buf.size() ) {
                if(exceptions & bad_format_string_bit)
                    boost::throw_exception(bad_format_string(i1, buf.size() ));
                else {
                  ++num_items;
                  break;
                }
            }
            if(buf[i1+1] == buf[i1] ) {
                i1+=2; continue;
            }

            ++i1;

            i1 = detail::wrap_scan_notdigit(fac, buf.begin()+i1, buf.end()) - buf.begin();
            if( i1 < buf.size() && buf[i1] == arg_mark )
                ++i1;
            ++num_items;
        }
        return num_items;
    }
    template<class String> inline
    void append_string(String& dst, const String& src,
                       const typename String::size_type beg,
                       const typename String::size_type end) {

        dst.append(src.begin()+beg, src.begin()+end);



    }

}
}






    template<class Ch, class Tr, class Alloc>
    basic_format<Ch, Tr, Alloc>& basic_format<Ch, Tr, Alloc>::
    parse (const string_type& buf) {

        using namespace std;

        const std::ctype<Ch> & fac = std::use_facet< std::ctype<Ch> >(getloc());





        const Ch arg_mark = io::detail::const_or_not(fac).widen( '%');
        bool ordered_args=true;
        int max_argN=-1;


        int num_items = io::detail::upper_bound_from_fstring(buf, arg_mark, fac, exceptions());
        make_or_reuse_data(num_items);


        num_items=0;
        typename string_type::size_type i0=0, i1=0;
        typename string_type::const_iterator it;
        bool special_things=false;
        int cur_item=0;
        while( (i1=buf.find(arg_mark,i1)) != string_type::npos ) {
            string_type & piece = (cur_item==0) ? prefix_ : items_[cur_item-1].appendix_;
            if( buf[i1+1] == buf[i1] ) {
                io::detail::append_string(piece, buf, i0, i1+1);
                i1+=2; i0=i1;
                continue;
            }
            ((static_cast<unsigned int>(cur_item) < items_.size() || cur_item==0) ? static_cast<void> (0) : __assert_fail ("static_cast<unsigned int>(cur_item) < items_.size() || cur_item==0", "/usr/include/boost/format/parsing.hpp", 441, __PRETTY_FUNCTION__));

            if(i1!=i0) {
                io::detail::append_string(piece, buf, i0, i1);
                i0=i1;
            }
            ++i1;
            it = buf.begin()+i1;
            bool parse_ok = io::detail::parse_printf_directive(
                it, buf.end(), &items_[cur_item], fac, i1, exceptions());
            i1 = it - buf.begin();
            if( ! parse_ok )
                continue;
            i0=i1;
            items_[cur_item].compute_states();

            int argN=items_[cur_item].argN_;
            if(argN == format_item_t::argN_ignored)
                continue;
            if(argN ==format_item_t::argN_no_posit)
                ordered_args=false;
            else if(argN == format_item_t::argN_tabulation) special_things=true;
            else if(argN > max_argN) max_argN = argN;
            ++num_items;
            ++cur_item;
        }
        ((cur_item == num_items) ? static_cast<void> (0) : __assert_fail ("cur_item == num_items", "/usr/include/boost/format/parsing.hpp", 467, __PRETTY_FUNCTION__));


        {
            string_type & piece = (cur_item==0) ? prefix_ : items_[cur_item-1].appendix_;
            io::detail::append_string(piece, buf, i0, buf.size());
        }

        if( !ordered_args) {
            if(max_argN >= 0 ) {
                if(exceptions() & io::bad_format_string_bit)
                    boost::throw_exception(io::bad_format_string(max_argN, 0));

            }

            int non_ordered_items = 0;
            for(int i=0; i< num_items; ++i)
                if(items_[i].argN_ == format_item_t::argN_no_posit) {
                    items_[i].argN_ = non_ordered_items;
                    ++non_ordered_items;
                }
            max_argN = non_ordered_items-1;
        }


        items_.resize(num_items, format_item_t(io::detail::const_or_not(fac).widen( ' ')) );

        if(special_things) style_ |= special_needs;
        num_args_ = max_argN + 1;
        if(ordered_args) style_ |= ordered;
        else style_ &= ~ordered;
        return *this;
    }

}
# 51 "/usr/include/boost/format.hpp" 2 3 4


# 1 "/usr/include/boost/format/free_funcs.hpp" 1 3 4
# 19 "/usr/include/boost/format/free_funcs.hpp" 3 4
namespace boost {

    template<class Ch, class Tr, class Alloc> inline
    std::basic_string<Ch, Tr, Alloc> str(const basic_format<Ch, Tr, Alloc>& f) {

        return f.str();
    }
    namespace io {
         using ::boost::str;
    }


        template<class Ch, class Tr, class Alloc>
        std::basic_ostream<Ch, Tr> &
        operator<<( std::basic_ostream<Ch, Tr> & os,
                    const basic_format<Ch, Tr, Alloc>& f)







    {
        typedef boost::basic_format<Ch, Tr, Alloc> format_t;
        if(f.items_.size()==0)
            os << f.prefix_;
        else {
            if(f.cur_arg_ < f.num_args_)
                if( f.exceptions() & io::too_few_args_bit )

                    boost::throw_exception(io::too_few_args(f.cur_arg_, f.num_args_));
            if(f.style_ & format_t::special_needs)
                os << f.str();
            else {

                os << f.prefix_;
                for(unsigned long i=0; i<f.items_.size(); ++i) {
                    const typename format_t::format_item_t& item = f.items_[i];
                    os << item.res_;
                    os << item.appendix_;
                }
            }
        }
        f.dumped_=true;
        return os;
    }

}
# 54 "/usr/include/boost/format.hpp" 2 3 4



# 1 "/usr/include/boost/format/detail/unset_macros.hpp" 1 3 4
# 58 "/usr/include/boost/format.hpp" 2 3 4
# 8 "../lib/error.h" 2


# 1 "../lib/source_file.h" 1
# 10 "../lib/source_file.h"
# 1 "../lib/cstring.h" 1
# 11 "../lib/cstring.h"
class cstring {
    const char *str;

 public:

    cstring() : str(0) {}
    cstring(const cstring &) = default;
    cstring(cstring &&) = default;
    cstring &operator=(const cstring &) = default;
    cstring &operator=(cstring &&) = default;
    cstring &operator=(const char *);
    cstring(const std::stringstream&);
    cstring(const char *s) { *this = s; }
    cstring(const std::string &a) { *this = a.c_str(); }
    cstring &operator=(const std::string &a) { return *this = a.c_str(); }
    const char *c_str() const { return str; }
    const char *find(int c) const { return str ? strchr(str, c) : nullptr; }
    const char *findlast(int c) const { return str ? strrchr(str, c) : str; }
    operator const char *() const { return str; }
    size_t size() const { return str ? strlen(str) : 0; }
    bool isNull() const { return str == nullptr; }
    bool isNullOrEmpty() const { return str == nullptr ? true : str[0] == 0; }
    bool operator==(const cstring &a) const { return str == a.str; }
    bool operator==(const char *a) const { return str ? a && !strcmp(str, a) : !a; }
    bool operator!=(const cstring &a) const { return str != a.str; }
    bool operator!=(const char *a) const { return str ? !a || !!strcmp(str, a) : !!a; }
    bool operator<(const cstring &a) const { return *this < a.str; }
    bool operator<(const char *a) const { return str ? a && strcmp(str, a) < 0 : !!a; }
    bool operator<=(const cstring &a) const { return *this <= a.str; }
    bool operator<=(const char *a) const { return str ? a && strcmp(str, a) <= 0 : true; }
    bool operator>(const cstring &a) const { return *this > a.str; }
    bool operator>(const char *a) const { return str ? !a || strcmp(str, a) > 0 : false; }
    bool operator>=(const cstring &a) const { return *this >= a.str; }
    bool operator>=(const char *a) const { return str ? !a || strcmp(str, a) >= 0 : !a; }

    bool operator==(const std::string &a) const { return *this == a.c_str(); }
    bool operator!=(const std::string &a) const { return *this != a.c_str(); }
    bool operator<(const std::string &a) const { return *this < a.c_str(); }
    bool operator<=(const std::string &a) const { return *this <= a.c_str(); }
    bool operator>(const std::string &a) const { return *this > a.c_str(); }
    bool operator>=(const std::string &a) const { return *this >= a.c_str(); }

    cstring operator+=(cstring a);
    cstring operator+=(const char *a);
    cstring operator+=(std::string a);
    cstring operator+=(char a);
    bool startsWith(const cstring& prefix) const;
    bool endsWith(const cstring& suffix) const;
    template<typename T>
    static cstring to_cstring(const T &t) {
        std::stringstream ss;
        ss << t;
        return cstring(ss.str()); }
    template<typename Iterator>
    static cstring join(Iterator begin, Iterator end, const char *delim = ", ") {
        std::stringstream ss;
        for (auto current = begin; current != end; ++current) {
            if (begin != current) ss << delim;
            ss << *current; }
        return cstring(ss.str()); }
    static cstring newline;
    static cstring empty;
    template<class T> static cstring make_unique(const T &inuse, cstring base, char sep = '.');
    cstring before(const char* at) const;
    cstring substr(size_t start) const
    { return (start >= size()) ? "" : substr(start, size() - start); }
    cstring substr(size_t start, size_t length) const;
};

inline bool operator==(const char *a, cstring b) { return b == a; }
inline bool operator!=(const char *a, cstring b) { return b != a; }

inline std::string operator+(cstring a, cstring b) {
    std::string rv(a); rv += b; return rv; }
inline std::string operator+(cstring a, const char *b) {
    std::string rv(a); rv += b; return rv; }
inline std::string operator+(cstring a, const std::string &b) {
    std::string rv(a); rv += b; return rv; }
inline std::string operator+(cstring a, char b) {
    std::string rv(a); rv += b; return rv; }
inline std::string operator+(const char *a, cstring b) {
    std::string rv(a); rv += b; return rv; }
inline std::string operator+(std::string a, cstring b) { a += b; return a; }
inline std::string operator+(char a, cstring b) {
    std::string rv(1, a); rv += b; return rv; }

inline cstring cstring::operator+=(cstring a) { *this = *this + a; return *this; }
inline cstring cstring::operator+=(const char *a) { *this = *this + a; return *this; }
inline cstring cstring::operator+=(std::string a) { *this = *this + a; return *this; }
inline cstring cstring::operator+=(char a) { *this = *this + a; return *this; }

inline std::string operator+=(std::string a, cstring b) {
    a.append(b.c_str());
    return a; }

template<class T> cstring cstring::make_unique(const T &inuse, cstring base, char sep) {
    char suffix[8];
    cstring rv = base;
    int counter = 0;
    while (inuse.count(rv)) {
        snprintf(suffix, sizeof(suffix)/sizeof(suffix[0]), "%c%d", sep, counter++);
        rv = base + suffix; }
    return rv; }

inline std::ostream &operator<<(std::ostream &out, cstring s) {
    return out << (s ? s.c_str() : "<null>"); }

namespace std {
template<> struct hash<cstring> {
    std::size_t operator()(const cstring& c) const {

        return hash<const char*>()(c.c_str());
    }
};
}
# 11 "../lib/source_file.h" 2
# 1 "../lib/stringref.h" 1
# 15 "../lib/stringref.h"
struct StringRef {
    const char *p;
    size_t len;
    StringRef() : p(0), len(0) {}
    StringRef(const char *str, size_t l) : p(str), len(l) {}
    StringRef(const char *str) : p(str), len(str ? strlen(str) : 0) {}
    StringRef(const std::string &str) : p(str.data()), len(str.size()) {}
    StringRef(cstring str) : p(str.c_str()), len(str.size()) {}
    void clear() { p = 0; len = 0; }
    StringRef(const StringRef &a) : p(a.p), len(a.len) {}
    StringRef &operator=(const StringRef &a) {
        p = a.p; len = a.len; return *this; }
    explicit operator bool () const { return p != 0; }

    bool operator==(const StringRef &a) const {
        return p ? (a.p && len == a.len && (!len || !memcmp(p, a.p, len))) : !a.p; }
    bool operator!=(const StringRef &a) const { return !operator==(a); }
    bool operator==(const std::string &a) const { return operator==(StringRef(a)); }
    bool operator==(const char *a) const {
        return p ? (a && (!len || !strncmp(p, a, len)) && !a[len]) : !a; }
    bool operator==(cstring a) const { return operator==(a.c_str()); }
    template <class T> bool operator!=(T a) const { return !(*this == a); }
    bool isNullOrEmpty() const { return p == 0 || len == 0; }

    int compare(const StringRef &a) const {
        if (!p) return a.p ? -1 : 0;
        if (!a.p) return 1;
        int rv = memcmp(p, a.p, std::min(len, a.len));
        if (!rv && len != a.len) rv = len < a.len ? -1 : 1;
        return rv; }
    int compare(const std::string &a) const { return compare(StringRef(a)); }
    int compare(const char *a) const {
        if (!p) return a ? -1 : 0;
        if (!a) return 1;
        int rv = strncmp(p, a, len);
        if (!rv && a[len]) rv = -1;
        return rv; }
    int compare(cstring a) const { return compare(a.c_str()); }
    template <class T> bool operator<(T a) const { return compare(a) < 0; }
    template <class T> bool operator<=(T a) const { return compare(a) <= 0; }
    template <class T> bool operator>(T a) const { return compare(a) > 0; }
    template <class T> bool operator>=(T a) const { return compare(a) >= 0; }

    operator std::string() const { return std::string(p, len); }
    operator cstring() const { return std::string(p, len); }
    cstring toString() const { return std::string(p, len); }
    std::string string() const { return std::string(p, len); }
    StringRef &operator+=(size_t i) {
        if (len < i) { p = 0; len = 0;
        } else { p += i; len -= i; }
        return *this; }
    StringRef &operator++() { p++; if (len) len--; else p = 0; return *this; }
    StringRef operator++(int) { StringRef rv(*this); ++*this; return rv; }
    char operator[](size_t i) const { return i < len ? p[i] : 0; }
    char operator*() const { return len ? *p : 0; }
    StringRef operator+(size_t i) const {
        StringRef rv(*this); rv += i; return rv; }
    StringRef &trim(const char *white = " \t\r\n") {
        while (len > 0 && strchr(white, *p)) { p++; len--; }
        while (len > 0 && strchr(white, p[len-1])) {len--; }
        return *this; }
    bool trimCR() {
        bool rv = false;
        while (len > 0 && p[len-1] == '\r') { rv = true; len--; }
        return rv; }
    StringRef trim(const char *white = " \t\r\n") const {
        StringRef rv(*this);
        rv.trim(white);
        return rv; }
    const char *begin() const { return p; }
    const char *end() const { return p + len; }
    const char *find(char ch) const {
        return p ? static_cast<const char *>(memchr(p, ch, len)) : p; }
    const char *findlast(char ch) const {
        return p ? static_cast<const char *>(memrchr(p, ch, len)) : p; }
    const char *find(const char *set) const {
        if (!p) return 0;
        size_t off = strcspn(p, set);
        return off >= len ? 0 : p + off; }
    const char *findstr(StringRef sub) {
        if (sub.len < 1) return p;
        const char *s = begin(), *e = end();
        while ((s = static_cast<const char *>(memchr(s, *sub.p, e-s)))) {
            if (sub.len > (size_t)(e-s)) return nullptr;
            if (!memcmp(s, sub.p, sub.len))
                return s; }
        return nullptr; }
    StringRef before(const char *s) const {
        return (size_t)(s-p) <= len ? StringRef(p, s-p) : StringRef(); }
    StringRef after(const char *s) const {
        return (size_t)(s-p) <= len ? StringRef(s, p+len-s) : StringRef(); }
    StringRef substr(size_t start, size_t length) const {
        if (len <= start) return 0;
        if (len <= length) return StringRef(p + start, len - start);
        return StringRef(p + start, length);
    }
};

template <class T> inline
    bool operator==(T a, const StringRef &b) { return b == a; }
template <class T> inline
    bool operator!=(T a, const StringRef &b) { return b != a; }
template <class T> inline
    bool operator>=(T a, const StringRef &b) { return b <= a; }
template <class T> inline
    bool operator>(T a, const StringRef &b) { return b < a; }
template <class T> inline
    bool operator<=(T a, const StringRef &b) { return b >= a; }
template <class T> inline
    bool operator<(T a, const StringRef &b) { return b > a; }

inline std::ostream &operator<<(std::ostream &os, const StringRef &a) {
    return a.len ? os.write(a.p, a.len) : os; }
inline std::string &operator+=(std::string &s, const StringRef &a) {
    return a.len ? s.append(a.p, a.len) : s; }
inline std::string operator+(const StringRef &s, const StringRef &a) {
    std::string rv(s); rv += a; return rv; }
inline std::string operator+(const std::string &s, const StringRef &a) {
    std::string rv(s); rv += a; return rv; }
inline std::string operator+(const StringRef &s, const std::string &a) {
    std::string rv(s); rv += a; return rv; }
inline std::string operator+(const char *s, const StringRef &a) {
    std::string rv(s); rv += a; return rv; }
inline std::string operator+(const StringRef &s, const char *a) {
    std::string rv(s); rv += a; return rv; }
inline std::string operator+(cstring s, const StringRef &a) {
    std::string rv(s); rv += a; return rv; }
inline std::string operator+(const StringRef &s, cstring a) {
    std::string rv(s); rv += a; return rv; }
# 12 "../lib/source_file.h" 2
# 1 "../lib/map.h" 1



# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/map" 1 3
# 59 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/map" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_map.h" 1 3
# 66 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_map.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 94 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_map.h" 3
  template <typename _Key, typename _Tp, typename _Compare = std::less<_Key>,
            typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class map
    {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;

    private:

      typedef typename _Alloc::value_type _Alloc_value_type;





    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
 friend class map<_Key, _Tp, _Compare, _Alloc>;
      protected:
 _Compare comp;

 value_compare(_Compare __c)
 : comp(__c) { }

      public:
 bool operator()(const value_type& __x, const value_type& __y) const
 { return comp(__x.first, __y.first); }
      };

    private:

      typedef typename _Alloc::template rebind<value_type>::other
        _Pair_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
         key_compare, _Pair_alloc_type> _Rep_type;


      _Rep_type _M_t;

    public:


      typedef typename _Pair_alloc_type::pointer pointer;
      typedef typename _Pair_alloc_type::const_pointer const_pointer;
      typedef typename _Pair_alloc_type::reference reference;
      typedef typename _Pair_alloc_type::const_reference const_reference;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;







      map()
      : _M_t() { }






      explicit
      map(const _Compare& __comp,
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Pair_alloc_type(__a)) { }
# 180 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_map.h" 3
      map(const map& __x)
      : _M_t(__x._M_t) { }
# 191 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_map.h" 3
      map(map&& __x)
      noexcept(is_nothrow_copy_constructible<_Compare>::value)
      : _M_t(std::move(__x._M_t)) { }
# 206 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_map.h" 3
      map(initializer_list<value_type> __l,
   const _Compare& __comp = _Compare(),
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Pair_alloc_type(__a))
      { _M_t._M_insert_unique(__l.begin(), __l.end()); }
# 223 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_map.h" 3
      template<typename _InputIterator>
        map(_InputIterator __first, _InputIterator __last)
 : _M_t()
        { _M_t._M_insert_unique(__first, __last); }
# 240 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_map.h" 3
      template<typename _InputIterator>
        map(_InputIterator __first, _InputIterator __last,
     const _Compare& __comp,
     const allocator_type& __a = allocator_type())
 : _M_t(__comp, _Pair_alloc_type(__a))
        { _M_t._M_insert_unique(__first, __last); }
# 263 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_map.h" 3
      map&
      operator=(const map& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
# 278 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_map.h" 3
      map&
      operator=(map&& __x)
      {


 this->clear();
 this->swap(__x);
 return *this;
      }
# 299 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_map.h" 3
      map&
      operator=(initializer_list<value_type> __l)
      {
 this->clear();
 this->insert(__l.begin(), __l.end());
 return *this;
      }



      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_t.get_allocator()); }







      iterator
      begin() noexcept
      { return _M_t.begin(); }






      const_iterator
      begin() const noexcept
      { return _M_t.begin(); }






      iterator
      end() noexcept
      { return _M_t.end(); }






      const_iterator
      end() const noexcept
      { return _M_t.end(); }






      reverse_iterator
      rbegin() noexcept
      { return _M_t.rbegin(); }






      const_reverse_iterator
      rbegin() const noexcept
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() noexcept
      { return _M_t.rend(); }






      const_reverse_iterator
      rend() const noexcept
      { return _M_t.rend(); }







      const_iterator
      cbegin() const noexcept
      { return _M_t.begin(); }






      const_iterator
      cend() const noexcept
      { return _M_t.end(); }






      const_reverse_iterator
      crbegin() const noexcept
      { return _M_t.rbegin(); }






      const_reverse_iterator
      crend() const noexcept
      { return _M_t.rend(); }






      bool
      empty() const noexcept
      { return _M_t.empty(); }


      size_type
      size() const noexcept
      { return _M_t.size(); }


      size_type
      max_size() const noexcept
      { return _M_t.max_size(); }
# 455 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_map.h" 3
      mapped_type&
      operator[](const key_type& __k)
      {



 iterator __i = lower_bound(__k);

 if (__i == end() || key_comp()(__k, (*__i).first))

   __i = _M_t._M_emplace_hint_unique(__i, std::piecewise_construct,
         std::tuple<const key_type&>(__k),
         std::tuple<>());



 return (*__i).second;
      }


      mapped_type&
      operator[](key_type&& __k)
      {



 iterator __i = lower_bound(__k);

 if (__i == end() || key_comp()(__k, (*__i).first))
   __i = _M_t._M_emplace_hint_unique(__i, std::piecewise_construct,
     std::forward_as_tuple(std::move(__k)),
     std::tuple<>());
 return (*__i).second;
      }
# 500 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_map.h" 3
      mapped_type&
      at(const key_type& __k)
      {
 iterator __i = lower_bound(__k);
 if (__i == end() || key_comp()(__k, (*__i).first))
   __throw_out_of_range(("map::at"));
 return (*__i).second;
      }

      const mapped_type&
      at(const key_type& __k) const
      {
 const_iterator __i = lower_bound(__k);
 if (__i == end() || key_comp()(__k, (*__i).first))
   __throw_out_of_range(("map::at"));
 return (*__i).second;
      }
# 538 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_map.h" 3
      template<typename... _Args>
 std::pair<iterator, bool>
 emplace(_Args&&... __args)
 { return _M_t._M_emplace_unique(std::forward<_Args>(__args)...); }
# 568 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_map.h" 3
      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __pos, _Args&&... __args)
 {
   return _M_t._M_emplace_hint_unique(__pos,
          std::forward<_Args>(__args)...);
 }
# 593 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_map.h" 3
      std::pair<iterator, bool>
      insert(const value_type& __x)
      { return _M_t._M_insert_unique(__x); }


      template<typename _Pair, typename = typename
        std::enable_if<std::is_constructible<value_type,
          _Pair&&>::value>::type>
        std::pair<iterator, bool>
        insert(_Pair&& __x)
        { return _M_t._M_insert_unique(std::forward<_Pair>(__x)); }
# 614 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_map.h" 3
      void
      insert(std::initializer_list<value_type> __list)
      { insert(__list.begin(), __list.end()); }
# 642 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_map.h" 3
      iterator

      insert(const_iterator __position, const value_type& __x)



      { return _M_t._M_insert_unique_(__position, __x); }


      template<typename _Pair, typename = typename
        std::enable_if<std::is_constructible<value_type,
          _Pair&&>::value>::type>
        iterator
        insert(const_iterator __position, _Pair&& __x)
        { return _M_t._M_insert_unique_(__position,
     std::forward<_Pair>(__x)); }
# 668 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_map.h" 3
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_unique(__first, __last); }
# 689 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_map.h" 3
      iterator
      erase(const_iterator __position)
      { return _M_t.erase(__position); }


      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(iterator __position)
      { return _M_t.erase(__position); }
# 725 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_map.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 745 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_map.h" 3
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_t.erase(__first, __last); }
# 777 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_map.h" 3
      void
      swap(map& __x)
      { _M_t.swap(__x._M_t); }







      void
      clear() noexcept
      { _M_t.clear(); }






      key_compare
      key_comp() const
      { return _M_t.key_comp(); }





      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }
# 820 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_map.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
# 835 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_map.h" 3
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
# 847 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_map.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
# 862 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_map.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }
# 877 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_map.h" 3
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }







      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }







      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 916 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_map.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }
# 935 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_map.h" 3
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator==(const map<_K1, _T1, _C1, _A1>&,
     const map<_K1, _T1, _C1, _A1>&);

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator<(const map<_K1, _T1, _C1, _A1>&,
    const map<_K1, _T1, _C1, _A1>&);
    };
# 960 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_map.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 977 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_map.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const map<_Key, _Tp, _Compare, _Alloc>& __x,
              const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const map<_Key, _Tp, _Compare, _Alloc>& __x,
              const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(map<_Key, _Tp, _Compare, _Alloc>& __x,
  map<_Key, _Tp, _Compare, _Alloc>& __y)
    { __x.swap(__y); }


}
# 62 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/map" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multimap.h" 1 3
# 64 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multimap.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 92 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multimap.h" 3
  template <typename _Key, typename _Tp,
     typename _Compare = std::less<_Key>,
     typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class multimap
    {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;

    private:

      typedef typename _Alloc::value_type _Alloc_value_type;





    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
 friend class multimap<_Key, _Tp, _Compare, _Alloc>;
      protected:
 _Compare comp;

 value_compare(_Compare __c)
 : comp(__c) { }

      public:
 bool operator()(const value_type& __x, const value_type& __y) const
 { return comp(__x.first, __y.first); }
      };

    private:

      typedef typename _Alloc::template rebind<value_type>::other
        _Pair_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
         key_compare, _Pair_alloc_type> _Rep_type;

      _Rep_type _M_t;

    public:


      typedef typename _Pair_alloc_type::pointer pointer;
      typedef typename _Pair_alloc_type::const_pointer const_pointer;
      typedef typename _Pair_alloc_type::reference reference;
      typedef typename _Pair_alloc_type::const_reference const_reference;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;






      multimap()
      : _M_t() { }






      explicit
      multimap(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Pair_alloc_type(__a)) { }
# 177 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multimap.h" 3
      multimap(const multimap& __x)
      : _M_t(__x._M_t) { }
# 188 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multimap.h" 3
      multimap(multimap&& __x)
      noexcept(is_nothrow_copy_constructible<_Compare>::value)
      : _M_t(std::move(__x._M_t)) { }
# 202 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multimap.h" 3
      multimap(initializer_list<value_type> __l,
        const _Compare& __comp = _Compare(),
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Pair_alloc_type(__a))
      { _M_t._M_insert_equal(__l.begin(), __l.end()); }
# 218 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multimap.h" 3
      template<typename _InputIterator>
        multimap(_InputIterator __first, _InputIterator __last)
 : _M_t()
        { _M_t._M_insert_equal(__first, __last); }
# 234 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multimap.h" 3
      template<typename _InputIterator>
        multimap(_InputIterator __first, _InputIterator __last,
   const _Compare& __comp,
   const allocator_type& __a = allocator_type())
 : _M_t(__comp, _Pair_alloc_type(__a))
        { _M_t._M_insert_equal(__first, __last); }
# 257 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multimap.h" 3
      multimap&
      operator=(const multimap& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
# 272 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multimap.h" 3
      multimap&
      operator=(multimap&& __x)
      {


 this->clear();
 this->swap(__x);
 return *this;
      }
# 293 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multimap.h" 3
      multimap&
      operator=(initializer_list<value_type> __l)
      {
 this->clear();
 this->insert(__l.begin(), __l.end());
 return *this;
      }



      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_t.get_allocator()); }







      iterator
      begin() noexcept
      { return _M_t.begin(); }






      const_iterator
      begin() const noexcept
      { return _M_t.begin(); }






      iterator
      end() noexcept
      { return _M_t.end(); }






      const_iterator
      end() const noexcept
      { return _M_t.end(); }






      reverse_iterator
      rbegin() noexcept
      { return _M_t.rbegin(); }






      const_reverse_iterator
      rbegin() const noexcept
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() noexcept
      { return _M_t.rend(); }






      const_reverse_iterator
      rend() const noexcept
      { return _M_t.rend(); }







      const_iterator
      cbegin() const noexcept
      { return _M_t.begin(); }






      const_iterator
      cend() const noexcept
      { return _M_t.end(); }






      const_reverse_iterator
      crbegin() const noexcept
      { return _M_t.rbegin(); }






      const_reverse_iterator
      crend() const noexcept
      { return _M_t.rend(); }




      bool
      empty() const noexcept
      { return _M_t.empty(); }


      size_type
      size() const noexcept
      { return _M_t.size(); }


      size_type
      max_size() const noexcept
      { return _M_t.max_size(); }
# 452 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multimap.h" 3
      template<typename... _Args>
 iterator
 emplace(_Args&&... __args)
 { return _M_t._M_emplace_equal(std::forward<_Args>(__args)...); }
# 479 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multimap.h" 3
      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __pos, _Args&&... __args)
 {
   return _M_t._M_emplace_hint_equal(__pos,
         std::forward<_Args>(__args)...);
 }
# 500 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multimap.h" 3
      iterator
      insert(const value_type& __x)
      { return _M_t._M_insert_equal(__x); }


      template<typename _Pair, typename = typename
        std::enable_if<std::is_constructible<value_type,
          _Pair&&>::value>::type>
        iterator
        insert(_Pair&& __x)
        { return _M_t._M_insert_equal(std::forward<_Pair>(__x)); }
# 533 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multimap.h" 3
      iterator

      insert(const_iterator __position, const value_type& __x)



      { return _M_t._M_insert_equal_(__position, __x); }


      template<typename _Pair, typename = typename
        std::enable_if<std::is_constructible<value_type,
          _Pair&&>::value>::type>
        iterator
        insert(const_iterator __position, _Pair&& __x)
        { return _M_t._M_insert_equal_(__position,
           std::forward<_Pair>(__x)); }
# 560 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multimap.h" 3
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_equal(__first, __last); }
# 573 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multimap.h" 3
      void
      insert(initializer_list<value_type> __l)
      { this->insert(__l.begin(), __l.end()); }
# 594 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multimap.h" 3
      iterator
      erase(const_iterator __position)
      { return _M_t.erase(__position); }


      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(iterator __position)
      { return _M_t.erase(__position); }
# 630 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multimap.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 651 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multimap.h" 3
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_t.erase(__first, __last); }
# 686 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multimap.h" 3
      void
      swap(multimap& __x)
      { _M_t.swap(__x._M_t); }







      void
      clear() noexcept
      { _M_t.clear(); }






      key_compare
      key_comp() const
      { return _M_t.key_comp(); }





      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }
# 729 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multimap.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
# 744 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multimap.h" 3
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }






      size_type
      count(const key_type& __x) const
      { return _M_t.count(__x); }
# 768 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multimap.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }
# 783 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multimap.h" 3
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }







      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }







      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 820 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multimap.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }
# 837 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multimap.h" 3
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator==(const multimap<_K1, _T1, _C1, _A1>&,
     const multimap<_K1, _T1, _C1, _A1>&);

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator<(const multimap<_K1, _T1, _C1, _A1>&,
    const multimap<_K1, _T1, _C1, _A1>&);
  };
# 862 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multimap.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 879 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_multimap.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
              const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
              const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(multimap<_Key, _Tp, _Compare, _Alloc>& __x,
         multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { __x.swap(__y); }


}
# 63 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/map" 2 3
# 5 "../lib/map.h" 2

template<class K, class T, class V, class Comp, class Alloc>
inline V get(const std::map<K, V, Comp, Alloc> &m, T key, V def = V()) {
    auto it = m.find(key);
    if (it != m.end()) return it->second;
    return def; }

template<class K, class T, class V, class Comp, class Alloc>
inline V *getref(std::map<K, V, Comp, Alloc> &m, T key) {
    auto it = m.find(key);
    if (it != m.end()) return &it->second;
    return 0; }

template<class K, class T, class V, class Comp, class Alloc>
inline const V *getref(const std::map<K, V, Comp, Alloc> &m, T key) {
    auto it = m.find(key);
    if (it != m.end()) return &it->second;
    return 0; }

template<class K, class T, class V, class Comp, class Alloc>
inline V get(const std::map<K, V, Comp, Alloc> *m, T key, V def = V()) {
    return m ? get(*m, key, def) : def; }

template<class K, class T, class V, class Comp, class Alloc>
inline V *getref(std::map<K, V, Comp, Alloc> *m, T key) {
    return m ? getref(*m, key) : 0; }

template<class K, class T, class V, class Comp, class Alloc>
inline const V *getref(const std::map<K, V, Comp, Alloc> *m, T key) {
    return m ? getref(*m, key) : 0; }


template<class PairIter>
class IterValues {
    class iterator : public std::iterator<
        typename std::iterator_traits<PairIter>::iterator_category,
        typename std::iterator_traits<PairIter>::value_type::second_type,
        typename std::iterator_traits<PairIter>::difference_type,
        typename std::iterator_traits<PairIter>::value_type::second_type*,
        typename std::iterator_traits<PairIter>::value_type::second_type&> {
        PairIter it;
     public:
        explicit iterator(PairIter i) : it(i) {}
        iterator &operator++() { ++it; return *this; }
        iterator &operator--() { --it; return *this; }
        bool operator==(const iterator &i) const { return it == i.it; }
        bool operator!=(const iterator &i) const { return it != i.it; }
        decltype(*&it->second) operator*() const { return it->second; }
        decltype(&it->second) operator->() const { return &it->second; }
    } b, e;

 public:
        template<class U> IterValues(U &map) : b(map.begin()), e(map.end()) {}
        IterValues(PairIter b, PairIter e) : b(b), e(e) {}
        iterator begin() const { return b; }
        iterator end() const { return e; }
};

template<class Map> IterValues<typename Map::iterator>
Values(Map &m) { return IterValues<typename Map::iterator>(m); }

template<class Map> IterValues<typename Map::const_iterator>
Values(const Map &m) { return IterValues<typename Map::const_iterator>(m); }

template<class PairIter> IterValues<PairIter>
Values(std::pair<PairIter, PairIter> range) {
    return IterValues<PairIter>(range.first, range.second); }
# 13 "../lib/source_file.h" 2

namespace Test { class TestSourceFile; }

namespace Util {
struct SourceFileLine;
# 26 "../lib/source_file.h"
class SourcePosition final {
 public:

    SourcePosition()
            : lineNumber(0),
              columnNumber(0) {}

    SourcePosition(unsigned lineNumber, unsigned columnNumber);

    SourcePosition(const SourcePosition& other)
            : lineNumber(other.lineNumber),
              columnNumber(other.columnNumber) {}

    inline bool operator==(const SourcePosition& rhs) const {
        return this->columnNumber == rhs.columnNumber &&
                this->lineNumber == rhs.columnNumber;
    }
    inline bool operator!=(const SourcePosition& rhs) const
    {return !this->operator==(rhs);}

    inline bool operator< (const SourcePosition& rhs) const {
        return (this->lineNumber < rhs.lineNumber) ||
                (this->lineNumber == rhs.lineNumber &&
                 this->columnNumber < rhs.columnNumber);
    }
    inline bool operator> (const SourcePosition& rhs) const
    {return rhs.operator< (*this);}
    inline bool operator<=(const SourcePosition& rhs) const
    {return !this->operator> (rhs);}
    inline bool operator>=(const SourcePosition& rhs) const
    {return !this->operator< (rhs);}


    SourcePosition& operator--() {
        if (this->columnNumber > 0)
            this->columnNumber--;
        return *this;
    }
    SourcePosition operator--(int) {
        SourcePosition tmp(*this);
        this->operator--();
        return tmp;
    }

    inline const SourcePosition& min(const SourcePosition& rhs) const {
        if (this->operator<(rhs))
            return *this;
        return rhs;
    }

    inline const SourcePosition& max(const SourcePosition& rhs) const {
        if (this->operator>(rhs))
            return *this;
        return rhs;
    }

    cstring toString() const;

    bool isValid() const {
        return this->lineNumber != 0;
    }

    unsigned getLineNumber() const {
        return this->lineNumber;
    }

    unsigned getColumnNumber() const {
        return this->columnNumber;
    }

 private:

    unsigned lineNumber;
    unsigned columnNumber;
};
# 111 "../lib/source_file.h"
class SourceInfo final {
 public:

    SourceInfo()
            : start(SourcePosition()),
              end(SourcePosition()) {}

    explicit SourceInfo(SourcePosition point) : start(point), end(point) {}

    SourceInfo(SourcePosition start, SourcePosition end);

    SourceInfo(const SourceInfo& other) = default;
    ~SourceInfo() = default;
    SourceInfo& operator=(const SourceInfo& other) = default;



    const SourceInfo operator+(const SourceInfo& rhs) const {
        if (!this->isValid())
            return rhs;
        if (!rhs.isValid())
            return *this;
        SourcePosition s = start.min(rhs.start);
        SourcePosition e = end.max(rhs.end);
        return SourceInfo(s, e);
    }
    SourceInfo &operator+=(const SourceInfo& rhs) {
        if (!isValid()) {
            *this = rhs;
        } else if (rhs.isValid()) {
            start = start.min(rhs.start);
            end = end.max(rhs.end);
        }
        return *this;
    }

    bool operator==(const SourceInfo &rhs) const
    { return start == rhs.start && end == rhs.end; }

    cstring toDebugString() const;

    void dbprint(std::ostream& out) const
    { out << this->toDebugString(); }

    cstring toSourceFragment() const;
    cstring toPositionString() const;
    SourceFileLine toPosition() const;

    bool isValid() const
    { return this->start.isValid(); }

    const SourcePosition& getStart() const
    { return this->start; }

    const SourcePosition& getEnd() const
    { return this->end; }





    bool operator< (const SourceInfo& rhs) const {
        if (!rhs.isValid()) return false;
        if (!isValid()) return true;
        return this->start < rhs.start;
    }
    inline bool operator> (const SourceInfo& rhs) const
    { return rhs.operator< (*this); }
    inline bool operator<=(const SourceInfo& rhs) const
    { return !this->operator> (rhs); }
    inline bool operator>=(const SourceInfo& rhs) const
    { return !this->operator< (rhs); }

 private:
    SourcePosition start;
    SourcePosition end;
};

class IHasDbPrint {
 public:
    virtual void dbprint(std::ostream& out) const = 0;
    virtual ~IHasDbPrint() {}
};

class IHasSourceInfo {
 public:
    virtual SourceInfo getSourceInfo() const = 0;
    virtual cstring toString() const = 0;
    virtual ~IHasSourceInfo() {}
};


struct SourceFileLine {

    cstring fileName;
    unsigned sourceLine;

    SourceFileLine(cstring file, unsigned line) :
            fileName(file),
            sourceLine(line) {}

    cstring toString() const;
};
# 225 "../lib/source_file.h"
class InputSources final {
    friend class Test::TestSourceFile;

 public:
    cstring getLine(unsigned lineNumber) const;

    SourceFileLine getSourceLine(unsigned line) const;

    unsigned lineCount() const;
    SourcePosition getCurrentPosition() const;
    unsigned getCurrentLineNumber() const;


    void seal();


    void appendText(const char* text);



    void mapLine(cstring file, unsigned originalSourceLineNo);





    cstring getSourceFragment(const SourcePosition &position) const;
    cstring getSourceFragment(const SourceInfo &position) const;

    cstring toDebugString() const;

    static InputSources* instance;

 private:
    InputSources();


    void appendToLastLine(StringRef text);

    void appendNewline(StringRef newline);


    bool sealed;

    std::map<unsigned, SourceFileLine> line_file_map;

    std::vector<cstring> contents;
};

}
# 11 "../lib/error.h" 2
# 1 "../lib/stringify.h" 1





# 1 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/stdint.h" 1 3
# 7 "../lib/stringify.h" 2






namespace Util {


template<typename T>
class HasToString final {
    template <typename U, cstring (U::*)() const> struct Check;
    template <typename U> static char func(Check<U, &U::toString> *);
    template <typename U> static int func(...);

 public:
    typedef HasToString type;
    enum { value = sizeof(func<T>(0)) == sizeof(char) };
};

cstring toString(bool value);
cstring toString(int value);
cstring toString(long value);
cstring toString(uint64_t value);
cstring toString(unsigned value);
cstring toString(double value);
cstring toString(std::string value);
cstring toString(const char* value);
cstring toString(cstring value);
cstring toString(StringRef value);
cstring toString(const mpz_class* value);
cstring toString(const void* value);

template<typename T>
auto toString(const T& value) -> typename std::enable_if<HasToString<T>::value, cstring>::type
{ return value.toString(); }


cstring printf_format(const char* fmt_str, ...);

cstring vprintf_format(const char* fmt_str, va_list ap);
}
# 12 "../lib/error.h" 2




static inline std::string error_helper(boost::format& f, std::string message,
                                       std::string position, std::string tail) {
    std::string text = boost::str(f);
    std::string result = position;
    if (!position.empty())
        result += ": ";
    result += message + text + "\n" + tail;
    return result;
}

template<class... Args>
std::string error_helper(boost::format& f, std::string message, std::string position,
                         std::string tail, const char* t, Args... args);

template<class... Args>
std::string error_helper(boost::format& f, std::string message, std::string position,
                         std::string tail, const cstring& t, Args... args);

template<class... Args>
std::string error_helper(boost::format& f, std::string message,
                         std::string position, std::string tail,
                         const Util::SourceInfo &info, Args... args);

template<typename T, class... Args>
auto error_helper(boost::format& f, std::string message, std::string position,
                  std::string tail, const T &t, Args... args) ->
    typename std::enable_if<Util::HasToString<T>::value &&
                            !std::is_base_of<Util::IHasSourceInfo, T>::value, std::string>::type;

template<typename T, class... Args>
auto error_helper(boost::format& f, std::string message, std::string position,
                  std::string tail, const T *t, Args... args) ->
    typename std::enable_if<Util::HasToString<T>::value &&
                            !std::is_base_of<Util::IHasSourceInfo, T>::value, std::string>::type;

template<typename T, class... Args>
auto error_helper(boost::format& f, std::string message, std::string position,
                  std::string tail, const T &t, Args... args) ->
    typename std::enable_if<std::is_base_of<Util::IHasSourceInfo, T>::value, std::string>::type;

template<typename T, class... Args>
auto error_helper(boost::format& f, std::string message, std::string position,
                  std::string tail, const T *t, Args... args) ->
    typename std::enable_if<std::is_base_of<Util::IHasSourceInfo, T>::value, std::string>::type;

template<class... Args>
std::string error_helper(boost::format& f, std::string message, std::string position,
                         std::string tail, const mpz_class *t, Args... args);

template<class... Args>
std::string error_helper(boost::format& f, std::string message, std::string position,
                         std::string tail, const mpz_class &t, Args... args);

template<typename T, class... Args>
auto
error_helper(boost::format& f, std::string message,
             std::string position, std::string tail,
             const T& t, Args... args) ->
    typename std::enable_if<std::is_arithmetic<T>::value, std::string>::type;



template<class... Args>
std::string error_helper(boost::format& f, std::string message, std::string position,
                         std::string tail, const char* t, Args... args) {
    return error_helper(f % t, message, position, tail, std::forward<Args>(args)...);
}

template<class... Args>
std::string error_helper(boost::format& f, std::string message, std::string position,
                         std::string tail, const cstring& t, Args... args) {
    return error_helper(f % t.c_str(), message, position, tail, std::forward<Args>(args)...);
}

template<typename T, class... Args>
auto error_helper(boost::format& f, std::string message, std::string position,
                  std::string tail, const T &t, Args... args) ->
    typename std::enable_if<Util::HasToString<T>::value &&
                            !std::is_base_of<Util::IHasSourceInfo, T>::value, std::string>::type {
    return error_helper(f % t.toString(), message, position, tail, std::forward<Args>(args)...);
}

template<typename T, class... Args>
auto error_helper(boost::format& f, std::string message, std::string position,
                  std::string tail, const T *t, Args... args) ->
    typename std::enable_if<Util::HasToString<T>::value &&
                            !std::is_base_of<Util::IHasSourceInfo, T>::value, std::string>::type {
    return error_helper(f % t->toString(), message, position, tail, std::forward<Args>(args)...);
}

template<class... Args>
std::string error_helper(boost::format& f, std::string message, std::string position,
                         std::string tail, const mpz_class *t, Args... args) {
    return error_helper(f % t->get_str(), message, position, tail, std::forward<Args>(args)...);
}

template<class... Args>
std::string error_helper(boost::format& f, std::string message, std::string position,
                         std::string tail, const mpz_class &t, Args... args) {
    return error_helper(f % t.get_str(), message, position, tail, std::forward<Args>(args)...);
}

template<typename T, class... Args>
auto
error_helper(boost::format& f, std::string message, std::string position,
             std::string tail, const T& t, Args... args) ->
    typename std::enable_if<std::is_arithmetic<T>::value, std::string>::type {
    return error_helper(f % t, message, position, tail, std::forward<Args>(args)...);
}

template<class... Args>
std::string error_helper(boost::format& f, std::string message, std::string position,
                         std::string tail, const Util::SourceInfo &info, Args... args) {
    cstring posString = info.toPositionString();
    if (position.empty()) {
        position = posString;
        posString = "";
    } else {
        if (!posString.isNullOrEmpty())
            posString += "\n";
    }
    return error_helper(f % "", message, position, tail + posString + info.toSourceFragment(),
                        std::forward<Args>(args)...);
}

template<typename T, class... Args>
auto error_helper(boost::format& f, std::string message, std::string position,
                  std::string tail, const T *t, Args... args) ->
    typename std::enable_if<std::is_base_of<Util::IHasSourceInfo, T>::value, std::string>::type {
    cstring posString = t->getSourceInfo().toPositionString();
    if (position.empty()) {
        position = posString;
        posString = "";
    } else {
        if (!posString.isNullOrEmpty())
            posString += "\n";
    }
    return error_helper(f % t->toString(), message, position,
                        tail + posString + t->getSourceInfo().toSourceFragment(),
                        std::forward<Args>(args)...);
}

template<typename T, class... Args>
auto error_helper(boost::format& f, std::string message, std::string position,
                  std::string tail, const T &t, Args... args) ->
    typename std::enable_if<std::is_base_of<Util::IHasSourceInfo, T>::value, std::string>::type {
    cstring posString = t.getSourceInfo().toPositionString();
    if (position.empty()) {
        position = posString;
        posString = "";
    } else {
        if (!posString.isNullOrEmpty())
            posString += "\n";
    }
    return error_helper(f % t.toString(), message, position,
                        tail + posString + t.getSourceInfo().toSourceFragment(),
                        std::forward<Args>(args)...);
}



static inline std::string bug_helper(boost::format& f, std::string message,
                                     std::string position, std::string tail) {
    std::string text = boost::str(f);
    std::string result = position;
    if (!position.empty())
        result += ": ";
    result += message + text + "\n" + tail;
    return result;
}

template<class... Args>
std::string bug_helper(boost::format& f, std::string message, std::string position,
                       std::string tail, const char* t, Args... args);

template<class... Args>
std::string bug_helper(boost::format& f, std::string message, std::string position,
                       std::string tail, const cstring& t, Args... args);

template<class... Args>
std::string bug_helper(boost::format& f, std::string message,
                       std::string position, std::string tail,
                       const Util::SourceInfo &info, Args... args);

template<typename T, class... Args>
auto bug_helper(boost::format& f, std::string message, std::string position,
                std::string tail, const T &t, Args... args) ->
    typename std::enable_if<std::is_base_of<Util::IHasSourceInfo, T>::value, std::string>::type;

template<typename T, class... Args>
auto bug_helper(boost::format& f, std::string message, std::string position,
                std::string tail, const T *t, Args... args) ->
    typename std::enable_if<std::is_base_of<Util::IHasSourceInfo, T>::value, std::string>::type;

template<typename T, class... Args>
auto bug_helper(boost::format& f, std::string message, std::string position,
                std::string tail, const T *t, Args... args) ->
    typename std::enable_if<!std::is_base_of<Util::IHasSourceInfo, T>::value, std::string>::type;

template<class... Args>
std::string bug_helper(boost::format& f, std::string message, std::string position,
                       std::string tail, const mpz_class *t, Args... args);

template<class... Args>
std::string bug_helper(boost::format& f, std::string message, std::string position,
                       std::string tail, const mpz_class &t, Args... args);

template<typename T, class... Args>
auto
bug_helper(boost::format& f, std::string message,
           std::string position, std::string tail,
           const T& t, Args... args) ->
    typename std::enable_if<std::is_arithmetic<T>::value, std::string>::type;



template<class... Args>
std::string bug_helper(boost::format& f, std::string message, std::string position,
                       std::string tail, const char* t, Args... args) {
    return bug_helper(f % t, message, position, tail, std::forward<Args>(args)...);
}

template<class... Args>
std::string bug_helper(boost::format& f, std::string message, std::string position,
                       std::string tail, const cstring& t, Args... args) {
    return bug_helper(f % t.c_str(), message, position, tail, std::forward<Args>(args)...);
}

template<typename T, class... Args>
auto bug_helper(boost::format& f, std::string message, std::string position,
                std::string tail, const T *t, Args... args) ->
        typename std::enable_if<!std::is_base_of<Util::IHasSourceInfo, T>::value,
                                std::string>::type {
    std::stringstream str;
    str << t;
    return bug_helper(f % str.str(), message, position, tail, std::forward<Args>(args)...);
}

template<class... Args>
std::string bug_helper(boost::format& f, std::string message, std::string position,
                       std::string tail, const mpz_class *t, Args... args) {
    return bug_helper(f % t->get_str(), message, position, tail, std::forward<Args>(args)...);
}

template<class... Args>
std::string bug_helper(boost::format& f, std::string message, std::string position,
                       std::string tail, const mpz_class &t, Args... args) {
    return bug_helper(f % t.get_str(), message, position, tail, std::forward<Args>(args)...);
}

template<typename T, class... Args>
auto
bug_helper(boost::format& f, std::string message, std::string position,
           std::string tail, const T& t, Args... args) ->
    typename std::enable_if<std::is_arithmetic<T>::value, std::string>::type {
    return bug_helper(f % t, message, position, tail, std::forward<Args>(args)...);
}

template<class... Args>
std::string bug_helper(boost::format& f, std::string message, std::string position,
                       std::string tail, const Util::SourceInfo &info, Args... args) {
    cstring posString = info.toPositionString();
    if (position.empty()) {
        position = posString;
        posString = "";
    } else {
        if (!posString.isNullOrEmpty())
            posString += "\n";
    }
    return bug_helper(f % "", message, position, tail + posString + info.toSourceFragment(),
                        std::forward<Args>(args)...);
}

template<typename T, class... Args>
auto bug_helper(boost::format& f, std::string message, std::string position,
                std::string tail, const T *t, Args... args) ->
    typename std::enable_if<std::is_base_of<Util::IHasSourceInfo, T>::value, std::string>::type {
    cstring posString = t->getSourceInfo().toPositionString();
    if (position.empty()) {
        position = posString;
        posString = "";
    } else {
        if (!posString.isNullOrEmpty())
            posString += "\n";
    }
    std::stringstream str;
    str << t;
    return bug_helper(f % str.str(), message, position,
                      tail + posString + t->getSourceInfo().toSourceFragment(),
                      std::forward<Args>(args)...);
}

template<typename T, class... Args>
auto bug_helper(boost::format& f, std::string message, std::string position,
                std::string tail, const T &t, Args... args) ->
    typename std::enable_if<std::is_base_of<Util::IHasSourceInfo, T>::value, std::string>::type {
    cstring posString = t.getSourceInfo().toPositionString();
    if (position.empty()) {
        position = posString;
        posString = "";
    } else {
        if (!posString.isNullOrEmpty())
            posString += "\n";
    }
    std::stringstream str;
    str << t;
    return bug_helper(f % str.str(), message, position,
                        tail + posString + t.getSourceInfo().toSourceFragment(),
                        std::forward<Args>(args)...);
}
# 335 "../lib/error.h"
class ErrorReporter final {
 public:
    static ErrorReporter instance;

 private:
    std::ostream* outputstream;

    ErrorReporter()
        : errorCount(0),
          warningCount(0)
    { outputstream = &std::cerr; }

 private:
    void emit_message(cstring message) {
        *outputstream << message;
        outputstream->flush();
    }

 public:

    template <typename... T>
    std::string bug_message(const char* format, T... args) {
        boost::format fmt(format);
        std::string message = ::bug_helper(fmt, "", "", "", args...);
        return message;
    }

    template <typename... T>
    std::string format_message(const char* format, T... args) {
        boost::format fmt(format);
        std::string message = ::error_helper(fmt, "", "", "", args...);
        return message;
    }

    template <typename... T>
    void error(const char* format, T... args) {
        errorCount++;
        boost::format fmt(format);
        std::string message = ::error_helper(fmt, "error: ", "", "", args...);
        emit_message(message);
    }

    template <typename... T>
    void warning(const char* format, T... args) {
        warningCount++;
        boost::format fmt(format);
        std::string message = ::error_helper(fmt, "warning: ", "", "", args...);
        emit_message(message);
    }

    unsigned getErrorCount() const {
        return errorCount;
    }

    unsigned getWarningCount() const {
        return warningCount;
    }





    void parser_error(const char *fmt, ...) {
        va_list args;
        __builtin_va_start(args, fmt);
        parser_error(fmt, args);
        __builtin_va_end(args);
    }

    void setOutputStream(std::ostream* stream)
    { outputstream = stream; }

    void parser_error(const char* fmt, va_list args) {
        errorCount++;

        Util::SourcePosition position = Util::InputSources::instance->getCurrentPosition();
        position--;
        Util::SourceFileLine fileError =
                Util::InputSources::instance->getSourceLine(position.getLineNumber());
        cstring msg = Util::vprintf_format(fmt, args);
        *outputstream << fileError.toString() << ":" << msg << std::endl;
        cstring sourceFragment = Util::InputSources::instance->getSourceFragment(position);
        emit_message(sourceFragment);
    }

 private:
    unsigned errorCount;
    unsigned warningCount;
};




template <typename... T>
inline void error(const char* format, T... args) {
    ErrorReporter::instance.error(format, args...);
}

inline unsigned errorCount() { return ErrorReporter::instance.getErrorCount(); }

template <typename... T>
inline void warning(const char* format, T... args) {
    ErrorReporter::instance.warning(format, args...);
}
# 7 "../lib/null.h" 2
# 10 "../ir/ir.h" 2

# 1 "../lib/algorithm.h" 1
# 14 "../lib/algorithm.h"
template<class C, class T>
inline bool contains(C &c, const T &val) {
    return std::find(c.begin(), c.end(), val) != c.end(); }

template<class C, class Pred>
inline bool contains_if(C &c, Pred pred) {
    return std::find_if(c.begin(), c.end(), pred) != c.end(); }

template<class Pred, class Key, class Compare = std::less<Key>, class Alloc = std::allocator<Key>>
inline void remove_if(std::set<Key, Compare, Alloc> &set, Pred pred) {
    auto it = set.begin();
    while (it != set.end())
        if (pred(*it))
            it = set.erase(it);
        else
            ++it;
}

template<class C, class Pred>
inline typename C::iterator remove_if(C &c, Pred pred) {
    return std::remove_if(c.begin(), c.end(), pred); }

template<class C, class T>
inline typename C::iterator find(C &c, const T &val) {
    return std::find(c.begin(), c.end(), val); }

using std::min_element;
using std::max_element;

template<class C>
inline typename C::const_iterator min_element(const C &c) {
    return min_element(c.begin(), c.end()); }
template<class C, class Compare>
inline typename C::const_iterator min_element(const C &c, Compare comp) {
    return min_element(c.begin(), c.end(), comp); }

template<class C>
inline typename C::const_iterator max_element(const C &c) {
    return max_element(c.begin(), c.end()); }
template<class C, class Compare>
inline typename C::const_iterator max_element(const C &c, Compare comp) {
    return max_element(c.begin(), c.end(), comp); }

template<class Iter, class Fn>
inline Fn for_each(std::pair<Iter, Iter> range, Fn fn) {
    return std::for_each(range.first, range.second, fn); }

template<class Iter> Iter begin(std::pair<Iter, Iter> pr) { return pr.first; }
template<class Iter> Iter end(std::pair<Iter, Iter> pr) { return pr.second; }
# 12 "../ir/ir.h" 2


# 1 "../lib/ordered_map.h" 1




# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/list" 1 3
# 59 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/list" 3




# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 1 3
# 64 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
  namespace __detail
  {
# 77 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
    struct _List_node_base
    {
      _List_node_base* _M_next;
      _List_node_base* _M_prev;

      static void
      swap(_List_node_base& __x, _List_node_base& __y) noexcept;

      void
      _M_transfer(_List_node_base* const __first,
    _List_node_base* const __last) noexcept;

      void
      _M_reverse() noexcept;

      void
      _M_hook(_List_node_base* const __position) noexcept;

      void
      _M_unhook() noexcept;
    };


  }




  template<typename _Tp>
    struct _List_node : public __detail::_List_node_base
    {

      _Tp _M_data;


      template<typename... _Args>
        _List_node(_Args&&... __args)
 : __detail::_List_node_base(), _M_data(std::forward<_Args>(__args)...)
        { }

    };






  template<typename _Tp>
    struct _List_iterator
    {
      typedef _List_iterator<_Tp> _Self;
      typedef _List_node<_Tp> _Node;

      typedef ptrdiff_t difference_type;
      typedef std::bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;

      _List_iterator()
      : _M_node() { }

      explicit
      _List_iterator(__detail::_List_node_base* __x)
      : _M_node(__x) { }


      reference
      operator*() const
      { return static_cast<_Node*>(_M_node)->_M_data; }

      pointer
      operator->() const
      { return std::__addressof(static_cast<_Node*>(_M_node)->_M_data); }

      _Self&
      operator++()
      {
 _M_node = _M_node->_M_next;
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_next;
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _M_node->_M_prev;
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_prev;
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }


      __detail::_List_node_base* _M_node;
    };






  template<typename _Tp>
    struct _List_const_iterator
    {
      typedef _List_const_iterator<_Tp> _Self;
      typedef const _List_node<_Tp> _Node;
      typedef _List_iterator<_Tp> iterator;

      typedef ptrdiff_t difference_type;
      typedef std::bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;

      _List_const_iterator()
      : _M_node() { }

      explicit
      _List_const_iterator(const __detail::_List_node_base* __x)
      : _M_node(__x) { }

      _List_const_iterator(const iterator& __x)
      : _M_node(__x._M_node) { }



      reference
      operator*() const
      { return static_cast<_Node*>(_M_node)->_M_data; }

      pointer
      operator->() const
      { return std::__addressof(static_cast<_Node*>(_M_node)->_M_data); }

      _Self&
      operator++()
      {
 _M_node = _M_node->_M_next;
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_next;
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _M_node->_M_prev;
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_prev;
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }


      const __detail::_List_node_base* _M_node;
    };

  template<typename _Val>
    inline bool
    operator==(const _List_iterator<_Val>& __x,
        const _List_const_iterator<_Val>& __y)
    { return __x._M_node == __y._M_node; }

  template<typename _Val>
    inline bool
    operator!=(const _List_iterator<_Val>& __x,
               const _List_const_iterator<_Val>& __y)
    { return __x._M_node != __y._M_node; }



  template<typename _Tp, typename _Alloc>
    class _List_base
    {
    protected:
# 305 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
      typedef typename _Alloc::template rebind<_List_node<_Tp> >::other
        _Node_alloc_type;

      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;

      struct _List_impl
      : public _Node_alloc_type
      {
 __detail::_List_node_base _M_node;

 _List_impl()
 : _Node_alloc_type(), _M_node()
 { }

 _List_impl(const _Node_alloc_type& __a)
 : _Node_alloc_type(__a), _M_node()
 { }


 _List_impl(_Node_alloc_type&& __a)
 : _Node_alloc_type(std::move(__a)), _M_node()
 { }

      };

      _List_impl _M_impl;

      _List_node<_Tp>*
      _M_get_node()
      { return _M_impl._Node_alloc_type::allocate(1); }

      void
      _M_put_node(_List_node<_Tp>* __p)
      { _M_impl._Node_alloc_type::deallocate(__p, 1); }

  public:
      typedef _Alloc allocator_type;

      _Node_alloc_type&
      _M_get_Node_allocator() noexcept
      { return *static_cast<_Node_alloc_type*>(&_M_impl); }

      const _Node_alloc_type&
      _M_get_Node_allocator() const noexcept
      { return *static_cast<const _Node_alloc_type*>(&_M_impl); }

      _Tp_alloc_type
      _M_get_Tp_allocator() const noexcept
      { return _Tp_alloc_type(_M_get_Node_allocator()); }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Node_allocator()); }

      _List_base()
      : _M_impl()
      { _M_init(); }

      _List_base(const _Node_alloc_type& __a)
      : _M_impl(__a)
      { _M_init(); }


      _List_base(_List_base&& __x)
      : _M_impl(std::move(__x._M_get_Node_allocator()))
      {
 _M_init();
 __detail::_List_node_base::swap(_M_impl._M_node, __x._M_impl._M_node);
      }



      ~_List_base() noexcept
      { _M_clear(); }

      void
      _M_clear();

      void
      _M_init()
      {
        this->_M_impl._M_node._M_next = &this->_M_impl._M_node;
        this->_M_impl._M_node._M_prev = &this->_M_impl._M_node;
      }
    };
# 437 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class list : protected _List_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;



      typedef _List_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
      typedef typename _Base::_Node_alloc_type _Node_alloc_type;

    public:
      typedef _Tp value_type;
      typedef typename _Tp_alloc_type::pointer pointer;
      typedef typename _Tp_alloc_type::const_pointer const_pointer;
      typedef typename _Tp_alloc_type::reference reference;
      typedef typename _Tp_alloc_type::const_reference const_reference;
      typedef _List_iterator<_Tp> iterator;
      typedef _List_const_iterator<_Tp> const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:


      typedef _List_node<_Tp> _Node;

      using _Base::_M_impl;
      using _Base::_M_put_node;
      using _Base::_M_get_node;
      using _Base::_M_get_Tp_allocator;
      using _Base::_M_get_Node_allocator;
# 498 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
      template<typename... _Args>
        _Node*
        _M_create_node(_Args&&... __args)
 {
   _Node* __p = this->_M_get_node();
   try
     {
       _M_get_Node_allocator().construct(__p,
      std::forward<_Args>(__args)...);
     }
   catch(...)
     {
       _M_put_node(__p);
       throw;
     }
   return __p;
 }


    public:





      list()
      : _Base() { }





      explicit
      list(const allocator_type& __a)
      : _Base(_Node_alloc_type(__a)) { }
# 542 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
      explicit
      list(size_type __n)
      : _Base()
      { _M_default_initialize(__n); }
# 555 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
      list(size_type __n, const value_type& __value,
    const allocator_type& __a = allocator_type())
      : _Base(_Node_alloc_type(__a))
      { _M_fill_initialize(__n, __value); }
# 582 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
      list(const list& __x)
      : _Base(__x._M_get_Node_allocator())
      { _M_initialize_dispatch(__x.begin(), __x.end(), __false_type()); }
# 594 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
      list(list&& __x) noexcept
      : _Base(std::move(__x)) { }
# 605 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
      list(initializer_list<value_type> __l,
           const allocator_type& __a = allocator_type())
      : _Base(_Node_alloc_type(__a))
      { _M_initialize_dispatch(__l.begin(), __l.end(), __false_type()); }
# 622 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        list(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
 : _Base(_Node_alloc_type(__a))
        { _M_initialize_dispatch(__first, __last, __false_type()); }
# 655 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
      list&
      operator=(const list& __x);
# 666 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
      list&
      operator=(list&& __x)
      {


 this->clear();
 this->swap(__x);
 return *this;
      }
# 683 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
      list&
      operator=(initializer_list<value_type> __l)
      {
 this->assign(__l.begin(), __l.end());
 return *this;
      }
# 701 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 718 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        void
        assign(_InputIterator __first, _InputIterator __last)
        { _M_assign_dispatch(__first, __last, __false_type()); }
# 742 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
      void
      assign(initializer_list<value_type> __l)
      { this->assign(__l.begin(), __l.end()); }



      allocator_type
      get_allocator() const noexcept
      { return _Base::get_allocator(); }






      iterator
      begin() noexcept
      { return iterator(this->_M_impl._M_node._M_next); }






      const_iterator
      begin() const noexcept
      { return const_iterator(this->_M_impl._M_node._M_next); }






      iterator
      end() noexcept
      { return iterator(&this->_M_impl._M_node); }






      const_iterator
      end() const noexcept
      { return const_iterator(&this->_M_impl._M_node); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }







      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_impl._M_node._M_next); }






      const_iterator
      cend() const noexcept
      { return const_iterator(&this->_M_impl._M_node); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }







      bool
      empty() const noexcept
      { return this->_M_impl._M_node._M_next == &this->_M_impl._M_node; }


      size_type
      size() const noexcept
      { return std::distance(begin(), end()); }


      size_type
      max_size() const noexcept
      { return _M_get_Node_allocator().max_size(); }
# 891 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
      void
      resize(size_type __new_size);
# 904 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
      void
      resize(size_type __new_size, const value_type& __x);
# 926 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
      reference
      front()
      { return *begin(); }





      const_reference
      front() const
      { return *begin(); }





      reference
      back()
      {
 iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }





      const_reference
      back() const
      {
 const_iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }
# 973 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
      void
      push_front(const value_type& __x)
      { this->_M_insert(begin(), __x); }


      void
      push_front(value_type&& __x)
      { this->_M_insert(begin(), std::move(__x)); }

      template<typename... _Args>
        void
        emplace_front(_Args&&... __args)
        { this->_M_insert(begin(), std::forward<_Args>(__args)...); }
# 1000 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
      void
      pop_front()
      { this->_M_erase(begin()); }
# 1014 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
      void
      push_back(const value_type& __x)
      { this->_M_insert(end(), __x); }


      void
      push_back(value_type&& __x)
      { this->_M_insert(end(), std::move(__x)); }

      template<typename... _Args>
        void
        emplace_back(_Args&&... __args)
        { this->_M_insert(end(), std::forward<_Args>(__args)...); }
# 1040 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
      void
      pop_back()
      { this->_M_erase(iterator(this->_M_impl._M_node._M_prev)); }
# 1057 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
      template<typename... _Args>
        iterator
        emplace(iterator __position, _Args&&... __args);
# 1073 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
# 1088 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
      iterator
      insert(iterator __position, value_type&& __x)
      { return emplace(__position, std::move(__x)); }
# 1105 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
      void
      insert(iterator __p, initializer_list<value_type> __l)
      { this->insert(__p, __l.begin(), __l.end()); }
# 1122 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      {
 list __tmp(__n, __x, get_allocator());
 splice(__position, __tmp);
      }
# 1143 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {
   list __tmp(__first, __last, get_allocator());
   splice(__position, __tmp);
 }
# 1171 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
      iterator
      erase(iterator __position);
# 1192 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
      iterator
      erase(iterator __first, iterator __last)
      {
 while (__first != __last)
   __first = erase(__first);
 return __last;
      }
# 1209 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
      void
      swap(list& __x)
      {
 __detail::_List_node_base::swap(this->_M_impl._M_node,
     __x._M_impl._M_node);



 std::__alloc_swap<typename _Base::_Node_alloc_type>::
   _S_do_it(_M_get_Node_allocator(), __x._M_get_Node_allocator());
      }







      void
      clear() noexcept
      {
        _Base::_M_clear();
        _Base::_M_init();
      }
# 1246 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
      void

      splice(iterator __position, list&& __x)



      {
 if (!__x.empty())
   {
     _M_check_equal_allocators(__x);

     this->_M_transfer(__position, __x.begin(), __x.end());
   }
      }


      void
      splice(iterator __position, list& __x)
      { splice(__position, std::move(__x)); }
# 1276 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
      void

      splice(iterator __position, list&& __x, iterator __i)



      {
 iterator __j = __i;
 ++__j;
 if (__position == __i || __position == __j)
   return;

 if (this != &__x)
   _M_check_equal_allocators(__x);

 this->_M_transfer(__position, __i, __j);
      }


      void
      splice(iterator __position, list& __x, iterator __i)
      { splice(__position, std::move(__x), __i); }
# 1312 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
      void

      splice(iterator __position, list&& __x, iterator __first,
      iterator __last)




      {
 if (__first != __last)
   {
     if (this != &__x)
       _M_check_equal_allocators(__x);

     this->_M_transfer(__position, __first, __last);
   }
      }


      void
      splice(iterator __position, list& __x, iterator __first, iterator __last)
      { splice(__position, std::move(__x), __first, __last); }
# 1347 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
      void
      remove(const _Tp& __value);
# 1361 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
      template<typename _Predicate>
        void
        remove_if(_Predicate);
# 1375 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
      void
      unique();
# 1390 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
      template<typename _BinaryPredicate>
        void
        unique(_BinaryPredicate);
# 1404 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
      void
      merge(list&& __x);

      void
      merge(list& __x)
      { merge(std::move(__x)); }
# 1429 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
      template<typename _StrictWeakOrdering>
        void
        merge(list&& __x, _StrictWeakOrdering __comp);

      template<typename _StrictWeakOrdering>
        void
        merge(list& __x, _StrictWeakOrdering __comp)
        { merge(std::move(__x), __comp); }
# 1448 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
      void
      reverse() noexcept
      { this->_M_impl._M_node._M_reverse(); }







      void
      sort();







      template<typename _StrictWeakOrdering>
        void
        sort(_StrictWeakOrdering);

    protected:






      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
        { _M_fill_initialize(static_cast<size_type>(__n), __x); }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   for (; __first != __last; ++__first)

     emplace_back(*__first);



 }



      void
      _M_fill_initialize(size_type __n, const value_type& __x)
      {
 for (; __n; --__n)
   push_back(__x);
      }



      void
      _M_default_initialize(size_type __n)
      {
 for (; __n; --__n)
   emplace_back();
      }


      void
      _M_default_append(size_type __n);
# 1526 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type);



      void
      _M_fill_assign(size_type __n, const value_type& __val);



      void
      _M_transfer(iterator __position, iterator __first, iterator __last)
      { __position._M_node->_M_transfer(__first._M_node, __last._M_node); }
# 1557 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
     template<typename... _Args>
       void
       _M_insert(iterator __position, _Args&&... __args)
       {
  _Node* __tmp = _M_create_node(std::forward<_Args>(__args)...);
  __tmp->_M_hook(__position._M_node);
       }



      void
      _M_erase(iterator __position)
      {
        __position._M_node->_M_unhook();
        _Node* __n = static_cast<_Node*>(__position._M_node);

        _M_get_Node_allocator().destroy(__n);



        _M_put_node(__n);
      }


      void
      _M_check_equal_allocators(list& __x)
      {
 if (std::__alloc_neq<typename _Base::_Node_alloc_type>::
     _S_do_it(_M_get_Node_allocator(), __x._M_get_Node_allocator()))
   __throw_runtime_error(("list::_M_check_equal_allocators"));
      }
    };
# 1600 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    {
      typedef typename list<_Tp, _Alloc>::const_iterator const_iterator;
      const_iterator __end1 = __x.end();
      const_iterator __end2 = __y.end();

      const_iterator __i1 = __x.begin();
      const_iterator __i2 = __y.begin();
      while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2)
 {
   ++__i1;
   ++__i2;
 }
      return __i1 == __end1 && __i2 == __end2;
    }
# 1629 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)
    { __x.swap(__y); }


}
# 64 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/list" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/list.tcc" 1 3
# 59 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/list.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, typename _Alloc>
    void
    _List_base<_Tp, _Alloc>::
    _M_clear()
    {
      typedef _List_node<_Tp> _Node;
      _Node* __cur = static_cast<_Node*>(_M_impl._M_node._M_next);
      while (__cur != &_M_impl._M_node)
 {
   _Node* __tmp = __cur;
   __cur = static_cast<_Node*>(__cur->_M_next);

   _M_get_Node_allocator().destroy(__tmp);



   _M_put_node(__tmp);
 }
    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      typename list<_Tp, _Alloc>::iterator
      list<_Tp, _Alloc>::
      emplace(iterator __position, _Args&&... __args)
      {
 _Node* __tmp = _M_create_node(std::forward<_Args>(__args)...);
 __tmp->_M_hook(__position._M_node);
 return iterator(__tmp);
      }


  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      _Node* __tmp = _M_create_node(__x);
      __tmp->_M_hook(__position._M_node);
      return iterator(__tmp);
    }

  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::
    erase(iterator __position)
    {
      iterator __ret = iterator(__position._M_node->_M_next);
      _M_erase(__position);
      return __ret;
    }


  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    _M_default_append(size_type __n)
    {
      size_type __i = 0;
      try
 {
   for (; __i < __n; ++__i)
     emplace_back();
 }
      catch(...)
 {
   for (; __i; --__i)
     pop_back();
   throw;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    resize(size_type __new_size)
    {
      iterator __i = begin();
      size_type __len = 0;
      for (; __i != end() && __len < __new_size; ++__i, ++__len)
        ;
      if (__len == __new_size)
        erase(__i, end());
      else
 _M_default_append(__new_size - __len);
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    resize(size_type __new_size, const value_type& __x)
    {
      iterator __i = begin();
      size_type __len = 0;
      for (; __i != end() && __len < __new_size; ++__i, ++__len)
        ;
      if (__len == __new_size)
        erase(__i, end());
      else
        insert(end(), __new_size - __len, __x);
    }
# 182 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/list.tcc" 3
  template<typename _Tp, typename _Alloc>
    list<_Tp, _Alloc>&
    list<_Tp, _Alloc>::
    operator=(const list& __x)
    {
      if (this != &__x)
 {
   iterator __first1 = begin();
   iterator __last1 = end();
   const_iterator __first2 = __x.begin();
   const_iterator __last2 = __x.end();
   for (; __first1 != __last1 && __first2 != __last2;
        ++__first1, ++__first2)
     *__first1 = *__first2;
   if (__first2 == __last2)
     erase(__first1, __last1);
   else
     insert(__last1, __first2, __last2);
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    _M_fill_assign(size_type __n, const value_type& __val)
    {
      iterator __i = begin();
      for (; __i != end() && __n > 0; ++__i, --__n)
        *__i = __val;
      if (__n > 0)
        insert(end(), __n, __val);
      else
        erase(__i, end());
    }

  template<typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      list<_Tp, _Alloc>::
      _M_assign_dispatch(_InputIterator __first2, _InputIterator __last2,
    __false_type)
      {
        iterator __first1 = begin();
        iterator __last1 = end();
        for (; __first1 != __last1 && __first2 != __last2;
      ++__first1, ++__first2)
          *__first1 = *__first2;
        if (__first2 == __last2)
          erase(__first1, __last1);
        else
          insert(__last1, __first2, __last2);
      }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    remove(const value_type& __value)
    {
      iterator __first = begin();
      iterator __last = end();
      iterator __extra = __last;
      while (__first != __last)
 {
   iterator __next = __first;
   ++__next;
   if (*__first == __value)
     {



       if (std::__addressof(*__first) != std::__addressof(__value))
  _M_erase(__first);
       else
  __extra = __first;
     }
   __first = __next;
 }
      if (__extra != __last)
 _M_erase(__extra);
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    unique()
    {
      iterator __first = begin();
      iterator __last = end();
      if (__first == __last)
 return;
      iterator __next = __first;
      while (++__next != __last)
 {
   if (*__first == *__next)
     _M_erase(__next);
   else
     __first = __next;
   __next = __first;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::

    merge(list&& __x)



    {


      if (this != &__x)
 {
   _M_check_equal_allocators(__x);

   iterator __first1 = begin();
   iterator __last1 = end();
   iterator __first2 = __x.begin();
   iterator __last2 = __x.end();
   while (__first1 != __last1 && __first2 != __last2)
     if (*__first2 < *__first1)
       {
  iterator __next = __first2;
  _M_transfer(__first1, __first2, ++__next);
  __first2 = __next;
       }
     else
       ++__first1;
   if (__first2 != __last2)
     _M_transfer(__last1, __first2, __last2);
 }
    }

  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp, _Alloc>::

      merge(list&& __x, _StrictWeakOrdering __comp)



      {


 if (this != &__x)
   {
     _M_check_equal_allocators(__x);

     iterator __first1 = begin();
     iterator __last1 = end();
     iterator __first2 = __x.begin();
     iterator __last2 = __x.end();
     while (__first1 != __last1 && __first2 != __last2)
       if (__comp(*__first2, *__first1))
  {
    iterator __next = __first2;
    _M_transfer(__first1, __first2, ++__next);
    __first2 = __next;
  }
       else
  ++__first1;
     if (__first2 != __last2)
       _M_transfer(__last1, __first2, __last2);
   }
      }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    sort()
    {

      if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
   && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
      {
        list __carry;
        list __tmp[64];
        list * __fill = &__tmp[0];
        list * __counter;

        do
   {
     __carry.splice(__carry.begin(), *this, begin());

     for(__counter = &__tmp[0];
  __counter != __fill && !__counter->empty();
  ++__counter)
       {
  __counter->merge(__carry);
  __carry.swap(*__counter);
       }
     __carry.swap(*__counter);
     if (__counter == __fill)
       ++__fill;
   }
 while ( !empty() );

        for (__counter = &__tmp[1]; __counter != __fill; ++__counter)
          __counter->merge(*(__counter - 1));
        swap( *(__fill - 1) );
      }
    }

  template<typename _Tp, typename _Alloc>
    template <typename _Predicate>
      void
      list<_Tp, _Alloc>::
      remove_if(_Predicate __pred)
      {
        iterator __first = begin();
        iterator __last = end();
        while (__first != __last)
   {
     iterator __next = __first;
     ++__next;
     if (__pred(*__first))
       _M_erase(__first);
     __first = __next;
   }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _BinaryPredicate>
      void
      list<_Tp, _Alloc>::
      unique(_BinaryPredicate __binary_pred)
      {
        iterator __first = begin();
        iterator __last = end();
        if (__first == __last)
   return;
        iterator __next = __first;
        while (++__next != __last)
   {
     if (__binary_pred(*__first, *__next))
       _M_erase(__next);
     else
       __first = __next;
     __next = __first;
   }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp, _Alloc>::
      sort(_StrictWeakOrdering __comp)
      {

 if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
     && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
   {
     list __carry;
     list __tmp[64];
     list * __fill = &__tmp[0];
     list * __counter;

     do
       {
  __carry.splice(__carry.begin(), *this, begin());

  for(__counter = &__tmp[0];
      __counter != __fill && !__counter->empty();
      ++__counter)
    {
      __counter->merge(__carry, __comp);
      __carry.swap(*__counter);
    }
  __carry.swap(*__counter);
  if (__counter == __fill)
    ++__fill;
       }
     while ( !empty() );

     for (__counter = &__tmp[1]; __counter != __fill; ++__counter)
       __counter->merge(*(__counter - 1), __comp);
     swap(*(__fill - 1));
   }
      }


}
# 65 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/list" 2 3
# 6 "../lib/ordered_map.h" 2




template <class K, class V, class COMP = std::less<K>,
          class ALLOC = std::allocator<std::pair<const K, V>>>
class ordered_map {
public:
    typedef K key_type;
    typedef V mapped_type;
    typedef std::pair<const K, V> value_type;
    typedef COMP key_compare;
    typedef ALLOC allocator_type;
    typedef value_type &reference;
    typedef const value_type &const_reference;
private:
    typedef std::list<value_type, ALLOC> list_type;
    list_type data;
public:
    typedef typename list_type::iterator iterator;
    typedef typename list_type::const_iterator const_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    class value_compare : std::binary_function<value_type, value_type, bool> {
    friend class ordered_map;
    protected:
        COMP comp;
        value_compare(COMP c) : comp(c) {}
    public:
        bool operator()(const value_type &a, const value_type &b) const {
            return comp(a.first, b.first); }
    };
private:
    struct mapcmp : std::binary_function<const K*, const K*, bool> {
        COMP comp;
        bool operator()(const K *a, const K *b) const { return comp(*a, *b); } };
    typedef std::map<const K *, iterator, mapcmp, ALLOC> map_type;
    map_type data_map;
    void init_data_map() {
        data_map.clear();
        for (auto it = data.begin(); it != data.end(); it++)
            data_map.emplace(&it->first, it); }
    iterator tr_iter(typename map_type::iterator i) {
        if (i == data_map.end())
            return data.end();
        return i->second; }
    const_iterator tr_iter(typename map_type::const_iterator i) const {
        if (i == data_map.end())
            return data.end();
        return i->second; }
public:
    typedef typename map_type::size_type size_type;

public:
    ordered_map() {}
    ordered_map(const ordered_map &a) : data(a.data) { init_data_map(); }
    ordered_map(ordered_map &&a) = default;
    ordered_map &operator=(const ordered_map &a) {

        if (this != &a) {
            data.clear();
            for (auto &el : a.data)
                data.push_back(el);
            init_data_map(); }
        return *this; }
    ordered_map &operator=(ordered_map &&a) = default;
    ordered_map(const std::initializer_list<value_type> &il) : data(il) { init_data_map(); }


    iterator begin() noexcept { return data.begin(); }
    const_iterator begin() const noexcept { return data.begin(); }
    iterator end() noexcept { return data.end(); }
    const_iterator end() const noexcept { return data.end(); }
    reverse_iterator rbegin() noexcept { return data.rbegin(); }
    const_reverse_iterator rbegin() const noexcept { return data.rbegin(); }
    reverse_iterator rend() noexcept { return data.rend(); }
    const_reverse_iterator rend() const noexcept { return data.rend(); }
    const_iterator cbegin() const noexcept { return data.cbegin(); }
    const_iterator cend() const noexcept { return data.cend(); }
    const_reverse_iterator crbegin() const noexcept { return data.crbegin(); }
    const_reverse_iterator crend() const noexcept { return data.crend(); }

    bool empty() const noexcept { return data.empty(); }
    size_type size() const noexcept { return data_map.size(); }
    size_type max_size() const noexcept { return data_map.max_size(); }
    bool operator==(const ordered_map &a) const { return data == a.data; }
    bool operator!=(const ordered_map &a) const { return data != a.data; }
    void clear() { data.clear(); data_map.clear(); }

    iterator find(const key_type &a) { return tr_iter(data_map.find(&a)); }
    const_iterator find(const key_type &a) const { return tr_iter(data_map.find(&a)); }
    size_type count(const key_type &a) const { return data_map.count(&a); }
    iterator lower_bound(const key_type &a) { return tr_iter(data_map.lower_bound(&a)); }
    const_iterator lower_bound(const key_type &a) const {
                        return tr_iter(data_map.lower_bound(&a)); }
    iterator upper_bound(const key_type &a) { return tr_iter(data_map.upper_bound(&a)); }
    const_iterator upper_bound(const key_type &a) const {
                        return tr_iter(data_map.upper_bound(&a)); }
    iterator upper_bound_pred(const key_type &a) {
                        auto ub = data_map.upper_bound(&a);
                        if (ub == data_map.begin()) return end();
                        return tr_iter(--ub); }
    const_iterator upper_bound_pred(const key_type &a) const {
                        auto ub = data_map.upper_bound(&a);
                        if (ub == data_map.begin()) return end();
                        return tr_iter(--ub); }

    V& operator[](const K &x) {
        auto it = find(x);
        if (it == data.end()) {
            it = data.emplace(data.end(), x, V());
            data_map.emplace(&it->first, it); }
        return it->second; }
    V& operator[](K &&x) {
        auto it = find(x);
        if (it == data.end()) {
            it = data.emplace(data.end(), std::move(x), V());
            data_map.emplace(&it->first, it); }
        return it->second; }
    V& at(const K &x) {
        auto it = find(x);
        if (it == data.end()) throw std::out_of_range("ordered_map");
        return it->second; }
    const V& at(const K &x) const {
        auto it = find(x);
        if (it == data.end()) throw std::out_of_range("ordered_map");
        return it->second; }

    std::pair<iterator, bool> emplace(K &&k, V &&v) {
        auto it = find(k);
        if (it == data.end()) {
            it = data.emplace(data.end(), std::move(k), std::move(v));
            data_map.emplace(&it->first, it);
            return std::make_pair(it, true); }
        return std::make_pair(it, false); }
    std::pair<iterator, bool> emplace_hint(iterator pos, K &&k, V &&v) {

        auto it = find(k);
        if (it == data.end()) {
            it = data.emplace(pos, std::move(k), std::move(v));
            data_map.emplace(&it->first, it);
            return std::make_pair(it, true); }
        return std::make_pair(it, false); }

    std::pair<iterator, bool> insert(const value_type &v) {
        auto it = find(v.first);
        if (it == data.end()) {
            it = data.insert(data.end(), v);
            data_map.emplace(&it->first, it);
            return std::make_pair(it, true); }
        return std::make_pair(it, false); }
    std::pair<iterator, bool> insert(iterator pos, const value_type &v) {

        auto it = find(v.first);
        if (it == data.end()) {
            it = data.insert(pos, v);
            data_map.emplace(&it->first, it);
            return std::make_pair(it, true); }
        return std::make_pair(it, false); }
    template<class InputIterator> void insert(InputIterator b, InputIterator e) {
        while (b != e) insert(*b++); }
    template<class InputIterator>
    void insert(iterator pos, InputIterator b, InputIterator e) {

        while (b != e) insert(pos, *b++); }


    iterator erase(iterator pos) {
        data_map.erase(&pos->first);
        return data.erase(pos); }
    size_type erase(const K &k) {
        auto it = find(k);
        if (it != data.end()) {
            data_map.erase(&k);
            data.erase(it);
            return 1; }
        return 0; }

    template<class Compare> void sort(Compare comp) { data.sort(comp); }
};
# 15 "../ir/ir.h" 2
# 1 "../lib/exceptions.h" 1








namespace Util {




class P4CExceptionBase : public std::exception {
 protected:
    cstring message;

 public:
    template <typename... T>
    P4CExceptionBase(const char* format, T... args) {



        boost::format fmt(format);
        this->message = ::bug_helper(fmt, "", "", "", std::forward<T>(args)...);

    }

    const char* what() const noexcept
    { return this->message.c_str(); }
};


class CompilerBug final : public P4CExceptionBase {
 public:
    template <typename... T>
    CompilerBug(const char* format, T... args)
            : P4CExceptionBase(format, args...)
    { message = "COMPILER BUG:\n" + message; }
    template <typename... T>
    CompilerBug(const char* file, int line, const char* format, T... args)
            : P4CExceptionBase(format, args...)
    { message = cstring("COMPILER BUG: ") + file + ":" + Util::toString(line) + "\n" + message; }
};




class CompilationError : public P4CExceptionBase {
 public:
    template <typename... T>
    CompilationError(const char* format, T... args)
            : P4CExceptionBase(format, args...) {}
};




}
# 16 "../ir/ir.h" 2

# 1 "../lib/ltbitmatrix.h" 1



# 1 "../lib/bitvec.h" 1



# 1 "/usr/include/assert.h" 1 3 4
# 5 "../lib/bitvec.h" 2
# 1 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/limits.h" 1 3
# 37 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/limits.h" 3
# 1 "/usr/include/limits.h" 1 3 4
# 143 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 1 3 4
# 160 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 39 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 2 3 4
# 161 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 144 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/posix2_lim.h" 1 3 4
# 148 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 2 3 4
# 152 "/usr/include/limits.h" 2 3 4
# 38 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/limits.h" 2 3
# 6 "../lib/bitvec.h" 2
# 1 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/stdint.h" 1 3
# 7 "../lib/bitvec.h" 2





class bitvec {
    size_t size;
    union {
        uintptr_t data;
        uintptr_t *ptr;
    };

 public:
    static constexpr size_t bits_per_unit = 8 * sizeof(uintptr_t);

    class bitref {
        friend class bitvec;
        bitvec &self;
        int idx;
        bitref(bitvec &s, int i) : self(s), idx(i) {}

     public:
        bitref(const bitref &a) = default;
        bitref(bitref &&a) = default;
        explicit operator bool() const { return self.getbit(idx); }
        operator int() const { return self.getbit(idx) ? 1 : 0; }
        int index() const { return idx; }
        int operator*() const { return idx; }
        bool operator=(bool b) const {
            ((idx >= 0) ? static_cast<void> (0) : __assert_fail ("idx >= 0", "../lib/bitvec.h", 36, __PRETTY_FUNCTION__));
            return b ? self.setbit(idx) : self.clrbit(idx); }
        bool set(bool b = true) {
            ((idx >= 0) ? static_cast<void> (0) : __assert_fail ("idx >= 0", "../lib/bitvec.h", 39, __PRETTY_FUNCTION__));
            bool rv = self.getbit(idx);
            b ? self.setbit(idx) : self.clrbit(idx);
            return rv; }
        bitref &operator++() {
            while ((size_t)++idx < self.size * bitvec::bits_per_unit)
                if (self.getbit(idx)) return *this;
            idx = -1;
            return *this; }
        bitref &operator--() {
            while (--idx >= 0)
                if (self.getbit(idx)) return *this;
            return *this; }
    };
    class const_bitref {
        friend class bitvec;
        const bitvec &self;
        int idx;
        const_bitref(const bitvec &s, int i) : self(s), idx(i) {}
     public:
        const_bitref(const const_bitref &a) = default;
        const_bitref(const_bitref &&a) = default;
        explicit operator bool() const { return self.getbit(idx); }
        operator int() const { return self.getbit(idx) ? 1 : 0; }
        int index() const { return idx; }
        int operator*() const { return idx; }
        const_bitref &operator++() {
            while ((size_t)++idx < self.size * bitvec::bits_per_unit)
                if (self.getbit(idx)) return *this;
            idx = -1;
            return *this; }
        const_bitref &operator--() {
            while (--idx >= 0)
                if (self.getbit(idx)) return *this;
            return *this; }
    };

    bitvec() : size(1), data(0) {}
    explicit bitvec(uintptr_t v) : size(1), data(v) {}
    bitvec(size_t lo, size_t cnt) : size(1), data(0) { setrange(lo, cnt); }
    bitvec(const bitvec &a) : size(a.size) {
        if (size > 1) {
            ptr = new uintptr_t[size];
            memcpy(ptr, a.ptr, size * sizeof(*ptr));
        } else {
            data = a.data; }}
    bitvec(bitvec &&a) : size(a.size), data(a.data) { a.size = 1; }
    bitvec &operator=(const bitvec &a) {
        if (this == &a) return *this;
        if (size > 1) delete [] ptr;
        if ((size = a.size) > 1) {
            ptr = new uintptr_t[size];
            memcpy(ptr, a.ptr, size * sizeof(*ptr));
        } else {
            data = a.data; }
        return *this; }
    bitvec &operator=(bitvec &&a) {
        std::swap(size, a.size); std::swap(data, a.data);
        return *this; }
    ~bitvec() { if (size > 1) delete [] ptr; }

    void clear() {
        if (size > 1) memset(ptr, 0, size * sizeof(*ptr));
        else data = 0; }
    bool setbit(size_t idx) {
        if (idx >= size * bits_per_unit) expand(1 + idx/bits_per_unit);
        if (size > 1)
            ptr[idx/bits_per_unit] |= (uintptr_t)1 << (idx%bits_per_unit);
        else
            data |= (uintptr_t)1 << idx;
        return true; }
    void setrange(size_t idx, size_t sz) {
        if (idx+sz > size * bits_per_unit) expand(1 + (idx+sz-1)/bits_per_unit);
        if (size == 1) {
            data |= ~(~(uintptr_t)1 << (sz-1)) << idx;
        } else if (idx/bits_per_unit == (idx+sz-1)/bits_per_unit) {
            ptr[idx/bits_per_unit] |=
                ~(~(uintptr_t)1 << (sz-1)) << (idx%bits_per_unit);
        } else {
            size_t i = idx/bits_per_unit;
            ptr[i] |= ~(uintptr_t)0 << (idx%bits_per_unit);
            idx += sz;
            while (++i < idx/bits_per_unit) {
                ptr[i] = ~(uintptr_t)0; }
            ptr[i] |= (((uintptr_t)1 << (idx%bits_per_unit)) - 1); } }
    void setraw(uintptr_t raw) {
        if (size == 1) {
            data = raw;
        } else {
            ptr[0] = raw;
            for (size_t i = 1; i < size; i++)
                ptr[i] = 0; } }
    void setraw(uintptr_t *raw, size_t sz) {
        if (sz > size) expand(sz);
        if (size == 1) {
            data = raw[0];
        } else {
            for (size_t i = 0; i < sz; i++)
                ptr[i] = raw[i];
            for (size_t i = sz; i < size; i++)
                ptr[i] = 0; } }
    bool clrbit(size_t idx) {
        if (idx >= size * bits_per_unit) return false;
        if (size > 1)
            ptr[idx/bits_per_unit] &= ~((uintptr_t)1 << (idx%bits_per_unit));
        else
            data &= ~((uintptr_t)1 << idx);
        return false; }
    void clrrange(size_t idx, size_t sz) {
        if (idx >= size * bits_per_unit) return;
        if (size == 1) {
            if (idx + sz < bits_per_unit)
                data &= ~(~(~(uintptr_t)1 << (sz-1)) << idx);
            else
                data &= ~(~(uintptr_t)0 << idx);
        } else if (idx/bits_per_unit == (idx+sz-1)/bits_per_unit) {
            ptr[idx/bits_per_unit] &=
                ~(~(~(uintptr_t)1 << (sz-1)) << (idx%bits_per_unit));
        } else {
            size_t i = idx/bits_per_unit;
            ptr[i] &= ~(~(uintptr_t)0 << (idx%bits_per_unit));
            idx += sz;
            while (++i < idx/bits_per_unit && i < size) {
                ptr[i] = 0; }
            if (i < size)
                ptr[i] &= ~(((uintptr_t)1 << (idx%bits_per_unit)) - 1); } }
    bool getbit(size_t idx) const {
        if (idx >= size * bits_per_unit) return false;
        if (size > 1)
            return (ptr[idx/bits_per_unit] >> (idx%bits_per_unit)) & 1;
        else
            return (data >> idx) & 1;
        return false; }
    uintptr_t getrange(size_t idx, size_t sz) const {
        ((sz > 0 && sz <= bits_per_unit) ? static_cast<void> (0) : __assert_fail ("sz > 0 && sz <= bits_per_unit", "../lib/bitvec.h", 173, __PRETTY_FUNCTION__));
        if (idx >= size * bits_per_unit) return 0;
        if (size > 1) {
            unsigned shift = idx % bits_per_unit;
            idx /= bits_per_unit;
            uintptr_t rv = ptr[idx] >> shift;
            if (shift != 0 && idx + 1 < size)
                rv |= ptr[idx + 1] << (bits_per_unit - shift);
            return rv & ~(~(uintptr_t)1 << (sz-1));
        } else {
            return (data >> idx) & ~(~(uintptr_t)1 << (sz-1)); }}
    bitvec getslice(size_t idx, size_t sz) const;
    bitref operator[](int idx) { return bitref(*this, idx); }
    bool operator[](int idx) const { return getbit(idx); }
    int ffs(unsigned start = 0) const;
    unsigned ffz(unsigned start = 0) const;
    const_bitref min() const { return const_bitref(*this, ffs()); }
    const_bitref max() const {
        return --const_bitref(*this, size * bits_per_unit); }
    const_bitref begin() const { return min(); }
    const_bitref end() const { return const_bitref(*this, -1); }
    bitref min() { return bitref(*this, ffs()); }
    bitref max() { return --bitref(*this, size * bits_per_unit); }
    bitref begin() { return min(); }
    bitref end() { return bitref(*this, -1); }
    bool empty() const {
        if (size > 1) {
            for (size_t i = 0; i < size; i++)
                if (ptr[i] != 0) return false;
            return true;
        } else { return data == 0; }}
    explicit operator bool() const { return !empty(); }
    bool operator&=(const bitvec &a) {
        bool rv = false;
        if (size > 1) {
            if (a.size > 1) {
                for (size_t i = 0; i < size && i < a.size; i++) {
                    rv |= ((ptr[i] & a.ptr[i]) != ptr[i]);
                    ptr[i] &= a.ptr[i]; }
            } else {
                rv |= ((*ptr & a.data) != *ptr);
                *ptr &= a.data; }
            if (size > a.size) {
                if (!rv) {
                    for (size_t i = a.size; i < size; i++)
                        if (ptr[i]) { rv = true; break; }}
                memset(ptr + a.size, 0, (size-a.size) * sizeof(*ptr)); }
        } else if (a.size > 1) {
            rv |= ((data & a.ptr[0]) != data);
            data &= a.ptr[0];
        } else {
            rv |= ((data & a.data) != data);
            data &= a.data; }
        return rv; }
    bitvec operator&(const bitvec &a) const {
        if (size <= a.size) {
            bitvec rv(*this); rv &= a; return rv;
        } else {
            bitvec rv(a); rv &= *this; return rv; } }
    bool operator|=(const bitvec &a) {
        bool rv = false;
        if (size < a.size) expand(a.size);
        if (size > 1) {
            if (a.size > 1) {
                for (size_t i = 0; i < a.size; i++) {
                    rv |= ((ptr[i] | a.ptr[i]) != ptr[i]);
                    ptr[i] |= a.ptr[i]; }
            } else {
                rv |= ((*ptr | a.data) != *ptr);
                *ptr |= a.data; }
        } else {
            rv |= ((data | a.data) != data);
            data |= a.data; }
        return rv; }
    bool operator|=(uintptr_t a) {
        bool rv = false;
        auto t = size > 1 ? ptr : &data;
        rv |= ((*t | a) != *t);
        *t |= a;
        return rv; }
    bitvec operator|(const bitvec &a) const {
        bitvec rv(*this); rv |= a; return rv; }
    bitvec operator|(uintptr_t a) const {
        bitvec rv(*this); rv |= a; return rv; }
    bitvec &operator^=(const bitvec &a) {
        if (size < a.size) expand(a.size);
        if (size > 1) {
            if (a.size > 1) {
                for (size_t i = 0; i < a.size; i++) ptr[i] ^= a.ptr[i];
            } else {
                *ptr ^= a.data; }
        } else {
            data ^= a.data; }
        return *this; }
    bitvec operator^(const bitvec &a) const {
        bitvec rv(*this); rv ^= a; return rv; }
    bool operator-=(const bitvec &a) {
        bool rv = false;
        if (size > 1) {
            if (a.size > 1) {
                for (size_t i = 0; i < size && i < a.size; i++) {
                    rv |= ((ptr[i] & ~a.ptr[i]) != ptr[i]);
                    ptr[i] &= ~a.ptr[i]; }
            } else {
                rv |= ((*ptr & ~a.data) != *ptr);
                *ptr &= ~a.data; }
        } else if (a.size > 1) {
            rv |= ((data & ~a.ptr[0]) != data);
            data &= ~a.ptr[0];
        } else {
            rv |= ((data & ~a.data) != data);
            data &= ~a.data; }
        return rv; }
    bitvec operator-(const bitvec &a) const {
        bitvec rv(*this); rv -= a; return rv; }
    bool operator==(const bitvec &a) const {
        if (size > 1) {
            if (a.size > 1) {
                size_t i;
                for (i = 0; i < size && i < a.size; i++)
                    if (ptr[i] != a.ptr[i]) return false;
                for (; i < size; i++)
                    if (ptr[i]) return false;
                for (; i < a.size; i++)
                    if (a.ptr[i]) return false;
            } else {
                if (ptr[0] != a.data) return false;
                for (size_t i = 1; i < size; i++)
                    if (ptr[i]) return false; }
        } else if (a.size > 1) {
            if (data != a.ptr[0]) return false;
            for (size_t i = 1; i < a.size; i++)
                if (a.ptr[i]) return false;
        } else {
            return data == a.data; }
        return true; }
    bool operator!=(const bitvec &a) const { return !(*this == a); }
    bool intersects(const bitvec &a) const {
        if (size > 1) {
            if (a.size > 1) {
                for (size_t i = 0; i < size && i < a.size; i++)
                    if (ptr[i] & a.ptr[i]) return true;
                return false;
            } else {
                return (ptr[0] & a.data) != 0; }
        } else if (a.size > 1) {
            return (data & a.ptr[0]) != 0;
        } else {
            return (data & a.data) != 0; }}
    bitvec &operator>>=(size_t count);
    bitvec &operator<<=(size_t count);
    bitvec operator>>(size_t count) const { bitvec rv(*this); rv >>= count; return rv; }
    bitvec operator<<(size_t count) const { bitvec rv(*this); rv <<= count; return rv; }

 private:
    void expand(size_t newsize) {
        ((newsize > size) ? static_cast<void> (0) : __assert_fail ("newsize > size", "../lib/bitvec.h", 329, __PRETTY_FUNCTION__));
        if (size > 1) {
            uintptr_t *old = ptr;
            ptr = new uintptr_t[newsize];
            memcpy(ptr, old, size * sizeof(*ptr));
            memset(ptr + size, 0, (newsize - size) * sizeof(*ptr));
            delete [] old;
        } else {
            uintptr_t d = data;
            ptr = new uintptr_t[newsize];
            *ptr = d;
            memset(ptr + size, 0, (newsize - size) * sizeof(*ptr));
        }
        size = newsize;
    }

 public:
    friend std::ostream &operator<<(std::ostream &, const bitvec &);
};

inline bitvec operator|(bitvec &&a, const bitvec &b) {
    bitvec rv(std::move(a)); rv |= b; return rv; }
inline bitvec operator&(bitvec &&a, const bitvec &b) {
    bitvec rv(std::move(a)); rv &= b; return rv; }
inline bitvec operator^(bitvec &&a, const bitvec &b) {
    bitvec rv(std::move(a)); rv ^= b; return rv; }
inline bitvec operator-(bitvec &&a, const bitvec &b) {
    bitvec rv(std::move(a)); rv -= b; return rv; }
# 5 "../lib/ltbitmatrix.h" 2


class LTBitMatrix : private bitvec {
 public:
    bitref operator()(unsigned r, unsigned c) {
        return r >= c ? bitvec::operator[]((r*r+r)/2 + c) : end(); }
    bool operator()(unsigned r, unsigned c) const {
        return r >= c ? bitvec::operator[]((r*r+r)/2 + c) : false; }
    unsigned size() const {
        if (empty()) return 0;
        unsigned m = *max();
        unsigned r = 1;
        while ((r*r+r)/2 <= m) r++;
        return r; }
    using bitvec::clear;
    using bitvec::empty;
    using bitvec::operator bool;

 private:
    template<class T> class rowref {
        friend class LTBitMatrix;
        T &self;
        unsigned row;
        rowref(T &s, unsigned r) : self(s), row(r) {}

     public:
        rowref(const rowref &) = default;
        rowref(rowref &&) = default;
        explicit operator bool() const {
            if (row < bits_per_unit)
                return self.getrange((row*row+row)/2, row+1) != 0;
            else
                return self.getslice((row*row+row)/2, row+1) ? true : false; }
        operator bitvec() const { return self.getslice((row*row+row)/2, row+1); }
    };
    class nonconst_rowref : public rowref<LTBitMatrix> {
     public:
        friend class LTBitMatrix;
        using rowref<LTBitMatrix>::rowref;
        void operator|=(bitvec a) const { a.clrrange(row+1, ~0); self |= a << (row*row+row)/2; }
        bitref operator[](unsigned col) const { return self(row, col); }
    };
    class const_rowref : public rowref<const LTBitMatrix> {
     public:
        friend class LTBitMatrix;
        using rowref<const LTBitMatrix>::rowref;
        bool operator[](unsigned col) const { return self(row, col); }
    };

 public:
    nonconst_rowref operator[](unsigned r) { return nonconst_rowref(*this, r); }
    const_rowref operator[](unsigned r) const { return const_rowref(*this, r); }

    bool operator==(const LTBitMatrix &a) const { return bitvec::operator==(a); }
    bool operator!=(const LTBitMatrix &a) const { return bitvec::operator!=(a); }
};

inline std::ostream &operator <<(std::ostream &out, const LTBitMatrix &bm) {
    for (unsigned i = 1; i < bm.size(); i++) {
        if (i > 1) out << ' ';
        for (unsigned j = 0; j < i; j++)
            out << (bm[i][j] ? '1' : '0'); }
    return out;
}
# 18 "../ir/ir.h" 2
# 1 "../lib/match.h" 1



# 1 "/usr/lib/llvm-3.5/bin/../lib/clang/3.5.0/include/stdint.h" 1 3
# 5 "../lib/match.h" 2


struct match_t {
    uintmax_t word0, word1;
    match_t() : word0(0), word1(0) {}
    match_t(uintmax_t w0, uintmax_t w1) : word0(w0), word1(w1) {}
    explicit operator bool() const { return (word0 | word1) != 0; }
    bool operator==(const match_t &a) const { return word0 == a.word0 && word1 == a.word1; }
    bool matches(uintmax_t v) const {
        return (v | word1) == word1 && ((~v & word1) | word0) == word0; }
    void setwidth(int bits) {
        uintmax_t mask = ~(~uintmax_t(0) << bits);
        word0 &= mask;
        word1 &= mask;
        mask &= ~(word0 | word1);
        word0 |= mask;
        word1 |= mask; }
    match_t(int size, uintmax_t val, uintmax_t mask) : word0(~val&mask), word1(val&mask)
        { setwidth(size); }
};

std::ostream &operator <<(std::ostream &, match_t);
# 19 "../ir/ir.h" 2


# 1 "../ir/node.h" 1




# 1 "../ir/std.h" 1





# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/unordered_map" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/unordered_map" 3
# 47 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/unordered_map" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/hashtable.h" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/hashtable.h" 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/hashtable_policy.h" 1 3
# 34 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/hashtable_policy.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    class _Hashtable;



namespace __detail
{







  template<typename _Key, typename _Value,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _Traits>
    struct _Hashtable_base;



  template<class _Iterator>
    inline typename std::iterator_traits<_Iterator>::difference_type
    __distance_fw(_Iterator __first, _Iterator __last,
    std::input_iterator_tag)
    { return 0; }

  template<class _Iterator>
    inline typename std::iterator_traits<_Iterator>::difference_type
    __distance_fw(_Iterator __first, _Iterator __last,
    std::forward_iterator_tag)
    { return std::distance(__first, __last); }

  template<class _Iterator>
    inline typename std::iterator_traits<_Iterator>::difference_type
    __distance_fw(_Iterator __first, _Iterator __last)
    {
      typedef typename std::iterator_traits<_Iterator>::iterator_category _Tag;
      return __distance_fw(__first, __last, _Tag());
    }


  template <typename _Key, typename _Hash>
    struct __is_noexcept_hash : std::integral_constant<bool,
 noexcept(declval<const _Hash&>()(declval<const _Key&>()))>
    { };

  struct _Identity
  {
    template<typename _Tp>
      _Tp&&
      operator()(_Tp&& __x) const
      { return std::forward<_Tp>(__x); }
  };

  struct _Select1st
  {
    template<typename _Tp>
      auto
      operator()(_Tp&& __x) const
      -> decltype(std::get<0>(std::forward<_Tp>(__x)))
      { return std::get<0>(std::forward<_Tp>(__x)); }
  };
# 130 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/hashtable_policy.h" 3
  template<bool _Cache_hash_code, bool _Constant_iterators, bool _Unique_keys>
    struct _Hashtable_traits
    {
      template<bool _Cond>
 using __bool_constant = integral_constant<bool, _Cond>;

      using __hash_cached = __bool_constant<_Cache_hash_code>;
      using __constant_iterators = __bool_constant<_Constant_iterators>;
      using __unique_keys = __bool_constant<_Unique_keys>;
    };
# 149 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/hashtable_policy.h" 3
  struct _Hash_node_base
  {
    _Hash_node_base* _M_nxt;

    _Hash_node_base() : _M_nxt() { }

    _Hash_node_base(_Hash_node_base* __next) : _M_nxt(__next) { }
  };




  template<typename _Value, bool _Cache_hash_code>
    struct _Hash_node;






  template<typename _Value>
    struct _Hash_node<_Value, true> : _Hash_node_base
    {
      _Value _M_v;
      std::size_t _M_hash_code;

      template<typename... _Args>
 _Hash_node(_Args&&... __args)
 : _M_v(std::forward<_Args>(__args)...), _M_hash_code() { }

      _Hash_node*
      _M_next() const { return static_cast<_Hash_node*>(_M_nxt); }
    };






  template<typename _Value>
    struct _Hash_node<_Value, false> : _Hash_node_base
    {
      _Value _M_v;

      template<typename... _Args>
 _Hash_node(_Args&&... __args)
 : _M_v(std::forward<_Args>(__args)...) { }

      _Hash_node*
      _M_next() const { return static_cast<_Hash_node*>(_M_nxt); }
    };


  template<typename _Value, bool _Cache_hash_code>
    struct _Node_iterator_base
    {
      using __node_type = _Hash_node<_Value, _Cache_hash_code>;

      __node_type* _M_cur;

      _Node_iterator_base(__node_type* __p)
      : _M_cur(__p) { }

      void
      _M_incr()
      { _M_cur = _M_cur->_M_next(); }
    };

  template<typename _Value, bool _Cache_hash_code>
    inline bool
    operator==(const _Node_iterator_base<_Value, _Cache_hash_code>& __x,
        const _Node_iterator_base<_Value, _Cache_hash_code >& __y)
    { return __x._M_cur == __y._M_cur; }

  template<typename _Value, bool _Cache_hash_code>
    inline bool
    operator!=(const _Node_iterator_base<_Value, _Cache_hash_code>& __x,
        const _Node_iterator_base<_Value, _Cache_hash_code>& __y)
    { return __x._M_cur != __y._M_cur; }


  template<typename _Value, bool __constant_iterators, bool __cache>
    struct _Node_iterator
    : public _Node_iterator_base<_Value, __cache>
    {
    private:
      using __base_type = _Node_iterator_base<_Value, __cache>;
      using __node_type = typename __base_type::__node_type;

    public:
      typedef _Value value_type;
      typedef std::ptrdiff_t difference_type;
      typedef std::forward_iterator_tag iterator_category;

      using pointer = typename std::conditional<__constant_iterators,
      const _Value*, _Value*>::type;

      using reference = typename std::conditional<__constant_iterators,
        const _Value&, _Value&>::type;

      _Node_iterator()
      : __base_type(0) { }

      explicit
      _Node_iterator(__node_type* __p)
      : __base_type(__p) { }

      reference
      operator*() const
      { return this->_M_cur->_M_v; }

      pointer
      operator->() const
      { return std::__addressof(this->_M_cur->_M_v); }

      _Node_iterator&
      operator++()
      {
 this->_M_incr();
 return *this;
      }

      _Node_iterator
      operator++(int)
      {
 _Node_iterator __tmp(*this);
 this->_M_incr();
 return __tmp;
      }
    };


  template<typename _Value, bool __constant_iterators, bool __cache>
    struct _Node_const_iterator
    : public _Node_iterator_base<_Value, __cache>
    {
    private:
      using __base_type = _Node_iterator_base<_Value, __cache>;
      using __node_type = typename __base_type::__node_type;

    public:
      typedef _Value value_type;
      typedef std::ptrdiff_t difference_type;
      typedef std::forward_iterator_tag iterator_category;

      typedef const _Value* pointer;
      typedef const _Value& reference;

      _Node_const_iterator()
      : __base_type(0) { }

      explicit
      _Node_const_iterator(__node_type* __p)
      : __base_type(__p) { }

      _Node_const_iterator(const _Node_iterator<_Value, __constant_iterators,
      __cache>& __x)
      : __base_type(__x._M_cur) { }

      reference
      operator*() const
      { return this->_M_cur->_M_v; }

      pointer
      operator->() const
      { return std::__addressof(this->_M_cur->_M_v); }

      _Node_const_iterator&
      operator++()
      {
 this->_M_incr();
 return *this;
      }

      _Node_const_iterator
      operator++(int)
      {
 _Node_const_iterator __tmp(*this);
 this->_M_incr();
 return __tmp;
      }
    };






  struct _Mod_range_hashing
  {
    typedef std::size_t first_argument_type;
    typedef std::size_t second_argument_type;
    typedef std::size_t result_type;

    result_type
    operator()(first_argument_type __num, second_argument_type __den) const
    { return __num % __den; }
  };






  struct _Default_ranged_hash { };



  struct _Prime_rehash_policy
  {
    _Prime_rehash_policy(float __z = 1.0)
    : _M_max_load_factor(__z), _M_next_resize(0) { }

    float
    max_load_factor() const noexcept
    { return _M_max_load_factor; }


    std::size_t
    _M_next_bkt(std::size_t __n) const;


    std::size_t
    _M_bkt_for_elements(std::size_t __n) const
    { return __builtin_ceil(__n / (long double)_M_max_load_factor); }





    std::pair<bool, std::size_t>
    _M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt,
     std::size_t __n_ins) const;

    typedef std::size_t _State;

    _State
    _M_state() const
    { return _M_next_resize; }

    void
    _M_reset(_State __state)
    { _M_next_resize = __state; }

    enum { _S_n_primes = sizeof(unsigned long) != 8 ? 256 : 256 + 48 };

    static const std::size_t _S_growth_factor = 2;

    float _M_max_load_factor;
    mutable std::size_t _M_next_resize;
  };
# 419 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/hashtable_policy.h" 3
  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits,
    bool _Unique_keys = _Traits::__unique_keys::value>
    struct _Map_base { };


  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, false>
    {
      using mapped_type = typename std::tuple_element<1, _Pair>::type;
    };


  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>
    {
    private:
      using __hashtable_base = __detail::_Hashtable_base<_Key, _Pair,
        _Select1st,
       _Equal, _H1, _H2, _Hash,
         _Traits>;

      using __hashtable = _Hashtable<_Key, _Pair, _Alloc,
         _Select1st, _Equal,
         _H1, _H2, _Hash, _RehashPolicy, _Traits>;

      using __hash_code = typename __hashtable_base::__hash_code;
      using __node_type = typename __hashtable_base::__node_type;

    public:
      using key_type = typename __hashtable_base::key_type;
      using iterator = typename __hashtable_base::iterator;
      using mapped_type = typename std::tuple_element<1, _Pair>::type;

      mapped_type&
      operator[](const key_type& __k);

      mapped_type&
      operator[](key_type&& __k);



      mapped_type&
      at(const key_type& __k);

      const mapped_type&
      at(const key_type& __k) const;
    };

  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    typename _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
         _H1, _H2, _Hash, _RehashPolicy, _Traits, true>
         ::mapped_type&
    _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
    operator[](const key_type& __k)
    {
      __hashtable* __h = static_cast<__hashtable*>(this);
      __hash_code __code = __h->_M_hash_code(__k);
      std::size_t __n = __h->_M_bucket_index(__k, __code);
      __node_type* __p = __h->_M_find_node(__n, __k, __code);

      if (!__p)
 {
   __p = __h->_M_allocate_node(std::piecewise_construct,
          std::tuple<const key_type&>(__k),
          std::tuple<>());
   return __h->_M_insert_unique_node(__n, __code, __p)->second;
 }

      return (__p->_M_v).second;
    }

  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    typename _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
         _H1, _H2, _Hash, _RehashPolicy, _Traits, true>
         ::mapped_type&
    _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
    operator[](key_type&& __k)
    {
      __hashtable* __h = static_cast<__hashtable*>(this);
      __hash_code __code = __h->_M_hash_code(__k);
      std::size_t __n = __h->_M_bucket_index(__k, __code);
      __node_type* __p = __h->_M_find_node(__n, __k, __code);

      if (!__p)
 {
   __p = __h->_M_allocate_node(std::piecewise_construct,
          std::forward_as_tuple(std::move(__k)),
          std::tuple<>());
   return __h->_M_insert_unique_node(__n, __code, __p)->second;
 }

      return (__p->_M_v).second;
    }

  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    typename _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
         _H1, _H2, _Hash, _RehashPolicy, _Traits, true>
         ::mapped_type&
    _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
    at(const key_type& __k)
    {
      __hashtable* __h = static_cast<__hashtable*>(this);
      __hash_code __code = __h->_M_hash_code(__k);
      std::size_t __n = __h->_M_bucket_index(__k, __code);
      __node_type* __p = __h->_M_find_node(__n, __k, __code);

      if (!__p)
 __throw_out_of_range(("_Map_base::at"));
      return (__p->_M_v).second;
    }

  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    const typename _Map_base<_Key, _Pair, _Alloc, _Select1st,
        _Equal, _H1, _H2, _Hash, _RehashPolicy,
        _Traits, true>::mapped_type&
    _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
    at(const key_type& __k) const
    {
      const __hashtable* __h = static_cast<const __hashtable*>(this);
      __hash_code __code = __h->_M_hash_code(__k);
      std::size_t __n = __h->_M_bucket_index(__k, __code);
      __node_type* __p = __h->_M_find_node(__n, __k, __code);

      if (!__p)
 __throw_out_of_range(("_Map_base::at"));
      return (__p->_M_v).second;
    }






  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Insert_base
    {
      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey,
         _Equal, _H1, _H2, _Hash,
         _RehashPolicy, _Traits>;

      using __hashtable_base = _Hashtable_base<_Key, _Value, _ExtractKey,
            _Equal, _H1, _H2, _Hash,
            _Traits>;

      using value_type = typename __hashtable_base::value_type;
      using iterator = typename __hashtable_base::iterator;
      using const_iterator = typename __hashtable_base::const_iterator;
      using size_type = typename __hashtable_base::size_type;

      using __unique_keys = typename __hashtable_base::__unique_keys;
      using __ireturn_type = typename __hashtable_base::__ireturn_type;
      using __iconv_type = typename __hashtable_base::__iconv_type;

      __hashtable&
      _M_conjure_hashtable()
      { return *(static_cast<__hashtable*>(this)); }

      __ireturn_type
      insert(const value_type& __v)
      {
 __hashtable& __h = _M_conjure_hashtable();
 return __h._M_insert(__v, __unique_keys());
      }

      iterator
      insert(const_iterator, const value_type& __v)
      { return __iconv_type()(insert(__v)); }

      void
      insert(initializer_list<value_type> __l)
      { this->insert(__l.begin(), __l.end()); }

      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last);
    };

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    template<typename _InputIterator>
      void
      _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,
      _RehashPolicy, _Traits>::
      insert(_InputIterator __first, _InputIterator __last)
      {
 using __rehash_type = typename __hashtable::__rehash_type;
 using __rehash_state = typename __hashtable::__rehash_state;
 using pair_type = std::pair<bool, std::size_t>;

 size_type __n_elt = __detail::__distance_fw(__first, __last);

 __hashtable& __h = _M_conjure_hashtable();
 __rehash_type& __rehash = __h._M_rehash_policy;
 const __rehash_state& __saved_state = __rehash._M_state();
 pair_type __do_rehash = __rehash._M_need_rehash(__h._M_bucket_count,
       __h._M_element_count,
       __n_elt);

 if (__do_rehash.first)
   __h._M_rehash(__do_rehash.second, __saved_state);

 for (; __first != __last; ++__first)
   __h._M_insert(*__first, __unique_keys());
      }






  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits,
    bool _Constant_iterators = _Traits::__constant_iterators::value,
    bool _Unique_keys = _Traits::__unique_keys::value>
    struct _Insert;


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,
     _RehashPolicy, _Traits, true, true>
    : public _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
      _H1, _H2, _Hash, _RehashPolicy, _Traits>
    {
      using __base_type = _Insert_base<_Key, _Value, _Alloc, _ExtractKey,
     _Equal, _H1, _H2, _Hash,
     _RehashPolicy, _Traits>;
      using value_type = typename __base_type::value_type;
      using iterator = typename __base_type::iterator;
      using const_iterator = typename __base_type::const_iterator;

      using __unique_keys = typename __base_type::__unique_keys;
      using __hashtable = typename __base_type::__hashtable;

      using __base_type::insert;

      std::pair<iterator, bool>
      insert(value_type&& __v)
      {
 __hashtable& __h = this->_M_conjure_hashtable();
 return __h._M_insert(std::move(__v), __unique_keys());
      }

      iterator
      insert(const_iterator, value_type&& __v)
      { return insert(std::move(__v)).first; }
    };


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,
     _RehashPolicy, _Traits, true, false>
    : public _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
      _H1, _H2, _Hash, _RehashPolicy, _Traits>
    {
      using __base_type = _Insert_base<_Key, _Value, _Alloc, _ExtractKey,
     _Equal, _H1, _H2, _Hash,
     _RehashPolicy, _Traits>;
      using value_type = typename __base_type::value_type;
      using iterator = typename __base_type::iterator;
      using const_iterator = typename __base_type::const_iterator;

      using __unique_keys = typename __base_type::__unique_keys;
      using __hashtable = typename __base_type::__hashtable;

      using __base_type::insert;

      iterator
      insert(value_type&& __v)
      {
 __hashtable& __h = this->_M_conjure_hashtable();
 return __h._M_insert(std::move(__v), __unique_keys());
      }

      iterator
      insert(const_iterator, value_type&& __v)
      { return insert(std::move(__v)); }
     };


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits, bool _Unique_keys>
    struct _Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,
     _RehashPolicy, _Traits, false, _Unique_keys>
    : public _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
      _H1, _H2, _Hash, _RehashPolicy, _Traits>
    {
      using __base_type = _Insert_base<_Key, _Value, _Alloc, _ExtractKey,
           _Equal, _H1, _H2, _Hash,
           _RehashPolicy, _Traits>;
      using value_type = typename __base_type::value_type;
      using iterator = typename __base_type::iterator;
      using const_iterator = typename __base_type::const_iterator;

      using __unique_keys = typename __base_type::__unique_keys;
      using __hashtable = typename __base_type::__hashtable;
      using __ireturn_type = typename __base_type::__ireturn_type;
      using __iconv_type = typename __base_type::__iconv_type;

      using __base_type::insert;

      template<typename _Pair>
 using __is_cons = std::is_constructible<value_type, _Pair&&>;

      template<typename _Pair>
 using _IFcons = std::enable_if<__is_cons<_Pair>::value>;

      template<typename _Pair>
 using _IFconsp = typename _IFcons<_Pair>::type;

      template<typename _Pair, typename = _IFconsp<_Pair>>
 __ireturn_type
 insert(_Pair&& __v)
 {
   __hashtable& __h = this->_M_conjure_hashtable();
   return __h._M_emplace(__unique_keys(), std::forward<_Pair>(__v));
 }

      template<typename _Pair, typename = _IFconsp<_Pair>>
 iterator
 insert(const_iterator, _Pair&& __v)
 { return __iconv_type()(insert(std::forward<_Pair>(__v))); }
   };







  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Rehash_base;


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _Traits>
    struct _Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _Prime_rehash_policy, _Traits>
    {
      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey,
         _Equal, _H1, _H2, _Hash,
         _Prime_rehash_policy, _Traits>;

      float
      max_load_factor() const noexcept
      {
 const __hashtable* __this = static_cast<const __hashtable*>(this);
 return __this->__rehash_policy().max_load_factor();
      }

      void
      max_load_factor(float __z)
      {
 __hashtable* __this = static_cast<__hashtable*>(this);
 __this->__rehash_policy(_Prime_rehash_policy(__z));
      }

      void
      reserve(std::size_t __n)
      {
 __hashtable* __this = static_cast<__hashtable*>(this);
 __this->rehash(__builtin_ceil(__n / max_load_factor()));
      }
    };







  template<int _Nm, typename _Tp,
    bool __use_ebo = !__is_final(_Tp) && __is_empty(_Tp)>
    struct _Hashtable_ebo_helper;


  template<int _Nm, typename _Tp>
    struct _Hashtable_ebo_helper<_Nm, _Tp, true>
    : private _Tp
    {
      _Hashtable_ebo_helper() = default;

      _Hashtable_ebo_helper(const _Tp& __tp) : _Tp(__tp)
      { }

      static const _Tp&
      _S_cget(const _Hashtable_ebo_helper& __eboh)
      { return static_cast<const _Tp&>(__eboh); }

      static _Tp&
      _S_get(_Hashtable_ebo_helper& __eboh)
      { return static_cast<_Tp&>(__eboh); }
    };


  template<int _Nm, typename _Tp>
    struct _Hashtable_ebo_helper<_Nm, _Tp, false>
    {
      _Hashtable_ebo_helper() = default;

      _Hashtable_ebo_helper(const _Tp& __tp) : _M_tp(__tp)
      { }

      static const _Tp&
      _S_cget(const _Hashtable_ebo_helper& __eboh)
      { return __eboh._M_tp; }

      static _Tp&
      _S_get(_Hashtable_ebo_helper& __eboh)
      { return __eboh._M_tp; }

    private:
      _Tp _M_tp;
    };







  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash,
    bool __cache_hash_code>
    struct _Local_iterator_base;
# 904 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/hashtable_policy.h" 3
  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash,
    bool __cache_hash_code>
    struct _Hash_code_base;



  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash>
    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, false>
    : private _Hashtable_ebo_helper<0, _ExtractKey>,
      private _Hashtable_ebo_helper<1, _Hash>
    {
    private:
      using __ebo_extract_key = _Hashtable_ebo_helper<0, _ExtractKey>;
      using __ebo_hash = _Hashtable_ebo_helper<1, _Hash>;

    protected:
      typedef void* __hash_code;
      typedef _Hash_node<_Value, false> __node_type;


      _Hash_code_base() = default;

      _Hash_code_base(const _ExtractKey& __ex, const _H1&, const _H2&,
        const _Hash& __h)
      : __ebo_extract_key(__ex), __ebo_hash(__h) { }

      __hash_code
      _M_hash_code(const _Key& __key) const
      { return 0; }

      std::size_t
      _M_bucket_index(const _Key& __k, __hash_code, std::size_t __n) const
      { return _M_ranged_hash()(__k, __n); }

      std::size_t
      _M_bucket_index(const __node_type* __p, std::size_t __n) const
      { return _M_ranged_hash()(_M_extract()(__p->_M_v), __n); }

      void
      _M_store_code(__node_type*, __hash_code) const
      { }

      void
      _M_copy_code(__node_type*, const __node_type*) const
      { }

      void
      _M_swap(_Hash_code_base& __x)
      {
 std::swap(_M_extract(), __x._M_extract());
 std::swap(_M_ranged_hash(), __x._M_ranged_hash());
      }

      const _ExtractKey&
      _M_extract() const { return __ebo_extract_key::_S_cget(*this); }

      _ExtractKey&
      _M_extract() { return __ebo_extract_key::_S_get(*this); }

      const _Hash&
      _M_ranged_hash() const { return __ebo_hash::_S_cget(*this); }

      _Hash&
      _M_ranged_hash() { return __ebo_hash::_S_get(*this); }
    };







  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash>
    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, true>;




  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2>
    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2,
      _Default_ranged_hash, false>
    : private _Hashtable_ebo_helper<0, _ExtractKey>,
      private _Hashtable_ebo_helper<1, _H1>,
      private _Hashtable_ebo_helper<2, _H2>
    {
    private:
      using __ebo_extract_key = _Hashtable_ebo_helper<0, _ExtractKey>;
      using __ebo_h1 = _Hashtable_ebo_helper<1, _H1>;
      using __ebo_h2 = _Hashtable_ebo_helper<2, _H2>;

    public:
      typedef _H1 hasher;

      hasher
      hash_function() const
      { return _M_h1(); }

    protected:
      typedef std::size_t __hash_code;
      typedef _Hash_node<_Value, false> __node_type;


      _Hash_code_base() = default;

      _Hash_code_base(const _ExtractKey& __ex,
        const _H1& __h1, const _H2& __h2,
        const _Default_ranged_hash&)
      : __ebo_extract_key(__ex), __ebo_h1(__h1), __ebo_h2(__h2) { }

      __hash_code
      _M_hash_code(const _Key& __k) const
      { return _M_h1()(__k); }

      std::size_t
      _M_bucket_index(const _Key&, __hash_code __c, std::size_t __n) const
      { return _M_h2()(__c, __n); }

      std::size_t
      _M_bucket_index(const __node_type* __p,
        std::size_t __n) const
      { return _M_h2()(_M_h1()(_M_extract()(__p->_M_v)), __n); }

      void
      _M_store_code(__node_type*, __hash_code) const
      { }

      void
      _M_copy_code(__node_type*, const __node_type*) const
      { }

      void
      _M_swap(_Hash_code_base& __x)
      {
 std::swap(_M_extract(), __x._M_extract());
 std::swap(_M_h1(), __x._M_h1());
 std::swap(_M_h2(), __x._M_h2());
      }

      const _ExtractKey&
      _M_extract() const { return __ebo_extract_key::_S_cget(*this); }

      _ExtractKey&
      _M_extract() { return __ebo_extract_key::_S_get(*this); }

      const _H1&
      _M_h1() const { return __ebo_h1::_S_cget(*this); }

      _H1&
      _M_h1() { return __ebo_h1::_S_get(*this); }

      const _H2&
      _M_h2() const { return __ebo_h2::_S_cget(*this); }

      _H2&
      _M_h2() { return __ebo_h2::_S_get(*this); }
    };




  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2>
    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2,
      _Default_ranged_hash, true>
    : private _Hashtable_ebo_helper<0, _ExtractKey>,
      private _Hashtable_ebo_helper<1, _H1>,
      private _Hashtable_ebo_helper<2, _H2>
    {
    private:

      friend struct _Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2,
      _Default_ranged_hash, true>;

      using __ebo_extract_key = _Hashtable_ebo_helper<0, _ExtractKey>;
      using __ebo_h1 = _Hashtable_ebo_helper<1, _H1>;
      using __ebo_h2 = _Hashtable_ebo_helper<2, _H2>;

    public:
      typedef _H1 hasher;

      hasher
      hash_function() const
      { return _M_h1(); }

    protected:
      typedef std::size_t __hash_code;
      typedef _Hash_node<_Value, true> __node_type;

      _Hash_code_base(const _ExtractKey& __ex,
        const _H1& __h1, const _H2& __h2,
        const _Default_ranged_hash&)
      : __ebo_extract_key(__ex), __ebo_h1(__h1), __ebo_h2(__h2) { }

      __hash_code
      _M_hash_code(const _Key& __k) const
      { return _M_h1()(__k); }

      std::size_t
      _M_bucket_index(const _Key&, __hash_code __c,
        std::size_t __n) const
      { return _M_h2()(__c, __n); }

      std::size_t
      _M_bucket_index(const __node_type* __p, std::size_t __n) const
      { return _M_h2()(__p->_M_hash_code, __n); }

      void
      _M_store_code(__node_type* __n, __hash_code __c) const
      { __n->_M_hash_code = __c; }

      void
      _M_copy_code(__node_type* __to, const __node_type* __from) const
      { __to->_M_hash_code = __from->_M_hash_code; }

      void
      _M_swap(_Hash_code_base& __x)
      {
 std::swap(_M_extract(), __x._M_extract());
 std::swap(_M_h1(), __x._M_h1());
 std::swap(_M_h2(), __x._M_h2());
      }

      const _ExtractKey&
      _M_extract() const { return __ebo_extract_key::_S_cget(*this); }

      _ExtractKey&
      _M_extract() { return __ebo_extract_key::_S_get(*this); }

      const _H1&
      _M_h1() const { return __ebo_h1::_S_cget(*this); }

      _H1&
      _M_h1() { return __ebo_h1::_S_get(*this); }

      const _H2&
      _M_h2() const { return __ebo_h2::_S_cget(*this); }

      _H2&
      _M_h2() { return __ebo_h2::_S_get(*this); }
    };





  template <typename _Key, typename _Value, typename _ExtractKey,
     typename _Equal, typename _HashCodeType,
     bool __cache_hash_code>
  struct _Equal_helper;


  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _Equal, typename _HashCodeType>
  struct _Equal_helper<_Key, _Value, _ExtractKey, _Equal, _HashCodeType, true>
  {
    static bool
    _S_equals(const _Equal& __eq, const _ExtractKey& __extract,
       const _Key& __k, _HashCodeType __c, _Hash_node<_Value, true>* __n)
    { return __c == __n->_M_hash_code && __eq(__k, __extract(__n->_M_v)); }
  };


  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _Equal, typename _HashCodeType>
  struct _Equal_helper<_Key, _Value, _ExtractKey, _Equal, _HashCodeType, false>
  {
    static bool
    _S_equals(const _Equal& __eq, const _ExtractKey& __extract,
       const _Key& __k, _HashCodeType, _Hash_node<_Value, false>* __n)
    { return __eq(__k, __extract(__n->_M_v)); }
  };



  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash>
    struct _Local_iterator_base<_Key, _Value, _ExtractKey,
    _H1, _H2, _Hash, true>
    : private _Hashtable_ebo_helper<0, _H2>
    {
    protected:
      using __base_type = _Hashtable_ebo_helper<0, _H2>;
      using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,
            _H1, _H2, _Hash, true>;

    public:
      _Local_iterator_base() = default;
      _Local_iterator_base(const __hash_code_base& __base,
      _Hash_node<_Value, true>* __p,
      std::size_t __bkt, std::size_t __bkt_count)
      : __base_type(__base._M_h2()),
 _M_cur(__p), _M_bucket(__bkt), _M_bucket_count(__bkt_count) { }

      void
      _M_incr()
      {
 _M_cur = _M_cur->_M_next();
 if (_M_cur)
   {
     std::size_t __bkt
       = __base_type::_S_get(*this)(_M_cur->_M_hash_code,
        _M_bucket_count);
     if (__bkt != _M_bucket)
       _M_cur = nullptr;
   }
      }

      _Hash_node<_Value, true>* _M_cur;
      std::size_t _M_bucket;
      std::size_t _M_bucket_count;
    };


  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash>
    struct _Local_iterator_base<_Key, _Value, _ExtractKey,
    _H1, _H2, _Hash, false>
    : private _Hash_code_base<_Key, _Value, _ExtractKey,
         _H1, _H2, _Hash, false>
    {
    protected:
      using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,
            _H1, _H2, _Hash, false>;

    public:
      _Local_iterator_base() = default;
      _Local_iterator_base(const __hash_code_base& __base,
      _Hash_node<_Value, false>* __p,
      std::size_t __bkt, std::size_t __bkt_count)
 : __hash_code_base(__base),
   _M_cur(__p), _M_bucket(__bkt), _M_bucket_count(__bkt_count) { }

      void
      _M_incr()
      {
 _M_cur = _M_cur->_M_next();
 if (_M_cur)
   {
     std::size_t __bkt = this->_M_bucket_index(_M_cur, _M_bucket_count);
     if (__bkt != _M_bucket)
       _M_cur = nullptr;
   }
      }

      _Hash_node<_Value, false>* _M_cur;
      std::size_t _M_bucket;
      std::size_t _M_bucket_count;
    };

  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash, bool __cache>
    inline bool
    operator==(const _Local_iterator_base<_Key, _Value, _ExtractKey,
       _H1, _H2, _Hash, __cache>& __x,
        const _Local_iterator_base<_Key, _Value, _ExtractKey,
       _H1, _H2, _Hash, __cache>& __y)
    { return __x._M_cur == __y._M_cur; }

  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash, bool __cache>
    inline bool
    operator!=(const _Local_iterator_base<_Key, _Value, _ExtractKey,
       _H1, _H2, _Hash, __cache>& __x,
        const _Local_iterator_base<_Key, _Value, _ExtractKey,
       _H1, _H2, _Hash, __cache>& __y)
    { return __x._M_cur != __y._M_cur; }


  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash,
    bool __constant_iterators, bool __cache>
    struct _Local_iterator
    : public _Local_iterator_base<_Key, _Value, _ExtractKey,
      _H1, _H2, _Hash, __cache>
    {
    private:
      using __base_type = _Local_iterator_base<_Key, _Value, _ExtractKey,
            _H1, _H2, _Hash, __cache>;
      using __hash_code_base = typename __base_type::__hash_code_base;
    public:
      typedef _Value value_type;
      typedef typename std::conditional<__constant_iterators,
     const _Value*, _Value*>::type
             pointer;
      typedef typename std::conditional<__constant_iterators,
     const _Value&, _Value&>::type
             reference;
      typedef std::ptrdiff_t difference_type;
      typedef std::forward_iterator_tag iterator_category;

      _Local_iterator() = default;

      _Local_iterator(const __hash_code_base& __base,
        _Hash_node<_Value, __cache>* __p,
        std::size_t __bkt, std::size_t __bkt_count)
 : __base_type(__base, __p, __bkt, __bkt_count)
      { }

      reference
      operator*() const
      { return this->_M_cur->_M_v; }

      pointer
      operator->() const
      { return std::__addressof(this->_M_cur->_M_v); }

      _Local_iterator&
      operator++()
      {
 this->_M_incr();
 return *this;
      }

      _Local_iterator
      operator++(int)
      {
 _Local_iterator __tmp(*this);
 this->_M_incr();
 return __tmp;
      }
    };


  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash,
    bool __constant_iterators, bool __cache>
    struct _Local_const_iterator
    : public _Local_iterator_base<_Key, _Value, _ExtractKey,
      _H1, _H2, _Hash, __cache>
    {
    private:
      using __base_type = _Local_iterator_base<_Key, _Value, _ExtractKey,
            _H1, _H2, _Hash, __cache>;
      using __hash_code_base = typename __base_type::__hash_code_base;

    public:
      typedef _Value value_type;
      typedef const _Value* pointer;
      typedef const _Value& reference;
      typedef std::ptrdiff_t difference_type;
      typedef std::forward_iterator_tag iterator_category;

      _Local_const_iterator() = default;

      _Local_const_iterator(const __hash_code_base& __base,
       _Hash_node<_Value, __cache>* __p,
       std::size_t __bkt, std::size_t __bkt_count)
 : __base_type(__base, __p, __bkt, __bkt_count)
      { }

      _Local_const_iterator(const _Local_iterator<_Key, _Value, _ExtractKey,
        _H1, _H2, _Hash,
        __constant_iterators,
        __cache>& __x)
 : __base_type(__x)
      { }

      reference
      operator*() const
      { return this->_M_cur->_M_v; }

      pointer
      operator->() const
      { return std::__addressof(this->_M_cur->_M_v); }

      _Local_const_iterator&
      operator++()
      {
 this->_M_incr();
 return *this;
      }

      _Local_const_iterator
      operator++(int)
      {
 _Local_const_iterator __tmp(*this);
 this->_M_incr();
 return __tmp;
      }
    };
# 1399 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/hashtable_policy.h" 3
  template<typename _Key, typename _Value,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _Traits>
  struct _Hashtable_base
  : public _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash,
      _Traits::__hash_cached::value>,
    private _Hashtable_ebo_helper<0, _Equal>
  {
  public:
    typedef _Key key_type;
    typedef _Value value_type;
    typedef _Equal key_equal;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;

    using __traits_type = _Traits;
    using __hash_cached = typename __traits_type::__hash_cached;
    using __constant_iterators = typename __traits_type::__constant_iterators;
    using __unique_keys = typename __traits_type::__unique_keys;

    using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,
          _H1, _H2, _Hash,
          __hash_cached::value>;

    using __hash_code = typename __hash_code_base::__hash_code;
    using __node_type = typename __hash_code_base::__node_type;

    using iterator = __detail::_Node_iterator<value_type,
           __constant_iterators::value,
           __hash_cached::value>;

    using const_iterator = __detail::_Node_const_iterator<value_type,
         __constant_iterators::value,
         __hash_cached::value>;

    using local_iterator = __detail::_Local_iterator<key_type, value_type,
        _ExtractKey, _H1, _H2, _Hash,
        __constant_iterators::value,
           __hash_cached::value>;

    using const_local_iterator = __detail::_Local_const_iterator<key_type,
         value_type,
     _ExtractKey, _H1, _H2, _Hash,
     __constant_iterators::value,
     __hash_cached::value>;

    using __ireturn_type = typename std::conditional<__unique_keys::value,
           std::pair<iterator, bool>,
           iterator>::type;

    using __iconv_type = typename std::conditional<__unique_keys::value,
          _Select1st, _Identity
          >::type;
  private:
    using _EqualEBO = _Hashtable_ebo_helper<0, _Equal>;
    using _EqualHelper = _Equal_helper<_Key, _Value, _ExtractKey, _Equal,
     __hash_code, __hash_cached::value>;

  protected:
    using __node_base = __detail::_Hash_node_base;
    using __bucket_type = __node_base*;

    _Hashtable_base(const _ExtractKey& __ex, const _H1& __h1, const _H2& __h2,
      const _Hash& __hash, const _Equal& __eq)
    : __hash_code_base(__ex, __h1, __h2, __hash), _EqualEBO(__eq)
    { }

    bool
    _M_equals(const _Key& __k, __hash_code __c, __node_type* __n) const
    {
      return _EqualHelper::_S_equals(_M_eq(), this->_M_extract(),
         __k, __c, __n);
    }

    void
    _M_swap(_Hashtable_base& __x)
    {
      __hash_code_base::_M_swap(__x);
      std::swap(_M_eq(), __x._M_eq());
    }

    const _Equal&
    _M_eq() const { return _EqualEBO::_S_cget(*this); }

    _Equal&
    _M_eq() { return _EqualEBO::_S_get(*this); }
  };






  struct _Equality_base
  {
  protected:
    template<typename _Uiterator>
      static bool
      _S_is_permutation(_Uiterator, _Uiterator, _Uiterator);
  };


  template<typename _Uiterator>
    bool
    _Equality_base::
    _S_is_permutation(_Uiterator __first1, _Uiterator __last1,
        _Uiterator __first2)
    {
      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!(*__first1 == *__first2))
   break;

      if (__first1 == __last1)
 return true;

      _Uiterator __last2 = __first2;
      std::advance(__last2, std::distance(__first1, __last1));

      for (_Uiterator __it1 = __first1; __it1 != __last1; ++__it1)
 {
   _Uiterator __tmp = __first1;
   while (__tmp != __it1 && !bool(*__tmp == *__it1))
     ++__tmp;


   if (__tmp != __it1)
     continue;

   std::ptrdiff_t __n2 = 0;
   for (__tmp = __first2; __tmp != __last2; ++__tmp)
     if (*__tmp == *__it1)
       ++__n2;

   if (!__n2)
     return false;

   std::ptrdiff_t __n1 = 0;
   for (__tmp = __it1; __tmp != __last1; ++__tmp)
     if (*__tmp == *__it1)
       ++__n1;

   if (__n1 != __n2)
     return false;
 }
      return true;
    }
# 1554 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/hashtable_policy.h" 3
  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits,
    bool _Unique_keys = _Traits::__unique_keys::value>
    struct _Equality;


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>
    {
      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         _H1, _H2, _Hash, _RehashPolicy, _Traits>;

      bool
      _M_equal(const __hashtable&) const;
    };

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    bool
    _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
    _M_equal(const __hashtable& __other) const
    {
      const __hashtable* __this = static_cast<const __hashtable*>(this);

      if (__this->size() != __other.size())
 return false;

      for (auto __itx = __this->begin(); __itx != __this->end(); ++__itx)
 {
   const auto __ity = __other.find(_ExtractKey()(*__itx));
   if (__ity == __other.end() || !bool(*__ity == *__itx))
     return false;
 }
      return true;
    }


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, false>
    : public _Equality_base
    {
      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         _H1, _H2, _Hash, _RehashPolicy, _Traits>;

      bool
      _M_equal(const __hashtable&) const;
    };

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    bool
    _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, false>::
    _M_equal(const __hashtable& __other) const
    {
      const __hashtable* __this = static_cast<const __hashtable*>(this);

      if (__this->size() != __other.size())
 return false;

      for (auto __itx = __this->begin(); __itx != __this->end();)
 {
   const auto __xrange = __this->equal_range(_ExtractKey()(*__itx));
   const auto __yrange = __other.equal_range(_ExtractKey()(*__itx));

   if (std::distance(__xrange.first, __xrange.second)
       != std::distance(__yrange.first, __yrange.second))
     return false;

   if (!_S_is_permutation(__xrange.first, __xrange.second,
     __yrange.first))
     return false;

   __itx = __xrange.second;
 }
      return true;
    }





  template<typename _NodeAlloc>
    struct _Before_begin : public _NodeAlloc
    {
      _Hash_node_base _M_node;

      _Before_begin(const _Before_begin&) = default;
      _Before_begin(_Before_begin&&) = default;

      template<typename _Alloc>
 _Before_begin(_Alloc&& __a)
   : _NodeAlloc(std::forward<_Alloc>(__a))
 { }
    };



}
}
# 36 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/hashtable.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, typename _Hash>
    using __cache_default
      = __not_<__and_<
         __is_fast_hash<_Hash>,


         is_default_constructible<_Hash>,
         is_copy_assignable<_Hash>,

         __detail::__is_noexcept_hash<_Tp, _Hash>>>;
# 170 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/hashtable.h" 3
  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    class _Hashtable
    : public __detail::_Hashtable_base<_Key, _Value, _ExtractKey, _Equal,
           _H1, _H2, _Hash, _Traits>,
      public __detail::_Map_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
     _H1, _H2, _Hash, _RehashPolicy, _Traits>,
      public __detail::_Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal,
          _H1, _H2, _Hash, _RehashPolicy, _Traits>,
      public __detail::_Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>,
      public __detail::_Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
     _H1, _H2, _Hash, _RehashPolicy, _Traits>
    {
    public:
      typedef _Key key_type;
      typedef _Value value_type;
      typedef _Alloc allocator_type;
      typedef _Equal key_equal;



      typedef typename _Alloc::pointer pointer;
      typedef typename _Alloc::const_pointer const_pointer;
      typedef typename _Alloc::reference reference;
      typedef typename _Alloc::const_reference const_reference;

    private:
      using __rehash_type = _RehashPolicy;
      using __rehash_state = typename __rehash_type::_State;

      using __traits_type = _Traits;
      using __hash_cached = typename __traits_type::__hash_cached;
      using __constant_iterators = typename __traits_type::__constant_iterators;
      using __unique_keys = typename __traits_type::__unique_keys;

      using __key_extract = typename std::conditional<
          __constant_iterators::value,
                 __detail::_Identity,
          __detail::_Select1st>::type;

      using __hashtable_base = __detail::
          _Hashtable_base<_Key, _Value, _ExtractKey,
           _Equal, _H1, _H2, _Hash, _Traits>;

      using __hash_code_base = typename __hashtable_base::__hash_code_base;
      using __hash_code = typename __hashtable_base::__hash_code;
      using __node_type = typename __hashtable_base::__node_type;
      using __node_base = typename __hashtable_base::__node_base;
      using __bucket_type = typename __hashtable_base::__bucket_type;
      using __ireturn_type = typename __hashtable_base::__ireturn_type;
      using __iconv_type = typename __hashtable_base::__iconv_type;

      using __map_base = __detail::_Map_base<_Key, _Value, _Alloc, _ExtractKey,
          _Equal, _H1, _H2, _Hash,
          _RehashPolicy, _Traits>;

      using __rehash_base = __detail::_Rehash_base<_Key, _Value, _Alloc,
         _ExtractKey, _Equal,
         _H1, _H2, _Hash,
         _RehashPolicy, _Traits>;

      using __eq_base = __detail::_Equality<_Key, _Value, _Alloc, _ExtractKey,
         _Equal, _H1, _H2, _Hash,
         _RehashPolicy, _Traits>;


      using __hash_noexcept = __detail::__is_noexcept_hash<_Key, _H1>;

      template<typename _Cond>
 using __if_hash_cached = __or_<__not_<__hash_cached>, _Cond>;

      template<typename _Cond>
 using __if_hash_not_cached = __or_<__hash_cached, _Cond>;






      static_assert(__if_hash_not_cached<__hash_noexcept>::value,
      "Cache the hash code"
      " or qualify your hash functor with noexcept");






      static_assert(__if_hash_cached<is_default_constructible<_H2>>::value,
      "Functor used to map hash code to bucket index"
      " must be default constructible");




      static_assert(__if_hash_not_cached<
      is_default_constructible<


        __detail::_Hashtable_ebo_helper<0, __hash_code_base>>>::value,
      "Cache the hash code or make functors involved in hash code"
      " and bucket index computation default constructible");




      static_assert(__if_hash_not_cached<
        is_copy_assignable<__hash_code_base>>::value,
      "Cache the hash code or make functors involved in hash code"
      " and bucket index computation copy assignable");

    public:
      template<typename _Keya, typename _Valuea, typename _Alloca,
        typename _ExtractKeya, typename _Equala,
        typename _H1a, typename _H2a, typename _Hasha,
        typename _RehashPolicya, typename _Traitsa,
        bool _Unique_keysa>
 friend struct __detail::_Map_base;

      template<typename _Keya, typename _Valuea, typename _Alloca,
        typename _ExtractKeya, typename _Equala,
        typename _H1a, typename _H2a, typename _Hasha,
        typename _RehashPolicya, typename _Traitsa>
 friend struct __detail::_Insert_base;

      template<typename _Keya, typename _Valuea, typename _Alloca,
        typename _ExtractKeya, typename _Equala,
        typename _H1a, typename _H2a, typename _Hasha,
        typename _RehashPolicya, typename _Traitsa,
        bool _Constant_iteratorsa, bool _Unique_keysa>
 friend struct __detail::_Insert;

      using size_type = typename __hashtable_base::size_type;
      using difference_type = typename __hashtable_base::difference_type;

      using iterator = typename __hashtable_base::iterator;
      using const_iterator = typename __hashtable_base::const_iterator;

      using local_iterator = typename __hashtable_base::local_iterator;
      using const_local_iterator = typename __hashtable_base::
       const_local_iterator;

    private:
      typedef typename _Alloc::template rebind<__node_type>::other
       _Node_allocator_type;
      typedef typename _Alloc::template rebind<__bucket_type>::other
       _Bucket_allocator_type;

      using __before_begin = __detail::_Before_begin<_Node_allocator_type>;

      __bucket_type* _M_buckets;
      size_type _M_bucket_count;
      __before_begin _M_bbegin;
      size_type _M_element_count;
      _RehashPolicy _M_rehash_policy;

      _Node_allocator_type&
      _M_node_allocator()
      { return _M_bbegin; }

      const _Node_allocator_type&
      _M_node_allocator() const
      { return _M_bbegin; }

      __node_base&
      _M_before_begin()
      { return _M_bbegin._M_node; }

      const __node_base&
      _M_before_begin() const
      { return _M_bbegin._M_node; }

      template<typename... _Args>
 __node_type*
 _M_allocate_node(_Args&&... __args);

      void
      _M_deallocate_node(__node_type* __n);


      void
      _M_deallocate_nodes(__node_type* __n);

      __bucket_type*
      _M_allocate_buckets(size_type __n);

      void
      _M_deallocate_buckets(__bucket_type*, size_type __n);



      __node_type*
      _M_bucket_begin(size_type __bkt) const;

      __node_type*
      _M_begin() const
      { return static_cast<__node_type*>(_M_before_begin()._M_nxt); }

    public:

      _Hashtable(size_type __bucket_hint,
   const _H1&, const _H2&, const _Hash&,
   const _Equal&, const _ExtractKey&,
   const allocator_type&);

      template<typename _InputIterator>
 _Hashtable(_InputIterator __first, _InputIterator __last,
     size_type __bucket_hint,
     const _H1&, const _H2&, const _Hash&,
     const _Equal&, const _ExtractKey&,
     const allocator_type&);

      _Hashtable(const _Hashtable&);

      _Hashtable(_Hashtable&&);


      explicit
      _Hashtable(size_type __n = 10,
   const _H1& __hf = _H1(),
   const key_equal& __eql = key_equal(),
   const allocator_type& __a = allocator_type())
      : _Hashtable(__n, __hf, __detail::_Mod_range_hashing(),
     __detail::_Default_ranged_hash(), __eql,
     __key_extract(), __a)
      { }

      template<typename _InputIterator>
 _Hashtable(_InputIterator __f, _InputIterator __l,
     size_type __n = 0,
     const _H1& __hf = _H1(),
     const key_equal& __eql = key_equal(),
     const allocator_type& __a = allocator_type())
 : _Hashtable(__f, __l, __n, __hf, __detail::_Mod_range_hashing(),
       __detail::_Default_ranged_hash(), __eql,
       __key_extract(), __a)
 { }

      _Hashtable(initializer_list<value_type> __l,
   size_type __n = 0,
   const _H1& __hf = _H1(),
   const key_equal& __eql = key_equal(),
   const allocator_type& __a = allocator_type())
      : _Hashtable(__l.begin(), __l.end(), __n, __hf,
     __detail::_Mod_range_hashing(),
     __detail::_Default_ranged_hash(), __eql,
     __key_extract(), __a)
      { }

      _Hashtable&
      operator=(const _Hashtable& __ht)
      {
 _Hashtable __tmp(__ht);
 this->swap(__tmp);
 return *this;
      }

      _Hashtable&
      operator=(_Hashtable&& __ht)
      {


 this->clear();
 this->swap(__ht);
 return *this;
      }

      _Hashtable&
      operator=(initializer_list<value_type> __l)
      {
 this->clear();
 this->insert(__l.begin(), __l.end());
 return *this;
      }

      ~_Hashtable() noexcept;

      void swap(_Hashtable&);


      iterator
      begin() noexcept
      { return iterator(_M_begin()); }

      const_iterator
      begin() const noexcept
      { return const_iterator(_M_begin()); }

      iterator
      end() noexcept
      { return iterator(nullptr); }

      const_iterator
      end() const noexcept
      { return const_iterator(nullptr); }

      const_iterator
      cbegin() const noexcept
      { return const_iterator(_M_begin()); }

      const_iterator
      cend() const noexcept
      { return const_iterator(nullptr); }

      size_type
      size() const noexcept
      { return _M_element_count; }

      bool
      empty() const noexcept
      { return size() == 0; }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_node_allocator()); }

      size_type
      max_size() const noexcept
      { return _M_node_allocator().max_size(); }


      key_equal
      key_eq() const
      { return this->_M_eq(); }




      size_type
      bucket_count() const noexcept
      { return _M_bucket_count; }

      size_type
      max_bucket_count() const noexcept
      { return max_size(); }

      size_type
      bucket_size(size_type __n) const
      { return std::distance(begin(__n), end(__n)); }

      size_type
      bucket(const key_type& __k) const
      { return _M_bucket_index(__k, this->_M_hash_code(__k)); }

      local_iterator
      begin(size_type __n)
      {
 return local_iterator(*this, _M_bucket_begin(__n),
         __n, _M_bucket_count);
      }

      local_iterator
      end(size_type __n)
      { return local_iterator(*this, nullptr, __n, _M_bucket_count); }

      const_local_iterator
      begin(size_type __n) const
      {
 return const_local_iterator(*this, _M_bucket_begin(__n),
        __n, _M_bucket_count);
      }

      const_local_iterator
      end(size_type __n) const
      { return const_local_iterator(*this, nullptr, __n, _M_bucket_count); }


      const_local_iterator
      cbegin(size_type __n) const
      {
 return const_local_iterator(*this, _M_bucket_begin(__n),
        __n, _M_bucket_count);
      }

      const_local_iterator
      cend(size_type __n) const
      { return const_local_iterator(*this, nullptr, __n, _M_bucket_count); }

      float
      load_factor() const noexcept
      {
 return static_cast<float>(size()) / static_cast<float>(bucket_count());
      }






      const _RehashPolicy&
      __rehash_policy() const
      { return _M_rehash_policy; }

      void
      __rehash_policy(const _RehashPolicy&);


      iterator
      find(const key_type& __k);

      const_iterator
      find(const key_type& __k) const;

      size_type
      count(const key_type& __k) const;

      std::pair<iterator, iterator>
      equal_range(const key_type& __k);

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __k) const;

    protected:

      size_type
      _M_bucket_index(__node_type* __n) const
      { return __hash_code_base::_M_bucket_index(__n, _M_bucket_count); }

      size_type
      _M_bucket_index(const key_type& __k, __hash_code __c) const
      { return __hash_code_base::_M_bucket_index(__k, __c, _M_bucket_count); }



      __node_base*
      _M_find_before_node(size_type, const key_type&, __hash_code) const;

      __node_type*
      _M_find_node(size_type __bkt, const key_type& __key,
     __hash_code __c) const
      {
 __node_base* __before_n = _M_find_before_node(__bkt, __key, __c);
 if (__before_n)
   return static_cast<__node_type*>(__before_n->_M_nxt);
 return nullptr;
      }


      void
      _M_insert_bucket_begin(size_type, __node_type*);


      void
      _M_remove_bucket_begin(size_type __bkt, __node_type* __next_n,
        size_type __next_bkt);


      __node_base*
      _M_get_previous_node(size_type __bkt, __node_base* __n);




      iterator
      _M_insert_unique_node(size_type __bkt, __hash_code __code,
       __node_type* __n);



      iterator
      _M_insert_multi_node(__hash_code __code, __node_type* __n);

      template<typename... _Args>
 std::pair<iterator, bool>
 _M_emplace(std::true_type, _Args&&... __args);

      template<typename... _Args>
 iterator
 _M_emplace(std::false_type, _Args&&... __args);

      template<typename _Arg>
 std::pair<iterator, bool>
 _M_insert(_Arg&&, std::true_type);

      template<typename _Arg>
 iterator
 _M_insert(_Arg&&, std::false_type);

      size_type
      _M_erase(std::true_type, const key_type&);

      size_type
      _M_erase(std::false_type, const key_type&);

      iterator
      _M_erase(size_type __bkt, __node_base* __prev_n, __node_type* __n);

    public:

      template<typename... _Args>
 __ireturn_type
 emplace(_Args&&... __args)
 { return _M_emplace(__unique_keys(), std::forward<_Args>(__args)...); }

      template<typename... _Args>
 iterator
 emplace_hint(const_iterator, _Args&&... __args)
 { return __iconv_type()(emplace(std::forward<_Args>(__args)...)); }




      iterator
      erase(const_iterator);


      iterator
      erase(iterator __it)
      { return erase(const_iterator(__it)); }

      size_type
      erase(const key_type& __k)
      { return _M_erase(__unique_keys(), __k); }

      iterator
      erase(const_iterator, const_iterator);

      void
      clear() noexcept;


      void rehash(size_type __n);




    private:

      void _M_rehash_aux(size_type __n, std::true_type);


      void _M_rehash_aux(size_type __n, std::false_type);



      void _M_rehash(size_type __n, const __rehash_state& __state);
    };



  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename... _Args>
      typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
     _H1, _H2, _Hash, _RehashPolicy, _Traits>::__node_type*
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _M_allocate_node(_Args&&... __args)
      {
 __node_type* __n = _M_node_allocator().allocate(1);
 try
   {
     _M_node_allocator().construct(__n, std::forward<_Args>(__args)...);
     return __n;
   }
 catch(...)
   {
     _M_node_allocator().deallocate(__n, 1);
     throw;
   }
      }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_deallocate_node(__node_type* __n)
    {
      _M_node_allocator().destroy(__n);
      _M_node_allocator().deallocate(__n, 1);
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_deallocate_nodes(__node_type* __n)
    {
      while (__n)
 {
   __node_type* __tmp = __n;
   __n = __n->_M_next();
   _M_deallocate_node(__tmp);
 }
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::__bucket_type*
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_allocate_buckets(size_type __n)
    {
      _Bucket_allocator_type __alloc(_M_node_allocator());

      __bucket_type* __p = __alloc.allocate(__n);
      __builtin_memset(__p, 0, __n * sizeof(__bucket_type));
      return __p;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_deallocate_buckets(__bucket_type* __p, size_type __n)
    {
      _Bucket_allocator_type __alloc(_M_node_allocator());
      __alloc.deallocate(__p, __n);
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey,
   _Equal, _H1, _H2, _Hash, _RehashPolicy,
   _Traits>::__node_type*
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_bucket_begin(size_type __bkt) const
    {
      __node_base* __n = _M_buckets[__bkt];
      return __n ? static_cast<__node_type*>(__n->_M_nxt) : nullptr;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _Hashtable(size_type __bucket_hint,
        const _H1& __h1, const _H2& __h2, const _Hash& __h,
        const _Equal& __eq, const _ExtractKey& __exk,
        const allocator_type& __a)
    : __hashtable_base(__exk, __h1, __h2, __h, __eq),
      __map_base(),
      __rehash_base(),
      _M_bucket_count(0),
      _M_bbegin(__a),
      _M_element_count(0),
      _M_rehash_policy()
    {
      _M_bucket_count = _M_rehash_policy._M_next_bkt(__bucket_hint);
      _M_buckets = _M_allocate_buckets(_M_bucket_count);
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename _InputIterator>
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _Hashtable(_InputIterator __f, _InputIterator __l,
   size_type __bucket_hint,
   const _H1& __h1, const _H2& __h2, const _Hash& __h,
   const _Equal& __eq, const _ExtractKey& __exk,
   const allocator_type& __a)
      : __hashtable_base(__exk, __h1, __h2, __h, __eq),
 __map_base(),
 __rehash_base(),
 _M_bucket_count(0),
 _M_bbegin(__a),
 _M_element_count(0),
 _M_rehash_policy()
      {
 auto __nb_elems = __detail::__distance_fw(__f, __l);
 _M_bucket_count =
   _M_rehash_policy._M_next_bkt(
     std::max(_M_rehash_policy._M_bkt_for_elements(__nb_elems),
       __bucket_hint));

 _M_buckets = _M_allocate_buckets(_M_bucket_count);
 try
   {
     for (; __f != __l; ++__f)
       this->insert(*__f);
   }
 catch(...)
   {
     clear();
     _M_deallocate_buckets(_M_buckets, _M_bucket_count);
     throw;
   }
      }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _Hashtable(const _Hashtable& __ht)
    : __hashtable_base(__ht),
      __map_base(__ht),
      __rehash_base(__ht),
      _M_bucket_count(__ht._M_bucket_count),
      _M_bbegin(__ht._M_bbegin),
      _M_element_count(__ht._M_element_count),
      _M_rehash_policy(__ht._M_rehash_policy)
    {
      _M_buckets = _M_allocate_buckets(_M_bucket_count);
      try
 {
   if (!__ht._M_before_begin()._M_nxt)
     return;



   const __node_type* __ht_n = __ht._M_begin();
   __node_type* __this_n = _M_allocate_node(__ht_n->_M_v);
   this->_M_copy_code(__this_n, __ht_n);
   _M_before_begin()._M_nxt = __this_n;
   _M_buckets[_M_bucket_index(__this_n)] = &_M_before_begin();


   __node_base* __prev_n = __this_n;
   for (__ht_n = __ht_n->_M_next(); __ht_n; __ht_n = __ht_n->_M_next())
     {
       __this_n = _M_allocate_node(__ht_n->_M_v);
       __prev_n->_M_nxt = __this_n;
       this->_M_copy_code(__this_n, __ht_n);
       size_type __bkt = _M_bucket_index(__this_n);
       if (!_M_buckets[__bkt])
  _M_buckets[__bkt] = __prev_n;
       __prev_n = __this_n;
     }
 }
      catch(...)
 {
   clear();
   _M_deallocate_buckets(_M_buckets, _M_bucket_count);
   throw;
 }
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _Hashtable(_Hashtable&& __ht)
    : __hashtable_base(__ht),
      __map_base(__ht),
      __rehash_base(__ht),
      _M_buckets(__ht._M_buckets),
      _M_bucket_count(__ht._M_bucket_count),
      _M_bbegin(std::move(__ht._M_bbegin)),
      _M_element_count(__ht._M_element_count),
      _M_rehash_policy(__ht._M_rehash_policy)
    {

      if (_M_begin())
 _M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin();
      __ht._M_rehash_policy = _RehashPolicy();
      __ht._M_bucket_count = __ht._M_rehash_policy._M_next_bkt(0);
      __ht._M_buckets = __ht._M_allocate_buckets(__ht._M_bucket_count);
      __ht._M_before_begin()._M_nxt = nullptr;
      __ht._M_element_count = 0;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    ~_Hashtable() noexcept
    {
      clear();
      _M_deallocate_buckets(_M_buckets, _M_bucket_count);
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    swap(_Hashtable& __x)
    {



      this->_M_swap(__x);



      std::__alloc_swap<_Node_allocator_type>::_S_do_it(_M_node_allocator(),
       __x._M_node_allocator());

      std::swap(_M_rehash_policy, __x._M_rehash_policy);
      std::swap(_M_buckets, __x._M_buckets);
      std::swap(_M_bucket_count, __x._M_bucket_count);
      std::swap(_M_before_begin()._M_nxt, __x._M_before_begin()._M_nxt);
      std::swap(_M_element_count, __x._M_element_count);



      if (_M_begin())
 _M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin();
      if (__x._M_begin())
 __x._M_buckets[__x._M_bucket_index(__x._M_begin())]
   = &(__x._M_before_begin());
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    __rehash_policy(const _RehashPolicy& __pol)
    {
      size_type __n_bkt = __pol._M_bkt_for_elements(_M_element_count);
      __n_bkt = __pol._M_next_bkt(__n_bkt);
      if (__n_bkt != _M_bucket_count)
 _M_rehash(__n_bkt, _M_rehash_policy._M_state());
      _M_rehash_policy = __pol;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy,
   _Traits>::iterator
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    find(const key_type& __k)
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __n = _M_bucket_index(__k, __code);
      __node_type* __p = _M_find_node(__n, __k, __code);
      return __p ? iterator(__p) : this->end();
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy,
   _Traits>::const_iterator
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    find(const key_type& __k) const
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __n = _M_bucket_index(__k, __code);
      __node_type* __p = _M_find_node(__n, __k, __code);
      return __p ? const_iterator(__p) : this->end();
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy,
   _Traits>::size_type
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    count(const key_type& __k) const
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __n = _M_bucket_index(__k, __code);
      __node_type* __p = _M_bucket_begin(__n);
      if (!__p)
 return 0;

      std::size_t __result = 0;
      for (;; __p = __p->_M_next())
 {
   if (this->_M_equals(__k, __code, __p))
     ++__result;
   else if (__result)



     break;
   if (!__p->_M_nxt || _M_bucket_index(__p->_M_next()) != __n)
     break;
 }
      return __result;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    std::pair<typename _Hashtable<_Key, _Value, _Alloc,
      _ExtractKey, _Equal, _H1,
      _H2, _Hash, _RehashPolicy,
      _Traits>::iterator,
       typename _Hashtable<_Key, _Value, _Alloc,
      _ExtractKey, _Equal, _H1,
      _H2, _Hash, _RehashPolicy,
      _Traits>::iterator>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    equal_range(const key_type& __k)
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __n = _M_bucket_index(__k, __code);
      __node_type* __p = _M_find_node(__n, __k, __code);

      if (__p)
 {
   __node_type* __p1 = __p->_M_next();
   while (__p1 && _M_bucket_index(__p1) == __n
   && this->_M_equals(__k, __code, __p1))
     __p1 = __p1->_M_next();

   return std::make_pair(iterator(__p), iterator(__p1));
 }
      else
 return std::make_pair(this->end(), this->end());
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    std::pair<typename _Hashtable<_Key, _Value, _Alloc,
      _ExtractKey, _Equal, _H1,
      _H2, _Hash, _RehashPolicy,
      _Traits>::const_iterator,
       typename _Hashtable<_Key, _Value, _Alloc,
      _ExtractKey, _Equal, _H1,
      _H2, _Hash, _RehashPolicy,
      _Traits>::const_iterator>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    equal_range(const key_type& __k) const
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __n = _M_bucket_index(__k, __code);
      __node_type* __p = _M_find_node(__n, __k, __code);

      if (__p)
 {
   __node_type* __p1 = __p->_M_next();
   while (__p1 && _M_bucket_index(__p1) == __n
   && this->_M_equals(__k, __code, __p1))
     __p1 = __p1->_M_next();

   return std::make_pair(const_iterator(__p), const_iterator(__p1));
 }
      else
 return std::make_pair(this->end(), this->end());
    }



  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey,
   _Equal, _H1, _H2, _Hash, _RehashPolicy,
   _Traits>::__node_base*
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_find_before_node(size_type __n, const key_type& __k,
   __hash_code __code) const
    {
      __node_base* __prev_p = _M_buckets[__n];
      if (!__prev_p)
 return nullptr;
      __node_type* __p = static_cast<__node_type*>(__prev_p->_M_nxt);
      for (;; __p = __p->_M_next())
 {
   if (this->_M_equals(__k, __code, __p))
     return __prev_p;
   if (!__p->_M_nxt || _M_bucket_index(__p->_M_next()) != __n)
     break;
   __prev_p = __p;
 }
      return nullptr;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_insert_bucket_begin(size_type __bkt, __node_type* __node)
    {
      if (_M_buckets[__bkt])
 {


   __node->_M_nxt = _M_buckets[__bkt]->_M_nxt;
   _M_buckets[__bkt]->_M_nxt = __node;
 }
      else
 {



   __node->_M_nxt = _M_before_begin()._M_nxt;
   _M_before_begin()._M_nxt = __node;
   if (__node->_M_nxt)


     _M_buckets[_M_bucket_index(__node->_M_next())] = __node;
   _M_buckets[__bkt] = &_M_before_begin();
 }
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_remove_bucket_begin(size_type __bkt, __node_type* __next,
      size_type __next_bkt)
    {
      if (!__next || __next_bkt != __bkt)
 {


   if (__next)
     _M_buckets[__next_bkt] = _M_buckets[__bkt];


   if (&_M_before_begin() == _M_buckets[__bkt])
     _M_before_begin()._M_nxt = __next;
   _M_buckets[__bkt] = nullptr;
 }
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey,
   _Equal, _H1, _H2, _Hash, _RehashPolicy,
   _Traits>::__node_base*
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_get_previous_node(size_type __bkt, __node_base* __n)
    {
      __node_base* __prev_n = _M_buckets[__bkt];
      while (__prev_n->_M_nxt != __n)
 __prev_n = __prev_n->_M_nxt;
      return __prev_n;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename... _Args>
      std::pair<typename _Hashtable<_Key, _Value, _Alloc,
        _ExtractKey, _Equal, _H1,
        _H2, _Hash, _RehashPolicy,
        _Traits>::iterator, bool>
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _M_emplace(std::true_type, _Args&&... __args)
      {

 __node_type* __node = _M_allocate_node(std::forward<_Args>(__args)...);
 const key_type& __k = this->_M_extract()(__node->_M_v);
 __hash_code __code;
 try
   {
     __code = this->_M_hash_code(__k);
   }
 catch(...)
   {
     _M_deallocate_node(__node);
     throw;
   }

 size_type __bkt = _M_bucket_index(__k, __code);
 if (__node_type* __p = _M_find_node(__bkt, __k, __code))
   {

     _M_deallocate_node(__node);
     return std::make_pair(iterator(__p), false);
   }


 return std::make_pair(_M_insert_unique_node(__bkt, __code, __node),
         true);
      }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename... _Args>
      typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
     _H1, _H2, _Hash, _RehashPolicy,
     _Traits>::iterator
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _M_emplace(std::false_type, _Args&&... __args)
      {

 __node_type* __node = _M_allocate_node(std::forward<_Args>(__args)...);

 __hash_code __code;
 try
   {
     __code = this->_M_hash_code(this->_M_extract()(__node->_M_v));
   }
 catch(...)
   {
     _M_deallocate_node(__node);
     throw;
   }

 return _M_insert_multi_node(__code, __node);
      }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy,
   _Traits>::iterator
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_insert_unique_node(size_type __bkt, __hash_code __code,
     __node_type* __node)
    {
      const __rehash_state& __saved_state = _M_rehash_policy._M_state();
      std::pair<bool, std::size_t> __do_rehash
 = _M_rehash_policy._M_need_rehash(_M_bucket_count, _M_element_count, 1);

      try
 {
   if (__do_rehash.first)
     {
       _M_rehash(__do_rehash.second, __saved_state);
       __bkt = _M_bucket_index(this->_M_extract()(__node->_M_v), __code);
     }

   this->_M_store_code(__node, __code);


   _M_insert_bucket_begin(__bkt, __node);
   ++_M_element_count;
   return iterator(__node);
 }
      catch(...)
 {
   _M_deallocate_node(__node);
   throw;
 }
    }



  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy,
   _Traits>::iterator
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_insert_multi_node(__hash_code __code, __node_type* __node)
    {
      const __rehash_state& __saved_state = _M_rehash_policy._M_state();
      std::pair<bool, std::size_t> __do_rehash
 = _M_rehash_policy._M_need_rehash(_M_bucket_count, _M_element_count, 1);

      try
 {
   if (__do_rehash.first)
     _M_rehash(__do_rehash.second, __saved_state);

   this->_M_store_code(__node, __code);
   const key_type& __k = this->_M_extract()(__node->_M_v);
   size_type __bkt = _M_bucket_index(__k, __code);


   __node_base* __prev = _M_find_before_node(__bkt, __k, __code);
   if (__prev)
     {

       __node->_M_nxt = __prev->_M_nxt;
       __prev->_M_nxt = __node;
     }
   else




     _M_insert_bucket_begin(__bkt, __node);
   ++_M_element_count;
   return iterator(__node);
 }
      catch(...)
 {
   _M_deallocate_node(__node);
   throw;
 }
    }


  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename _Arg>
      std::pair<typename _Hashtable<_Key, _Value, _Alloc,
        _ExtractKey, _Equal, _H1,
        _H2, _Hash, _RehashPolicy,
        _Traits>::iterator, bool>
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _M_insert(_Arg&& __v, std::true_type)
      {
 const key_type& __k = this->_M_extract()(__v);
 __hash_code __code = this->_M_hash_code(__k);
 size_type __bkt = _M_bucket_index(__k, __code);

 __node_type* __n = _M_find_node(__bkt, __k, __code);
 if (__n)
   return std::make_pair(iterator(__n), false);

 __n = _M_allocate_node(std::forward<_Arg>(__v));
 return std::make_pair(_M_insert_unique_node(__bkt, __code, __n), true);
      }


  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename _Arg>
      typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
     _H1, _H2, _Hash, _RehashPolicy,
     _Traits>::iterator
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _M_insert(_Arg&& __v, std::false_type)
      {


 __hash_code __code = this->_M_hash_code(this->_M_extract()(__v));


 __node_type* __node = _M_allocate_node(std::forward<_Arg>(__v));

 return _M_insert_multi_node(__code, __node);
      }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy,
   _Traits>::iterator
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    erase(const_iterator __it)
    {
      __node_type* __n = __it._M_cur;
      std::size_t __bkt = _M_bucket_index(__n);




      __node_base* __prev_n = _M_get_previous_node(__bkt, __n);
      return _M_erase(__bkt, __prev_n, __n);
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy,
   _Traits>::iterator
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_erase(size_type __bkt, __node_base* __prev_n, __node_type* __n)
    {
      if (__prev_n == _M_buckets[__bkt])
 _M_remove_bucket_begin(__bkt, __n->_M_next(),
    __n->_M_nxt ? _M_bucket_index(__n->_M_next()) : 0);
      else if (__n->_M_nxt)
 {
   size_type __next_bkt = _M_bucket_index(__n->_M_next());
   if (__next_bkt != __bkt)
     _M_buckets[__next_bkt] = __prev_n;
 }

      __prev_n->_M_nxt = __n->_M_nxt;
      iterator __result(__n->_M_next());
      _M_deallocate_node(__n);
      --_M_element_count;

      return __result;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy,
   _Traits>::size_type
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_erase(std::true_type, const key_type& __k)
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __bkt = _M_bucket_index(__k, __code);


      __node_base* __prev_n = _M_find_before_node(__bkt, __k, __code);
      if (!__prev_n)
 return 0;


      __node_type* __n = static_cast<__node_type*>(__prev_n->_M_nxt);
      _M_erase(__bkt, __prev_n, __n);
      return 1;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy,
   _Traits>::size_type
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_erase(std::false_type, const key_type& __k)
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __bkt = _M_bucket_index(__k, __code);


      __node_base* __prev_n = _M_find_before_node(__bkt, __k, __code);
      if (!__prev_n)
 return 0;







      __node_type* __n = static_cast<__node_type*>(__prev_n->_M_nxt);
      __node_type* __n_last = __n;
      std::size_t __n_last_bkt = __bkt;
      do
 {
   __n_last = __n_last->_M_next();
   if (!__n_last)
     break;
   __n_last_bkt = _M_bucket_index(__n_last);
 }
      while (__n_last_bkt == __bkt && this->_M_equals(__k, __code, __n_last));


      size_type __result = 0;
      do
 {
   __node_type* __p = __n->_M_next();
   _M_deallocate_node(__n);
   __n = __p;
   ++__result;
   --_M_element_count;
 }
      while (__n != __n_last);

      if (__prev_n == _M_buckets[__bkt])
 _M_remove_bucket_begin(__bkt, __n_last, __n_last_bkt);
      else if (__n_last && __n_last_bkt != __bkt)
 _M_buckets[__n_last_bkt] = __prev_n;
      __prev_n->_M_nxt = __n_last;
      return __result;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy,
   _Traits>::iterator
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    erase(const_iterator __first, const_iterator __last)
    {
      __node_type* __n = __first._M_cur;
      __node_type* __last_n = __last._M_cur;
      if (__n == __last_n)
 return iterator(__n);

      std::size_t __bkt = _M_bucket_index(__n);

      __node_base* __prev_n = _M_get_previous_node(__bkt, __n);
      bool __is_bucket_begin = __n == _M_bucket_begin(__bkt);
      std::size_t __n_bkt = __bkt;
      for (;;)
 {
   do
     {
       __node_type* __tmp = __n;
       __n = __n->_M_next();
       _M_deallocate_node(__tmp);
       --_M_element_count;
       if (!__n)
  break;
       __n_bkt = _M_bucket_index(__n);
     }
   while (__n != __last_n && __n_bkt == __bkt);
   if (__is_bucket_begin)
     _M_remove_bucket_begin(__bkt, __n, __n_bkt);
   if (__n == __last_n)
     break;
   __is_bucket_begin = true;
   __bkt = __n_bkt;
 }

      if (__n && (__n_bkt != __bkt || __is_bucket_begin))
 _M_buckets[__n_bkt] = __prev_n;
      __prev_n->_M_nxt = __n;
      return iterator(__n);
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    clear() noexcept
    {
      _M_deallocate_nodes(_M_begin());
      __builtin_memset(_M_buckets, 0, _M_bucket_count * sizeof(__bucket_type));
      _M_element_count = 0;
      _M_before_begin()._M_nxt = nullptr;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    rehash(size_type __n)
    {
      const __rehash_state& __saved_state = _M_rehash_policy._M_state();
      std::size_t __buckets
 = std::max(_M_rehash_policy._M_bkt_for_elements(_M_element_count + 1),
     __n);
      __buckets = _M_rehash_policy._M_next_bkt(__buckets);

      if (__buckets != _M_bucket_count)
 _M_rehash(__buckets, __saved_state);
      else

 _M_rehash_policy._M_reset(__saved_state);
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_rehash(size_type __n, const __rehash_state& __state)
    {
      try
 {
   _M_rehash_aux(__n, __unique_keys());
 }
      catch(...)
 {


   _M_rehash_policy._M_reset(__state);
   throw;
 }
    }


  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_rehash_aux(size_type __n, std::true_type)
    {
      __bucket_type* __new_buckets = _M_allocate_buckets(__n);
      __node_type* __p = _M_begin();
      _M_before_begin()._M_nxt = nullptr;
      std::size_t __bbegin_bkt = 0;
      while (__p)
 {
   __node_type* __next = __p->_M_next();
   std::size_t __bkt = __hash_code_base::_M_bucket_index(__p, __n);
   if (!__new_buckets[__bkt])
     {
       __p->_M_nxt = _M_before_begin()._M_nxt;
       _M_before_begin()._M_nxt = __p;
       __new_buckets[__bkt] = &_M_before_begin();
       if (__p->_M_nxt)
  __new_buckets[__bbegin_bkt] = __p;
       __bbegin_bkt = __bkt;
     }
   else
     {
       __p->_M_nxt = __new_buckets[__bkt]->_M_nxt;
       __new_buckets[__bkt]->_M_nxt = __p;
     }
   __p = __next;
 }
      _M_deallocate_buckets(_M_buckets, _M_bucket_count);
      _M_bucket_count = __n;
      _M_buckets = __new_buckets;
    }



  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_rehash_aux(size_type __n, std::false_type)
    {
      __bucket_type* __new_buckets = _M_allocate_buckets(__n);

      __node_type* __p = _M_begin();
      _M_before_begin()._M_nxt = nullptr;
      std::size_t __bbegin_bkt = 0;
      std::size_t __prev_bkt = 0;
      __node_type* __prev_p = nullptr;
      bool __check_bucket = false;

      while (__p)
 {
   __node_type* __next = __p->_M_next();
   std::size_t __bkt = __hash_code_base::_M_bucket_index(__p, __n);

   if (__prev_p && __prev_bkt == __bkt)
     {



       __p->_M_nxt = __prev_p->_M_nxt;
       __prev_p->_M_nxt = __p;






       __check_bucket = true;
     }
   else
     {
       if (__check_bucket)
  {


    if (__prev_p->_M_nxt)
      {
        std::size_t __next_bkt
   = __hash_code_base::_M_bucket_index(__prev_p->_M_next(),
           __n);
        if (__next_bkt != __prev_bkt)
   __new_buckets[__next_bkt] = __prev_p;
      }
    __check_bucket = false;
  }

       if (!__new_buckets[__bkt])
  {
    __p->_M_nxt = _M_before_begin()._M_nxt;
    _M_before_begin()._M_nxt = __p;
    __new_buckets[__bkt] = &_M_before_begin();
    if (__p->_M_nxt)
      __new_buckets[__bbegin_bkt] = __p;
    __bbegin_bkt = __bkt;
  }
       else
  {
    __p->_M_nxt = __new_buckets[__bkt]->_M_nxt;
    __new_buckets[__bkt]->_M_nxt = __p;
  }
     }
   __prev_p = __p;
   __prev_bkt = __bkt;
   __p = __next;
 }

      if (__check_bucket && __prev_p->_M_nxt)
 {
   std::size_t __next_bkt
     = __hash_code_base::_M_bucket_index(__prev_p->_M_next(), __n);
   if (__next_bkt != __prev_bkt)
     __new_buckets[__next_bkt] = __prev_p;
 }

      _M_deallocate_buckets(_M_buckets, _M_bucket_count);
      _M_bucket_count = __n;
      _M_buckets = __new_buckets;
    }


}
# 48 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/unordered_map" 2 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<bool _Cache>
    using __umap_traits = __detail::_Hashtable_traits<_Cache, false, true>;

  template<typename _Key,
    typename _Tp,
    typename _Hash = hash<_Key>,
    typename _Pred = std::equal_to<_Key>,
    typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >,
    typename _Tr = __umap_traits<__cache_default<_Key, _Hash>::value>>
    using __umap_hashtable = _Hashtable<_Key, std::pair<const _Key, _Tp>,
                                        _Alloc, __detail::_Select1st,
            _Pred, _Hash,
            __detail::_Mod_range_hashing,
            __detail::_Default_ranged_hash,
            __detail::_Prime_rehash_policy, _Tr>;


  template<bool _Cache>
    using __ummap_traits = __detail::_Hashtable_traits<_Cache, false, false>;

  template<typename _Key,
    typename _Tp,
    typename _Hash = hash<_Key>,
    typename _Pred = std::equal_to<_Key>,
    typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >,
    typename _Tr = __ummap_traits<__cache_default<_Key, _Hash>::value>>
    using __ummap_hashtable = _Hashtable<_Key, std::pair<const _Key, _Tp>,
      _Alloc, __detail::_Select1st,
      _Pred, _Hash,
      __detail::_Mod_range_hashing,
      __detail::_Default_ranged_hash,
      __detail::_Prime_rehash_policy, _Tr>;
# 93 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
  template<class _Key, class _Tp,
    class _Hash = hash<_Key>,
    class _Pred = std::equal_to<_Key>,
    class _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class unordered_map : __check_copy_constructible<_Alloc>
    {
      typedef __umap_hashtable<_Key, _Tp, _Hash, _Pred, _Alloc> _Hashtable;
      _Hashtable _M_h;

    public:



      typedef typename _Hashtable::key_type key_type;
      typedef typename _Hashtable::value_type value_type;
      typedef typename _Hashtable::mapped_type mapped_type;
      typedef typename _Hashtable::hasher hasher;
      typedef typename _Hashtable::key_equal key_equal;
      typedef typename _Hashtable::allocator_type allocator_type;




      typedef typename allocator_type::pointer pointer;
      typedef typename allocator_type::const_pointer const_pointer;
      typedef typename allocator_type::reference reference;
      typedef typename allocator_type::const_reference const_reference;
      typedef typename _Hashtable::iterator iterator;
      typedef typename _Hashtable::const_iterator const_iterator;
      typedef typename _Hashtable::local_iterator local_iterator;
      typedef typename _Hashtable::const_local_iterator const_local_iterator;
      typedef typename _Hashtable::size_type size_type;
      typedef typename _Hashtable::difference_type difference_type;
# 137 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      explicit
      unordered_map(size_type __n = 10,
      const hasher& __hf = hasher(),
      const key_equal& __eql = key_equal(),
      const allocator_type& __a = allocator_type())
      : _M_h(__n, __hf, __eql, __a)
      { }
# 158 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      template<typename _InputIterator>
 unordered_map(_InputIterator __f, _InputIterator __l,
        size_type __n = 0,
        const hasher& __hf = hasher(),
        const key_equal& __eql = key_equal(),
        const allocator_type& __a = allocator_type())
 : _M_h(__f, __l, __n, __hf, __eql, __a)
 { }


      unordered_map(const unordered_map&) = default;


      unordered_map(unordered_map&&) = default;
# 184 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      unordered_map(initializer_list<value_type> __l,
      size_type __n = 0,
      const hasher& __hf = hasher(),
      const key_equal& __eql = key_equal(),
      const allocator_type& __a = allocator_type())
 : _M_h(__l, __n, __hf, __eql, __a)
      { }


      unordered_map&
      operator=(const unordered_map&) = default;


      unordered_map&
      operator=(unordered_map&&) = default;
# 211 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      unordered_map&
      operator=(initializer_list<value_type> __l)
      {
 _M_h = __l;
 return *this;
      }



      allocator_type
      get_allocator() const noexcept
      { return _M_h.get_allocator(); }




      bool
      empty() const noexcept
      { return _M_h.empty(); }


      size_type
      size() const noexcept
      { return _M_h.size(); }


      size_type
      max_size() const noexcept
      { return _M_h.max_size(); }







      iterator
      begin() noexcept
      { return _M_h.begin(); }






      const_iterator
      begin() const noexcept
      { return _M_h.begin(); }

      const_iterator
      cbegin() const noexcept
      { return _M_h.begin(); }






      iterator
      end() noexcept
      { return _M_h.end(); }






      const_iterator
      end() const noexcept
      { return _M_h.end(); }

      const_iterator
      cend() const noexcept
      { return _M_h.end(); }
# 308 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      template<typename... _Args>
 std::pair<iterator, bool>
 emplace(_Args&&... __args)
 { return _M_h.emplace(std::forward<_Args>(__args)...); }
# 338 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __pos, _Args&&... __args)
 { return _M_h.emplace_hint(__pos, std::forward<_Args>(__args)...); }
# 361 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      std::pair<iterator, bool>
      insert(const value_type& __x)
      { return _M_h.insert(__x); }

      template<typename _Pair, typename = typename
        std::enable_if<std::is_constructible<value_type,
          _Pair&&>::value>::type>
 std::pair<iterator, bool>
 insert(_Pair&& __x)
        { return _M_h.insert(std::forward<_Pair>(__x)); }
# 395 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      iterator
      insert(const_iterator __hint, const value_type& __x)
      { return _M_h.insert(__hint, __x); }

      template<typename _Pair, typename = typename
        std::enable_if<std::is_constructible<value_type,
          _Pair&&>::value>::type>
 iterator
 insert(const_iterator __hint, _Pair&& __x)
 { return _M_h.insert(__hint, std::forward<_Pair>(__x)); }
# 416 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 { _M_h.insert(__first, __last); }
# 428 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      void
      insert(initializer_list<value_type> __l)
      { _M_h.insert(__l); }
# 446 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      iterator
      erase(const_iterator __position)
      { return _M_h.erase(__position); }


      iterator
      erase(iterator __it)
      { return _M_h.erase(__it); }
# 468 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_h.erase(__x); }
# 486 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_h.erase(__first, __last); }







      void
      clear() noexcept
      { _M_h.clear(); }
# 509 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      void
      swap(unordered_map& __x)
      { _M_h.swap(__x._M_h); }





      hasher
      hash_function() const
      { return _M_h.hash_function(); }



      key_equal
      key_eq() const
      { return _M_h.key_eq(); }
# 541 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      iterator
      find(const key_type& __x)
      { return _M_h.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_h.find(__x); }
# 559 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_h.count(__x); }
# 572 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_h.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_h.equal_range(__x); }
# 594 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      mapped_type&
      operator[](const key_type& __k)
      { return _M_h[__k]; }

      mapped_type&
      operator[](key_type&& __k)
      { return _M_h[std::move(__k)]; }
# 611 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      mapped_type&
      at(const key_type& __k)
      { return _M_h.at(__k); }

      const mapped_type&
      at(const key_type& __k) const
      { return _M_h.at(__k); }





      size_type
      bucket_count() const noexcept
      { return _M_h.bucket_count(); }


      size_type
      max_bucket_count() const noexcept
      { return _M_h.max_bucket_count(); }






      size_type
      bucket_size(size_type __n) const
      { return _M_h.bucket_size(__n); }






      size_type
      bucket(const key_type& __key) const
      { return _M_h.bucket(__key); }







      local_iterator
      begin(size_type __n)
      { return _M_h.begin(__n); }
# 667 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      const_local_iterator
      begin(size_type __n) const
      { return _M_h.begin(__n); }

      const_local_iterator
      cbegin(size_type __n) const
      { return _M_h.cbegin(__n); }
# 682 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      local_iterator
      end(size_type __n)
      { return _M_h.end(__n); }
# 693 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      const_local_iterator
      end(size_type __n) const
      { return _M_h.end(__n); }

      const_local_iterator
      cend(size_type __n) const
      { return _M_h.cend(__n); }





      float
      load_factor() const noexcept
      { return _M_h.load_factor(); }



      float
      max_load_factor() const noexcept
      { return _M_h.max_load_factor(); }





      void
      max_load_factor(float __z)
      { _M_h.max_load_factor(__z); }
# 730 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      void
      rehash(size_type __n)
      { _M_h.rehash(__n); }
# 741 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      void
      reserve(size_type __n)
      { _M_h.reserve(__n); }

      template<typename _Key1, typename _Tp1, typename _Hash1, typename _Pred1,
        typename _Alloc1>
        friend bool
      operator==(const unordered_map<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1>&,
   const unordered_map<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1>&);
    };
# 774 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
  template<class _Key, class _Tp,
    class _Hash = hash<_Key>,
    class _Pred = std::equal_to<_Key>,
    class _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class unordered_multimap : __check_copy_constructible<_Alloc>
    {
      typedef __ummap_hashtable<_Key, _Tp, _Hash, _Pred, _Alloc> _Hashtable;
      _Hashtable _M_h;

    public:



      typedef typename _Hashtable::key_type key_type;
      typedef typename _Hashtable::value_type value_type;
      typedef typename _Hashtable::mapped_type mapped_type;
      typedef typename _Hashtable::hasher hasher;
      typedef typename _Hashtable::key_equal key_equal;
      typedef typename _Hashtable::allocator_type allocator_type;




      typedef typename allocator_type::pointer pointer;
      typedef typename allocator_type::const_pointer const_pointer;
      typedef typename allocator_type::reference reference;
      typedef typename allocator_type::const_reference const_reference;
      typedef typename _Hashtable::iterator iterator;
      typedef typename _Hashtable::const_iterator const_iterator;
      typedef typename _Hashtable::local_iterator local_iterator;
      typedef typename _Hashtable::const_local_iterator const_local_iterator;
      typedef typename _Hashtable::size_type size_type;
      typedef typename _Hashtable::difference_type difference_type;
# 818 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      explicit
      unordered_multimap(size_type __n = 10,
    const hasher& __hf = hasher(),
    const key_equal& __eql = key_equal(),
    const allocator_type& __a = allocator_type())
      : _M_h(__n, __hf, __eql, __a)
      { }
# 839 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      template<typename _InputIterator>
 unordered_multimap(_InputIterator __f, _InputIterator __l,
      size_type __n = 0,
      const hasher& __hf = hasher(),
      const key_equal& __eql = key_equal(),
      const allocator_type& __a = allocator_type())
 : _M_h(__f, __l, __n, __hf, __eql, __a)
 { }


      unordered_multimap(const unordered_multimap&) = default;


      unordered_multimap(unordered_multimap&&) = default;
# 865 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      unordered_multimap(initializer_list<value_type> __l,
    size_type __n = 0,
    const hasher& __hf = hasher(),
    const key_equal& __eql = key_equal(),
    const allocator_type& __a = allocator_type())
 : _M_h(__l, __n, __hf, __eql, __a)
      { }


      unordered_multimap&
      operator=(const unordered_multimap&) = default;


      unordered_multimap&
      operator=(unordered_multimap&&) = default;
# 892 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      unordered_multimap&
      operator=(initializer_list<value_type> __l)
      {
 _M_h = __l;
 return *this;
      }



      allocator_type
      get_allocator() const noexcept
      { return _M_h.get_allocator(); }




      bool
      empty() const noexcept
      { return _M_h.empty(); }


      size_type
      size() const noexcept
      { return _M_h.size(); }


      size_type
      max_size() const noexcept
      { return _M_h.max_size(); }







      iterator
      begin() noexcept
      { return _M_h.begin(); }






      const_iterator
      begin() const noexcept
      { return _M_h.begin(); }

      const_iterator
      cbegin() const noexcept
      { return _M_h.begin(); }






      iterator
      end() noexcept
      { return _M_h.end(); }






      const_iterator
      end() const noexcept
      { return _M_h.end(); }

      const_iterator
      cend() const noexcept
      { return _M_h.end(); }
# 985 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      template<typename... _Args>
 iterator
 emplace(_Args&&... __args)
 { return _M_h.emplace(std::forward<_Args>(__args)...); }
# 1011 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __pos, _Args&&... __args)
 { return _M_h.emplace_hint(__pos, std::forward<_Args>(__args)...); }
# 1026 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      iterator
      insert(const value_type& __x)
      { return _M_h.insert(__x); }

      template<typename _Pair, typename = typename
        std::enable_if<std::is_constructible<value_type,
          _Pair&&>::value>::type>
 iterator
 insert(_Pair&& __x)
        { return _M_h.insert(std::forward<_Pair>(__x)); }
# 1058 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      iterator
      insert(const_iterator __hint, const value_type& __x)
      { return _M_h.insert(__hint, __x); }

      template<typename _Pair, typename = typename
        std::enable_if<std::is_constructible<value_type,
          _Pair&&>::value>::type>
 iterator
 insert(const_iterator __hint, _Pair&& __x)
        { return _M_h.insert(__hint, std::forward<_Pair>(__x)); }
# 1079 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 { _M_h.insert(__first, __last); }
# 1092 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      void
      insert(initializer_list<value_type> __l)
      { _M_h.insert(__l); }
# 1110 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      iterator
      erase(const_iterator __position)
      { return _M_h.erase(__position); }


      iterator
      erase(iterator __it)
      { return _M_h.erase(__it); }
# 1131 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_h.erase(__x); }
# 1150 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_h.erase(__first, __last); }







      void
      clear() noexcept
      { _M_h.clear(); }
# 1174 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      void
      swap(unordered_multimap& __x)
      { _M_h.swap(__x._M_h); }





      hasher
      hash_function() const
      { return _M_h.hash_function(); }



      key_equal
      key_eq() const
      { return _M_h.key_eq(); }
# 1206 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      iterator
      find(const key_type& __x)
      { return _M_h.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_h.find(__x); }







      size_type
      count(const key_type& __x) const
      { return _M_h.count(__x); }
# 1231 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_h.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_h.equal_range(__x); }





      size_type
      bucket_count() const noexcept
      { return _M_h.bucket_count(); }


      size_type
      max_bucket_count() const noexcept
      { return _M_h.max_bucket_count(); }






      size_type
      bucket_size(size_type __n) const
      { return _M_h.bucket_size(__n); }






      size_type
      bucket(const key_type& __key) const
      { return _M_h.bucket(__key); }







      local_iterator
      begin(size_type __n)
      { return _M_h.begin(__n); }
# 1287 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      const_local_iterator
      begin(size_type __n) const
      { return _M_h.begin(__n); }

      const_local_iterator
      cbegin(size_type __n) const
      { return _M_h.cbegin(__n); }
# 1302 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      local_iterator
      end(size_type __n)
      { return _M_h.end(__n); }
# 1313 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      const_local_iterator
      end(size_type __n) const
      { return _M_h.end(__n); }

      const_local_iterator
      cend(size_type __n) const
      { return _M_h.cend(__n); }





      float
      load_factor() const noexcept
      { return _M_h.load_factor(); }



      float
      max_load_factor() const noexcept
      { return _M_h.max_load_factor(); }





      void
      max_load_factor(float __z)
      { _M_h.max_load_factor(__z); }
# 1350 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      void
      rehash(size_type __n)
      { _M_h.rehash(__n); }
# 1361 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_map.h" 3
      void
      reserve(size_type __n)
      { _M_h.reserve(__n); }

      template<typename _Key1, typename _Tp1, typename _Hash1, typename _Pred1,
        typename _Alloc1>
        friend bool
 operator==(const unordered_multimap<_Key1, _Tp1,
         _Hash1, _Pred1, _Alloc1>&,
     const unordered_multimap<_Key1, _Tp1,
         _Hash1, _Pred1, _Alloc1>&);
    };

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline void
    swap(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
  unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    { __x.swap(__y); }

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline void
    swap(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
  unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    { __x.swap(__y); }

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline bool
    operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
        const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    { return __x._M_h._M_equal(__y._M_h); }

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline bool
    operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
        const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    { return !(__x == __y); }

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline bool
    operator==(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
        const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    { return __x._M_h._M_equal(__y._M_h); }

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline bool
    operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
        const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    { return !(__x == __y); }


}
# 49 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/unordered_map" 2 3
# 7 "../ir/std.h" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/unordered_set" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/unordered_set" 3
# 48 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/unordered_set" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 1 3
# 33 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<bool _Cache>
    using __uset_traits = __detail::_Hashtable_traits<_Cache, true, true>;

  template<typename _Value,
    typename _Hash = hash<_Value>,
    typename _Pred = std::equal_to<_Value>,
      typename _Alloc = std::allocator<_Value>,
    typename _Tr = __uset_traits<__cache_default<_Value, _Hash>::value>>
    using __uset_hashtable = _Hashtable<_Value, _Value, _Alloc,
     __detail::_Identity, _Pred, _Hash,
     __detail::_Mod_range_hashing,
     __detail::_Default_ranged_hash,
     __detail::_Prime_rehash_policy, _Tr>;


  template<bool _Cache>
    using __umset_traits = __detail::_Hashtable_traits<_Cache, true, false>;

  template<typename _Value,
    typename _Hash = hash<_Value>,
    typename _Pred = std::equal_to<_Value>,
    typename _Alloc = std::allocator<_Value>,
    typename _Tr = __umset_traits<__cache_default<_Value, _Hash>::value>>
    using __umset_hashtable = _Hashtable<_Value, _Value, _Alloc,
      __detail::_Identity,
      _Pred, _Hash,
      __detail::_Mod_range_hashing,
      __detail::_Default_ranged_hash,
      __detail::_Prime_rehash_policy, _Tr>;
# 89 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
  template<class _Value,
    class _Hash = hash<_Value>,
    class _Pred = std::equal_to<_Value>,
    class _Alloc = std::allocator<_Value> >
    class unordered_set : __check_copy_constructible<_Alloc>
    {
      typedef __uset_hashtable<_Value, _Hash, _Pred, _Alloc> _Hashtable;
      _Hashtable _M_h;

    public:



      typedef typename _Hashtable::key_type key_type;
      typedef typename _Hashtable::value_type value_type;
      typedef typename _Hashtable::hasher hasher;
      typedef typename _Hashtable::key_equal key_equal;
      typedef typename _Hashtable::allocator_type allocator_type;




      typedef typename allocator_type::pointer pointer;
      typedef typename allocator_type::const_pointer const_pointer;
      typedef typename allocator_type::reference reference;
      typedef typename allocator_type::const_reference const_reference;
      typedef typename _Hashtable::iterator iterator;
      typedef typename _Hashtable::const_iterator const_iterator;
      typedef typename _Hashtable::local_iterator local_iterator;
      typedef typename _Hashtable::const_local_iterator const_local_iterator;
      typedef typename _Hashtable::size_type size_type;
      typedef typename _Hashtable::difference_type difference_type;
# 131 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      explicit
      unordered_set(size_type __n = 10,
      const hasher& __hf = hasher(),
      const key_equal& __eql = key_equal(),
      const allocator_type& __a = allocator_type())
      : _M_h(__n, __hf, __eql, __a)
      { }
# 152 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      template<typename _InputIterator>
 unordered_set(_InputIterator __f, _InputIterator __l,
        size_type __n = 0,
        const hasher& __hf = hasher(),
        const key_equal& __eql = key_equal(),
        const allocator_type& __a = allocator_type())
 : _M_h(__f, __l, __n, __hf, __eql, __a)
 { }


      unordered_set(const unordered_set&) = default;


      unordered_set(unordered_set&&) = default;
# 178 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      unordered_set(initializer_list<value_type> __l,
      size_type __n = 0,
      const hasher& __hf = hasher(),
      const key_equal& __eql = key_equal(),
      const allocator_type& __a = allocator_type())
 : _M_h(__l, __n, __hf, __eql, __a)
      { }


      unordered_set&
      operator=(const unordered_set&) = default;


      unordered_set&
      operator=(unordered_set&&) = default;
# 205 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      unordered_set&
      operator=(initializer_list<value_type> __l)
      {
 _M_h = __l;
 return *this;
      }



      allocator_type
      get_allocator() const noexcept
      { return _M_h.get_allocator(); }




      bool
      empty() const noexcept
      { return _M_h.empty(); }


      size_type
      size() const noexcept
      { return _M_h.size(); }


      size_type
      max_size() const noexcept
      { return _M_h.max_size(); }
# 242 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      iterator
      begin() noexcept
      { return _M_h.begin(); }

      const_iterator
      begin() const noexcept
      { return _M_h.begin(); }







      iterator
      end() noexcept
      { return _M_h.end(); }

      const_iterator
      end() const noexcept
      { return _M_h.end(); }






      const_iterator
      cbegin() const noexcept
      { return _M_h.begin(); }





      const_iterator
      cend() const noexcept
      { return _M_h.end(); }
# 298 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      template<typename... _Args>
 std::pair<iterator, bool>
 emplace(_Args&&... __args)
 { return _M_h.emplace(std::forward<_Args>(__args)...); }
# 324 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __pos, _Args&&... __args)
 { return _M_h.emplace_hint(__pos, std::forward<_Args>(__args)...); }
# 343 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      std::pair<iterator, bool>
      insert(const value_type& __x)
      { return _M_h.insert(__x); }

      std::pair<iterator, bool>
      insert(value_type&& __x)
      { return _M_h.insert(std::move(__x)); }
# 372 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      iterator
      insert(const_iterator __hint, const value_type& __x)
      { return _M_h.insert(__hint, __x); }

      iterator
      insert(const_iterator __hint, value_type&& __x)
      { return _M_h.insert(__hint, std::move(__x)); }
# 390 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 { _M_h.insert(__first, __last); }
# 402 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      void
      insert(initializer_list<value_type> __l)
      { _M_h.insert(__l); }
# 420 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      iterator
      erase(const_iterator __position)
      { return _M_h.erase(__position); }


      iterator
      erase(iterator __it)
      { return _M_h.erase(__it); }
# 442 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_h.erase(__x); }
# 460 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_h.erase(__first, __last); }







      void
      clear() noexcept
      { _M_h.clear(); }
# 483 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      void
      swap(unordered_set& __x)
      { _M_h.swap(__x._M_h); }





      hasher
      hash_function() const
      { return _M_h.hash_function(); }



      key_equal
      key_eq() const
      { return _M_h.key_eq(); }
# 515 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      iterator
      find(const key_type& __x)
      { return _M_h.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_h.find(__x); }
# 533 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_h.count(__x); }
# 546 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_h.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_h.equal_range(__x); }





      size_type
      bucket_count() const noexcept
      { return _M_h.bucket_count(); }


      size_type
      max_bucket_count() const noexcept
      { return _M_h.max_bucket_count(); }






      size_type
      bucket_size(size_type __n) const
      { return _M_h.bucket_size(__n); }






      size_type
      bucket(const key_type& __key) const
      { return _M_h.bucket(__key); }
# 592 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      local_iterator
      begin(size_type __n)
      { return _M_h.begin(__n); }

      const_local_iterator
      begin(size_type __n) const
      { return _M_h.begin(__n); }

      const_local_iterator
      cbegin(size_type __n) const
      { return _M_h.cbegin(__n); }
# 612 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      local_iterator
      end(size_type __n)
      { return _M_h.end(__n); }

      const_local_iterator
      end(size_type __n) const
      { return _M_h.end(__n); }

      const_local_iterator
      cend(size_type __n) const
      { return _M_h.cend(__n); }





      float
      load_factor() const noexcept
      { return _M_h.load_factor(); }



      float
      max_load_factor() const noexcept
      { return _M_h.max_load_factor(); }





      void
      max_load_factor(float __z)
      { _M_h.max_load_factor(__z); }
# 653 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      void
      rehash(size_type __n)
      { _M_h.rehash(__n); }
# 664 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      void
      reserve(size_type __n)
      { _M_h.reserve(__n); }

      template<typename _Value1, typename _Hash1, typename _Pred1,
        typename _Alloc1>
        friend bool
      operator==(const unordered_set<_Value1, _Hash1, _Pred1, _Alloc1>&,
   const unordered_set<_Value1, _Hash1, _Pred1, _Alloc1>&);
    };
# 694 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
  template<class _Value,
    class _Hash = hash<_Value>,
    class _Pred = std::equal_to<_Value>,
    class _Alloc = std::allocator<_Value> >
    class unordered_multiset : __check_copy_constructible<_Alloc>
    {
      typedef __umset_hashtable<_Value, _Hash, _Pred, _Alloc> _Hashtable;
      _Hashtable _M_h;

    public:



      typedef typename _Hashtable::key_type key_type;
      typedef typename _Hashtable::value_type value_type;
      typedef typename _Hashtable::hasher hasher;
      typedef typename _Hashtable::key_equal key_equal;
      typedef typename _Hashtable::allocator_type allocator_type;




      typedef typename allocator_type::pointer pointer;
      typedef typename allocator_type::const_pointer const_pointer;
      typedef typename allocator_type::reference reference;
      typedef typename allocator_type::const_reference const_reference;
      typedef typename _Hashtable::iterator iterator;
      typedef typename _Hashtable::const_iterator const_iterator;
      typedef typename _Hashtable::local_iterator local_iterator;
      typedef typename _Hashtable::const_local_iterator const_local_iterator;
      typedef typename _Hashtable::size_type size_type;
      typedef typename _Hashtable::difference_type difference_type;
# 736 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      explicit
      unordered_multiset(size_type __n = 10,
    const hasher& __hf = hasher(),
    const key_equal& __eql = key_equal(),
    const allocator_type& __a = allocator_type())
      : _M_h(__n, __hf, __eql, __a)
      { }
# 757 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      template<typename _InputIterator>
 unordered_multiset(_InputIterator __f, _InputIterator __l,
      size_type __n = 0,
      const hasher& __hf = hasher(),
      const key_equal& __eql = key_equal(),
      const allocator_type& __a = allocator_type())
 : _M_h(__f, __l, __n, __hf, __eql, __a)
 { }


      unordered_multiset(const unordered_multiset&) = default;


      unordered_multiset(unordered_multiset&&) = default;
# 783 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      unordered_multiset(initializer_list<value_type> __l,
    size_type __n = 0,
    const hasher& __hf = hasher(),
    const key_equal& __eql = key_equal(),
    const allocator_type& __a = allocator_type())
 : _M_h(__l, __n, __hf, __eql, __a)
      { }


      unordered_multiset&
      operator=(const unordered_multiset&) = default;


      unordered_multiset&
      operator=(unordered_multiset&& __x) = default;
# 810 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      unordered_multiset&
      operator=(initializer_list<value_type> __l)
      {
 _M_h = __l;
 return *this;
      }



      allocator_type
      get_allocator() const noexcept
      { return _M_h.get_allocator(); }




      bool
      empty() const noexcept
      { return _M_h.empty(); }


      size_type
      size() const noexcept
      { return _M_h.size(); }


      size_type
      max_size() const noexcept
      { return _M_h.max_size(); }
# 847 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      iterator
      begin() noexcept
      { return _M_h.begin(); }

      const_iterator
      begin() const noexcept
      { return _M_h.begin(); }







      iterator
      end() noexcept
      { return _M_h.end(); }

      const_iterator
      end() const noexcept
      { return _M_h.end(); }






      const_iterator
      cbegin() const noexcept
      { return _M_h.begin(); }





      const_iterator
      cend() const noexcept
      { return _M_h.end(); }
# 895 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      template<typename... _Args>
 iterator
 emplace(_Args&&... __args)
 { return _M_h.emplace(std::forward<_Args>(__args)...); }
# 917 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __pos, _Args&&... __args)
 { return _M_h.emplace_hint(__pos, std::forward<_Args>(__args)...); }
# 930 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      iterator
      insert(const value_type& __x)
      { return _M_h.insert(__x); }

      iterator
      insert(value_type&& __x)
      { return _M_h.insert(std::move(__x)); }
# 956 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      iterator
      insert(const_iterator __hint, const value_type& __x)
      { return _M_h.insert(__hint, __x); }

      iterator
      insert(const_iterator __hint, value_type&& __x)
      { return _M_h.insert(__hint, std::move(__x)); }
# 973 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 { _M_h.insert(__first, __last); }
# 985 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      void
      insert(initializer_list<value_type> __l)
      { _M_h.insert(__l); }
# 1004 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      iterator
      erase(const_iterator __position)
      { return _M_h.erase(__position); }


      iterator
      erase(iterator __it)
      { return _M_h.erase(__it); }
# 1027 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_h.erase(__x); }
# 1047 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_h.erase(__first, __last); }
# 1058 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      void
      clear() noexcept
      { _M_h.clear(); }
# 1071 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      void
      swap(unordered_multiset& __x)
      { _M_h.swap(__x._M_h); }





      hasher
      hash_function() const
      { return _M_h.hash_function(); }



      key_equal
      key_eq() const
      { return _M_h.key_eq(); }
# 1103 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      iterator
      find(const key_type& __x)
      { return _M_h.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_h.find(__x); }







      size_type
      count(const key_type& __x) const
      { return _M_h.count(__x); }
# 1128 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_h.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_h.equal_range(__x); }





      size_type
      bucket_count() const noexcept
      { return _M_h.bucket_count(); }


      size_type
      max_bucket_count() const noexcept
      { return _M_h.max_bucket_count(); }






      size_type
      bucket_size(size_type __n) const
      { return _M_h.bucket_size(__n); }






      size_type
      bucket(const key_type& __key) const
      { return _M_h.bucket(__key); }
# 1174 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      local_iterator
      begin(size_type __n)
      { return _M_h.begin(__n); }

      const_local_iterator
      begin(size_type __n) const
      { return _M_h.begin(__n); }

      const_local_iterator
      cbegin(size_type __n) const
      { return _M_h.cbegin(__n); }
# 1194 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      local_iterator
      end(size_type __n)
      { return _M_h.end(__n); }

      const_local_iterator
      end(size_type __n) const
      { return _M_h.end(__n); }

      const_local_iterator
      cend(size_type __n) const
      { return _M_h.cend(__n); }





      float
      load_factor() const noexcept
      { return _M_h.load_factor(); }



      float
      max_load_factor() const noexcept
      { return _M_h.max_load_factor(); }





      void
      max_load_factor(float __z)
      { _M_h.max_load_factor(__z); }
# 1235 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      void
      rehash(size_type __n)
      { _M_h.rehash(__n); }
# 1246 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/bits/unordered_set.h" 3
      void
      reserve(size_type __n)
      { _M_h.reserve(__n); }

      template<typename _Value1, typename _Hash1, typename _Pred1,
        typename _Alloc1>
        friend bool
      operator==(const unordered_multiset<_Value1, _Hash1, _Pred1, _Alloc1>&,
   const unordered_multiset<_Value1, _Hash1, _Pred1, _Alloc1>&);
    };

  template<class _Value, class _Hash, class _Pred, class _Alloc>
    inline void
    swap(unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,
  unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)
    { __x.swap(__y); }

  template<class _Value, class _Hash, class _Pred, class _Alloc>
    inline void
    swap(unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,
  unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)
    { __x.swap(__y); }

  template<class _Value, class _Hash, class _Pred, class _Alloc>
    inline bool
    operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,
        const unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)
    { return __x._M_h._M_equal(__y._M_h); }

  template<class _Value, class _Hash, class _Pred, class _Alloc>
    inline bool
    operator!=(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,
        const unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)
    { return !(__x == __y); }

  template<class _Value, class _Hash, class _Pred, class _Alloc>
    inline bool
    operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,
        const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)
    { return __x._M_h._M_equal(__y._M_h); }

  template<class _Value, class _Hash, class _Pred, class _Alloc>
    inline bool
    operator!=(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,
        const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)
    { return !(__x == __y); }


}
# 49 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/unordered_set" 2 3
# 8 "../ir/std.h" 2


using std::const_pointer_cast;
using std::map;
using std::set;
using std::unordered_map;
using std::unordered_set;



template<class T, class _Alloc = std::allocator<T>>
class vector : public std::vector<T, _Alloc> {
public:
    using std::vector<T, _Alloc>::vector;
    typedef typename std::vector<T, _Alloc>::reference reference;
    typedef typename std::vector<T, _Alloc>::const_reference const_reference;
    typedef typename std::vector<T, _Alloc>::size_type size_type;
    typedef typename std::vector<T>::const_iterator const_iterator;
    reference operator[](size_type n) { return this->at(n); }
    const_reference operator[](size_type n) const { return this->at(n); }
};

template<class T, size_t N>
class array : public std::array<T, N> {
public:
    using std::array<T, N>::array;
    typedef typename std::array<T, N>::reference reference;
    typedef typename std::array<T, N>::const_reference const_reference;
    typedef typename std::array<T, N>::size_type size_type;
    reference operator[](size_type n) { return this->at(n); }
    const_reference operator[](size_type n) const { return this->at(n); }
};
# 6 "../ir/node.h" 2


# 1 "../lib/indent.h" 1




# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/iomanip" 1 3
# 37 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/iomanip" 3
# 46 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/iomanip" 3
namespace std __attribute__ ((__visibility__ ("default")))
{





  struct _Resetiosflags { ios_base::fmtflags _M_mask; };
# 62 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/iomanip" 3
  inline _Resetiosflags
  resetiosflags(ios_base::fmtflags __mask)
  { return { __mask }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Resetiosflags __f)
    {
      __is.setf(ios_base::fmtflags(0), __f._M_mask);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Resetiosflags __f)
    {
      __os.setf(ios_base::fmtflags(0), __f._M_mask);
      return __os;
    }


  struct _Setiosflags { ios_base::fmtflags _M_mask; };
# 92 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/iomanip" 3
  inline _Setiosflags
  setiosflags(ios_base::fmtflags __mask)
  { return { __mask }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setiosflags __f)
    {
      __is.setf(__f._M_mask);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setiosflags __f)
    {
      __os.setf(__f._M_mask);
      return __os;
    }


  struct _Setbase { int _M_base; };
# 123 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/iomanip" 3
  inline _Setbase
  setbase(int __base)
  { return { __base }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setbase __f)
    {
      __is.setf(__f._M_base == 8 ? ios_base::oct :
  __f._M_base == 10 ? ios_base::dec :
  __f._M_base == 16 ? ios_base::hex :
  ios_base::fmtflags(0), ios_base::basefield);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setbase __f)
    {
      __os.setf(__f._M_base == 8 ? ios_base::oct :
  __f._M_base == 10 ? ios_base::dec :
  __f._M_base == 16 ? ios_base::hex :
  ios_base::fmtflags(0), ios_base::basefield);
      return __os;
    }


  template<typename _CharT>
    struct _Setfill { _CharT _M_c; };
# 160 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/iomanip" 3
  template<typename _CharT>
    inline _Setfill<_CharT>
    setfill(_CharT __c)
    { return { __c }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setfill<_CharT> __f)
    {
      __is.fill(__f._M_c);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setfill<_CharT> __f)
    {
      __os.fill(__f._M_c);
      return __os;
    }


  struct _Setprecision { int _M_n; };
# 191 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/iomanip" 3
  inline _Setprecision
  setprecision(int __n)
  { return { __n }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setprecision __f)
    {
      __is.precision(__f._M_n);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setprecision __f)
    {
      __os.precision(__f._M_n);
      return __os;
    }


  struct _Setw { int _M_n; };
# 221 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/iomanip" 3
  inline _Setw
  setw(int __n)
  { return { __n }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setw __f)
    {
      __is.width(__f._M_n);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setw __f)
    {
      __os.width(__f._M_n);
      return __os;
    }



  template<typename _MoneyT>
    struct _Get_money { _MoneyT& _M_mon; bool _M_intl; };
# 254 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/iomanip" 3
  template<typename _MoneyT>
    inline _Get_money<_MoneyT>
    get_money(_MoneyT& __mon, bool __intl = false)
    { return { __mon, __intl }; }

  template<typename _CharT, typename _Traits, typename _MoneyT>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Get_money<_MoneyT> __f)
    {
      typename basic_istream<_CharT, _Traits>::sentry __cerb(__is, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       typedef istreambuf_iterator<_CharT, _Traits> _Iter;
       typedef money_get<_CharT, _Iter> _MoneyGet;

       const _MoneyGet& __mg = use_facet<_MoneyGet>(__is.getloc());
       __mg.get(_Iter(__is.rdbuf()), _Iter(), __f._M_intl,
         __is, __err, __f._M_mon);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __is._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __is._M_setstate(ios_base::badbit); }
   if (__err)
     __is.setstate(__err);
 }
      return __is;
    }


  template<typename _MoneyT>
    struct _Put_money { const _MoneyT& _M_mon; bool _M_intl; };
# 301 "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/iomanip" 3
  template<typename _MoneyT>
    inline _Put_money<_MoneyT>
    put_money(const _MoneyT& __mon, bool __intl = false)
    { return { __mon, __intl }; }

  template<typename _CharT, typename _Traits, typename _MoneyT>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Put_money<_MoneyT> __f)
    {
      typename basic_ostream<_CharT, _Traits>::sentry __cerb(__os);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       typedef ostreambuf_iterator<_CharT, _Traits> _Iter;
       typedef money_put<_CharT, _Iter> _MoneyPut;

       const _MoneyPut& __mp = use_facet<_MoneyPut>(__os.getloc());
       if (__mp.put(_Iter(__os.rdbuf()), __f._M_intl, __os,
      __os.fill(), __f._M_mon).failed())
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __os._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __os._M_setstate(ios_base::badbit); }
   if (__err)
     __os.setstate(__err);
 }
      return __os;
    }







  extern template ostream& operator<<(ostream&, _Setfill<char>);
  extern template ostream& operator<<(ostream&, _Setiosflags);
  extern template ostream& operator<<(ostream&, _Resetiosflags);
  extern template ostream& operator<<(ostream&, _Setbase);
  extern template ostream& operator<<(ostream&, _Setprecision);
  extern template ostream& operator<<(ostream&, _Setw);
  extern template istream& operator>>(istream&, _Setfill<char>);
  extern template istream& operator>>(istream&, _Setiosflags);
  extern template istream& operator>>(istream&, _Resetiosflags);
  extern template istream& operator>>(istream&, _Setbase);
  extern template istream& operator>>(istream&, _Setprecision);
  extern template istream& operator>>(istream&, _Setw);


  extern template wostream& operator<<(wostream&, _Setfill<wchar_t>);
  extern template wostream& operator<<(wostream&, _Setiosflags);
  extern template wostream& operator<<(wostream&, _Resetiosflags);
  extern template wostream& operator<<(wostream&, _Setbase);
  extern template wostream& operator<<(wostream&, _Setprecision);
  extern template wostream& operator<<(wostream&, _Setw);
  extern template wistream& operator>>(wistream&, _Setfill<wchar_t>);
  extern template wistream& operator>>(wistream&, _Setiosflags);
  extern template wistream& operator>>(wistream&, _Resetiosflags);
  extern template wistream& operator>>(wistream&, _Setbase);
  extern template wistream& operator>>(wistream&, _Setprecision);
  extern template wistream& operator>>(wistream&, _Setw);




}
# 6 "../lib/indent.h" 2

class indent_t {
    int indent;
 public:
    static int tabsz;
    indent_t() : indent(0) {}
    explicit indent_t(int i) : indent(i) {}
    indent_t &operator++() { ++indent; return *this; }
    indent_t &operator--() { --indent; return *this; }
    indent_t operator++(int) { indent_t rv = *this; ++indent; return rv; }
    indent_t operator--(int) { indent_t rv = *this; --indent; return rv; }
    friend std::ostream &operator<<(std::ostream &os, indent_t i);
    indent_t operator+(int v) { indent_t rv = *this; rv.indent += v; return rv; }
    indent_t operator-(int v) { indent_t rv = *this; rv.indent -= v; return rv; }
    indent_t &operator+=(int v) { indent += v; return *this; }
    indent_t &operator-=(int v) { indent -= v; return *this; }
    static indent_t &getindent(std::ostream &);
};

inline std::ostream &operator<<(std::ostream &os, indent_t i) {
    os << std::setw(i.indent * i.tabsz) << "";
    return os;
}

namespace IndentCtl {
inline std::ostream &endl(std::ostream &out) {
    return out << std::endl << indent_t::getindent(out); }
inline std::ostream &indent(std::ostream &out) { ++indent_t::getindent(out); return out; }
inline std::ostream &unindent(std::ostream &out) { --indent_t::getindent(out); return out; }
}
# 9 "../ir/node.h" 2

# 1 "../ir/ir-tree-macros.h" 1
# 12 "../ir/ir-tree-macros.h"
# 1 "./ir/gen-tree-macro.h" 1
# 13 "../ir/ir-tree-macros.h" 2
# 11 "../ir/node.h" 2


class Visitor;
class Inspector;
class Modifier;
class Transform;

namespace IR {

class Node;


class INode : public Util::IHasSourceInfo, public Util::IHasDbPrint {
 public:
    virtual ~INode() {}
    virtual const Node* getNode() const = 0;
    virtual Node* getNode() = 0;
    virtual void dbprint(std::ostream &out) const = 0;
    virtual cstring toString() const = 0;
    virtual cstring node_type_name() const = 0;
    virtual void validate() const {}
    template<typename T> bool is() const;
    template<typename T> const T* to() const;
};

class Node : public virtual INode {
 public:
    virtual bool apply_visitor_preorder(Modifier &v);
    virtual void apply_visitor_postorder(Modifier &v);
    virtual bool apply_visitor_preorder(Inspector &v) const;
    virtual void apply_visitor_postorder(Inspector &v) const;
    virtual const Node *apply_visitor_preorder(Transform &v);
    virtual const Node *apply_visitor_postorder(Transform &v);

 protected:
    static int currentId;
    void traceVisit(const char* visitor) const;
    virtual void visit_children(Visitor &) { }
    virtual void visit_children(Visitor &) const { }
    friend class ::Visitor;
    friend class ::Inspector;
    friend class ::Modifier;
    friend class ::Transform;

 public:
    Util::SourceInfo srcInfo;
    int id;
    void traceCreation() const;
    Node() : id(currentId++) { traceCreation(); }
    explicit Node(Util::SourceInfo si) : srcInfo(si), id(currentId++)
    { traceCreation(); }
    Node(const Node& other) : srcInfo(other.srcInfo), id(currentId++)
    { traceCreation(); }
    virtual ~Node() {}
    const Node *apply(Visitor &v) const;
    const Node *apply(Visitor &&v) const { return apply(v); }
    virtual Node *clone() const = 0;
    virtual void dbprint(std::ostream &out) const;
    virtual void dump_fields(std::ostream &) const { }
    virtual const Node* getNode() const { return this; }
    virtual Node* getNode() { return this; }
    Util::SourceInfo getSourceInfo() const override { return srcInfo; }
    cstring node_type_name() const override { return "Node"; }
    static cstring static_type_name() { return "Node"; }
    virtual int num_children() { return 0; }
    template<typename T> bool is() const { return to<T>() != nullptr; }
    template<typename T> const T* to() const {
        do { if ((this) == nullptr) do { throw Util::CompilerBug("../ir/node.h", 78, "../ir/node.h" ":" "78" ": Null " "this"); } while (0); } while (0);
        return dynamic_cast<const T*>(this); }
    virtual cstring toString() const { return node_type_name(); }
    virtual bool operator==(const Node &n) const = 0;
    bool operator!=(const Node &n) const { return !operator==(n); }
};

template<typename T> bool INode::is() const { return getNode()->is<T>(); }
template<typename T> const T* INode::to() const { return getNode()->to<T>(); }
# 123 "../ir/node.h"
}
# 22 "../ir/ir.h" 2
# 1 "../ir/vector.h" 1



# 1 "../ir/dbprint.h" 1



# 1 "/usr/include/assert.h" 1 3 4
# 5 "../ir/dbprint.h" 2



namespace DBPrint {



enum dbprint_flags {
    Precedence = 0xf,
    Prec_Postfix = 15,
    Prec_Prefix = 14,
    Prec_Mul = 13, Prec_Div = 13, Prec_Mod = 13,
    Prec_Add = 12, Prec_Sub = 12,
    Prec_Shl = 11, Prec_Shr = 11,
    Prec_Lss = 10, Prec_Leq = 10, Prec_Grt = 10, Prec_Geq = 10,
    Prec_Equ = 9, Prec_Neq = 9,
    Prec_BAnd = 8,
    Prec_BXor = 7,
    Prec_BOr = 6,
    Prec_LAnd = 5,
    Prec_LOr = 4,
    Prec_Cond = 3,
    Prec_Low = 1,

    TableNoActions = 0x10,
};

int dbgetflags(std::ostream &out);
int dbsetflags(std::ostream &out, int val, int mask);

inline int getprec(std::ostream &out) { return dbgetflags(out) & DBPrint::Precedence; }
class setflags_helper {
    int val, mask;
    setflags_helper() = delete;
 protected:
    setflags_helper(int v, int m) : val(v), mask(m) { (((val & ~mask) == 0) ? static_cast<void> (0) : __assert_fail ("(val & ~mask) == 0", "../ir/dbprint.h", 40, __PRETTY_FUNCTION__)); }
 public:
    void set(std::ostream &out) const { dbsetflags(out, val, mask); }
};
struct setprec : public setflags_helper {
    explicit setprec(int prec) : setflags_helper(prec, DBPrint::Precedence) {}
};
struct setflag : public setflags_helper {
    explicit setflag(int fl) : setflags_helper(fl, fl) {}
};
struct clrflag : public setflags_helper {
    explicit clrflag(int fl) : setflags_helper(0, ~fl) {}
};


}

inline std::ostream &operator<<(std::ostream &out, const DBPrint::setflags_helper &p) {
    p.set(out); return out; }
# 5 "../ir/vector.h" 2
# 1 "../lib/enumerator.h" 1
# 13 "../lib/enumerator.h"
# 1 "../lib/default.h" 1





namespace Util {


template<typename T>
auto Default() ->
        typename std::enable_if<std::is_pointer<T>::value, T>::type
{ return nullptr; }

template<typename T>
auto Default() ->
        typename std::enable_if<std::is_class<T>::value, T>::type
{ return T(); }

template<typename T>
auto Default() ->
        typename std::enable_if<std::is_arithmetic<T>::value, T>::type
{ return static_cast<T>(0); }

}
# 14 "../lib/enumerator.h" 2

namespace Util {
enum class EnumeratorState {
    NotStarted,
    Valid,
    PastEnd
};

template <typename T> class Enumerator;




template<typename T>
class EnumeratorHandle {
 private:
    Enumerator<T>* enumerator;
    explicit EnumeratorHandle(Enumerator<T>* enumerator) :
            enumerator(enumerator) {}
    friend class Enumerator<T>;

 public:
    T operator* () const;
    const EnumeratorHandle<T>& operator++();
    bool operator != (const EnumeratorHandle<T>& other) const;
};

template <class T>
class Enumerator {
 protected:
    EnumeratorState state = EnumeratorState::NotStarted;


    template <class S> friend class Enumerator;
    static std::vector<T> emptyVector;
    template <typename S> friend class EnumeratorHandle;

 public:
    Enumerator();
    virtual ~Enumerator() {}



    virtual bool moveNext() = 0;

    virtual T getCurrent() const = 0;

    virtual void reset();

    EnumeratorHandle<T> begin() { this->moveNext(); return EnumeratorHandle<T>(this); }
    EnumeratorHandle<T> end() { return EnumeratorHandle<T>(nullptr); }

    cstring stateName() const {
        switch (this->state) {
            case EnumeratorState::NotStarted:
                return "NotStarted";
            case EnumeratorState::Valid:
                return "Valid";
            case EnumeratorState::PastEnd:
                return "PastEnd";
        }
        throw std::logic_error(cstring("Unexpected state ") +
                               std::to_string(static_cast<int>(this->state)));
    }


    static Enumerator<T>* createEnumerator(const std::vector<T> &data);
    static Enumerator<T>* createEnumerator(const std::list<T> &data);
    static Enumerator<T>* emptyEnumerator();
    template <typename Iter>
    static Enumerator<typename Iter::value_type>* createEnumerator(Iter begin, Iter end);

    static Enumerator<T>* concatAll(Enumerator<Enumerator<T>*>* inputs);

    std::vector<T>* toVector();

    Enumerator<T>* where(std::function<bool(const T&)> filter);

    template <typename S>
    Enumerator<S>* map(std::function<S(const T&)> map);

    template<typename S>
    Enumerator<S>* as();

    Enumerator<T>* concat(Enumerator<T>* other);

    uint64_t count();

    bool any();

    T single();

    T nextOrDefault();

    T next();
};
# 120 "../lib/enumerator.h"
template <typename Iter>
class GenericEnumerator : public Enumerator<typename Iter::value_type> {
 protected:
    Iter begin;
    Iter end;
    Iter current;
    cstring name;
    friend class Enumerator<typename Iter::value_type>;

    GenericEnumerator(Iter begin, Iter end, cstring name)
            : Enumerator<typename Iter::value_type>(),
            begin(begin), end(end), current(begin), name(name) {}

 public:
    cstring toString() const {
        return this->name + ":" + this->stateName();
    }

    bool moveNext() {
        switch (this->state) {
            case EnumeratorState::NotStarted:
                this->current = this->begin;
                if (this->current == this->end) {
                    this->state = EnumeratorState::PastEnd;
                    return false;
                } else {
                    this->state = EnumeratorState::Valid;
                }
                return true;
            case EnumeratorState::PastEnd:
                return false;
            case EnumeratorState::Valid:
                ++this->current;
                if (this->current == this->end) {
                    this->state = EnumeratorState::PastEnd;
                    return false;
                }
                return true;
        }

        throw new std::runtime_error("Unexpected enumerator state");
    }

    typename Iter::value_type getCurrent() const {
        switch (this->state) {
            case EnumeratorState::NotStarted:
                throw std::logic_error("You cannot call 'getCurrent' before 'moveNext'");
            case EnumeratorState::PastEnd:
                throw std::logic_error("You cannot call 'getCurrent' past the collection end");
            case EnumeratorState::Valid:
                return *this->current;
        }
        throw new std::runtime_error("Unexpected enumerator state");
    }
};




template <typename T>
class FilterEnumerator final : public Enumerator<T> {
 protected:
    Enumerator<T>* input;
    std::function<bool(const T&)> filter;
    T current;

 public:
    FilterEnumerator(Enumerator<T> *input, std::function<bool(const T&)> filter) :
            input(input), filter(filter) {}

 private:
    bool advance() {
        this->state = EnumeratorState::Valid;
        while (this->input->moveNext()) {
            this->current = this->input->getCurrent();
            bool match = this->filter(this->current);
            if (match)
                return true;
        }
        this->state = EnumeratorState::PastEnd;
        return false;
    }

 public:
    cstring toString() const {
        return cstring("FilterEnumerator(") + this->input->toString() + "):" + this->stateName();
    }

    void reset() {
        this->input->reset();
        Enumerator<T>::reset();
    }

    bool moveNext() {
        switch (this->state) {
            case EnumeratorState::NotStarted:
            case EnumeratorState::Valid:
                return this->advance();
            case EnumeratorState::PastEnd:
                return false;
        }
        throw new std::runtime_error("Unexpected enumerator state");
    }

    T getCurrent() const {
        switch (this->state) {
            case EnumeratorState::NotStarted:
                throw std::logic_error("You cannot call 'getCurrent' before 'moveNext'");
            case EnumeratorState::PastEnd:
                throw std::logic_error("You cannot call 'getCurrent' past the collection end");
            case EnumeratorState::Valid:
                return this->current;
        }
        throw new std::runtime_error("Unexpected enumerator state");
    }
};




template <typename T, typename S>
class AsEnumerator final : public Enumerator<S> {
 protected:
    Enumerator<T>* input;

 public:
    explicit AsEnumerator(Enumerator<T> *input) :
            input(input) {}

    cstring toString() const {
        return cstring("AsEnumerator(") + this->input->toString() + "):" + this->stateName();
    }

    void reset() {
        Enumerator<S>::reset();
        this->input->reset();
    }

    bool moveNext() {
        bool result = this->input->moveNext();
        if (result)
            this->state = EnumeratorState::Valid;
        else
            this->state = EnumeratorState::PastEnd;
        return result;
    }

    S getCurrent() const {
        return dynamic_cast<S>(input->getCurrent());
    }
};





template <typename T, typename S>
class MapEnumerator final : public Enumerator<S> {
 protected:
    Enumerator<T>* input;
    std::function<S(const T&)> map;
    S current;

 public:
    MapEnumerator(Enumerator<T>* input, std::function<S(const T&)> map) :
            input(input), map(map) {}

    void reset() {
        this->input->reset();
        Enumerator<S>::reset();
    }

    cstring toString() const {
        return cstring("MapEnumerator(") + this->input->toString() + "):" + this->stateName();
    }

    bool moveNext() {
        switch (this->state) {
            case EnumeratorState::NotStarted:
            case EnumeratorState::Valid: {
                bool success = input->moveNext();
                if (success) {
                    T currentInput = this->input->getCurrent();
                    this->current = this->map(currentInput);
                    this->state = EnumeratorState::Valid;
                    return true;
                } else {
                    this->state = EnumeratorState::PastEnd;
                    return false;
                }
            }
            case EnumeratorState::PastEnd:
                return false;
        }
        throw new std::runtime_error("Unexpected enumerator state");
    }

    S getCurrent() const {
        switch (this->state) {
            case EnumeratorState::NotStarted:
                throw std::logic_error("You cannot call 'getCurrent' before 'moveNext'");
            case EnumeratorState::PastEnd:
                throw std::logic_error("You cannot call 'getCurrent' past the collection end");
            case EnumeratorState::Valid:
                return this->current;
        }
        throw new std::runtime_error("Unexpected enumerator state");
    }
};




template <typename T>
class ConcatEnumerator final : public Enumerator<T> {
 protected:
    Enumerator<Enumerator<T>*>* inputs;
    T currentResult;

 public:
    explicit ConcatEnumerator(Enumerator<Enumerator<T>*>* inputs) :
            inputs(inputs) {}

 private:
    cstring toString() const {
        return "ConcatEnumerator:" + this->stateName();
    }

    bool advance() {
        if (this->state == EnumeratorState::NotStarted) {
            bool start = this->inputs->moveNext();
            if (!start)
                goto theend;
        }

        this->state = EnumeratorState::Valid;
        bool more;
        do {
            Enumerator<T>* currentInput = this->inputs->getCurrent();
            if (currentInput == nullptr)
                throw std::logic_error("Null iterator in concatenation");
            bool moreCurrent = currentInput->moveNext();
            if (moreCurrent) {
                this->currentResult = currentInput->getCurrent();
                return true;
            }

            more = this->inputs->moveNext();
        } while (more);

  theend:
        this->state = EnumeratorState::PastEnd;
        return false;
    }

 public:
    void reset() {
        this->inputs->reset();
        while (this->inputs->moveNext())
            this->inputs->getCurrent()->reset();
        this->inputs->reset();
        Enumerator<T>::reset();
    }

    bool moveNext() {
        switch (this->state) {
            case EnumeratorState::NotStarted:
            case EnumeratorState::Valid:
                return this->advance();
            case EnumeratorState::PastEnd:
                return false;
        }
        throw new std::runtime_error("Unexpected enumerator state");
    }

    T getCurrent() const {
        switch (this->state) {
            case EnumeratorState::NotStarted:
                throw std::logic_error("You cannot call 'getCurrent' before 'moveNext'");
            case EnumeratorState::PastEnd:
                throw std::logic_error("You cannot call 'getCurrent' past the collection end");
            case EnumeratorState::Valid:
                return this->currentResult;
        }
        throw new std::runtime_error("Unexpected enumerator state");
    }
};



template <typename T>
Enumerator<T>::Enumerator() {
    this->reset();
}

template <typename T>
void Enumerator<T>::reset() {
    this->state = EnumeratorState::NotStarted;
}

template <typename T>
template <typename S>
Enumerator<S>* Enumerator<T>::map(std::function<S(const T&)> map) {
    return new MapEnumerator<T, S>(this, map);
}

template <typename T>
template <typename S>
Enumerator<S>* Enumerator<T>::as() {
    return new AsEnumerator<T, S>(this);
}

template <typename T>
Enumerator<T>* Enumerator<T>::where(std::function<bool(const T&)> filter) {
    return new FilterEnumerator<T>(this, filter);
}

template <typename T>
uint64_t Enumerator<T>::count() {
    uint64_t found = 0;
    while (this->moveNext())
        found++;
    return found;
}

template <typename T>
bool Enumerator<T>::any() {
    return this->moveNext();
}

template <typename T>
std::vector<T> Enumerator<T>::emptyVector;

template <typename T>
Enumerator<T>* Enumerator<T>::createEnumerator(const std::vector<T> &data) {
    return new GenericEnumerator<typename std::vector<T>::const_iterator>(
        data.begin(), data.end(), "vector");
}

template <typename T>
Enumerator<T>* Enumerator<T>::emptyEnumerator() {
    return Enumerator<T>::createEnumerator(Enumerator<T>::emptyVector);
}

template <typename T>
Enumerator<T>* Enumerator<T>::createEnumerator(const std::list<T> &data) {
    return new GenericEnumerator<typename std::list<T>::const_iterator>(
        data.begin(), data.end(), "list");
}

template <typename T>
template <typename Iter>
Enumerator<typename Iter::value_type>* Enumerator<T>::createEnumerator(Iter begin, Iter end) {
    return new GenericEnumerator<Iter>(begin, end, "iterator");
}

template <typename T>
std::vector<T>* Enumerator<T>::toVector() {
    auto result = new std::vector<T>();
    while (moveNext())
        result->push_back(getCurrent());
    return result;
}

template <typename T>
Enumerator<T>* Enumerator<T>::concatAll(Enumerator<Enumerator<T>*>* inputs) {
    return new ConcatEnumerator<T>(inputs);
}

template <typename T>
Enumerator<T>* Enumerator<T>::concat(Enumerator<T>* other) {
    std::vector<Enumerator<T>*>* toConcat = new std::vector<Enumerator<T>*>();
    toConcat->push_back(this);
    toConcat->push_back(other);
    Enumerator<Enumerator<T>*>* ce = Enumerator<Enumerator<T>*>::createEnumerator(*toConcat);
    return Enumerator<T>::concatAll(ce);
}

template <typename T>
T Enumerator<T>::next() {
    bool next = moveNext();
    if (!next)
        throw std::logic_error("There is no element for `next()'");
    return getCurrent();
}

template <typename T>
T Enumerator<T>::single() {
    bool next = moveNext();
    if (!next)
        throw std::logic_error("There is no element for `single()'");
    T result = getCurrent();
    next = moveNext();
    if (next)
        throw std::logic_error("There are multiple elements when calling `single()'");
    return result;
}

template <typename T>
T Enumerator<T>::nextOrDefault() {
    bool next = moveNext();
    if (!next)
        return Util::Default<T>();
    return getCurrent();
}



template <typename T>
T EnumeratorHandle<T>::operator* () const {
    if (enumerator == nullptr)
        throw std::logic_error("Dereferencing end() iterator");
    return enumerator->getCurrent();
}

template <typename T>
const EnumeratorHandle<T>& EnumeratorHandle<T>::operator++() {
    enumerator->moveNext();
    return *this;
}

template <typename T>
bool EnumeratorHandle<T>::operator != (const EnumeratorHandle<T>& other) const {
    if (this->enumerator == other.enumerator) return true;
    if (other.enumerator != nullptr)
        throw std::logic_error("Comparison with different iterator");
    return this->enumerator->state == EnumeratorState::Valid;
}

}
# 6 "../ir/vector.h" 2


namespace IR {






class VectorBase : public Node {
 public:
    typedef const Node * const *iterator;
    virtual iterator VectorBase_begin() const = 0;
    virtual iterator VectorBase_end() const = 0;
    virtual size_t size() const = 0;
    virtual bool empty() const = 0;
    iterator begin() const { return VectorBase_begin(); }
    iterator end() const { return VectorBase_end(); }
};

template<class T>
class Vector : public VectorBase {
    vector<const T *> vec;

 public:
    Vector() = default;
    Vector(const Vector &) = default;
    Vector(Vector &&) = default;
    Vector &operator=(const Vector &) = default;
    Vector &operator=(Vector &&) = default;
    explicit Vector(const T *a) {
        vec.emplace_back(std::move(a)); }
    explicit Vector(const vector<const T *> &a) {
        vec.insert(vec.end(), a.begin(), a.end()); }

    typedef typename vector<const T *>::iterator iterator;
    typedef typename vector<const T *>::const_iterator const_iterator;
    iterator begin() { return vec.begin(); }
    const_iterator begin() const { return vec.begin(); }
    VectorBase::iterator VectorBase_begin() const {

        return reinterpret_cast<VectorBase::iterator>(&vec[0]); }
    iterator end() { return vec.end(); }
    const_iterator end() const { return vec.end(); }
    VectorBase::iterator VectorBase_end() const {

        return reinterpret_cast<VectorBase::iterator>(&vec[0] + vec.size()); }
    std::reverse_iterator<iterator> rbegin() { return vec.rbegin(); }
    std::reverse_iterator<const_iterator> rbegin() const { return vec.rbegin(); }
    std::reverse_iterator<iterator> rend() { return vec.rend(); }
    std::reverse_iterator<const_iterator> rend() const { return vec.rend(); }
    size_t size() const { return vec.size(); }
    bool empty() const { return vec.empty(); }
    const T* const & front() const { return vec.front(); }
    const T*& front() { return vec.front(); }
    void clear() { vec.clear(); }
    iterator erase(iterator i) { return vec.erase(i); }
    template<typename ForwardIter>
    iterator insert(iterator i, ForwardIter b, ForwardIter e) {


        int index = i - vec.begin();
        vec.insert(i, b, e);
        return vec.begin() + index; }
    iterator append(const Vector<T>& toAppend)
    { return insert(end(), toAppend.begin(), toAppend.end()); }
    iterator insert(iterator i, const T* v) {


        int index = i - vec.begin();
        vec.insert(i, v);
        return vec.begin() + index; }
    iterator insert(iterator i, size_t n, const T* v) {


        int index = i - vec.begin();
        vec.insert(i, n, v);
        return vec.begin() + index; }

    const T *const &operator[](size_t idx) const { return vec[idx]; }
    const T *&operator[](size_t idx) { return vec[idx]; }
    const T *const &at(size_t idx) const { return vec.at(idx); }
    const T *&at(size_t idx) { return vec.at(idx); }
    template <class... Args> void emplace_back(Args&&... args) {
        vec.emplace_back(new T(std::forward<Args>(args)...)); }
    void push_back(T *a) { vec.push_back(a); }
    void push_back(const T *a) { vec.push_back(a); }
    void pop_back() { vec.pop_back(); }
    const T* const & back() const { return vec.back(); }
    const T*& back() { return vec.back(); }
    template<class U> void push_back(U &a) { vec.push_back(a); }
    void check_null() const { for (auto e : vec) do { if ((e) == nullptr) do { throw Util::CompilerBug("../ir/vector.h", 97, "../ir/vector.h" ":" "97" ": Null " "e"); } while (0); } while (0); }

    public: Vector *clone() const override { return new Vector(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    const Vector *apply(Visitor &v) const; const Vector *apply(Visitor &&v) const { return apply(v); }
    bool operator==(const Vector &a) const { return vec == a.vec; }
    cstring node_type_name() const override {
        return "Vector<" + T::static_type_name() + ">"; }
    static cstring static_type_name() {
        return "Vector<" + T::static_type_name() + ">"; }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    Util::Enumerator<const T*>* getEnumerator() const {
        return Util::Enumerator<const T*>::createEnumerator(vec); }
    template <typename S>
    Util::Enumerator<const S*>* only() const {
        std::function<bool(const T*)> filter = [](const T* d) { return d->template is<S>(); };
        return getEnumerator()->where(filter)->template as<const S*>(); }
};

}

template<class T, class U> const T *get(const IR::Vector<T> &vec, U name) {
    for (auto el : vec)
        if (el->name == name)
            return el;
    return nullptr; }
template<class T, class U> const T *get(const IR::Vector<T> *vec, U name) {
    if (vec)
        for (auto el : *vec)
            if (el->name == name)
                return el;
    return nullptr; }
# 23 "../ir/ir.h" 2
# 1 "../ir/indexed_vector.h" 1








# 1 "../ir/id.h" 1








namespace IR {


struct ID : Util::IHasSourceInfo {
    Util::SourceInfo srcInfo;
    cstring name = nullptr;
    ID() = default;
    ID(Util::SourceInfo si, cstring n) : srcInfo(si), name(n) {
        if (n.isNullOrEmpty()) do { throw Util::CompilerBug("../ir/id.h", 17, "Identifier with no name"); } while (0); }
    ID(const char *n) : ID(Util::SourceInfo(), n) {}
    ID(cstring n) : ID(Util::SourceInfo(), n) {}
    void dbprint(std::ostream &out) const { out << name; }
    bool operator==(const ID &a) const { return name == a.name; }
    bool operator!=(const ID &a) const { return name != a.name; }
    explicit operator bool() const { return name; }
    operator cstring() const { return name; }
    bool isDontCare() const { return name == "_"; }
    Util::SourceInfo getSourceInfo() const override { return srcInfo; }
    cstring toString() const override { return name; }
};

}
# 10 "../ir/indexed_vector.h" 2

namespace IR {


class IDeclaration : public virtual INode {
 public:

    virtual ID getName() const = 0;

    virtual cstring externalName() const;
    virtual ~IDeclaration() {}
};



template<class T>
class IndexedVector : public Vector<T> {
    ordered_map<cstring, const IDeclaration*> declarations;

    void insertInMap(const T* a) {
        if (!a->template is<IDeclaration>())
            return;
        auto decl = a->template to<IDeclaration>();
        auto name = decl->getName().name;
        auto previous = declarations.find(name);
        if (previous != declarations.end())
            ::error("%1%: Duplicates declaration %2%", a, previous->second);
        else
            declarations[name] = decl;
    }
    void removeFromMap(const T* a) {
        auto decl = a->template to<IDeclaration>();
        if (decl == nullptr)
            return;
        cstring name = decl->getName().name;
        auto it = declarations.find(name);
        if (it == declarations.end())
            do { throw Util::CompilerBug("../ir/indexed_vector.h", 47, "%1% does not exist", a); } while (0);
        declarations.erase(it);
    }
 public:
    using Vector<T>::begin;
    using Vector<T>::end;

    IndexedVector() = default;
    IndexedVector(const IndexedVector &) = default;
    IndexedVector(IndexedVector &&) = default;
    IndexedVector &operator=(const IndexedVector &) = default;
    IndexedVector &operator=(IndexedVector &&) = default;
    explicit IndexedVector(const T *a) {
        push_back(std::move(a)); }
    explicit IndexedVector(const vector<const T *> &a) {
        insert(typename Vector<T>::end(), a.begin(), a.end()); }
    explicit IndexedVector(const Vector<T> &a) {
        insert(typename Vector<T>::end(), a.begin(), a.end()); }

    void clear() { typename Vector<T>::clear(); declarations.clear(); }
    typedef typename Vector<T>::iterator iterator;

    const IDeclaration* getDeclaration(cstring name) const {
        auto it = declarations.find(name);
        if (it == declarations.end())
            return nullptr;
        return it->second;
    }
    Util::Enumerator<const IDeclaration*>* getDeclarations() const
    { return Util::Enumerator<const IDeclaration*>::createEnumerator(
        Values(declarations).begin(), Values(declarations).end()); }
    iterator erase(iterator i) {
        removeFromMap(*i);
        return Vector<T>::erase(i); }
    template<typename ForwardIter>
    iterator insert(iterator i, ForwardIter b, ForwardIter e) {
        for (auto it = b; it != e; ++it)
            insertInMap(*it);
        return Vector<T>::insert(i, b, e);
    }
    iterator append(const Vector<T>& toAppend)
    { return insert(Vector<T>::end(), toAppend.begin(), toAppend.end()); }
    iterator insert(iterator i, const T* v) {
        insertInMap(v);
        return typename Vector<T>::insert(i, v);
    }
    template <class... Args> void emplace_back(Args&&... args) {
        auto el = new T(std::forward<Args>(args)...);
        insert(el); }
    void push_back(T *a) { Vector<T>::push_back(a); insertInMap(a); }
    void push_back(const T *a) { Vector<T>::push_back(a); insertInMap(a); }
    void pop_back() {
        if (typename Vector<T>::empty())
            do { throw Util::CompilerBug("../ir/indexed_vector.h", 100, "pop_back from empty IndexedVector"); } while (0);
        auto last = typename Vector<T>::back();
        removeFromMap(last);
        typename Vector<T>::pop_back();
    }
    template<class U> void push_back(U &a) { Vector<T>::push_back(a); insertInMap(a); }

    public: IndexedVector *clone() const override { return new IndexedVector(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    const IndexedVector *apply(Visitor &v) const; const IndexedVector *apply(Visitor &&v) const { return apply(v); }
    bool operator==(const IndexedVector &a) const
    { return Vector<T>::operator==(*dynamic_cast<Vector<T>>(this), *dynamic_cast<Vector<T>>(&a)); }
    cstring node_type_name() const override {
        return "IndexedVector<" + T::static_type_name() + ">"; }
    static cstring static_type_name() {
        return "IndexedVector<" + T::static_type_name() + ">"; }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
};

}
# 24 "../ir/ir.h" 2

# 1 "../ir/namemap.h" 1



namespace IR {

template<class T, template<class K, class V, class COMP, class ALLOC> class MAP = std::map,
         class COMP = std::less<cstring>,
         class ALLOC = std::allocator<std::pair<const cstring, const T*>>>
class NameMap : public Node {
    typedef MAP<cstring, const T *, COMP, ALLOC> map_t;
    map_t symbols;

    template<class U> auto match_name(cstring name, const U *obj) -> decltype(name == obj->name) {
        return name == obj->name; }
    bool match_name(cstring, const void *) { return true; }
    template<class U> auto obj_name(const U *obj) -> decltype(obj->name) { return obj->name; }
    cstring obj_name(const void *) { return cstring(0); }

 public:
    typedef typename map_t::value_type value_type;
    typedef typename map_t::iterator iterator;
    typedef typename map_t::const_iterator const_iterator;
    typedef typename map_t::reverse_iterator reverse_iterator;
    typedef typename map_t::const_reverse_iterator const_reverse_iterator;

 private:
    struct elem_ref {
        NameMap &self;
        cstring name;
        elem_ref(NameMap &s, cstring n) : self(s), name(n) {}
        const T *operator=(const T *v) const {
            if (!self.match_name(name, v))
                do { throw Util::CompilerBug("../ir/namemap.h", 33, "Inserting into NameMap with incorrect name"); } while (0);
            return self.symbols[name] = v; }
        operator const T *() const { return self.symbols.at(name); }
    };

 public:
    const_iterator begin() const { return symbols.begin(); }
    const_iterator end() const { return symbols.end(); }
    iterator begin() { return symbols.begin(); }
    iterator end() { return symbols.end(); }
    const_reverse_iterator rbegin() const { return symbols.rbegin(); }
    const_reverse_iterator rend() const { return symbols.rend(); }
    reverse_iterator rbegin() { return symbols.rbegin(); }
    reverse_iterator rend() { return symbols.rend(); }
    size_t count(cstring name) const { return symbols.count(name); }
    size_t size() const { return symbols.size(); }
    bool empty() const { return symbols.empty(); }
    size_t erase(cstring n) { return symbols.erase(n); }

    iterator erase(iterator p) { return symbols.erase(p); }
    iterator erase(iterator f, iterator l) { return symbols.erase(f, l); }
    const_iterator find(cstring name) const { return symbols.find(name); }
    template<class U> const U *get(cstring name) const {
        for (auto it = symbols.find(name); it != symbols.end() && it->first == name; it++)
            if (auto rv = dynamic_cast<const U *>(it->second))
                return rv;
        return nullptr; }
    void add(cstring name, const T *n) {
        if (!match_name(name, n))
            do { throw Util::CompilerBug("../ir/namemap.h", 62, "Inserting into NameMap with incorrect name"); } while (0);
        symbols.emplace(std::move(name), std::move(n)); }


    void addUnique(cstring name, const T *n) {
        auto prev = symbols.find(name);
        if (prev != symbols.end())
            ::error("%1%: duplicated name (%2% is previous instance)", n, prev->second);
        symbols.emplace(std::move(name), std::move(n)); }


    const T *getUnique(cstring name) const {
        auto it = symbols.find(name);
        if (it == symbols.end())
            return nullptr;
        return it->second;
    }
    elem_ref operator[](cstring name) { return elem_ref(*this, name); }
    const T *operator[](cstring name) const { return symbols.at(name); }
    const T *&at(cstring name) { return symbols.at(name); }
    const T *const &at(cstring name) const { return symbols.at(name); }
    void check_null() const { for (auto &e : symbols) do { if ((e.second) == nullptr) do { throw Util::CompilerBug("../ir/namemap.h", 83, "../ir/namemap.h" ":" "83" ": Null " "e.second"); } while (0); } while (0); }

    public: NameMap *clone() const override { return new NameMap(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    bool operator==(const NameMap &a) const { return symbols == a.symbols; }
    cstring node_type_name() const override {
        return "NameMap<" + T::static_type_name() + ">"; }
    static cstring static_type_name() {
        return "NameMap<" + T::static_type_name() + ">"; }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;

    Util::Enumerator<const T*>* valueEnumerator() const {
        return Util::Enumerator<const T*>::createEnumerator(Values(symbols).begin(),
                                                            Values(symbols).end()); }
    template <typename S>
    Util::Enumerator<const S*>* only() const {
        std::function<bool(const T*)> filter = [](const T* d) { return d->template is<S>(); };
        return valueEnumerator()->where(filter)->template as<const S*>(); }
};

}
# 26 "../ir/ir.h" 2
# 1 "../ir/nodemap.h" 1



namespace IR {

template<class KEY, class VALUE,
         template<class K, class V, class COMP, class ALLOC> class MAP = std::map,
         class COMP = std::less<cstring>,
         class ALLOC = std::allocator<std::pair<const KEY * const, const VALUE *>>>
class NodeMap : public Node {
    typedef MAP<const KEY *, const VALUE *, COMP, ALLOC> map_t;
    map_t symbols;
 public:
    typedef typename map_t::value_type value_type;
    typedef typename map_t::iterator iterator;
    typedef typename map_t::const_iterator const_iterator;
    typedef typename map_t::reverse_iterator reverse_iterator;
    typedef typename map_t::const_reverse_iterator const_reverse_iterator;

 private:
    struct elem_ref {
        NodeMap &self;
        const KEY *key;
        elem_ref(NodeMap &s, const KEY *k) : self(s), key(k) {}
        const VALUE *operator=(const VALUE *v) const {
            return self.symbols[key] = v; }
        operator const VALUE *() const { return self.symbols.at(key); }
    };

 public:
    const_iterator begin() const { return symbols.begin(); }
    const_iterator end() const { return symbols.end(); }
    iterator begin() { return symbols.begin(); }
    iterator end() { return symbols.end(); }
    const_reverse_iterator rbegin() const { return symbols.rbegin(); }
    const_reverse_iterator rend() const { return symbols.rend(); }
    reverse_iterator rbegin() { return symbols.rbegin(); }
    reverse_iterator rend() { return symbols.rend(); }
    size_t count(cstring name) const { return symbols.count(name); }
    size_t size() const { return symbols.size(); }
    bool empty() const { return symbols.empty(); }
    size_t erase(const KEY *k) { return symbols.erase(k); }
    iterator erase(const_iterator p) { return symbols.erase(p); }
    iterator erase(const_iterator f, const_iterator l) { return symbols.erase(f, l); }
    const_iterator find(const KEY *k) const { return symbols.find(k); }
    template<class U> const U *get(const KEY *k) const {
        for (auto it = symbols.find(k); it != symbols.end() && it->first == k; it++)
            if (auto rv = dynamic_cast<const U *>(it->second))
                return rv;
        return nullptr; }
    elem_ref operator[](const KEY *k) { return elem_ref(*this, k); }
    const VALUE *operator[](const KEY *k) const { return symbols.at(k); }
    const VALUE *&at(const KEY *k) { return symbols.at(k); }
    const VALUE *const &at(const KEY *k) const { return symbols.at(k); }
    public: NodeMap *clone() const override { return new NodeMap(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    bool operator==(const NodeMap &a) const { return symbols == a.symbols; }
    cstring node_type_name() const override {
        return "NodeMap<" + KEY::static_type_name() + "," + VALUE::static_type_name() + ">"; }
    static cstring static_type_name() {
        return "NodeMap<" + KEY::static_type_name() + "," + VALUE::static_type_name() + ">"; }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
};

}
# 27 "../ir/ir.h" 2



# 1 "./ir/ir-generated.h" 1



namespace IR {
class CompileTimeValue;
class Type;
class IMayBeGenericType;
class IApply;
class INamespace;
class ISimpleNamespace;
class IGeneralNamespace;
class ITypeVar;
class IContainer;
class Type_Base;
class Type_Unknown;
class StatOrDecl;
class Declaration;
class Type_Declaration;
class Expression;
class Operation;
class PathPrefix;
class Path;
class Annotation;
class Annotations;
class IAnnotated;
class Type_Boolean;
class Type_State;
class Type_Bits;
class Type_Varbits;
class Parameter;
class ParameterList;
class Type_Var;
class Type_InfInt;
class Type_Dontcare;
class Type_Void;
class Type_Error;
class Type_MatchKind;
class TypeParameters;
class StructField;
class Type_StructLike;
class Type_Struct;
class Type_Union;
class Type_Header;
class Type_Set;
class Type_Tuple;
class Type_ArchBlock;
class Type_Package;
class Type_Parser;
class Type_Control;
class Type_Name;
class Type_Stack;
class Type_Specialized;
class Type_SpecializedCanonical;
class Declaration_ID;
class Type_Enum;
class Type_Table;
class Type_ActionEnum;
class Type_MethodBase;
class Type_Method;
class ArgumentInfo;
class Type_MethodCall;
class Type_Action;
class Method;
class Type_Typedef;
class Type_Extern;
class Operation_Unary;
class Neg;
class Cmpl;
class LNot;
class Operation_Binary;
class Operation_Ternary;
class Operation_Relation;
class Mul;
class Div;
class Mod;
class Add;
class Sub;
class Shl;
class Shr;
class Equ;
class Neq;
class Lss;
class Leq;
class Grt;
class Geq;
class BAnd;
class BOr;
class BXor;
class LAnd;
class LOr;
class Constant;
class BoolLiteral;
class StringLiteral;
class PathExpression;
class TypeNameExpression;
class Slice;
class Member;
class Concat;
class ArrayIndex;
class Range;
class Mask;
class Mux;
class DefaultExpression;
class This;
class Cast;
class SelectExpression;
class MethodCallExpression;
class ConstructorCallExpression;
class ListExpression;
class SelectCase;
class ParserState;
class P4Parser;
class P4Control;
class P4Action;
class Declaration_Errors;
class Declaration_MatchKind;
class PropertyValue;
class ExpressionValue;
class ActionListElement;
class ActionList;
class KeyElement;
class Key;
class TableProperty;
class TableProperties;
class P4Table;
class Declaration_Variable;
class Declaration_Constant;
class Declaration_Instance;
class P4Program;
class Statement;
class ExitStatement;
class ReturnStatement;
class EmptyStatement;
class AssignmentStatement;
class IfStatement;
class BlockStatement;
class MethodCallStatement;
class SwitchCase;
class SwitchStatement;
class Function;
class Block;
class TableBlock;
class InstantiatedBlock;
class ParserBlock;
class ControlBlock;
class PackageBlock;
class ExternBlock;
class ToplevelBlock;
class HeaderOrMetadata;
class Header;
class HeaderStack;
class Metadata;
class HeaderRef;
class ConcreteHeaderRef;
class HeaderStackItemRef;
class NamedRef;
class If;
class NamedCond;
class Apply;
class Primitive;
class FieldList;
class FieldListCalculation;
class CalculatedField;
class CaseEntry;
class V1Parser;
class ParserException;
class Attached;
class Stateful;
class CounterOrMeter;
class Counter;
class Meter;
class Register;
class PrimitiveAction;
class NameList;
class ActionArg;
class ActionFunction;
class ActionProfile;
class ActionSelector;
class V1Table;
class V1Control;
class V1Program;
class v1HeaderType;
class IntMod;
namespace Tofino {
class Pipe;
}
class InstanceRef;
class HeaderSliceRef;
namespace MAU {
class Table;
}
namespace MAU {
class TernaryIndirect;
}
namespace MAU {
class ActionData;
}
namespace MAU {
class TableSeq;
}
namespace MAU {
class Instruction;
}
namespace Tofino {
class ParserMatch;
}
namespace Tofino {
class ParserState;
}
namespace Tofino {
class Parser;
}
namespace Tofino {
class Deparser;
}
}
namespace IR {
class CompileTimeValue : public virtual INode {
 public:
};
}
namespace IR {
class Type : public Node {
 public:
# 13 "../ir/base.def"
 typedef Type_Unknown Unknown;
    typedef Type_Boolean Boolean;
    typedef Type_Bits Bits;
    typedef Type_Varbits Varbits;
    virtual int width_bits() const { return 0; }
# 232 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Type&a) const {
        return typeid(*this) == typeid(a);
    }
    cstring node_type_name() const override { return "Type"; }
    static cstring static_type_name() { return "Type"; }
    public: Type *clone() const override = 0; public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
 protected:
    Type(Util::SourceInfo srcInfo) :
        Node(srcInfo)
    { validate(); }
 public:
};
}
namespace IR {
class IMayBeGenericType : public virtual INode {
 public:
# 25 "../ir/base.def"
 virtual const TypeParameters* getTypeParameters() const = 0;
    const Type* toType() const { return getNode()->to<Type>(); }
    const Type* specialize(const Vector<Type>* arguments) const;
# 253 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
};
}
namespace IR {
class IApply : public virtual INode {
 public:
# 34 "../ir/base.def"
 static const cstring applyMethodName;
    virtual const Type_Method* getApplyMethodType() const = 0;
# 262 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
};
}
namespace IR {
class INamespace : public virtual INode {
 public:
# 41 "../ir/base.def"
 virtual Util::Enumerator<const IDeclaration*>* getDeclarations() const = 0;
# 270 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
};
}
namespace IR {
class ISimpleNamespace : public virtual INode, public virtual INamespace {
 public:
# 48 "../ir/base.def"
 virtual const IDeclaration* getDeclByName(cstring name) const = 0;
# 278 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
};
}
namespace IR {
class IGeneralNamespace : public virtual INode, public virtual INamespace {
 public:
# 54 "../ir/base.def"
 virtual Util::Enumerator<const IDeclaration*>* getDeclsByName(cstring name) const;
    void checkDuplicateDeclarations() const;
# 287 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 57 "../ir/base.def"
 void validate() const override { checkDuplicateDeclarations(); }
# 290 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
};
}
namespace IR {
class ITypeVar : public virtual INode {
 public:
# 63 "../ir/base.def"
 virtual cstring getVarName() const = 0;
    const Type* asType() const { return to<Type>(); }
# 299 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
};
}
namespace IR {
class IContainer : public virtual INode, public virtual IMayBeGenericType {
 public:
# 70 "../ir/base.def"

    virtual const Type_Method* getConstructorMethodType() const = 0;
    virtual const ParameterList* getConstructorParameters() const = 0;
# 309 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
};
}
namespace IR {
class Type_Base : public Type {
 public:
    bool operator==(const Type_Base&a) const {
        return Type::operator==(a);
    }
    cstring node_type_name() const override { return "Type_Base"; }
    static cstring static_type_name() { return "Type_Base"; }
    public: Type_Base *clone() const override = 0; public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
 protected:
    Type_Base(Util::SourceInfo srcInfo) :
        Type(srcInfo)
    { validate(); }
 public:
};
}
namespace IR {
class Type_Unknown : public Type_Base {
 public:
# 84 "../ir/base.def"
 static const Type::Unknown *get();
# 333 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 86 "../ir/base.def"
 cstring toString() const override { return "Unknown type"; }
# 336 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Type_Unknown&a) const {
        return Type_Base::operator==(a);
    }
    cstring node_type_name() const override { return "Type_Unknown"; }
    static cstring static_type_name() { return "Type_Unknown"; }
    public: Type_Unknown *clone() const override { return new Type_Unknown(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Type_Unknown(Util::SourceInfo srcInfo) :
        Type_Base(srcInfo)
    { validate(); }
};
}
namespace IR {
class StatOrDecl : public Node {
 public:
    bool operator==(const StatOrDecl&a) const {
        return typeid(*this) == typeid(a);
    }
    cstring node_type_name() const override { return "StatOrDecl"; }
    static cstring static_type_name() { return "StatOrDecl"; }
    public: StatOrDecl *clone() const override = 0; public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
 protected:
    StatOrDecl(Util::SourceInfo srcInfo) :
        Node(srcInfo)
    { validate(); }
 public:
};
}
namespace IR {
class Declaration : public StatOrDecl, public virtual IDeclaration {
 public:
    ID name;
# 97 "../ir/base.def"
 ID getName() const { return name; }
 private:
    static int nextId;
 public:
    int declid;
    Declaration(Util::SourceInfo si, ID name) : StatOrDecl(si), name(name), declid(nextId++) {}
# 375 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 104 "../ir/base.def"
 void dbprint(std::ostream &out) const override { Node::dbprint(out); out << name << "/" << declid; }
# 378 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 105 "../ir/base.def"
 cstring toString() const override { return externalName(); }
# 381 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 106 "../ir/base.def"
 bool operator==(const Declaration&a) const { return StatOrDecl::operator==(a) && name == a.name && declid == a.declid; }
# 384 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 cstring node_type_name() const override { return "Declaration"; }
    static cstring static_type_name() { return "Declaration"; }
    void dump_fields(std::ostream& out) const override;
    public: Declaration *clone() const override = 0; public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
};
}
namespace IR {
class Type_Declaration : public Type, public virtual IDeclaration {
 public:
    ID name;
# 114 "../ir/base.def"
 ID getName() const { return name; }
 private:
    static int nextId;
 public:
    int declid;
    Type_Declaration(Util::SourceInfo si, ID name) : Type(si), name(name), declid(nextId++) {}
# 402 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 121 "../ir/base.def"
 cstring toString() const override { return externalName(); }
# 405 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 122 "../ir/base.def"
 bool operator==(const Type_Declaration&a) const { return Type::operator==(a) && name == a.name && declid == a.declid; }
# 408 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 123 "../ir/base.def"
 void dbprint(std::ostream &out) const override { Node::dbprint(out); out << name << "/" << declid; }
# 411 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 cstring node_type_name() const override { return "Type_Declaration"; }
    static cstring static_type_name() { return "Type_Declaration"; }
    void dump_fields(std::ostream& out) const override;
    public: Type_Declaration *clone() const override = 0; public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
};
}
namespace IR {
class Expression : public Node {
 public:
# 128 "../ir/base.def"






    const Type* type = Type::Unknown::get();
    Expression() : type(Type::Unknown::get()) {}
    explicit Expression(const Type *t) : type(t) {}
    Expression(Util::SourceInfo srcInfo, const Type *t) : Node(srcInfo), type(t) {}
# 432 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 139 "../ir/base.def"
 bool operator==(const Expression&a) const { return typeid(*this) == typeid(a) && type == a.type; }
# 435 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 cstring node_type_name() const override { return "Expression"; }
    static cstring static_type_name() { return "Expression"; }
    public: Expression *clone() const override = 0; public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
 protected:
    Expression(Util::SourceInfo srcInfo) :
        Node(srcInfo)
    { validate(); }
 public:
};
}
namespace IR {
class Operation : public Expression {
 public:
# 144 "../ir/base.def"
 virtual int getPrecedence() const = 0;
    virtual cstring getStringOp() const = 0;
    Operation(Util::SourceInfo si, const Type *t) : Expression(si, t) {}
    explicit Operation(const Type *t) : Expression(t) {}
    Operation() : Expression() {}
    typedef Operation_Unary Unary;
    typedef Operation_Binary Binary;
    typedef Operation_Relation Relation;
# 458 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 153 "../ir/base.def"
 cstring toString() const override { return getStringOp(); }
# 461 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Operation&a) const {
        return Expression::operator==(a);
    }
    cstring node_type_name() const override { return "Operation"; }
    static cstring static_type_name() { return "Operation"; }
    public: Operation *clone() const override = 0; public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
 protected:
    Operation(Util::SourceInfo srcInfo) :
        Expression(srcInfo)
    { validate(); }
 public:
};
}
namespace IR {
class PathPrefix : public Node {
 public:
    bool absolute;
    std::vector<ID> components;
# 161 "../ir/base.def"
 PathPrefix() : absolute(false) {}
    PathPrefix(Util::SourceInfo si, PathPrefix* start, ID end)
            : Node(si), absolute(start->absolute) {
        do { if ((start) == nullptr) do { throw Util::CompilerBug("../ir/base.def", 164, "../ir/base.def" ":" "164" ": Null " "start"); } while (0); } while (0);
        std::copy(start->components.begin(), start->components.end(), components.begin());
        components.push_back(end);
    }
    void setAbsolute() { absolute = true; }
# 489 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 170 "../ir/base.def"
 cstring toString() const override {
        std::stringstream result;
        bool first = true;
        if (absolute)
            result << ".";
        for (auto a : components) {
            if (!first)
                result << ".";
            first = false;
            result << a.name.c_str();
        }
        return cstring(result.str());
    }
# 504 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const PathPrefix&a) const {
        return typeid(*this) == typeid(a)
        && absolute == a.absolute
        && components == a.components;
    }
    cstring node_type_name() const override { return "PathPrefix"; }
    static cstring static_type_name() { return "PathPrefix"; }
    void dump_fields(std::ostream& out) const override;
    public: PathPrefix *clone() const override { return new PathPrefix(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
};
}
namespace IR {
class Path : public Node {
 public:
    const PathPrefix* prefix = nullptr;
    ID name;
# 191 "../ir/base.def"
 Path(const PathPrefix* prefix, ID name) :
    Node(prefix != nullptr ? prefix->srcInfo + name.srcInfo : name.srcInfo),
            prefix(prefix),
            name(name) {}
    explicit Path(ID name) :
            Node(name.srcInfo),
            prefix(nullptr),
            name(name) {}
    bool isDontCare() const { return prefix == nullptr && name.isDontCare(); }
# 531 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 201 "../ir/base.def"
 cstring toString() const override {
        std::stringstream str;
        if (prefix == nullptr) {
            str << name;
        } else {
            cstring ps = prefix->toString();
            str << ps << "." << name;
        }
        return cstring(str.str());
    }
# 543 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 211 "../ir/base.def"
 void dbprint(std::ostream &out) const override { Node::dbprint(out); out << ":" << toString(); }
# 546 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Path&a) const {
        return typeid(*this) == typeid(a)
        && prefix == a.prefix
        && name == a.name;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    cstring node_type_name() const override { return "Path"; }
    static cstring static_type_name() { return "Path"; }
    void dump_fields(std::ostream& out) const override;
    public: Path *clone() const override { return new Path(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
};
}
namespace IR {
class Annotation : public Node {
 public:
    ID name;
    const Expression* expr = nullptr;
# 218 "../ir/base.def"
 Annotation(cstring n, const Expression *e) : name(n), expr(e) {}
    Annotation(cstring n, intmax_t v);

    static const cstring nameAnnotation;
# 570 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 226 "../ir/base.def"
 cstring toString() const override { return cstring("@") + name; }
# 573 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 228 "../ir/base.def"
 void validate() const override { do { if (!(!name.name.isNullOrEmpty())) do { throw Util::CompilerBug("../ir/base.def", 228, "empty annotation name"); } while (0); } while (0); }
# 576 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Annotation&a) const {
        return typeid(*this) == typeid(a)
        && name == a.name
        && expr == a.expr;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    cstring node_type_name() const override { return "Annotation"; }
    static cstring static_type_name() { return "Annotation"; }
    void dump_fields(std::ostream& out) const override;
    public: Annotation *clone() const override { return new Annotation(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Annotation(Util::SourceInfo srcInfo,
        ID name,
        const Expression* expr) :
        Node(srcInfo),
        name(name),
        expr(expr)
    { validate(); }
};
}
namespace IR {
class Annotations : public Node {
 public:
    const Vector<Annotation>* annotations = nullptr;
# 236 "../ir/base.def"
 Annotations(const Vector<Annotation>* annotations) :
            Node(annotations->srcInfo), annotations(annotations) {}
    static Annotations *empty;
    size_t size() const { return annotations->size(); }


    const Annotation* getSingle(cstring name) const
    { return get(annotations, name); }
    Annotations* addAnnotation(cstring name, const Expression* expr) const {
        auto vec = new Vector<Annotation>(*annotations);
        vec->push_back(new Annotation(name, expr));
        return new Annotations(vec);
    }


    const Annotations* addAnnotationIfNew(cstring name, const Expression* expr) const {
        if (getSingle(name) != nullptr)
            return this;
        return addAnnotation(name, expr);
    }


    const Annotations* addOrReplace(cstring name, const Expression* expr) const {
        auto vec = new Vector<Annotation>();
        for (auto a : *annotations) {
            if (a->name.name != name)
                vec->push_back(new Annotation(name, expr));
        }
        vec->push_back(new Annotation(name, expr));
        return new Annotations(vec);
    }
# 633 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 268 "../ir/base.def"
 void validate() const override {
        do { if ((annotations) == nullptr) do { throw Util::CompilerBug("../ir/base.def", 269, "../ir/base.def" ":" "269" ": Null " "annotations"); } while (0); } while (0);{ annotations->check_null(); } }
# 637 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Annotations&a) const {
        return typeid(*this) == typeid(a)
        && annotations == a.annotations;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    cstring node_type_name() const override { return "Annotations"; }
    static cstring static_type_name() { return "Annotations"; }
    public: Annotations *clone() const override { return new Annotations(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Annotations(Util::SourceInfo srcInfo,
        const Vector<Annotation>* annotations) :
        Node(srcInfo),
        annotations(annotations)
    { validate(); }
};
}
namespace IR {
class IAnnotated : public virtual INode {
 public:
# 273 "../ir/base.def"
 virtual const Annotations* getAnnotations() const = 0;
# 659 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
};
}
# 9 "../ir/type.def"
namespace IR {
enum class Direction {
    None,
    In,
    Out,
    InOut
};
}

inline std::ostream& operator<<(std::ostream &out, IR::Direction d) {
    switch (d) {
        case IR::Direction::None:
            break;
        case IR::Direction::In:
            out << "in";
            break;
        case IR::Direction::Out:
            out << "out";
            break;
        case IR::Direction::InOut:
            out << "inout";
            break;
        default:
            do { throw Util::CompilerBug("../ir/type.def", 32, "Unhandled case"); } while (0);
    }
    return out;
}
# 690 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
namespace IR {
class Type_Boolean : public Type_Base {
 public:
# 41 "../ir/type.def"
 static const Type::Boolean *get();
    int width_bits() const { return 1; }
# 697 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 44 "../ir/type.def"
 cstring toString() const override { return "bool"; }
# 700 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Type_Boolean&a) const {
        return Type_Base::operator==(a);
    }
    cstring node_type_name() const override { return "Type_Boolean"; }
    static cstring static_type_name() { return "Type_Boolean"; }
    public: Type_Boolean *clone() const override { return new Type_Boolean(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Type_Boolean(Util::SourceInfo srcInfo) :
        Type_Base(srcInfo)
    { validate(); }
};
}
namespace IR {
class Type_State : public Type_Base {
 public:
# 51 "../ir/type.def"
 static const Type_State *get();
# 717 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 53 "../ir/type.def"
 cstring toString() const override { return "state"; }
# 720 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Type_State&a) const {
        return Type_Base::operator==(a);
    }
    cstring node_type_name() const override { return "Type_State"; }
    static cstring static_type_name() { return "Type_State"; }
    public: Type_State *clone() const override { return new Type_State(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Type_State(Util::SourceInfo srcInfo) :
        Type_Base(srcInfo)
    { validate(); }
};
}
namespace IR {
class Type_Bits : public Type_Base {
 public:
    int size;
    bool isSigned;
# 61 "../ir/type.def"
 static const Type::Bits *get(Util::SourceInfo si, int sz, bool isSigned = false);
    static const Type::Bits *get(int sz, bool isSigned = false);
    cstring baseName() const { return isSigned ? "int" : "bit"; }
    int width_bits() const { return size; }


    static std::map<int, const IR::Type_Bits*> *signedTypes;
    static std::map<int, const IR::Type_Bits*> *unsignedTypes;
# 746 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 70 "../ir/type.def"
 cstring toString() const override { return baseName() + "<" + Util::toString(size) + ">"; }
# 749 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Type_Bits&a) const {
        return Type_Base::operator==(a)
        && size == a.size
        && isSigned == a.isSigned;
    }
    cstring node_type_name() const override { return "Type_Bits"; }
    static cstring static_type_name() { return "Type_Bits"; }
    void dbprint(std::ostream &out) const override ;
    void dump_fields(std::ostream& out) const override;
    public: Type_Bits *clone() const override { return new Type_Bits(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Type_Bits(Util::SourceInfo srcInfo,
        int size,
        bool isSigned) :
        Type_Base(srcInfo),
        size(size),
        isSigned(isSigned)
    { validate(); }
};
}
namespace IR {
class Type_Varbits : public Type_Base {
 public:
    int size;
# 77 "../ir/type.def"
 static const Type::Varbits *get(Util::SourceInfo si, int size = 0);
    static const Type::Varbits *get();
# 776 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 80 "../ir/type.def"
 cstring toString() const override { return cstring("varbit<") + Util::toString(size) + ">"; }
# 779 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Type_Varbits&a) const {
        return Type_Base::operator==(a)
        && size == a.size;
    }
    cstring node_type_name() const override { return "Type_Varbits"; }
    static cstring static_type_name() { return "Type_Varbits"; }
    void dump_fields(std::ostream& out) const override;
    public: Type_Varbits *clone() const override { return new Type_Varbits(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Type_Varbits(Util::SourceInfo srcInfo,
        int size) :
        Type_Base(srcInfo),
        size(size)
    { validate(); }
};
}
namespace IR {
class Parameter : public Declaration, public virtual IAnnotated {
 public:
    const Annotations* annotations = nullptr;
    Direction direction;
    const Type* type = nullptr;
# 88 "../ir/type.def"
 const Annotations* getAnnotations() const override { return annotations; }
# 803 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Parameter&a) const {
        return Declaration::operator==(a)
        && annotations == a.annotations
        && direction == a.direction
        && type == a.type;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((annotations) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 812, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "812" ": Null " "annotations"); } while (0); } while (0);
        do { if ((type) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 813, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "813" ": Null " "type"); } while (0); } while (0); }
    cstring node_type_name() const override { return "Parameter"; }
    static cstring static_type_name() { return "Parameter"; }
    void dbprint(std::ostream &out) const override ;
    void dump_fields(std::ostream& out) const override;
    public: Parameter *clone() const override { return new Parameter(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Parameter(Util::SourceInfo srcInfo,
        ID name,
        const Annotations* annotations,
        Direction direction,
        const Type* type) :
        Declaration(srcInfo, name),
        annotations(annotations),
        direction(direction),
        type(type)
    { validate(); }
};
}
namespace IR {
class ParameterList : public Node, public virtual ISimpleNamespace {
 public:
    NameMap<Parameter, ordered_map> parameters;
# 94 "../ir/type.def"
 void validate() const override {
        parameters.validate();{ parameters.check_null(); } }
# 839 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 95 "../ir/type.def"
 void dbprint(std::ostream &out) const override { Node::dbprint(out); }
# 842 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 97 "../ir/type.def"
 ParameterList() {}
    Util::Enumerator<const Parameter*>* getEnumerator() const
    { return parameters.valueEnumerator(); }
    Util::Enumerator<const IDeclaration*>* getDeclarations() const
    { return getEnumerator()->as<const IDeclaration*>(); }
    size_t size() const { return parameters.size(); }
    const IR::Parameter* getParameter(cstring name) const
    { return parameters.getUnique(name); }
    const IR::Parameter* getParameter(unsigned index) const {
        for (auto &param : parameters)
            if (0 == index--) return param.second;
        do { throw Util::CompilerBug("../ir/type.def", 108, "Only %1% parameters; %2% requested", size(), size()+index); } while (0); }
    void add(const Parameter* param)
    { parameters.addUnique(param->name, param); }
    const IR::IDeclaration* getDeclByName(cstring name) const
    { return getParameter(name); }
# 860 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const ParameterList&a) const {
        return typeid(*this) == typeid(a)
        && parameters == a.parameters;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    cstring node_type_name() const override { return "ParameterList"; }
    static cstring static_type_name() { return "ParameterList"; }
    public: ParameterList *clone() const override { return new ParameterList(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    ParameterList(Util::SourceInfo srcInfo,
        NameMap<Parameter, ordered_map> parameters) :
        Node(srcInfo),
        parameters(parameters)
    { validate(); }
};
}
namespace IR {
class Type_Var : public Type_Declaration, public virtual ITypeVar {
 public:
# 119 "../ir/type.def"
 cstring getVarName() const { return getName(); }
# 882 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Type_Var&a) const {
        return Type_Declaration::operator==(a);
    }
    cstring node_type_name() const override { return "Type_Var"; }
    static cstring static_type_name() { return "Type_Var"; }
    void dbprint(std::ostream &out) const override ;
    public: Type_Var *clone() const override { return new Type_Var(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Type_Var(Util::SourceInfo srcInfo,
        ID name) :
        Type_Declaration(srcInfo, name)
    { validate(); }
};
}
namespace IR {
class Type_InfInt : public Type, public virtual ITypeVar {
 public:
# 130 "../ir/type.def"
 private:
    static int nextId;
 public:
    int declid;
    Type_InfInt() : Type(Util::SourceInfo()), declid(nextId++) {}
    cstring getVarName() const { return "int_" + Util::toString(declid); }
# 906 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 137 "../ir/type.def"
 void dbprint(std::ostream &out) const override { Node::dbprint(out); out << declid; }
# 909 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 138 "../ir/type.def"
 cstring toString() const override { return "int"; }
# 912 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 139 "../ir/type.def"
 bool operator==(const Type_InfInt&a) const { return declid == a.declid; }
# 915 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 cstring node_type_name() const override { return "Type_InfInt"; }
    static cstring static_type_name() { return "Type_InfInt"; }
    public: Type_InfInt *clone() const override { return new Type_InfInt(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
};
}
namespace IR {
class Type_Dontcare : public Type_Base {
 public:
# 143 "../ir/type.def"
 cstring toString() const override { return "_"; }
# 926 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 145 "../ir/type.def"
 static const Type_Dontcare* get();
# 929 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Type_Dontcare&a) const {
        return Type_Base::operator==(a);
    }
    cstring node_type_name() const override { return "Type_Dontcare"; }
    static cstring static_type_name() { return "Type_Dontcare"; }
    public: Type_Dontcare *clone() const override { return new Type_Dontcare(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Type_Dontcare(Util::SourceInfo srcInfo) :
        Type_Base(srcInfo)
    { validate(); }
};
}
namespace IR {
class Type_Void : public Type_Base {
 public:
# 151 "../ir/type.def"
 cstring toString() const override { return "void"; }
# 946 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 153 "../ir/type.def"
 static const Type_Void* get();
# 949 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Type_Void&a) const {
        return Type_Base::operator==(a);
    }
    cstring node_type_name() const override { return "Type_Void"; }
    static cstring static_type_name() { return "Type_Void"; }
    public: Type_Void *clone() const override { return new Type_Void(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Type_Void(Util::SourceInfo srcInfo) :
        Type_Base(srcInfo)
    { validate(); }
};
}
namespace IR {
class Type_Error : public Type_Base {
 public:
# 159 "../ir/type.def"
 cstring toString() const override { return "error"; }
# 966 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 161 "../ir/type.def"
 static const Type_Error* get();
# 969 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Type_Error&a) const {
        return Type_Base::operator==(a);
    }
    cstring node_type_name() const override { return "Type_Error"; }
    static cstring static_type_name() { return "Type_Error"; }
    public: Type_Error *clone() const override { return new Type_Error(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Type_Error(Util::SourceInfo srcInfo) :
        Type_Base(srcInfo)
    { validate(); }
};
}
namespace IR {
class Type_MatchKind : public Type_Base {
 public:
# 167 "../ir/type.def"
 cstring toString() const override { return "match_kind"; }
# 986 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 169 "../ir/type.def"
 static const Type_MatchKind* get();
# 989 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Type_MatchKind&a) const {
        return Type_Base::operator==(a);
    }
    cstring node_type_name() const override { return "Type_MatchKind"; }
    static cstring static_type_name() { return "Type_MatchKind"; }
    public: Type_MatchKind *clone() const override { return new Type_MatchKind(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Type_MatchKind(Util::SourceInfo srcInfo) :
        Type_Base(srcInfo)
    { validate(); }
};
}
namespace IR {
class TypeParameters : public Node, public virtual ISimpleNamespace {
 public:
    NameMap<Type_Var, ordered_map> parameters;
# 177 "../ir/type.def"
 TypeParameters() : Node(Util::SourceInfo()) {}
    TypeParameters(Util::SourceInfo &si, NameMap<Type_Var, ordered_map> &&p)
            : Node(si), parameters(std::move(p)) {}
    Util::Enumerator<const IDeclaration*>* getDeclarations() const
    { return parameters.valueEnumerator()->as<const IDeclaration*>(); }
    bool empty() const { return parameters.empty(); }
    size_t size() const { return parameters.size(); }
    Util::Enumerator<const Type_Var*>* getEnumerator() const
    { return parameters.valueEnumerator(); }
    const IR::IDeclaration* getDeclByName(cstring name) const
    { return parameters.getUnique(name); }
# 1017 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 189 "../ir/type.def"
 void validate() const override {
        parameters.validate();{ parameters.check_null(); } }
# 1021 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const TypeParameters&a) const {
        return typeid(*this) == typeid(a)
        && parameters == a.parameters;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    cstring node_type_name() const override { return "TypeParameters"; }
    static cstring static_type_name() { return "TypeParameters"; }
    void dbprint(std::ostream &out) const override ;
    public: TypeParameters *clone() const override { return new TypeParameters(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    TypeParameters(Util::SourceInfo srcInfo,
        NameMap<Type_Var, ordered_map> parameters) :
        Node(srcInfo),
        parameters(parameters)
    { validate(); }
};
}
namespace IR {
class StructField : public Declaration, public virtual IAnnotated {
 public:
    const Annotations* annotations = nullptr;
    const Type* type = nullptr;
# 197 "../ir/type.def"
 StructField(Util::SourceInfo si, ID name, const Type *type);
    StructField(ID name, const Type *type);
    const Annotations* getAnnotations() const override { return annotations; }
# 1048 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const StructField&a) const {
        return Declaration::operator==(a)
        && annotations == a.annotations
        && type == a.type;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((annotations) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 1056, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "1056" ": Null " "annotations"); } while (0); } while (0);
        do { if ((type) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 1057, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "1057" ": Null " "type"); } while (0); } while (0); }
    cstring node_type_name() const override { return "StructField"; }
    static cstring static_type_name() { return "StructField"; }
    public: StructField *clone() const override { return new StructField(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    StructField(Util::SourceInfo srcInfo,
        ID name,
        const Annotations* annotations,
        const Type* type) :
        Declaration(srcInfo, name),
        annotations(annotations),
        type(type)
    { validate(); }
};
}
namespace IR {
class Type_StructLike : public Type_Declaration, public virtual ISimpleNamespace, public virtual IAnnotated {
 public:
    const Annotations* annotations = nullptr;
    NameMap<StructField, ordered_map> fields;
# 207 "../ir/type.def"
 const Annotations* getAnnotations() const override { return annotations; }
    Util::Enumerator<const StructField*>* getEnumerator() const
    { return fields.valueEnumerator(); }
    Util::Enumerator<const IDeclaration*>* getDeclarations() const override
    { return getEnumerator()->as<const IDeclaration*>(); }
    const StructField* getField(cstring name) const
    { return fields.getUnique(name); }
    int width_bits() const override {

        int rv = 0;
        for (auto f : *getEnumerator())
            rv += f->type->width_bits();
        return rv; }
    const IR::IDeclaration* getDeclByName(cstring name) const
    { return getField(name); }
# 1093 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 223 "../ir/type.def"
 void dbprint(std::ostream &out) const override { Node::dbprint(out); out << toString(); }
# 1096 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 224 "../ir/type.def"
 void validate() const override {
        do { if ((annotations) == nullptr) do { throw Util::CompilerBug("../ir/type.def", 225, "../ir/type.def" ":" "225" ": Null " "annotations"); } while (0); } while (0);
        fields.validate();{ fields.check_null(); } }
# 1101 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Type_StructLike&a) const {
        return Type_Declaration::operator==(a)
        && annotations == a.annotations
        && fields == a.fields;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    cstring node_type_name() const override { return "Type_StructLike"; }
    static cstring static_type_name() { return "Type_StructLike"; }
    public: Type_StructLike *clone() const override = 0; public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
 protected:
    Type_StructLike(Util::SourceInfo srcInfo,
        ID name,
        const Annotations* annotations,
        NameMap<StructField, ordered_map> fields) :
        Type_Declaration(srcInfo, name),
        annotations(annotations),
        fields(fields)
    { validate(); }
 public:
};
}
namespace IR {
class Type_Struct : public Type_StructLike {
 public:
# 229 "../ir/type.def"
 cstring toString() const override { return cstring("struct ") + externalName(); }
# 1129 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 231 "../ir/type.def"
 Type_Struct(cstring name, const NameMap<StructField, ordered_map> &&fields);
# 1132 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Type_Struct&a) const {
        return Type_StructLike::operator==(a);
    }
    cstring node_type_name() const override { return "Type_Struct"; }
    static cstring static_type_name() { return "Type_Struct"; }
    public: Type_Struct *clone() const override { return new Type_Struct(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Type_Struct(Util::SourceInfo srcInfo,
        ID name,
        const Annotations* annotations,
        NameMap<StructField, ordered_map> fields) :
        Type_StructLike(srcInfo, name, annotations, fields)
    { validate(); }
};
}
namespace IR {
class Type_Union : public Type_StructLike {
 public:
# 237 "../ir/type.def"
 cstring toString() const override { return cstring("header_union ") + externalName(); }
# 1152 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 239 "../ir/type.def"
 int width_bits() const override {
        int rv = 0;
        for (auto f : *getEnumerator())
            rv = std::max(rv, f->type->width_bits());
        return rv; }
# 1159 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Type_Union&a) const {
        return Type_StructLike::operator==(a);
    }
    cstring node_type_name() const override { return "Type_Union"; }
    static cstring static_type_name() { return "Type_Union"; }
    public: Type_Union *clone() const override { return new Type_Union(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Type_Union(Util::SourceInfo srcInfo,
        ID name,
        const Annotations* annotations,
        NameMap<StructField, ordered_map> fields) :
        Type_StructLike(srcInfo, name, annotations, fields)
    { validate(); }
};
}
namespace IR {
class Type_Header : public Type_StructLike {
 public:
# 249 "../ir/type.def"
 const static cstring setValid;
    const static cstring isValid;
# 1180 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 253 "../ir/type.def"
 cstring toString() const override { return cstring("header ") + externalName(); }
# 1183 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Type_Header&a) const {
        return Type_StructLike::operator==(a);
    }
    cstring node_type_name() const override { return "Type_Header"; }
    static cstring static_type_name() { return "Type_Header"; }
    public: Type_Header *clone() const override { return new Type_Header(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Type_Header(Util::SourceInfo srcInfo,
        ID name,
        const Annotations* annotations,
        NameMap<StructField, ordered_map> fields) :
        Type_StructLike(srcInfo, name, annotations, fields)
    { validate(); }
};
}
namespace IR {
class Type_Set : public Type {
 public:
    const Type* elementType = nullptr;
# 258 "../ir/type.def"
 void dbprint(std::ostream &out) const override { Node::dbprint(out); out << "<" << elementType << ">"; }
# 1204 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 259 "../ir/type.def"
 cstring toString() const override { return cstring("set<") + elementType->toString() + ">"; }
# 1207 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Type_Set&a) const {
        return Type::operator==(a)
        && elementType == a.elementType;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((elementType) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 1214, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "1214" ": Null " "elementType"); } while (0); } while (0); }
    cstring node_type_name() const override { return "Type_Set"; }
    static cstring static_type_name() { return "Type_Set"; }
    public: Type_Set *clone() const override { return new Type_Set(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Type_Set(Util::SourceInfo srcInfo,
        const Type* elementType) :
        Type(srcInfo),
        elementType(elementType)
    { validate(); }
};
}
namespace IR {
class Type_Tuple : public Type {
 public:
    const Vector<Type>* components = nullptr;
# 266 "../ir/type.def"
 cstring toString() const override { return "Tuple(" + Util::toString(components->size()) + ")"; }
# 1232 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 267 "../ir/type.def"
 void validate() const override {
        do { if ((components) == nullptr) do { throw Util::CompilerBug("../ir/type.def", 268, "../ir/type.def" ":" "268" ": Null " "components"); } while (0); } while (0);{ components->check_null(); } }
# 1236 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Type_Tuple&a) const {
        return Type::operator==(a)
        && components == a.components;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    cstring node_type_name() const override { return "Type_Tuple"; }
    static cstring static_type_name() { return "Type_Tuple"; }
    public: Type_Tuple *clone() const override { return new Type_Tuple(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Type_Tuple(Util::SourceInfo srcInfo,
        const Vector<Type>* components) :
        Type(srcInfo),
        components(components)
    { validate(); }
};
}
namespace IR {
class Type_ArchBlock : public Type_Declaration, public virtual IMayBeGenericType, public virtual IAnnotated {
 public:
    const Annotations* annotations = nullptr;
    const TypeParameters* typeParams = nullptr;
# 276 "../ir/type.def"
 const Annotations* getAnnotations() const override { return annotations; }
    const TypeParameters* getTypeParameters() const override { return typeParams; }
# 1261 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Type_ArchBlock&a) const {
        return Type_Declaration::operator==(a)
        && annotations == a.annotations
        && typeParams == a.typeParams;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((annotations) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 1269, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "1269" ": Null " "annotations"); } while (0); } while (0);
        do { if ((typeParams) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 1270, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "1270" ": Null " "typeParams"); } while (0); } while (0); }
    cstring node_type_name() const override { return "Type_ArchBlock"; }
    static cstring static_type_name() { return "Type_ArchBlock"; }
    public: Type_ArchBlock *clone() const override = 0; public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
 protected:
    Type_ArchBlock(Util::SourceInfo srcInfo,
        ID name,
        const Annotations* annotations,
        const TypeParameters* typeParams) :
        Type_Declaration(srcInfo, name),
        annotations(annotations),
        typeParams(typeParams)
    { validate(); }
 public:
};
}
namespace IR {
class Type_Package : public Type_ArchBlock, public virtual IContainer {
 public:
    const ParameterList* constructorParams = nullptr;
# 284 "../ir/type.def"
 const Type_Method* getConstructorMethodType() const override;
    const ParameterList* getConstructorParameters() const override { return constructorParams; }
# 1294 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 287 "../ir/type.def"
 cstring toString() const override { return cstring("package ") + externalName(); }
# 1297 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Type_Package&a) const {
        return Type_ArchBlock::operator==(a)
        && constructorParams == a.constructorParams;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((constructorParams) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 1304, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "1304" ": Null " "constructorParams"); } while (0); } while (0); }
    cstring node_type_name() const override { return "Type_Package"; }
    static cstring static_type_name() { return "Type_Package"; }
    void dbprint(std::ostream &out) const override ;
    public: Type_Package *clone() const override { return new Type_Package(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Type_Package(Util::SourceInfo srcInfo,
        ID name,
        const Annotations* annotations,
        const TypeParameters* typeParams,
        const ParameterList* constructorParams) :
        Type_ArchBlock(srcInfo, name, annotations, typeParams),
        constructorParams(constructorParams)
    { validate(); }
};
}
namespace IR {
class Type_Parser : public Type_ArchBlock, public virtual IApply {
 public:
    const ParameterList* applyParams = nullptr;
# 293 "../ir/type.def"
 const Type_Method* getApplyMethodType() const override;
# 1326 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 295 "../ir/type.def"
 cstring toString() const override { return cstring("parser ") + externalName(); }
# 1329 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Type_Parser&a) const {
        return Type_ArchBlock::operator==(a)
        && applyParams == a.applyParams;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((applyParams) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 1336, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "1336" ": Null " "applyParams"); } while (0); } while (0); }
    cstring node_type_name() const override { return "Type_Parser"; }
    static cstring static_type_name() { return "Type_Parser"; }
    void dbprint(std::ostream &out) const override ;
    public: Type_Parser *clone() const override { return new Type_Parser(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Type_Parser(Util::SourceInfo srcInfo,
        ID name,
        const Annotations* annotations,
        const TypeParameters* typeParams,
        const ParameterList* applyParams) :
        Type_ArchBlock(srcInfo, name, annotations, typeParams),
        applyParams(applyParams)
    { validate(); }
};
}
namespace IR {
class Type_Control : public Type_ArchBlock, public virtual IApply {
 public:
    const ParameterList* applyParams = nullptr;
# 301 "../ir/type.def"
 const Type_Method* getApplyMethodType() const override;
# 1358 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 303 "../ir/type.def"
 cstring toString() const override { return cstring("control ") + externalName(); }
# 1361 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Type_Control&a) const {
        return Type_ArchBlock::operator==(a)
        && applyParams == a.applyParams;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((applyParams) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 1368, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "1368" ": Null " "applyParams"); } while (0); } while (0); }
    cstring node_type_name() const override { return "Type_Control"; }
    static cstring static_type_name() { return "Type_Control"; }
    void dbprint(std::ostream &out) const override ;
    public: Type_Control *clone() const override { return new Type_Control(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Type_Control(Util::SourceInfo srcInfo,
        ID name,
        const Annotations* annotations,
        const TypeParameters* typeParams,
        const ParameterList* applyParams) :
        Type_ArchBlock(srcInfo, name, annotations, typeParams),
        applyParams(applyParams)
    { validate(); }
};
}
namespace IR {
class Type_Name : public Type {
 public:
# 309 "../ir/type.def"
 explicit Type_Name(const Path* path)
        : Type(path->srcInfo), path(path)
    { do { if ((path) == nullptr) do { throw Util::CompilerBug("../ir/type.def", 311, "../ir/type.def" ":" "311" ": Null " "path"); } while (0); } while (0); }
    explicit Type_Name(IR::ID id)
        : Type(id.srcInfo), path(new IR::Path(id)) {}
# 1393 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 const Path* path = nullptr;
# 316 "../ir/type.def"
 cstring toString() const override { return path->name; }
# 1397 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 317 "../ir/type.def"
 void dbprint(std::ostream &out) const override { Type::dbprint(out); out << ":" << path->toString(); }
# 1400 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Type_Name&a) const {
        return Type::operator==(a)
        && path == a.path;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((path) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 1407, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "1407" ": Null " "path"); } while (0); } while (0); }
    cstring node_type_name() const override { return "Type_Name"; }
    static cstring static_type_name() { return "Type_Name"; }
    public: Type_Name *clone() const override { return new Type_Name(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Type_Name(Util::SourceInfo srcInfo,
        const Path* path) :
        Type(srcInfo),
        path(path)
    { validate(); }
};
}
namespace IR {
class Type_Stack : public Type {
 public:
    const Type* baseType = nullptr;
    const Expression* size = nullptr;
# 323 "../ir/type.def"
 cstring toString() const override { return baseType->toString() + "[]"; }
# 1426 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 324 "../ir/type.def"
 void dbprint(std::ostream &out) const override { Type::dbprint(out); out << baseType << "[" << size << "]"; }
# 1429 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 326 "../ir/type.def"
 bool sizeKnown() const;
    int getSize() const;
    static const cstring next;
    static const cstring last;
    static const cstring push_front;
    static const cstring pop_front;
    static const cstring full;
    static const cstring empty;
# 1439 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Type_Stack&a) const {
        return Type::operator==(a)
        && baseType == a.baseType
        && size == a.size;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((baseType) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 1447, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "1447" ": Null " "baseType"); } while (0); } while (0);
        do { if ((size) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 1448, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "1448" ": Null " "size"); } while (0); } while (0); }
    cstring node_type_name() const override { return "Type_Stack"; }
    static cstring static_type_name() { return "Type_Stack"; }
    public: Type_Stack *clone() const override { return new Type_Stack(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Type_Stack(Util::SourceInfo srcInfo,
        const Type* baseType,
        const Expression* size) :
        Type(srcInfo),
        baseType(baseType),
        size(size)
    { validate(); }
};
}
namespace IR {
class Type_Specialized : public Type {
 public:
    const Type* baseType = nullptr;
    const Vector<Type>* arguments = nullptr;
# 345 "../ir/type.def"
 void dbprint(std::ostream &out) const override { Node::dbprint(out); out << baseType; }
# 1469 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 346 "../ir/type.def"
 cstring toString() const override { return baseType->toString() + "<...>"; }
# 1472 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 347 "../ir/type.def"
 void validate() const override {
        do { if ((baseType) == nullptr) do { throw Util::CompilerBug("../ir/type.def", 348, "../ir/type.def" ":" "348" ": Null " "baseType"); } while (0); } while (0);
        do { if ((arguments) == nullptr) do { throw Util::CompilerBug("../ir/type.def", 349, "../ir/type.def" ":" "349" ": Null " "arguments"); } while (0); } while (0);{ arguments->check_null(); } }
# 1477 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Type_Specialized&a) const {
        return Type::operator==(a)
        && baseType == a.baseType
        && arguments == a.arguments;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    cstring node_type_name() const override { return "Type_Specialized"; }
    static cstring static_type_name() { return "Type_Specialized"; }
    public: Type_Specialized *clone() const override { return new Type_Specialized(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Type_Specialized(Util::SourceInfo srcInfo,
        const Type* baseType,
        const Vector<Type>* arguments) :
        Type(srcInfo),
        baseType(baseType),
        arguments(arguments)
    { validate(); }
};
}
namespace IR {
class Type_SpecializedCanonical : public Type {
 public:
    const Type* baseType = nullptr;
    const Vector<Type>* arguments = nullptr;
    const Type* substituted = nullptr;
# 359 "../ir/type.def"
 void validate() const override {
        do { if ((baseType) == nullptr) do { throw Util::CompilerBug("../ir/type.def", 360, "../ir/type.def" ":" "360" ": Null " "baseType"); } while (0); } while (0);
        do { if ((arguments) == nullptr) do { throw Util::CompilerBug("../ir/type.def", 361, "../ir/type.def" ":" "361" ": Null " "arguments"); } while (0); } while (0);
        do { if ((substituted) == nullptr) do { throw Util::CompilerBug("../ir/type.def", 362, "../ir/type.def" ":" "362" ": Null " "substituted"); } while (0); } while (0);{
        arguments->check_null();
        do { if (!(baseType->is<IMayBeGenericType>())) do { throw Util::CompilerBug("../ir/type.def", 364, "base type %1% is not generic", baseType); } while (0); } while (0);
    } }
# 1511 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Type_SpecializedCanonical&a) const {
        return Type::operator==(a)
        && baseType == a.baseType
        && arguments == a.arguments
        && substituted == a.substituted;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    cstring node_type_name() const override { return "Type_SpecializedCanonical"; }
    static cstring static_type_name() { return "Type_SpecializedCanonical"; }
    public: Type_SpecializedCanonical *clone() const override { return new Type_SpecializedCanonical(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Type_SpecializedCanonical(Util::SourceInfo srcInfo,
        const Type* baseType,
        const Vector<Type>* arguments,
        const Type* substituted) :
        Type(srcInfo),
        baseType(baseType),
        arguments(arguments),
        substituted(substituted)
    { validate(); }
};
}
namespace IR {
class Declaration_ID : public Declaration, public virtual CompileTimeValue {
 public:
    bool operator==(const Declaration_ID&a) const {
        return Declaration::operator==(a);
    }
    cstring node_type_name() const override { return "Declaration_ID"; }
    static cstring static_type_name() { return "Declaration_ID"; }
    public: Declaration_ID *clone() const override { return new Declaration_ID(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Declaration_ID(Util::SourceInfo srcInfo,
        ID name) :
        Declaration(srcInfo, name)
    { validate(); }
};
}
namespace IR {
class Type_Enum : public Type_Declaration, public virtual ISimpleNamespace {
 public:
    NameMap<Declaration_ID, ordered_map> members;
# 373 "../ir/type.def"
 Util::Enumerator<const IDeclaration*>* getDeclarations() const
    { return members.valueEnumerator()->as<const IDeclaration*>(); }
    Util::Enumerator<const Declaration_ID*>* getEnumerator() const
    { return members.valueEnumerator(); }
    const IDeclaration* getDeclByName(cstring name) const
    { return members.getUnique(name); }
# 1560 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 381 "../ir/type.def"
 void validate() const override {
        members.validate();{ members.check_null(); } }
# 1564 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Type_Enum&a) const {
        return Type_Declaration::operator==(a)
        && members == a.members;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    cstring node_type_name() const override { return "Type_Enum"; }
    static cstring static_type_name() { return "Type_Enum"; }
    public: Type_Enum *clone() const override { return new Type_Enum(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Type_Enum(Util::SourceInfo srcInfo,
        ID name,
        NameMap<Declaration_ID, ordered_map> members) :
        Type_Declaration(srcInfo, name),
        members(members)
    { validate(); }
};
}
namespace IR {
class Type_Table : public Type, public virtual IApply {
 public:
    const P4Table* container = nullptr;
# 387 "../ir/type.def"
 mutable const Type_Method* applyMethod = nullptr;
    const Type_Method* getApplyMethodType() const;


    static const ID hit;
    static const ID action_run;
# 1593 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Type_Table&a) const {
        return Type::operator==(a)
        && container == a.container;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((container) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 1600, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "1600" ": Null " "container"); } while (0); } while (0); }
    cstring node_type_name() const override { return "Type_Table"; }
    static cstring static_type_name() { return "Type_Table"; }
    void dbprint(std::ostream &out) const override ;
    public: Type_Table *clone() const override { return new Type_Table(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Type_Table(Util::SourceInfo srcInfo,
        const P4Table* container) :
        Type(srcInfo),
        container(container)
    { validate(); }
};
}
namespace IR {
class Type_ActionEnum : public Type {
 public:
    const ActionList* actionList = nullptr;
# 402 "../ir/type.def"
 bool contains(cstring name) const;
# 1619 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Type_ActionEnum&a) const {
        return Type::operator==(a)
        && actionList == a.actionList;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((actionList) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 1626, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "1626" ": Null " "actionList"); } while (0); } while (0); }
    cstring node_type_name() const override { return "Type_ActionEnum"; }
    static cstring static_type_name() { return "Type_ActionEnum"; }
    void dbprint(std::ostream &out) const override ;
    public: Type_ActionEnum *clone() const override { return new Type_ActionEnum(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Type_ActionEnum(Util::SourceInfo srcInfo,
        const ActionList* actionList) :
        Type(srcInfo),
        actionList(actionList)
    { validate(); }
};
}
namespace IR {
class Type_MethodBase : public Type, public virtual IMayBeGenericType {
 public:
    const TypeParameters* typeParameters = nullptr;
    const Type* returnType = nullptr;
    const ParameterList* parameters = nullptr;
# 411 "../ir/type.def"
 size_t getParameterCount() const { return parameters->size(); }
    virtual const TypeParameters* getTypeParameters() const { return typeParameters; }
    void dbprint(std::ostream& out) const;
# 1649 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Type_MethodBase&a) const {
        return Type::operator==(a)
        && typeParameters == a.typeParameters
        && returnType == a.returnType
        && parameters == a.parameters;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((typeParameters) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 1658, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "1658" ": Null " "typeParameters"); } while (0); } while (0);
        do { if ((parameters) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 1659, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "1659" ": Null " "parameters"); } while (0); } while (0); }
    cstring node_type_name() const override { return "Type_MethodBase"; }
    static cstring static_type_name() { return "Type_MethodBase"; }
    public: Type_MethodBase *clone() const override = 0; public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
 protected:
    Type_MethodBase(Util::SourceInfo srcInfo,
        const TypeParameters* typeParameters,
        const Type* returnType,
        const ParameterList* parameters) :
        Type(srcInfo),
        typeParameters(typeParameters),
        returnType(returnType),
        parameters(parameters)
    { validate(); }
 public:
};
}
namespace IR {
class Type_Method : public Type_MethodBase {
 public:
    bool operator==(const Type_Method&a) const {
        return Type_MethodBase::operator==(a);
    }
    cstring node_type_name() const override { return "Type_Method"; }
    static cstring static_type_name() { return "Type_Method"; }
    public: Type_Method *clone() const override { return new Type_Method(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Type_Method(Util::SourceInfo srcInfo,
        const TypeParameters* typeParameters,
        const Type* returnType,
        const ParameterList* parameters) :
        Type_MethodBase(srcInfo, typeParameters, returnType, parameters)
    { validate(); }
};
}
namespace IR {
class ArgumentInfo : public Node {
 public:
    bool leftValue;
    const Type* type = nullptr;
    bool operator==(const ArgumentInfo&a) const {
        return typeid(*this) == typeid(a)
        && leftValue == a.leftValue
        && type == a.type;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((type) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 1706, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "1706" ": Null " "type"); } while (0); } while (0); }
    cstring node_type_name() const override { return "ArgumentInfo"; }
    static cstring static_type_name() { return "ArgumentInfo"; }
    void dbprint(std::ostream &out) const override ;
    void dump_fields(std::ostream& out) const override;
    public: ArgumentInfo *clone() const override { return new ArgumentInfo(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    ArgumentInfo(Util::SourceInfo srcInfo,
        bool leftValue,
        const Type* type) :
        Node(srcInfo),
        leftValue(leftValue),
        type(type)
    { validate(); }
};
}
namespace IR {
class Type_MethodCall : public Type {
 public:
    const Vector<Type>* typeArguments = nullptr;
    const Type_Var* returnType = nullptr;
    const Vector<ArgumentInfo>* arguments = nullptr;
# 436 "../ir/type.def"
 void validate() const override {
        do { if ((typeArguments) == nullptr) do { throw Util::CompilerBug("../ir/type.def", 437, "../ir/type.def" ":" "437" ": Null " "typeArguments"); } while (0); } while (0);
        do { if ((returnType) == nullptr) do { throw Util::CompilerBug("../ir/type.def", 438, "../ir/type.def" ":" "438" ": Null " "returnType"); } while (0); } while (0);
        do { if ((arguments) == nullptr) do { throw Util::CompilerBug("../ir/type.def", 439, "../ir/type.def" ":" "439" ": Null " "arguments"); } while (0); } while (0);{ typeArguments->check_null(); arguments->check_null(); } }
# 1733 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Type_MethodCall&a) const {
        return Type::operator==(a)
        && typeArguments == a.typeArguments
        && returnType == a.returnType
        && arguments == a.arguments;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    cstring node_type_name() const override { return "Type_MethodCall"; }
    static cstring static_type_name() { return "Type_MethodCall"; }
    void dbprint(std::ostream &out) const override ;
    public: Type_MethodCall *clone() const override { return new Type_MethodCall(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Type_MethodCall(Util::SourceInfo srcInfo,
        const Vector<Type>* typeArguments,
        const Type_Var* returnType,
        const Vector<ArgumentInfo>* arguments) :
        Type(srcInfo),
        typeArguments(typeArguments),
        returnType(returnType),
        arguments(arguments)
    { validate(); }
};
}
namespace IR {
class Type_Action : public Type_MethodBase {
 public:
    bool operator==(const Type_Action&a) const {
        return Type_MethodBase::operator==(a);
    }
    cstring node_type_name() const override { return "Type_Action"; }
    static cstring static_type_name() { return "Type_Action"; }
    public: Type_Action *clone() const override { return new Type_Action(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Type_Action(Util::SourceInfo srcInfo,
        const TypeParameters* typeParameters,
        const Type* returnType,
        const ParameterList* parameters) :
        Type_MethodBase(srcInfo, typeParameters, returnType, parameters)
    { validate(); }
};
}
namespace IR {
class Method : public Declaration {
 public:
    const Type_Method* type = nullptr;
    bool isAbstract;
# 449 "../ir/type.def"
 size_t getParameterCount() const { return type->getParameterCount(); }
    void setAbstract() { isAbstract = true; }
# 1782 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Method&a) const {
        return Declaration::operator==(a)
        && type == a.type
        && isAbstract == a.isAbstract;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((type) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 1790, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "1790" ": Null " "type"); } while (0); } while (0); }
    cstring node_type_name() const override { return "Method"; }
    static cstring static_type_name() { return "Method"; }
    void dbprint(std::ostream &out) const override ;
    void dump_fields(std::ostream& out) const override;
    public: Method *clone() const override { return new Method(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Method(Util::SourceInfo srcInfo,
        ID name,
        const Type_Method* type,
        bool isAbstract) :
        Declaration(srcInfo, name),
        type(type),
        isAbstract(isAbstract)
    { validate(); }
};
}
namespace IR {
class Type_Typedef : public Type_Declaration, public virtual IAnnotated {
 public:
    const Type* type = nullptr;
    const Annotations* annotations = nullptr;
# 458 "../ir/type.def"
 const Annotations* getAnnotations() const override { return annotations; }
# 1814 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Type_Typedef&a) const {
        return Type_Declaration::operator==(a)
        && type == a.type
        && annotations == a.annotations;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((type) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 1822, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "1822" ": Null " "type"); } while (0); } while (0);
        do { if ((annotations) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 1823, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "1823" ": Null " "annotations"); } while (0); } while (0); }
    cstring node_type_name() const override { return "Type_Typedef"; }
    static cstring static_type_name() { return "Type_Typedef"; }
    public: Type_Typedef *clone() const override { return new Type_Typedef(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Type_Typedef(Util::SourceInfo srcInfo,
        ID name,
        const Type* type,
        const Annotations* annotations) :
        Type_Declaration(srcInfo, name),
        type(type),
        annotations(annotations)
    { validate(); }
};
}
namespace IR {
class Type_Extern : public Type_Declaration, public virtual IGeneralNamespace, public virtual IMayBeGenericType {
 public:
    const TypeParameters* typeParameters = nullptr;
    const Vector<Method>* methods = nullptr;
# 468 "../ir/type.def"
 Util::Enumerator<const IDeclaration*>* getDeclarations() const
    { return methods->getEnumerator()->as<const IDeclaration*>(); }
    virtual const TypeParameters* getTypeParameters() const { return typeParameters; }
    const Method* lookupMethod(cstring name, int argCount) const;
# 1848 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 473 "../ir/type.def"
 void validate() const override {
        do { if ((typeParameters) == nullptr) do { throw Util::CompilerBug("../ir/type.def", 474, "../ir/type.def" ":" "474" ": Null " "typeParameters"); } while (0); } while (0);
        do { if ((methods) == nullptr) do { throw Util::CompilerBug("../ir/type.def", 475, "../ir/type.def" ":" "475" ": Null " "methods"); } while (0); } while (0);{ methods->check_null(); } }
# 1853 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Type_Extern&a) const {
        return Type_Declaration::operator==(a)
        && typeParameters == a.typeParameters
        && methods == a.methods;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    cstring node_type_name() const override { return "Type_Extern"; }
    static cstring static_type_name() { return "Type_Extern"; }
    void dbprint(std::ostream &out) const override ;
    public: Type_Extern *clone() const override { return new Type_Extern(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Type_Extern(Util::SourceInfo srcInfo,
        ID name,
        const TypeParameters* typeParameters,
        const Vector<Method>* methods) :
        Type_Declaration(srcInfo, name),
        typeParameters(typeParameters),
        methods(methods)
    { validate(); }
};
}
namespace IR {
class Operation_Unary : public Operation {
 public:
    const Expression* expr = nullptr;
    int getPrecedence() const { return DBPrint::Prec_Prefix; }
# 9 "../ir/expression.def"
 Operation_Unary(Util::SourceInfo si, const Type *t, const Expression *e)
    : Operation(si, t), expr(e) {}
    Operation_Unary(const Type *t, const Expression *e) : Operation(t), expr(e) {}
    Operation_Unary(const Expression *e) : expr(e) {}
# 1885 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Operation_Unary&a) const {
        return Operation::operator==(a)
        && expr == a.expr;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((expr) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 1892, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "1892" ": Null " "expr"); } while (0); } while (0); }
    cstring node_type_name() const override { return "Operation_Unary"; }
    static cstring static_type_name() { return "Operation_Unary"; }
    public: Operation_Unary *clone() const override = 0; public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
 protected:
    Operation_Unary(Util::SourceInfo srcInfo,
        const Expression* expr) :
        Operation(srcInfo),
        expr(expr)
    { validate(); }
 public:
};
}
namespace IR {
class Neg : public Operation_Unary {
 public:
    cstring getStringOp() const { return "-"; }
# 19 "../ir/expression.def"
 Neg(const Expression *e) : Operation_Unary(e) {}
# 1912 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Neg&a) const {
        return Operation_Unary::operator==(a);
    }
    cstring node_type_name() const override { return "Neg"; }
    static cstring static_type_name() { return "Neg"; }
    void dbprint(std::ostream &out) const override ;
    public: Neg *clone() const override { return new Neg(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Neg(Util::SourceInfo srcInfo,
        const Expression* expr) :
        Operation_Unary(srcInfo, expr)
    { validate(); }
};
}
namespace IR {
class Cmpl : public Operation_Unary {
 public:
    cstring getStringOp() const { return "~"; }
# 26 "../ir/expression.def"
 Cmpl(const Expression *e) : Operation_Unary(e) {}
# 1932 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Cmpl&a) const {
        return Operation_Unary::operator==(a);
    }
    cstring node_type_name() const override { return "Cmpl"; }
    static cstring static_type_name() { return "Cmpl"; }
    void dbprint(std::ostream &out) const override ;
    public: Cmpl *clone() const override { return new Cmpl(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Cmpl(Util::SourceInfo srcInfo,
        const Expression* expr) :
        Operation_Unary(srcInfo, expr)
    { validate(); }
};
}
namespace IR {
class LNot : public Operation_Unary {
 public:
    cstring getStringOp() const { return "!"; }
# 33 "../ir/expression.def"
 LNot(const Expression *e) : Operation_Unary(e) {}
# 1952 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const LNot&a) const {
        return Operation_Unary::operator==(a);
    }
    cstring node_type_name() const override { return "LNot"; }
    static cstring static_type_name() { return "LNot"; }
    void dbprint(std::ostream &out) const override ;
    public: LNot *clone() const override { return new LNot(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    LNot(Util::SourceInfo srcInfo,
        const Expression* expr) :
        Operation_Unary(srcInfo, expr)
    { validate(); }
};
}
namespace IR {
class Operation_Binary : public Operation {
 public:
    const Expression* left = nullptr;
    const Expression* right = nullptr;
# 41 "../ir/expression.def"
 Operation_Binary(const Expression *l, const Expression *r) : left(l), right(r) {}
# 1973 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Operation_Binary&a) const {
        return Operation::operator==(a)
        && left == a.left
        && right == a.right;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((left) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 1981, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "1981" ": Null " "left"); } while (0); } while (0);
        do { if ((right) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 1982, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "1982" ": Null " "right"); } while (0); } while (0); }
    cstring node_type_name() const override { return "Operation_Binary"; }
    static cstring static_type_name() { return "Operation_Binary"; }
    public: Operation_Binary *clone() const override = 0; public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
 protected:
    Operation_Binary(Util::SourceInfo srcInfo,
        const Expression* left,
        const Expression* right) :
        Operation(srcInfo),
        left(left),
        right(right)
    { validate(); }
 public:
};
}
namespace IR {
class Operation_Ternary : public Operation {
 public:
    const Expression* e0 = nullptr;
    const Expression* e1 = nullptr;
    const Expression* e2 = nullptr;
# 50 "../ir/expression.def"
 Operation_Ternary(const Expression *e0, const Expression *e1, const Expression *e2)
    : e0(e0), e1(e1), e2(e2) {}
# 2007 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Operation_Ternary&a) const {
        return Operation::operator==(a)
        && e0 == a.e0
        && e1 == a.e1
        && e2 == a.e2;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((e0) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 2016, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "2016" ": Null " "e0"); } while (0); } while (0);
        do { if ((e1) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 2017, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "2017" ": Null " "e1"); } while (0); } while (0);
        do { if ((e2) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 2018, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "2018" ": Null " "e2"); } while (0); } while (0); }
    cstring node_type_name() const override { return "Operation_Ternary"; }
    static cstring static_type_name() { return "Operation_Ternary"; }
    public: Operation_Ternary *clone() const override = 0; public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
 protected:
    Operation_Ternary(Util::SourceInfo srcInfo,
        const Expression* e0,
        const Expression* e1,
        const Expression* e2) :
        Operation(srcInfo),
        e0(e0),
        e1(e1),
        e2(e2)
    { validate(); }
 public:
};
}
namespace IR {
class Operation_Relation : public Operation_Binary {
 public:
# 57 "../ir/expression.def"
 Operation_Relation(const Expression *l, const Expression *r) : Operation_Binary(l, r) {}
# 2041 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Operation_Relation&a) const {
        return Operation_Binary::operator==(a);
    }
    cstring node_type_name() const override { return "Operation_Relation"; }
    static cstring static_type_name() { return "Operation_Relation"; }
    public: Operation_Relation *clone() const override = 0; public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
 protected:
    Operation_Relation(Util::SourceInfo srcInfo,
        const Expression* left,
        const Expression* right) :
        Operation_Binary(srcInfo, left, right)
    { validate(); }
 public:
};
}
namespace IR {
class Mul : public Operation_Binary {
 public:
    cstring getStringOp() const { return "*"; }
    int getPrecedence() const { return DBPrint::Prec_Mul; }
# 65 "../ir/expression.def"
 Mul(const Expression *l, const Expression *r) : Operation_Binary(l, r) {}
# 2064 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Mul&a) const {
        return Operation_Binary::operator==(a);
    }
    cstring node_type_name() const override { return "Mul"; }
    static cstring static_type_name() { return "Mul"; }
    void dbprint(std::ostream &out) const override ;
    public: Mul *clone() const override { return new Mul(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Mul(Util::SourceInfo srcInfo,
        const Expression* left,
        const Expression* right) :
        Operation_Binary(srcInfo, left, right)
    { validate(); }
};
}
namespace IR {
class Div : public Operation_Binary {
 public:
    cstring getStringOp() const { return "/"; }
    int getPrecedence() const { return DBPrint::Prec_Div; }
# 73 "../ir/expression.def"
 Div(const Expression *l, const Expression *r) : Operation_Binary(l, r) {}
# 2086 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Div&a) const {
        return Operation_Binary::operator==(a);
    }
    cstring node_type_name() const override { return "Div"; }
    static cstring static_type_name() { return "Div"; }
    void dbprint(std::ostream &out) const override ;
    public: Div *clone() const override { return new Div(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Div(Util::SourceInfo srcInfo,
        const Expression* left,
        const Expression* right) :
        Operation_Binary(srcInfo, left, right)
    { validate(); }
};
}
namespace IR {
class Mod : public Operation_Binary {
 public:
    cstring getStringOp() const { return "%"; }
    int getPrecedence() const { return DBPrint::Prec_Mod; }
# 80 "../ir/expression.def"
 Mod(const Expression *l, const Expression *r) : Operation_Binary(l, r) {}
# 2108 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Mod&a) const {
        return Operation_Binary::operator==(a);
    }
    cstring node_type_name() const override { return "Mod"; }
    static cstring static_type_name() { return "Mod"; }
    void dbprint(std::ostream &out) const override ;
    public: Mod *clone() const override { return new Mod(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Mod(Util::SourceInfo srcInfo,
        const Expression* left,
        const Expression* right) :
        Operation_Binary(srcInfo, left, right)
    { validate(); }
};
}
namespace IR {
class Add : public Operation_Binary {
 public:
    cstring getStringOp() const { return "+"; }
    int getPrecedence() const { return DBPrint::Prec_Add; }
# 87 "../ir/expression.def"
 Add(const Expression *l, const Expression *r) : Operation_Binary(l, r) {}
# 2130 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Add&a) const {
        return Operation_Binary::operator==(a);
    }
    cstring node_type_name() const override { return "Add"; }
    static cstring static_type_name() { return "Add"; }
    void dbprint(std::ostream &out) const override ;
    public: Add *clone() const override { return new Add(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Add(Util::SourceInfo srcInfo,
        const Expression* left,
        const Expression* right) :
        Operation_Binary(srcInfo, left, right)
    { validate(); }
};
}
namespace IR {
class Sub : public Operation_Binary {
 public:
    cstring getStringOp() const { return "-"; }
    int getPrecedence() const { return DBPrint::Prec_Sub; }
# 94 "../ir/expression.def"
 Sub(const Expression *l, const Expression *r) : Operation_Binary(l, r) {}
# 2152 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Sub&a) const {
        return Operation_Binary::operator==(a);
    }
    cstring node_type_name() const override { return "Sub"; }
    static cstring static_type_name() { return "Sub"; }
    void dbprint(std::ostream &out) const override ;
    public: Sub *clone() const override { return new Sub(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Sub(Util::SourceInfo srcInfo,
        const Expression* left,
        const Expression* right) :
        Operation_Binary(srcInfo, left, right)
    { validate(); }
};
}
namespace IR {
class Shl : public Operation_Binary {
 public:
    cstring getStringOp() const { return "<<"; }
    int getPrecedence() const { return DBPrint::Prec_Shl; }
# 101 "../ir/expression.def"
 Shl(const Expression *l, const Expression *r) : Operation_Binary(l, r) {}
# 2174 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Shl&a) const {
        return Operation_Binary::operator==(a);
    }
    cstring node_type_name() const override { return "Shl"; }
    static cstring static_type_name() { return "Shl"; }
    void dbprint(std::ostream &out) const override ;
    public: Shl *clone() const override { return new Shl(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Shl(Util::SourceInfo srcInfo,
        const Expression* left,
        const Expression* right) :
        Operation_Binary(srcInfo, left, right)
    { validate(); }
};
}
namespace IR {
class Shr : public Operation_Binary {
 public:
    cstring getStringOp() const { return ">>"; }
    int getPrecedence() const { return DBPrint::Prec_Shr; }
# 108 "../ir/expression.def"
 Shr(const Expression *l, const Expression *r) : Operation_Binary(l, r) {}
# 2196 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Shr&a) const {
        return Operation_Binary::operator==(a);
    }
    cstring node_type_name() const override { return "Shr"; }
    static cstring static_type_name() { return "Shr"; }
    void dbprint(std::ostream &out) const override ;
    public: Shr *clone() const override { return new Shr(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Shr(Util::SourceInfo srcInfo,
        const Expression* left,
        const Expression* right) :
        Operation_Binary(srcInfo, left, right)
    { validate(); }
};
}
namespace IR {
class Equ : public Operation_Relation {
 public:
    cstring getStringOp() const { return "=="; }
    int getPrecedence() const { return DBPrint::Prec_Equ; }
# 115 "../ir/expression.def"
 Equ(const Expression *l, const Expression *r) : Operation_Relation(l, r) {}
# 2218 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Equ&a) const {
        return Operation_Relation::operator==(a);
    }
    cstring node_type_name() const override { return "Equ"; }
    static cstring static_type_name() { return "Equ"; }
    void dbprint(std::ostream &out) const override ;
    public: Equ *clone() const override { return new Equ(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Equ(Util::SourceInfo srcInfo,
        const Expression* left,
        const Expression* right) :
        Operation_Relation(srcInfo, left, right)
    { validate(); }
};
}
namespace IR {
class Neq : public Operation_Relation {
 public:
    cstring getStringOp() const { return "!="; }
    int getPrecedence() const { return DBPrint::Prec_Neq; }
# 122 "../ir/expression.def"
 Neq(const Expression *l, const Expression *r) : Operation_Relation(l, r) {}
# 2240 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Neq&a) const {
        return Operation_Relation::operator==(a);
    }
    cstring node_type_name() const override { return "Neq"; }
    static cstring static_type_name() { return "Neq"; }
    void dbprint(std::ostream &out) const override ;
    public: Neq *clone() const override { return new Neq(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Neq(Util::SourceInfo srcInfo,
        const Expression* left,
        const Expression* right) :
        Operation_Relation(srcInfo, left, right)
    { validate(); }
};
}
namespace IR {
class Lss : public Operation_Relation {
 public:
    cstring getStringOp() const { return "<"; }
    int getPrecedence() const { return DBPrint::Prec_Lss; }
# 129 "../ir/expression.def"
 Lss(const Expression *l, const Expression *r) : Operation_Relation(l, r) {}
# 2262 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Lss&a) const {
        return Operation_Relation::operator==(a);
    }
    cstring node_type_name() const override { return "Lss"; }
    static cstring static_type_name() { return "Lss"; }
    void dbprint(std::ostream &out) const override ;
    public: Lss *clone() const override { return new Lss(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Lss(Util::SourceInfo srcInfo,
        const Expression* left,
        const Expression* right) :
        Operation_Relation(srcInfo, left, right)
    { validate(); }
};
}
namespace IR {
class Leq : public Operation_Relation {
 public:
    cstring getStringOp() const { return "<="; }
    int getPrecedence() const { return DBPrint::Prec_Leq; }
# 136 "../ir/expression.def"
 Leq(const Expression *l, const Expression *r) : Operation_Relation(l, r) {}
# 2284 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Leq&a) const {
        return Operation_Relation::operator==(a);
    }
    cstring node_type_name() const override { return "Leq"; }
    static cstring static_type_name() { return "Leq"; }
    void dbprint(std::ostream &out) const override ;
    public: Leq *clone() const override { return new Leq(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Leq(Util::SourceInfo srcInfo,
        const Expression* left,
        const Expression* right) :
        Operation_Relation(srcInfo, left, right)
    { validate(); }
};
}
namespace IR {
class Grt : public Operation_Relation {
 public:
    cstring getStringOp() const { return ">"; }
    int getPrecedence() const { return DBPrint::Prec_Grt; }
# 143 "../ir/expression.def"
 Grt(const Expression *l, const Expression *r) : Operation_Relation(l, r) {}
# 2306 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Grt&a) const {
        return Operation_Relation::operator==(a);
    }
    cstring node_type_name() const override { return "Grt"; }
    static cstring static_type_name() { return "Grt"; }
    void dbprint(std::ostream &out) const override ;
    public: Grt *clone() const override { return new Grt(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Grt(Util::SourceInfo srcInfo,
        const Expression* left,
        const Expression* right) :
        Operation_Relation(srcInfo, left, right)
    { validate(); }
};
}
namespace IR {
class Geq : public Operation_Relation {
 public:
    cstring getStringOp() const { return ">="; }
    int getPrecedence() const { return DBPrint::Prec_Geq; }
# 150 "../ir/expression.def"
 Geq(const Expression *l, const Expression *r) : Operation_Relation(l, r) {}
# 2328 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Geq&a) const {
        return Operation_Relation::operator==(a);
    }
    cstring node_type_name() const override { return "Geq"; }
    static cstring static_type_name() { return "Geq"; }
    void dbprint(std::ostream &out) const override ;
    public: Geq *clone() const override { return new Geq(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Geq(Util::SourceInfo srcInfo,
        const Expression* left,
        const Expression* right) :
        Operation_Relation(srcInfo, left, right)
    { validate(); }
};
}
namespace IR {
class BAnd : public Operation_Binary {
 public:
    cstring getStringOp() const { return "&"; }
    int getPrecedence() const { return DBPrint::Prec_BAnd; }
# 157 "../ir/expression.def"
 BAnd(const Expression *l, const Expression *r) : Operation_Binary(l, r) {}
# 2350 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const BAnd&a) const {
        return Operation_Binary::operator==(a);
    }
    cstring node_type_name() const override { return "BAnd"; }
    static cstring static_type_name() { return "BAnd"; }
    void dbprint(std::ostream &out) const override ;
    public: BAnd *clone() const override { return new BAnd(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    BAnd(Util::SourceInfo srcInfo,
        const Expression* left,
        const Expression* right) :
        Operation_Binary(srcInfo, left, right)
    { validate(); }
};
}
namespace IR {
class BOr : public Operation_Binary {
 public:
    cstring getStringOp() const { return "|"; }
    int getPrecedence() const { return DBPrint::Prec_BOr; }
# 164 "../ir/expression.def"
 BOr(const Expression *l, const Expression *r) : Operation_Binary(l, r) {}
# 2372 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const BOr&a) const {
        return Operation_Binary::operator==(a);
    }
    cstring node_type_name() const override { return "BOr"; }
    static cstring static_type_name() { return "BOr"; }
    void dbprint(std::ostream &out) const override ;
    public: BOr *clone() const override { return new BOr(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    BOr(Util::SourceInfo srcInfo,
        const Expression* left,
        const Expression* right) :
        Operation_Binary(srcInfo, left, right)
    { validate(); }
};
}
namespace IR {
class BXor : public Operation_Binary {
 public:
    cstring getStringOp() const { return "^"; }
    int getPrecedence() const { return DBPrint::Prec_BXor; }
# 171 "../ir/expression.def"
 BXor(const Expression *l, const Expression *r) : Operation_Binary(l, r) {}
# 2394 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const BXor&a) const {
        return Operation_Binary::operator==(a);
    }
    cstring node_type_name() const override { return "BXor"; }
    static cstring static_type_name() { return "BXor"; }
    void dbprint(std::ostream &out) const override ;
    public: BXor *clone() const override { return new BXor(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    BXor(Util::SourceInfo srcInfo,
        const Expression* left,
        const Expression* right) :
        Operation_Binary(srcInfo, left, right)
    { validate(); }
};
}
namespace IR {
class LAnd : public Operation_Binary {
 public:
    cstring getStringOp() const { return "&&"; }
    int getPrecedence() const { return DBPrint::Prec_LAnd; }
# 178 "../ir/expression.def"
 LAnd(const Expression *l, const Expression *r) : Operation_Binary(l, r) {}
# 2416 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const LAnd&a) const {
        return Operation_Binary::operator==(a);
    }
    cstring node_type_name() const override { return "LAnd"; }
    static cstring static_type_name() { return "LAnd"; }
    void dbprint(std::ostream &out) const override ;
    public: LAnd *clone() const override { return new LAnd(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    LAnd(Util::SourceInfo srcInfo,
        const Expression* left,
        const Expression* right) :
        Operation_Binary(srcInfo, left, right)
    { validate(); }
};
}
namespace IR {
class LOr : public Operation_Binary {
 public:
    cstring getStringOp() const { return "||"; }
    int getPrecedence() const { return DBPrint::Prec_LOr; }
# 185 "../ir/expression.def"
 LOr(const Expression *l, const Expression *r) : Operation_Binary(l, r) {}
# 2438 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const LOr&a) const {
        return Operation_Binary::operator==(a);
    }
    cstring node_type_name() const override { return "LOr"; }
    static cstring static_type_name() { return "LOr"; }
    void dbprint(std::ostream &out) const override ;
    public: LOr *clone() const override { return new LOr(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    LOr(Util::SourceInfo srcInfo,
        const Expression* left,
        const Expression* right) :
        Operation_Binary(srcInfo, left, right)
    { validate(); }
};
}
namespace IR {
class Constant : public Expression, public virtual CompileTimeValue {
 public:
    mpz_class value;
    unsigned base;
# 195 "../ir/expression.def"

    void handleOverflow(bool noWarning);
    explicit Constant(intmax_t v, unsigned base = 10) :
            Expression(new Type_InfInt()), value(v), base(base) {}
    explicit Constant(mpz_class v, unsigned base = 10) :
            Expression(new Type_InfInt()), value(v), base(base) {}
    Constant(Util::SourceInfo si, mpz_class v, unsigned base = 10) :
            Expression(si, new Type_InfInt()), value(v), base(base) {}
    Constant(const Type *t, mpz_class v, unsigned base = 10, bool noWarning = false) :
            Expression(t), value(v), base(base) { do { if ((t) == nullptr) do { throw Util::CompilerBug("../ir/expression.def", 204, "../ir/expression.def" ":" "204" ": Null " "t"); } while (0); } while (0); handleOverflow(noWarning); }
    Constant(Util::SourceInfo si, const Type *t, mpz_class v,
             unsigned base = 10, bool noWarning = false) :
            Expression(si, t), value(v), base(base) { do { if ((t) == nullptr) do { throw Util::CompilerBug("../ir/expression.def", 207, "../ir/expression.def" ":" "207" ": Null " "t"); } while (0); } while (0); handleOverflow(noWarning); }
    static Constant GetMask(unsigned width);
    bool fitsInt() const { return value.fits_sint_p(); }
    bool fitsLong() const { return value.fits_slong_p(); }
    long asLong() const {
        if (!fitsLong())
            ::error("%1%: Value too large", this);
        return value.get_si(); }
    int asInt() const {
        if (!fitsInt())
            ::error("%1%: Value too large", this);
        return value.get_si(); }



    Constant operator<<(const unsigned &shift) const;
    Constant operator>>(const unsigned &shift) const;
    Constant operator&(const Constant &c) const;
    Constant operator-(const Constant &c) const;
# 2490 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 227 "../ir/expression.def"
 cstring toString() const override { return Util::toString(&value); }
# 2493 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    bool operator==(const Constant&a) const {
        return Expression::operator==(a)
        && value == a.value
        && base == a.base;
    }
    cstring node_type_name() const override { return "Constant"; }
    static cstring static_type_name() { return "Constant"; }
    void dbprint(std::ostream &out) const override ;
    void dump_fields(std::ostream& out) const override;
    public: Constant *clone() const override { return new Constant(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
};
}
namespace IR {
class BoolLiteral : public Expression, public virtual CompileTimeValue {
 public:
    bool value;
# 233 "../ir/expression.def"
 cstring toString() const override { return value ? "true" : "false"; }
# 2514 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const BoolLiteral&a) const {
        return Expression::operator==(a)
        && value == a.value;
    }
    cstring node_type_name() const override { return "BoolLiteral"; }
    static cstring static_type_name() { return "BoolLiteral"; }
    void dbprint(std::ostream &out) const override ;
    void dump_fields(std::ostream& out) const override;
    public: BoolLiteral *clone() const override { return new BoolLiteral(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    BoolLiteral(Util::SourceInfo srcInfo,
        bool value) :
        Expression(srcInfo),
        value(value)
    { validate(); }
};
}
namespace IR {
class StringLiteral : public Expression {
 public:
    cstring value;
# 238 "../ir/expression.def"
 void validate() const override { if (value.isNull()) do { throw Util::CompilerBug("../ir/expression.def", 238, "null StringLiteral"); } while (0); }
# 2537 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 239 "../ir/expression.def"
 cstring toString() const override { return cstring("\"") + value + "\""; }
# 2540 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const StringLiteral&a) const {
        return Expression::operator==(a)
        && value == a.value;
    }
    cstring node_type_name() const override { return "StringLiteral"; }
    static cstring static_type_name() { return "StringLiteral"; }
    void dbprint(std::ostream &out) const override ;
    void dump_fields(std::ostream& out) const override;
    public: StringLiteral *clone() const override { return new StringLiteral(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    StringLiteral(Util::SourceInfo srcInfo,
        cstring value) :
        Expression(srcInfo),
        value(value)
    { validate(); }
};
}
namespace IR {
class PathExpression : public Expression {
 public:
    const Path* path = nullptr;
# 246 "../ir/expression.def"
 explicit PathExpression(IR::ID id) :
            Expression(id.srcInfo), path(new IR::Path(id)) {}
    explicit PathExpression(const Path* path)
        : Expression(path->srcInfo), path(path)
    { do { if ((path) == nullptr) do { throw Util::CompilerBug("../ir/expression.def", 250, "../ir/expression.def" ":" "250" ": Null " "path"); } while (0); } while (0); }
# 2567 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 252 "../ir/expression.def"
 cstring toString() const override { return path->toString(); }
# 2570 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const PathExpression&a) const {
        return Expression::operator==(a)
        && path == a.path;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((path) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 2577, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "2577" ": Null " "path"); } while (0); } while (0); }
    cstring node_type_name() const override { return "PathExpression"; }
    static cstring static_type_name() { return "PathExpression"; }
    void dbprint(std::ostream &out) const override ;
    public: PathExpression *clone() const override { return new PathExpression(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
};
}
namespace IR {
class TypeNameExpression : public Expression {
 public:
    const Type_Name* typeName = nullptr;
# 261 "../ir/expression.def"
 TypeNameExpression(ID id) : typeName(new IR::Type_Name(new IR::Path(id))) {}
# 2591 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 263 "../ir/expression.def"
 void dbprint(std::ostream &out) const override { Node::dbprint(out); out << typeName; }
# 2594 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 264 "../ir/expression.def"
 cstring toString() const override { return typeName->toString(); }
# 2597 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const TypeNameExpression&a) const {
        return Expression::operator==(a)
        && typeName == a.typeName;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((typeName) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 2604, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "2604" ": Null " "typeName"); } while (0); } while (0); }
    cstring node_type_name() const override { return "TypeNameExpression"; }
    static cstring static_type_name() { return "TypeNameExpression"; }
    public: TypeNameExpression *clone() const override { return new TypeNameExpression(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    TypeNameExpression(Util::SourceInfo srcInfo,
        const Type_Name* typeName) :
        Expression(srcInfo),
        typeName(typeName)
    { validate(); }
};
}
namespace IR {
class Slice : public Operation_Ternary {
 public:
    int getPrecedence() const { return DBPrint::Prec_Postfix; }
    cstring getStringOp() const { return "[:]"; }
# 270 "../ir/expression.def"
 cstring toString() const override { return e0->toString() + "[" + e1->toString() + ":" + e2->toString() + "]"; }
# 2623 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 273 "../ir/expression.def"
 int getH() const { return e1->to<IR::Constant>()->asInt(); }
    int getL() const { return e2->to<IR::Constant>()->asInt(); }
    Slice(const Expression *a, int hi, int lo)
    : Operation_Ternary(a, new Constant(hi), new Constant(lo)) {}
    Slice(const Util::SourceInfo &si, const Expression *a, int hi, int lo)
    : Operation_Ternary(si, a, new Constant(hi), new Constant(lo)) {}
# 2631 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Slice&a) const {
        return Operation_Ternary::operator==(a);
    }
    cstring node_type_name() const override { return "Slice"; }
    static cstring static_type_name() { return "Slice"; }
    void dbprint(std::ostream &out) const override ;
    public: Slice *clone() const override { return new Slice(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Slice(Util::SourceInfo srcInfo,
        const Expression* e0,
        const Expression* e1,
        const Expression* e2) :
        Operation_Ternary(srcInfo, e0, e1, e2)
    { validate(); }
};
}
namespace IR {
class Member : public Operation_Unary {
 public:
    ID member;
# 285 "../ir/expression.def"
 Member(Util::SourceInfo si, const Type *t, const Expression *b, cstring n)
    : Operation_Unary(si, t, b), member(n) {}
    Member(const Expression *b, ID n) : Operation_Unary(b), member(n) {}
    Member(const Type *t, const Expression *b, cstring n) : Operation_Unary(t, b), member(n) {}
    virtual int offset_bits() const;
    int lsb() const;
    int msb() const;
# 2659 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 cstring getStringOp() const { return "."; }
# 294 "../ir/expression.def"
 cstring toString() const override { return expr->toString() + "." + member; }
# 2663 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Member&a) const {
        return Operation_Unary::operator==(a)
        && member == a.member;
    }
    cstring node_type_name() const override { return "Member"; }
    static cstring static_type_name() { return "Member"; }
    void dbprint(std::ostream &out) const override ;
    void dump_fields(std::ostream& out) const override;
    public: Member *clone() const override { return new Member(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Member(Util::SourceInfo srcInfo,
        const Expression* expr,
        ID member) :
        Operation_Unary(srcInfo, expr),
        member(member)
    { validate(); }
};
}
namespace IR {
class Concat : public Operation_Binary {
 public:
    cstring getStringOp() const { return "++"; }
    int getPrecedence() const { return DBPrint::Prec_Add; }
    bool operator==(const Concat&a) const {
        return Operation_Binary::operator==(a);
    }
    cstring node_type_name() const override { return "Concat"; }
    static cstring static_type_name() { return "Concat"; }
    void dbprint(std::ostream &out) const override ;
    public: Concat *clone() const override { return new Concat(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Concat(Util::SourceInfo srcInfo,
        const Expression* left,
        const Expression* right) :
        Operation_Binary(srcInfo, left, right)
    { validate(); }
};
}
namespace IR {
class ArrayIndex : public Operation_Binary {
 public:
    cstring getStringOp() const { return "[]"; }
    int getPrecedence() const { return DBPrint::Prec_Postfix; }
    bool operator==(const ArrayIndex&a) const {
        return Operation_Binary::operator==(a);
    }
    cstring node_type_name() const override { return "ArrayIndex"; }
    static cstring static_type_name() { return "ArrayIndex"; }
    void dbprint(std::ostream &out) const override ;
    public: ArrayIndex *clone() const override { return new ArrayIndex(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    ArrayIndex(Util::SourceInfo srcInfo,
        const Expression* left,
        const Expression* right) :
        Operation_Binary(srcInfo, left, right)
    { validate(); }
};
}
namespace IR {
class Range : public Operation_Binary {
 public:
    cstring getStringOp() const { return ".."; }
    int getPrecedence() const { return DBPrint::Prec_Low; }
    bool operator==(const Range&a) const {
        return Operation_Binary::operator==(a);
    }
    cstring node_type_name() const override { return "Range"; }
    static cstring static_type_name() { return "Range"; }
    void dbprint(std::ostream &out) const override ;
    public: Range *clone() const override { return new Range(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Range(Util::SourceInfo srcInfo,
        const Expression* left,
        const Expression* right) :
        Operation_Binary(srcInfo, left, right)
    { validate(); }
};
}
namespace IR {
class Mask : public Operation_Binary {
 public:
    cstring getStringOp() const { return "&&&"; }
    int getPrecedence() const { return DBPrint::Prec_Low; }
    bool operator==(const Mask&a) const {
        return Operation_Binary::operator==(a);
    }
    cstring node_type_name() const override { return "Mask"; }
    static cstring static_type_name() { return "Mask"; }
    void dbprint(std::ostream &out) const override ;
    public: Mask *clone() const override { return new Mask(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Mask(Util::SourceInfo srcInfo,
        const Expression* left,
        const Expression* right) :
        Operation_Binary(srcInfo, left, right)
    { validate(); }
};
}
namespace IR {
class Mux : public Operation_Ternary {
 public:
    cstring getStringOp() const { return "?:"; }
    int getPrecedence() const { return DBPrint::Prec_Low; }
    bool operator==(const Mux&a) const {
        return Operation_Ternary::operator==(a);
    }
    cstring node_type_name() const override { return "Mux"; }
    static cstring static_type_name() { return "Mux"; }
    void dbprint(std::ostream &out) const override ;
    public: Mux *clone() const override { return new Mux(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Mux(Util::SourceInfo srcInfo,
        const Expression* e0,
        const Expression* e1,
        const Expression* e2) :
        Operation_Ternary(srcInfo, e0, e1, e2)
    { validate(); }
};
}
namespace IR {
class DefaultExpression : public Expression {
 public:
    bool operator==(const DefaultExpression&a) const {
        return Expression::operator==(a);
    }
    cstring node_type_name() const override { return "DefaultExpression"; }
    static cstring static_type_name() { return "DefaultExpression"; }
    void dbprint(std::ostream &out) const override ;
    public: DefaultExpression *clone() const override { return new DefaultExpression(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    DefaultExpression(Util::SourceInfo srcInfo) :
        Expression(srcInfo)
    { validate(); }
};
}
namespace IR {
class This : public Expression {
 public:
    bool operator==(const This&a) const {
        return Expression::operator==(a);
    }
    cstring node_type_name() const override { return "This"; }
    static cstring static_type_name() { return "This"; }
    void dbprint(std::ostream &out) const override ;
    public: This *clone() const override { return new This(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    This(Util::SourceInfo srcInfo) :
        Expression(srcInfo)
    { validate(); }
};
}
namespace IR {
class Cast : public Operation_Unary {
 public:
    const Type* destType = nullptr;
# 329 "../ir/expression.def"

    Cast(Util::SourceInfo srcInfo, const IR::Type* type, const IR::Expression *expression) :
            Operation_Unary(srcInfo, type, expression), destType(type) {}
# 2815 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 int getPrecedence() const { return DBPrint::Prec_Prefix; }
    cstring getStringOp() const { return "(cast)"; }
# 335 "../ir/expression.def"
 cstring toString() const override { return "cast"; }
# 2820 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 336 "../ir/expression.def"
 void validate() const override {
        do { if ((destType) == nullptr) do { throw Util::CompilerBug("../ir/expression.def", 337, "../ir/expression.def" ":" "337" ": Null " "destType"); } while (0); } while (0);{ if (destType->is<Type_Unknown>()) do { throw Util::CompilerBug("../ir/expression.def", 337, "%1%: Cannot cast to unknown type", this); } while (0); } }
# 2824 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Cast&a) const {
        return Operation_Unary::operator==(a)
        && destType == a.destType;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    cstring node_type_name() const override { return "Cast"; }
    static cstring static_type_name() { return "Cast"; }
    void dbprint(std::ostream &out) const override ;
    public: Cast *clone() const override { return new Cast(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Cast(Util::SourceInfo srcInfo,
        const Expression* expr,
        const Type* destType) :
        Operation_Unary(srcInfo, expr),
        destType(destType)
    { validate(); }
};
}
namespace IR {
class SelectExpression : public Expression {
 public:
    const ListExpression* select = nullptr;
    const Vector<SelectCase>* selectCases = nullptr;
# 343 "../ir/expression.def"
 void validate() const override {
        do { if ((select) == nullptr) do { throw Util::CompilerBug("../ir/expression.def", 344, "../ir/expression.def" ":" "344" ": Null " "select"); } while (0); } while (0);
        do { if ((selectCases) == nullptr) do { throw Util::CompilerBug("../ir/expression.def", 345, "../ir/expression.def" ":" "345" ": Null " "selectCases"); } while (0); } while (0);{ selectCases->check_null(); } }
# 2852 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const SelectExpression&a) const {
        return Expression::operator==(a)
        && select == a.select
        && selectCases == a.selectCases;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    cstring node_type_name() const override { return "SelectExpression"; }
    static cstring static_type_name() { return "SelectExpression"; }
    public: SelectExpression *clone() const override { return new SelectExpression(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    SelectExpression(Util::SourceInfo srcInfo,
        const ListExpression* select,
        const Vector<SelectCase>* selectCases) :
        Expression(srcInfo),
        select(select),
        selectCases(selectCases)
    { validate(); }
};
}
namespace IR {
class MethodCallExpression : public Expression {
 public:
    const Expression* method = nullptr;
    const Vector<Type>* typeArguments = nullptr;
    const Vector<Expression>* arguments = nullptr;
# 350 "../ir/expression.def"
 cstring toString() const override { return method->toString(); }
# 2880 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 351 "../ir/expression.def"
 void validate() const override {
        do { if ((method) == nullptr) do { throw Util::CompilerBug("../ir/expression.def", 352, "../ir/expression.def" ":" "352" ": Null " "method"); } while (0); } while (0);
        do { if ((typeArguments) == nullptr) do { throw Util::CompilerBug("../ir/expression.def", 353, "../ir/expression.def" ":" "353" ": Null " "typeArguments"); } while (0); } while (0);
        do { if ((arguments) == nullptr) do { throw Util::CompilerBug("../ir/expression.def", 354, "../ir/expression.def" ":" "354" ": Null " "arguments"); } while (0); } while (0);{ typeArguments->check_null(); arguments->check_null(); } }
# 2886 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const MethodCallExpression&a) const {
        return Expression::operator==(a)
        && method == a.method
        && typeArguments == a.typeArguments
        && arguments == a.arguments;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    cstring node_type_name() const override { return "MethodCallExpression"; }
    static cstring static_type_name() { return "MethodCallExpression"; }
    void dbprint(std::ostream &out) const override ;
    public: MethodCallExpression *clone() const override { return new MethodCallExpression(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    MethodCallExpression(Util::SourceInfo srcInfo,
        const Expression* method,
        const Vector<Type>* typeArguments,
        const Vector<Expression>* arguments) :
        Expression(srcInfo),
        method(method),
        typeArguments(typeArguments),
        arguments(arguments)
    { validate(); }
};
}
namespace IR {
class ConstructorCallExpression : public Expression {
 public:
    const Type* constructedType = nullptr;
    const Vector<Expression>* arguments = nullptr;
# 359 "../ir/expression.def"
 ConstructorCallExpression(Util::SourceInfo srcInfo, const Type* type,
                              const Vector<Expression> *arguments) :
            Expression(srcInfo), constructedType(type), arguments(arguments) {}
# 2919 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 363 "../ir/expression.def"
 cstring toString() const override { return constructedType->toString(); }
# 2922 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 364 "../ir/expression.def"
 void validate() const override {
        do { if ((constructedType) == nullptr) do { throw Util::CompilerBug("../ir/expression.def", 365, "../ir/expression.def" ":" "365" ": Null " "constructedType"); } while (0); } while (0);
        do { if ((arguments) == nullptr) do { throw Util::CompilerBug("../ir/expression.def", 366, "../ir/expression.def" ":" "366" ": Null " "arguments"); } while (0); } while (0);{ arguments->check_null(); } }
# 2927 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const ConstructorCallExpression&a) const {
        return Expression::operator==(a)
        && constructedType == a.constructedType
        && arguments == a.arguments;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    cstring node_type_name() const override { return "ConstructorCallExpression"; }
    static cstring static_type_name() { return "ConstructorCallExpression"; }
    void dbprint(std::ostream &out) const override ;
    public: ConstructorCallExpression *clone() const override { return new ConstructorCallExpression(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
};
}
namespace IR {
class ListExpression : public Expression {
 public:
    const Vector<Expression>* components = nullptr;
# 370 "../ir/expression.def"
 void validate() const override {
        do { if ((components) == nullptr) do { throw Util::CompilerBug("../ir/expression.def", 371, "../ir/expression.def" ":" "371" ": Null " "components"); } while (0); } while (0);{
        if (components->empty()) do { throw Util::CompilerBug("../ir/expression.def", 372, "List expression with no components"); } while (0);
        components->check_null();
    } }
# 2951 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const ListExpression&a) const {
        return Expression::operator==(a)
        && components == a.components;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    cstring node_type_name() const override { return "ListExpression"; }
    static cstring static_type_name() { return "ListExpression"; }
    void dbprint(std::ostream &out) const override ;
    public: ListExpression *clone() const override { return new ListExpression(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    ListExpression(Util::SourceInfo srcInfo,
        const Vector<Expression>* components) :
        Expression(srcInfo),
        components(components)
    { validate(); }
};
}
namespace IR {
class SelectCase : public Node {
 public:
    const Expression* keyset = nullptr;
    const PathExpression* state = nullptr;
    bool operator==(const SelectCase&a) const {
        return typeid(*this) == typeid(a)
        && keyset == a.keyset
        && state == a.state;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((keyset) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 2981, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "2981" ": Null " "keyset"); } while (0); } while (0);
        do { if ((state) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 2982, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "2982" ": Null " "state"); } while (0); } while (0); }
    cstring node_type_name() const override { return "SelectCase"; }
    static cstring static_type_name() { return "SelectCase"; }
    public: SelectCase *clone() const override { return new SelectCase(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    SelectCase(Util::SourceInfo srcInfo,
        const Expression* keyset,
        const PathExpression* state) :
        Node(srcInfo),
        keyset(keyset),
        state(state)
    { validate(); }
};
}
namespace IR {
class ParserState : public virtual IGeneralNamespace, public Declaration, public virtual IAnnotated {
 public:
    const Annotations* annotations = nullptr;
    const Vector<StatOrDecl>* components = nullptr;
    const Expression* selectExpression = nullptr;
# 44 "../ir/ir.def"
 const Annotations* getAnnotations() const override { return annotations; }
    Util::Enumerator<const IDeclaration*>* getDeclarations() const
    { return components->only<IDeclaration>(); }

    static const ID accept;
    static const ID reject;
    static const ID start;
    bool isBuiltin() const { return name == ParserState::accept || name == ParserState::reject; }
# 3011 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 54 "../ir/ir.def"
 void validate() const override {
        do { if ((annotations) == nullptr) do { throw Util::CompilerBug("../ir/ir.def", 55, "../ir/ir.def" ":" "55" ": Null " "annotations"); } while (0); } while (0);
        do { if ((components) == nullptr) do { throw Util::CompilerBug("../ir/ir.def", 56, "../ir/ir.def" ":" "56" ": Null " "components"); } while (0); } while (0);{ components->check_null(); } }
# 3016 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const ParserState&a) const {
        return Declaration::operator==(a)
        && annotations == a.annotations
        && components == a.components
        && selectExpression == a.selectExpression;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    cstring node_type_name() const override { return "ParserState"; }
    static cstring static_type_name() { return "ParserState"; }
    public: ParserState *clone() const override { return new ParserState(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    ParserState(Util::SourceInfo srcInfo,
        ID name,
        const Annotations* annotations,
        const Vector<StatOrDecl>* components,
        const Expression* selectExpression) :
        Declaration(srcInfo, name),
        annotations(annotations),
        components(components),
        selectExpression(selectExpression)
    { validate(); }
};
}
namespace IR {
class P4Parser : public Type_Declaration, public virtual IGeneralNamespace, public virtual IApply, public virtual IContainer {
 public:
    const Type_Parser* type = nullptr;
    const ParameterList* constructorParams = nullptr;
    const Vector<Declaration>* stateful = nullptr;
    const Vector<ParserState>* states = nullptr;
# 64 "../ir/ir.def"
 const TypeParameters* getTypeParameters() const override { return type->getTypeParameters(); }
    Util::Enumerator<const IDeclaration*>* getDeclarations() const override
    { return stateful->getEnumerator()->
                       as<const IDeclaration*>()->
                       concat(states->only<IDeclaration>()); }
    const Type_Method* getApplyMethodType() const override { return type->getApplyMethodType(); }
    const Type_Method* getConstructorMethodType() const override;
    const ParameterList* getConstructorParameters() const override { return constructorParams; }
# 3056 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 const P4Parser *apply(Visitor &v) const; const P4Parser *apply(Visitor &&v) const { return apply(v); }
# 75 "../ir/ir.def"
 void validate() const override {
        do { if ((type) == nullptr) do { throw Util::CompilerBug("../ir/ir.def", 76, "../ir/ir.def" ":" "76" ": Null " "type"); } while (0); } while (0);
        do { if ((constructorParams) == nullptr) do { throw Util::CompilerBug("../ir/ir.def", 77, "../ir/ir.def" ":" "77" ": Null " "constructorParams"); } while (0); } while (0);
        do { if ((stateful) == nullptr) do { throw Util::CompilerBug("../ir/ir.def", 78, "../ir/ir.def" ":" "78" ": Null " "stateful"); } while (0); } while (0);
        do { if ((states) == nullptr) do { throw Util::CompilerBug("../ir/ir.def", 79, "../ir/ir.def" ":" "79" ": Null " "states"); } while (0); } while (0);{
        if (!(name == type->name))
            do { throw Util::CompilerBug("../ir/ir.def", 81, "Name mismatch for %1%: %2% != %3%", this, name, type->name); } while (0);
        stateful->check_null();
        states->check_null();
    } }
# 3069 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 81 "../ir/ir.def"
 cstring toString() const override { return cstring("parser ") + externalName(); }
# 3072 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const P4Parser&a) const {
        return Type_Declaration::operator==(a)
        && type == a.type
        && constructorParams == a.constructorParams
        && stateful == a.stateful
        && states == a.states;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    cstring node_type_name() const override { return "P4Parser"; }
    static cstring static_type_name() { return "P4Parser"; }
    public: P4Parser *clone() const override { return new P4Parser(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    P4Parser(Util::SourceInfo srcInfo,
        ID name,
        const Type_Parser* type,
        const ParameterList* constructorParams,
        const Vector<Declaration>* stateful,
        const Vector<ParserState>* states) :
        Type_Declaration(srcInfo, name),
        type(type),
        constructorParams(constructorParams),
        stateful(stateful),
        states(states)
    { validate(); }
};
}
namespace IR {
class P4Control : public Type_Declaration, public virtual ISimpleNamespace, public virtual IApply, public virtual IContainer {
 public:
    const Type_Control* type = nullptr;
    const ParameterList* constructorParams = nullptr;
    NameMap<Declaration, ordered_map> stateful;
    const BlockStatement* body = nullptr;
# 90 "../ir/ir.def"
 Util::Enumerator<const Declaration*>* statefulEnumerator() const
    { return stateful.valueEnumerator(); }
    const TypeParameters* getTypeParameters() const { return type->getTypeParameters(); }
    Util::Enumerator<const IDeclaration*>* getDeclarations() const override;
    const Type_Method* getApplyMethodType() const override { return type->getApplyMethodType(); }
    const Type_Method* getConstructorMethodType() const override;
    const IDeclaration* getDeclByName(cstring name) const override
    { return stateful.getUnique(name); }
    const ParameterList* getConstructorParameters() const override { return constructorParams; }
# 3116 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 const P4Control *apply(Visitor &v) const; const P4Control *apply(Visitor &&v) const { return apply(v); }
# 102 "../ir/ir.def"
 void validate() const override {
        do { if ((type) == nullptr) do { throw Util::CompilerBug("../ir/ir.def", 103, "../ir/ir.def" ":" "103" ": Null " "type"); } while (0); } while (0);
        do { if ((constructorParams) == nullptr) do { throw Util::CompilerBug("../ir/ir.def", 104, "../ir/ir.def" ":" "104" ": Null " "constructorParams"); } while (0); } while (0);
        stateful.validate();
        do { if ((body) == nullptr) do { throw Util::CompilerBug("../ir/ir.def", 106, "../ir/ir.def" ":" "106" ": Null " "body"); } while (0); } while (0);{
        if (!(name == type->name))
            do { throw Util::CompilerBug("../ir/ir.def", 108, "Name mismatch for %1%: %2% != %3%", this, name, type->name); } while (0);
        stateful.check_null();
    } }
# 3128 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 107 "../ir/ir.def"
 cstring toString() const override { return cstring("control ") + externalName(); }
# 3131 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const P4Control&a) const {
        return Type_Declaration::operator==(a)
        && type == a.type
        && constructorParams == a.constructorParams
        && stateful == a.stateful
        && body == a.body;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    cstring node_type_name() const override { return "P4Control"; }
    static cstring static_type_name() { return "P4Control"; }
    public: P4Control *clone() const override { return new P4Control(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    P4Control(Util::SourceInfo srcInfo,
        ID name,
        const Type_Control* type,
        const ParameterList* constructorParams,
        NameMap<Declaration, ordered_map> stateful,
        const BlockStatement* body) :
        Type_Declaration(srcInfo, name),
        type(type),
        constructorParams(constructorParams),
        stateful(stateful),
        body(body)
    { validate(); }
};
}
namespace IR {
class P4Action : public Declaration, public virtual IGeneralNamespace, public virtual IAnnotated {
 public:
    const Annotations* annotations = nullptr;
    const ParameterList* parameters = nullptr;
    const IndexedVector<StatOrDecl>* body = nullptr;
# 115 "../ir/ir.def"
 Util::Enumerator<const IDeclaration*>* getDeclarations() const
    { return body->only<IDeclaration>(); }
    const Annotations* getAnnotations() const override { return annotations; }
# 3168 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 119 "../ir/ir.def"
 void validate() const override {
        do { if ((annotations) == nullptr) do { throw Util::CompilerBug("../ir/ir.def", 120, "../ir/ir.def" ":" "120" ": Null " "annotations"); } while (0); } while (0);
        do { if ((parameters) == nullptr) do { throw Util::CompilerBug("../ir/ir.def", 121, "../ir/ir.def" ":" "121" ": Null " "parameters"); } while (0); } while (0);
        do { if ((body) == nullptr) do { throw Util::CompilerBug("../ir/ir.def", 122, "../ir/ir.def" ":" "122" ": Null " "body"); } while (0); } while (0);{ body->check_null(); } }
# 3174 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const P4Action&a) const {
        return Declaration::operator==(a)
        && annotations == a.annotations
        && parameters == a.parameters
        && body == a.body;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    cstring node_type_name() const override { return "P4Action"; }
    static cstring static_type_name() { return "P4Action"; }
    void dbprint(std::ostream &out) const override ;
    public: P4Action *clone() const override { return new P4Action(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    P4Action(Util::SourceInfo srcInfo,
        ID name,
        const Annotations* annotations,
        const ParameterList* parameters,
        const IndexedVector<StatOrDecl>* body) :
        Declaration(srcInfo, name),
        annotations(annotations),
        parameters(parameters),
        body(body)
    { validate(); }
};
}
namespace IR {
class Declaration_Errors : public Declaration, public virtual ISimpleNamespace {
 public:
    NameMap<Declaration_ID, ordered_map> members;
# 125 "../ir/ir.def"
 static const ID EID;
    Util::Enumerator<const IDeclaration*>* getDeclarations() const
    { return getEnumerator()->as<const IDeclaration*>(); }
    Util::Enumerator<const Declaration_ID*>* getEnumerator() const
    { return members.valueEnumerator(); }
    const IDeclaration* getDeclByName(cstring name) const
    { return members.getUnique(name); }
# 3211 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 134 "../ir/ir.def"
 void validate() const override {
        members.validate();{ members.check_null(); } }
# 3215 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Declaration_Errors&a) const {
        return Declaration::operator==(a)
        && members == a.members;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    cstring node_type_name() const override { return "Declaration_Errors"; }
    static cstring static_type_name() { return "Declaration_Errors"; }
    public: Declaration_Errors *clone() const override { return new Declaration_Errors(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Declaration_Errors(Util::SourceInfo srcInfo,
        ID name,
        NameMap<Declaration_ID, ordered_map> members) :
        Declaration(srcInfo, name),
        members(members)
    { validate(); }
};
}
namespace IR {
class Declaration_MatchKind : public Declaration, public virtual ISimpleNamespace {
 public:
    NameMap<Declaration_ID, ordered_map> members;
# 140 "../ir/ir.def"
 static const ID MKID;
    Util::Enumerator<const IDeclaration*>* getDeclarations() const
    { return getEnumerator()->as<const IDeclaration*>(); }
    Util::Enumerator<const Declaration_ID*>* getEnumerator() const
    { return members.valueEnumerator(); }
    const IDeclaration* getDeclByName(cstring name) const
    { return members.getUnique(name); }
# 3245 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 149 "../ir/ir.def"
 void validate() const override {
        members.validate();{ members.check_null(); } }
# 3249 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Declaration_MatchKind&a) const {
        return Declaration::operator==(a)
        && members == a.members;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    cstring node_type_name() const override { return "Declaration_MatchKind"; }
    static cstring static_type_name() { return "Declaration_MatchKind"; }
    public: Declaration_MatchKind *clone() const override { return new Declaration_MatchKind(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Declaration_MatchKind(Util::SourceInfo srcInfo,
        ID name,
        NameMap<Declaration_ID, ordered_map> members) :
        Declaration(srcInfo, name),
        members(members)
    { validate(); }
};
}
namespace IR {
class PropertyValue : public Node {
 public:
    bool operator==(const PropertyValue&a) const {
        return typeid(*this) == typeid(a);
    }
    cstring node_type_name() const override { return "PropertyValue"; }
    static cstring static_type_name() { return "PropertyValue"; }
    public: PropertyValue *clone() const override = 0; public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
 protected:
    PropertyValue(Util::SourceInfo srcInfo) :
        Node(srcInfo)
    { validate(); }
 public:
};
}
namespace IR {
class ExpressionValue : public PropertyValue {
 public:
    const Expression* expression = nullptr;
    bool operator==(const ExpressionValue&a) const {
        return PropertyValue::operator==(a)
        && expression == a.expression;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((expression) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 3293, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "3293" ": Null " "expression"); } while (0); } while (0); }
    cstring node_type_name() const override { return "ExpressionValue"; }
    static cstring static_type_name() { return "ExpressionValue"; }
    public: ExpressionValue *clone() const override { return new ExpressionValue(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    ExpressionValue(Util::SourceInfo srcInfo,
        const Expression* expression) :
        PropertyValue(srcInfo),
        expression(expression)
    { validate(); }
};
}
namespace IR {
class ActionListElement : public Node, public virtual IAnnotated {
 public:
    const Annotations* annotations = nullptr;
    const PathExpression* name = nullptr;
    const Vector<Expression>* arguments = nullptr;
# 170 "../ir/ir.def"
 ID getName() const { return name->path->name; }
    const Annotations* getAnnotations() const override { return annotations; }
# 3314 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const ActionListElement&a) const {
        return typeid(*this) == typeid(a)
        && annotations == a.annotations
        && name == a.name
        && arguments == a.arguments;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((annotations) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 3323, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "3323" ": Null " "annotations"); } while (0); } while (0);
        do { if ((name) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 3324, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "3324" ": Null " "name"); } while (0); } while (0); }
    cstring node_type_name() const override { return "ActionListElement"; }
    static cstring static_type_name() { return "ActionListElement"; }
    public: ActionListElement *clone() const override { return new ActionListElement(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    ActionListElement(Util::SourceInfo srcInfo,
        const Annotations* annotations,
        const PathExpression* name,
        const Vector<Expression>* arguments) :
        Node(srcInfo),
        annotations(annotations),
        name(name),
        arguments(arguments)
    { validate(); }
};
}
namespace IR {
class ActionList : public PropertyValue {
 public:
    const Vector<ActionListElement>* actionList = nullptr;
# 179 "../ir/ir.def"
 void checkDuplicates() const;
# 3346 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 182 "../ir/ir.def"
 void validate() const override {
        do { if ((actionList) == nullptr) do { throw Util::CompilerBug("../ir/ir.def", 183, "../ir/ir.def" ":" "183" ": Null " "actionList"); } while (0); } while (0);{ checkDuplicates(); actionList->check_null(); } }
# 3350 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const ActionList&a) const {
        return PropertyValue::operator==(a)
        && actionList == a.actionList;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    cstring node_type_name() const override { return "ActionList"; }
    static cstring static_type_name() { return "ActionList"; }
    public: ActionList *clone() const override { return new ActionList(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    ActionList(Util::SourceInfo srcInfo,
        const Vector<ActionListElement>* actionList) :
        PropertyValue(srcInfo),
        actionList(actionList)
    { validate(); }
};
}
namespace IR {
class KeyElement : public Node {
 public:
    const Expression* expression = nullptr;
    const PathExpression* matchType = nullptr;
    bool operator==(const KeyElement&a) const {
        return typeid(*this) == typeid(a)
        && expression == a.expression
        && matchType == a.matchType;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((expression) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 3379, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "3379" ": Null " "expression"); } while (0); } while (0);
        do { if ((matchType) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 3380, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "3380" ": Null " "matchType"); } while (0); } while (0); }
    cstring node_type_name() const override { return "KeyElement"; }
    static cstring static_type_name() { return "KeyElement"; }
    public: KeyElement *clone() const override { return new KeyElement(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    KeyElement(Util::SourceInfo srcInfo,
        const Expression* expression,
        const PathExpression* matchType) :
        Node(srcInfo),
        expression(expression),
        matchType(matchType)
    { validate(); }
};
}
namespace IR {
class Key : public PropertyValue {
 public:
    const Vector<KeyElement>* keyElements = nullptr;
# 195 "../ir/ir.def"
 void validate() const override {
        do { if ((keyElements) == nullptr) do { throw Util::CompilerBug("../ir/ir.def", 196, "../ir/ir.def" ":" "196" ": Null " "keyElements"); } while (0); } while (0);{ keyElements->check_null(); } }
# 3401 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Key&a) const {
        return PropertyValue::operator==(a)
        && keyElements == a.keyElements;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    cstring node_type_name() const override { return "Key"; }
    static cstring static_type_name() { return "Key"; }
    public: Key *clone() const override { return new Key(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Key(Util::SourceInfo srcInfo,
        const Vector<KeyElement>* keyElements) :
        PropertyValue(srcInfo),
        keyElements(keyElements)
    { validate(); }
};
}
namespace IR {
class TableProperty : public Declaration, public virtual IAnnotated {
 public:
    const Annotations* annotations = nullptr;
    const PropertyValue* value = nullptr;
    bool isConstant;
# 203 "../ir/ir.def"
 const Annotations* getAnnotations() const override { return annotations; }
# 3426 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const TableProperty&a) const {
        return Declaration::operator==(a)
        && annotations == a.annotations
        && value == a.value
        && isConstant == a.isConstant;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((annotations) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 3435, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "3435" ": Null " "annotations"); } while (0); } while (0);
        do { if ((value) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 3436, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "3436" ": Null " "value"); } while (0); } while (0); }
    cstring node_type_name() const override { return "TableProperty"; }
    static cstring static_type_name() { return "TableProperty"; }
    void dump_fields(std::ostream& out) const override;
    public: TableProperty *clone() const override { return new TableProperty(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    TableProperty(Util::SourceInfo srcInfo,
        ID name,
        const Annotations* annotations,
        const PropertyValue* value,
        bool isConstant) :
        Declaration(srcInfo, name),
        annotations(annotations),
        value(value),
        isConstant(isConstant)
    { validate(); }
};
}
namespace IR {
class TableProperties : public Node, public virtual ISimpleNamespace {
 public:
    NameMap<TableProperty, ordered_map> properties;
# 210 "../ir/ir.def"
 cstring toString() const override { return "TableProperties(" + Util::toString(properties.size()) + ")"; }
# 3460 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 212 "../ir/ir.def"
 TableProperties() {}
    Util::Enumerator<const IDeclaration*>* getDeclarations() const
    { return getEnumerator()->as<const IDeclaration*>(); }
    const TableProperty* getProperty(cstring name) const
    { return properties.getUnique(name); }
    Util::Enumerator<const TableProperty*>* getEnumerator() const
    { return properties.valueEnumerator(); }
    const IDeclaration* getDeclByName(cstring name) const
    { return properties.getUnique(name); }

    static const cstring actionsPropertyName;
    static const cstring keyPropertyName;
    static const cstring defaultActionPropertyName;
# 3475 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 227 "../ir/ir.def"
 void validate() const override {
        properties.validate();{ properties.check_null(); } }
# 3479 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const TableProperties&a) const {
        return typeid(*this) == typeid(a)
        && properties == a.properties;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    cstring node_type_name() const override { return "TableProperties"; }
    static cstring static_type_name() { return "TableProperties"; }
    public: TableProperties *clone() const override { return new TableProperties(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    TableProperties(Util::SourceInfo srcInfo,
        NameMap<TableProperty, ordered_map> properties) :
        Node(srcInfo),
        properties(properties)
    { validate(); }
};
}
namespace IR {
class P4Table : public Declaration, public virtual IAnnotated {
 public:
    const Annotations* annotations = nullptr;
    const ParameterList* parameters = nullptr;
    const TableProperties* properties = nullptr;
# 235 "../ir/ir.def"
 const Annotations* getAnnotations() const override { return annotations; }
    const ActionList* getActionList() const {
        auto ap = properties->getProperty(TableProperties::actionsPropertyName);
        if (ap == nullptr)
            return nullptr;
        if (!ap->value->is<IR::ActionList>()) {
            ::error("%1% must be an action list", ap);
            return nullptr;
        }
        return ap->value->to<IR::ActionList>();
    }
    const Key* getKey() const {
        auto kp = properties->getProperty(TableProperties::keyPropertyName);
        if (kp == nullptr)
            return nullptr;
        if (!kp->value->is<IR::Key>()) {
            ::error("%1% must be a key", kp);
            return nullptr;
        }
        return kp->value->to<IR::Key>();
    }
# 3524 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const P4Table&a) const {
        return Declaration::operator==(a)
        && annotations == a.annotations
        && parameters == a.parameters
        && properties == a.properties;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((annotations) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 3533, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "3533" ": Null " "annotations"); } while (0); } while (0);
        do { if ((parameters) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 3534, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "3534" ": Null " "parameters"); } while (0); } while (0);
        do { if ((properties) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 3535, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "3535" ": Null " "properties"); } while (0); } while (0); }
    cstring node_type_name() const override { return "P4Table"; }
    static cstring static_type_name() { return "P4Table"; }
    public: P4Table *clone() const override { return new P4Table(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    P4Table(Util::SourceInfo srcInfo,
        ID name,
        const Annotations* annotations,
        const ParameterList* parameters,
        const TableProperties* properties) :
        Declaration(srcInfo, name),
        annotations(annotations),
        parameters(parameters),
        properties(properties)
    { validate(); }
};
}
namespace IR {
class Declaration_Variable : public Declaration, public virtual IAnnotated {
 public:
    const Annotations* annotations = nullptr;
    const Type* type = nullptr;
    const Expression* initializer = nullptr;
# 265 "../ir/ir.def"
 const Annotations* getAnnotations() const override { return annotations; }
# 3560 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 267 "../ir/ir.def"
 void dbprint(std::ostream &out) const override { Declaration::dbprint(out);
        if (initializer) out << " = " << *initializer; }
# 3564 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Declaration_Variable&a) const {
        return Declaration::operator==(a)
        && annotations == a.annotations
        && type == a.type
        && initializer == a.initializer;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((annotations) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 3573, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "3573" ": Null " "annotations"); } while (0); } while (0);
        do { if ((type) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 3574, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "3574" ": Null " "type"); } while (0); } while (0); }
    cstring node_type_name() const override { return "Declaration_Variable"; }
    static cstring static_type_name() { return "Declaration_Variable"; }
    public: Declaration_Variable *clone() const override { return new Declaration_Variable(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Declaration_Variable(Util::SourceInfo srcInfo,
        ID name,
        const Annotations* annotations,
        const Type* type,
        const Expression* initializer) :
        Declaration(srcInfo, name),
        annotations(annotations),
        type(type),
        initializer(initializer)
    { validate(); }
};
}
namespace IR {
class Declaration_Constant : public Declaration, public virtual IAnnotated {
 public:
    const Annotations* annotations = nullptr;
    const Type* type = nullptr;
    const Expression* initializer = nullptr;
# 276 "../ir/ir.def"
 const Annotations* getAnnotations() const override { return annotations; }
# 3599 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 279 "../ir/ir.def"
 cstring toString() const override { return Declaration::toString(); }
# 3602 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Declaration_Constant&a) const {
        return Declaration::operator==(a)
        && annotations == a.annotations
        && type == a.type
        && initializer == a.initializer;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((annotations) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 3611, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "3611" ": Null " "annotations"); } while (0); } while (0);
        do { if ((type) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 3612, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "3612" ": Null " "type"); } while (0); } while (0);
        do { if ((initializer) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 3613, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "3613" ": Null " "initializer"); } while (0); } while (0); }
    cstring node_type_name() const override { return "Declaration_Constant"; }
    static cstring static_type_name() { return "Declaration_Constant"; }
    public: Declaration_Constant *clone() const override { return new Declaration_Constant(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Declaration_Constant(Util::SourceInfo srcInfo,
        ID name,
        const Annotations* annotations,
        const Type* type,
        const Expression* initializer) :
        Declaration(srcInfo, name),
        annotations(annotations),
        type(type),
        initializer(initializer)
    { validate(); }
};
}
namespace IR {
class Declaration_Instance : public Declaration, public virtual IAnnotated {
 public:
    const Type* type = nullptr;
    const Vector<Expression>* arguments = nullptr;
    const Annotations* annotations = nullptr;
    const BlockStatement* initializer = nullptr;
# 290 "../ir/ir.def"
 const Annotations* getAnnotations() const override { return annotations; }
# 3639 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 293 "../ir/ir.def"
 void validate() const override {
        do { if ((type) == nullptr) do { throw Util::CompilerBug("../ir/ir.def", 294, "../ir/ir.def" ":" "294" ": Null " "type"); } while (0); } while (0);
        do { if ((arguments) == nullptr) do { throw Util::CompilerBug("../ir/ir.def", 295, "../ir/ir.def" ":" "295" ": Null " "arguments"); } while (0); } while (0);
        do { if ((annotations) == nullptr) do { throw Util::CompilerBug("../ir/ir.def", 296, "../ir/ir.def" ":" "296" ": Null " "annotations"); } while (0); } while (0);{ arguments->check_null(); } }
# 3645 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Declaration_Instance&a) const {
        return Declaration::operator==(a)
        && type == a.type
        && arguments == a.arguments
        && annotations == a.annotations
        && initializer == a.initializer;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    cstring node_type_name() const override { return "Declaration_Instance"; }
    static cstring static_type_name() { return "Declaration_Instance"; }
    public: Declaration_Instance *clone() const override { return new Declaration_Instance(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Declaration_Instance(Util::SourceInfo srcInfo,
        ID name,
        const Type* type,
        const Vector<Expression>* arguments,
        const Annotations* annotations,
        const BlockStatement* initializer) :
        Declaration(srcInfo, name),
        type(type),
        arguments(arguments),
        annotations(annotations),
        initializer(initializer)
    { validate(); }
};
}
namespace IR {
class P4Program : public Node, public virtual IGeneralNamespace {
 public:
    const Vector<Node>* declarations = nullptr;
# 299 "../ir/ir.def"
 void validate() const override {
        do { if ((declarations) == nullptr) do { throw Util::CompilerBug("../ir/ir.def", 300, "../ir/ir.def" ":" "300" ": Null " "declarations"); } while (0); } while (0);{ checkDeclarations(); } }
# 3679 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 301 "../ir/ir.def"
 Util::Enumerator<const IDeclaration*>* getDeclarations() const
    { return declarations->getEnumerator()->as<const IDeclaration*>(); }
    void checkDeclarations() const;
    static const cstring main;
# 3685 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 const P4Program *apply(Visitor &v) const; const P4Program *apply(Visitor &&v) const { return apply(v); }
    bool operator==(const P4Program&a) const {
        return typeid(*this) == typeid(a)
        && declarations == a.declarations;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    cstring node_type_name() const override { return "P4Program"; }
    static cstring static_type_name() { return "P4Program"; }
    public: P4Program *clone() const override { return new P4Program(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    P4Program(Util::SourceInfo srcInfo,
        const Vector<Node>* declarations) :
        Node(srcInfo),
        declarations(declarations)
    { validate(); }
};
}
namespace IR {
class Statement : public StatOrDecl {
 public:
    bool operator==(const Statement&a) const {
        return StatOrDecl::operator==(a);
    }
    cstring node_type_name() const override { return "Statement"; }
    static cstring static_type_name() { return "Statement"; }
    public: Statement *clone() const override = 0; public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
 protected:
    Statement(Util::SourceInfo srcInfo) :
        StatOrDecl(srcInfo)
    { validate(); }
 public:
};
}
namespace IR {
class ExitStatement : public Statement {
 public:
# 317 "../ir/ir.def"
 cstring toString() const override { return "exit"; }
# 3724 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const ExitStatement&a) const {
        return Statement::operator==(a);
    }
    cstring node_type_name() const override { return "ExitStatement"; }
    static cstring static_type_name() { return "ExitStatement"; }
    public: ExitStatement *clone() const override { return new ExitStatement(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    ExitStatement(Util::SourceInfo srcInfo) :
        Statement(srcInfo)
    { validate(); }
};
}
namespace IR {
class ReturnStatement : public Statement {
 public:
    const Expression* expression = nullptr;
# 323 "../ir/ir.def"
 cstring toString() const override { return "return"; }
# 3742 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const ReturnStatement&a) const {
        return Statement::operator==(a)
        && expression == a.expression;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    cstring node_type_name() const override { return "ReturnStatement"; }
    static cstring static_type_name() { return "ReturnStatement"; }
    public: ReturnStatement *clone() const override { return new ReturnStatement(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    ReturnStatement(Util::SourceInfo srcInfo,
        const Expression* expression) :
        Statement(srcInfo),
        expression(expression)
    { validate(); }
};
}
namespace IR {
class EmptyStatement : public Statement {
 public:
    bool operator==(const EmptyStatement&a) const {
        return Statement::operator==(a);
    }
    cstring node_type_name() const override { return "EmptyStatement"; }
    static cstring static_type_name() { return "EmptyStatement"; }
    public: EmptyStatement *clone() const override { return new EmptyStatement(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    EmptyStatement(Util::SourceInfo srcInfo) :
        Statement(srcInfo)
    { validate(); }
};
}
namespace IR {
class AssignmentStatement : public Statement {
 public:
    const Expression* left = nullptr;
    const Expression* right = nullptr;
# 334 "../ir/ir.def"
 void dbprint(std::ostream &out) const override { out << left << " = " << right; }
# 3780 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const AssignmentStatement&a) const {
        return Statement::operator==(a)
        && left == a.left
        && right == a.right;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((left) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 3788, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "3788" ": Null " "left"); } while (0); } while (0);
        do { if ((right) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 3789, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "3789" ": Null " "right"); } while (0); } while (0); }
    cstring node_type_name() const override { return "AssignmentStatement"; }
    static cstring static_type_name() { return "AssignmentStatement"; }
    public: AssignmentStatement *clone() const override { return new AssignmentStatement(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    AssignmentStatement(Util::SourceInfo srcInfo,
        const Expression* left,
        const Expression* right) :
        Statement(srcInfo),
        left(left),
        right(right)
    { validate(); }
};
}
namespace IR {
class IfStatement : public Statement {
 public:
    const Expression* condition = nullptr;
    const Statement* ifTrue = nullptr;
    const Statement* ifFalse = nullptr;
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    bool operator==(const IfStatement&a) const {
        return Statement::operator==(a)
        && condition == a.condition
        && ifTrue == a.ifTrue
        && ifFalse == a.ifFalse;
    }
    void validate() const override {
        do { if ((condition) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 3817, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "3817" ": Null " "condition"); } while (0); } while (0);
        do { if ((ifTrue) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 3818, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "3818" ": Null " "ifTrue"); } while (0); } while (0); }
    cstring node_type_name() const override { return "IfStatement"; }
    static cstring static_type_name() { return "IfStatement"; }
    public: IfStatement *clone() const override { return new IfStatement(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    IfStatement(Util::SourceInfo srcInfo,
        const Expression* condition,
        const Statement* ifTrue,
        const Statement* ifFalse) :
        Statement(srcInfo),
        condition(condition),
        ifTrue(ifTrue),
        ifFalse(ifFalse)
    { validate(); }
};
}
namespace IR {
class BlockStatement : public Statement, public virtual ISimpleNamespace {
 public:
    const IndexedVector<StatOrDecl>* components = nullptr;
# 354 "../ir/ir.def"
 const IDeclaration* getDeclByName(cstring name) const
    { return components->getDeclaration(name); }
    Util::Enumerator<const IDeclaration*>* getDeclarations() const
    { return components->getDeclarations(); }
# 3843 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const BlockStatement&a) const {
        return Statement::operator==(a)
        && components == a.components;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((components) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 3850, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "3850" ": Null " "components"); } while (0); } while (0); }
    cstring node_type_name() const override { return "BlockStatement"; }
    static cstring static_type_name() { return "BlockStatement"; }
    void dbprint(std::ostream &out) const override ;
    public: BlockStatement *clone() const override { return new BlockStatement(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    BlockStatement(Util::SourceInfo srcInfo,
        const IndexedVector<StatOrDecl>* components) :
        Statement(srcInfo),
        components(components)
    { validate(); }
};
}
namespace IR {
class MethodCallStatement : public Statement {
 public:
    const MethodCallExpression* methodCall = nullptr;
    bool operator==(const MethodCallStatement&a) const {
        return Statement::operator==(a)
        && methodCall == a.methodCall;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((methodCall) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 3873, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "3873" ": Null " "methodCall"); } while (0); } while (0); }
    cstring node_type_name() const override { return "MethodCallStatement"; }
    static cstring static_type_name() { return "MethodCallStatement"; }
    void dbprint(std::ostream &out) const override ;
    public: MethodCallStatement *clone() const override { return new MethodCallStatement(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    MethodCallStatement(Util::SourceInfo srcInfo,
        const MethodCallExpression* methodCall) :
        Statement(srcInfo),
        methodCall(methodCall)
    { validate(); }
};
}
namespace IR {
class SwitchCase : public Node {
 public:
    const Expression* label = nullptr;
    const Statement* statement = nullptr;
    bool operator==(const SwitchCase&a) const {
        return typeid(*this) == typeid(a)
        && label == a.label
        && statement == a.statement;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((label) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 3898, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "3898" ": Null " "label"); } while (0); } while (0); }
    cstring node_type_name() const override { return "SwitchCase"; }
    static cstring static_type_name() { return "SwitchCase"; }
    public: SwitchCase *clone() const override { return new SwitchCase(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    SwitchCase(Util::SourceInfo srcInfo,
        const Expression* label,
        const Statement* statement) :
        Node(srcInfo),
        label(label),
        statement(statement)
    { validate(); }
};
}
namespace IR {
class SwitchStatement : public Statement {
 public:
    const Expression* expression = nullptr;
    const Vector<SwitchCase>* cases = nullptr;
    bool operator==(const SwitchStatement&a) const {
        return Statement::operator==(a)
        && expression == a.expression
        && cases == a.cases;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((expression) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 3924, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "3924" ": Null " "expression"); } while (0); } while (0);
        do { if ((cases) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 3925, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "3925" ": Null " "cases"); } while (0); } while (0); }
    cstring node_type_name() const override { return "SwitchStatement"; }
    static cstring static_type_name() { return "SwitchStatement"; }
    public: SwitchStatement *clone() const override { return new SwitchStatement(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    SwitchStatement(Util::SourceInfo srcInfo,
        const Expression* expression,
        const Vector<SwitchCase>* cases) :
        Statement(srcInfo),
        expression(expression),
        cases(cases)
    { validate(); }
};
}
namespace IR {
class Function : public Declaration {
 public:
    const Type_Method* type = nullptr;
    const BlockStatement* body = nullptr;
    bool operator==(const Function&a) const {
        return Declaration::operator==(a)
        && type == a.type
        && body == a.body;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((type) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 3951, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "3951" ": Null " "type"); } while (0); } while (0);
        do { if ((body) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 3952, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "3952" ": Null " "body"); } while (0); } while (0); }
    cstring node_type_name() const override { return "Function"; }
    static cstring static_type_name() { return "Function"; }
    public: Function *clone() const override { return new Function(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Function(Util::SourceInfo srcInfo,
        ID name,
        const Type_Method* type,
        const BlockStatement* body) :
        Declaration(srcInfo, name),
        type(type),
        body(body)
    { validate(); }
};
}
namespace IR {
class Block : public Node, public virtual CompileTimeValue {
 public:
    const Node* node = nullptr;
# 396 "../ir/ir.def"


    ordered_map<const Node*, const CompileTimeValue*> constantValue;

    virtual void dbprint(std::ostream& out) const;
    virtual void dbprint_recursive(std::ostream& out) const;
    void setValue(const Node* node, const CompileTimeValue* value) {
        do { if ((node) == nullptr) do { throw Util::CompilerBug("../ir/ir.def", 403, "../ir/ir.def" ":" "403" ": Null " "node"); } while (0); } while (0); do { if ((value) == nullptr) do { throw Util::CompilerBug("../ir/ir.def", 403, "../ir/ir.def" ":" "403" ": Null " "value"); } while (0); } while (0);
        auto it = constantValue.find(node);
        do { if (!(it == constantValue.end())) do { throw Util::CompilerBug("../ir/ir.def", 405, "%1% already set", node); } while (0); } while (0);
        constantValue[node] = value;
    }
    const CompileTimeValue* getValue(const Node* node) const {
        do { if ((node) == nullptr) do { throw Util::CompilerBug("../ir/ir.def", 409, "../ir/ir.def" ":" "409" ": Null " "node"); } while (0); } while (0);
        auto it = constantValue.find(node);
        if (it == constantValue.end())
            return nullptr;
        return it->second;
    }
# 3991 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    bool operator==(const Block&a) const {
        return typeid(*this) == typeid(a)
        && node == a.node;
    }
    void validate() const override {
        do { if ((node) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 3998, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "3998" ": Null " "node"); } while (0); } while (0); }
    cstring node_type_name() const override { return "Block"; }
    static cstring static_type_name() { return "Block"; }
    public: Block *clone() const override = 0; public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
 protected:
    Block(Util::SourceInfo srcInfo,
        const Node* node) :
        Node(srcInfo),
        node(node)
    { validate(); }
 public:
};
}
namespace IR {
class TableBlock : public Block {
 public:
    const P4Table* container = nullptr;
    bool operator==(const TableBlock&a) const {
        return Block::operator==(a)
        && container == a.container;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((container) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 4022, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "4022" ": Null " "container"); } while (0); } while (0); }
    cstring node_type_name() const override { return "TableBlock"; }
    static cstring static_type_name() { return "TableBlock"; }
    public: TableBlock *clone() const override { return new TableBlock(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    TableBlock(Util::SourceInfo srcInfo,
        const Node* node,
        const P4Table* container) :
        Block(srcInfo, node),
        container(container)
    { validate(); }
};
}
namespace IR {
class InstantiatedBlock : public Block {
 public:
    const Type* instanceType = nullptr;
# 429 "../ir/ir.def"
 virtual const IR::ParameterList* getConstructorParameters() const = 0;
    void instantiate(std::vector<const IR::CompileTimeValue*> *args);
    const CompileTimeValue* getParameterValue(cstring paramName) const;
    virtual void dbprint(std::ostream& out) const;
# 4044 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const InstantiatedBlock&a) const {
        return Block::operator==(a)
        && instanceType == a.instanceType;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((instanceType) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 4051, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "4051" ": Null " "instanceType"); } while (0); } while (0); }
    cstring node_type_name() const override { return "InstantiatedBlock"; }
    static cstring static_type_name() { return "InstantiatedBlock"; }
    public: InstantiatedBlock *clone() const override = 0; public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
 protected:
    InstantiatedBlock(Util::SourceInfo srcInfo,
        const Node* node,
        const Type* instanceType) :
        Block(srcInfo, node),
        instanceType(instanceType)
    { validate(); }
 public:
};
}
namespace IR {
class ParserBlock : public InstantiatedBlock {
 public:
    const P4Parser* container = nullptr;
# 439 "../ir/ir.def"
 const IR::ParameterList* getConstructorParameters() const override
    { return container->constructorParams; }
# 4073 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const ParserBlock&a) const {
        return InstantiatedBlock::operator==(a)
        && container == a.container;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((container) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 4080, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "4080" ": Null " "container"); } while (0); } while (0); }
    cstring node_type_name() const override { return "ParserBlock"; }
    static cstring static_type_name() { return "ParserBlock"; }
    public: ParserBlock *clone() const override { return new ParserBlock(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    ParserBlock(Util::SourceInfo srcInfo,
        const Node* node,
        const Type* instanceType,
        const P4Parser* container) :
        InstantiatedBlock(srcInfo, node, instanceType),
        container(container)
    { validate(); }
};
}
namespace IR {
class ControlBlock : public InstantiatedBlock {
 public:
    const P4Control* container = nullptr;
# 448 "../ir/ir.def"
 const IR::ParameterList* getConstructorParameters() const override
    { return container->constructorParams; }
# 4101 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const ControlBlock&a) const {
        return InstantiatedBlock::operator==(a)
        && container == a.container;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((container) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 4108, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "4108" ": Null " "container"); } while (0); } while (0); }
    cstring node_type_name() const override { return "ControlBlock"; }
    static cstring static_type_name() { return "ControlBlock"; }
    public: ControlBlock *clone() const override { return new ControlBlock(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    ControlBlock(Util::SourceInfo srcInfo,
        const Node* node,
        const Type* instanceType,
        const P4Control* container) :
        InstantiatedBlock(srcInfo, node, instanceType),
        container(container)
    { validate(); }
};
}
namespace IR {
class PackageBlock : public InstantiatedBlock {
 public:
    const Type_Package* type = nullptr;
# 457 "../ir/ir.def"
 const IR::ParameterList* getConstructorParameters() const override
    { return type->constructorParams; }
# 4129 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const PackageBlock&a) const {
        return InstantiatedBlock::operator==(a)
        && type == a.type;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((type) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 4136, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "4136" ": Null " "type"); } while (0); } while (0); }
    cstring node_type_name() const override { return "PackageBlock"; }
    static cstring static_type_name() { return "PackageBlock"; }
    public: PackageBlock *clone() const override { return new PackageBlock(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    PackageBlock(Util::SourceInfo srcInfo,
        const Node* node,
        const Type* instanceType,
        const Type_Package* type) :
        InstantiatedBlock(srcInfo, node, instanceType),
        type(type)
    { validate(); }
};
}
namespace IR {
class ExternBlock : public InstantiatedBlock {
 public:
    const Type_Extern* type = nullptr;
    const Method* constructor = nullptr;
# 467 "../ir/ir.def"
 const IR::ParameterList* getConstructorParameters() const override
    { return constructor->type->parameters; }
# 4158 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const ExternBlock&a) const {
        return InstantiatedBlock::operator==(a)
        && type == a.type
        && constructor == a.constructor;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((type) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 4166, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "4166" ": Null " "type"); } while (0); } while (0);
        do { if ((constructor) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 4167, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "4167" ": Null " "constructor"); } while (0); } while (0); }
    cstring node_type_name() const override { return "ExternBlock"; }
    static cstring static_type_name() { return "ExternBlock"; }
    public: ExternBlock *clone() const override { return new ExternBlock(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    ExternBlock(Util::SourceInfo srcInfo,
        const Node* node,
        const Type* instanceType,
        const Type_Extern* type,
        const Method* constructor) :
        InstantiatedBlock(srcInfo, node, instanceType),
        type(type),
        constructor(constructor)
    { validate(); }
};
}
namespace IR {
class ToplevelBlock : public Block {
 public:
    bool operator==(const ToplevelBlock&a) const {
        return Block::operator==(a);
    }
    cstring node_type_name() const override { return "ToplevelBlock"; }
    static cstring static_type_name() { return "ToplevelBlock"; }
    public: ToplevelBlock *clone() const override { return new ToplevelBlock(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    ToplevelBlock(Util::SourceInfo srcInfo,
        const Node* node) :
        Block(srcInfo, node)
    { validate(); }
};
}
# 8 "../ir/v1.def"
namespace IR {
enum class CounterType { NONE, PACKETS, BYTES, BOTH };
}

inline std::ostream& operator<<(std::ostream &out, IR::CounterType d) {
    switch (d) {
        case IR::CounterType::NONE:
            out << "NONE";
            break;
        case IR::CounterType::PACKETS:
            out << "PACKETS";
            break;
        case IR::CounterType::BYTES:
            out << "BYTES";
            break;
        case IR::CounterType::BOTH:
            out << "BOTH";
            break;
        default:
            do { throw Util::CompilerBug("../ir/v1.def", 27, "Unhandled case"); } while (0);
    }
    return out;
}
# 4222 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
namespace IR {
class HeaderOrMetadata : public Node {
 public:
    IR::ID type_name;
    IR::ID name;
    const Type_StructLike* type = nullptr;
# 38 "../ir/v1.def"
 HeaderOrMetadata(IR::ID n, const Type_StructLike *t) : type_name(t->name), name(n), type(t) {}
# 4231 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 40 "../ir/v1.def"
 void dbprint(std::ostream &out) const override { out << type_name << ' ' << name; }
# 4234 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const HeaderOrMetadata&a) const {
        return typeid(*this) == typeid(a)
        && type_name == a.type_name
        && name == a.name
        && type == a.type;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    cstring node_type_name() const override { return "HeaderOrMetadata"; }
    static cstring static_type_name() { return "HeaderOrMetadata"; }
    void dump_fields(std::ostream& out) const override;
    public: HeaderOrMetadata *clone() const override = 0; public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
 protected:
    HeaderOrMetadata(Util::SourceInfo srcInfo,
        IR::ID type_name,
        IR::ID name,
        const Type_StructLike* type) :
        Node(srcInfo),
        type_name(type_name),
        name(name),
        type(type)
    { validate(); }
 public:
};
}
namespace IR {
class Header : public HeaderOrMetadata {
 public:
# 45 "../ir/v1.def"
 Header(IR::ID n, const Type_Header *t) : HeaderOrMetadata(n, t) {}
# 4265 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Header&a) const {
        return HeaderOrMetadata::operator==(a);
    }
    cstring node_type_name() const override { return "Header"; }
    static cstring static_type_name() { return "Header"; }
    public: Header *clone() const override { return new Header(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Header(Util::SourceInfo srcInfo,
        IR::ID type_name,
        IR::ID name,
        const Type_StructLike* type) :
        HeaderOrMetadata(srcInfo, type_name, name, type)
    { validate(); }
};
}
namespace IR {
class HeaderStack : public HeaderOrMetadata {
 public:
    int size;
# 53 "../ir/v1.def"
 HeaderStack(IR::ID n, const Type_Header *t, int sz) : HeaderOrMetadata(n, t), size(sz) {}
# 4286 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const HeaderStack&a) const {
        return HeaderOrMetadata::operator==(a)
        && size == a.size;
    }
    cstring node_type_name() const override { return "HeaderStack"; }
    static cstring static_type_name() { return "HeaderStack"; }
    void dump_fields(std::ostream& out) const override;
    public: HeaderStack *clone() const override { return new HeaderStack(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    HeaderStack(Util::SourceInfo srcInfo,
        IR::ID type_name,
        IR::ID name,
        const Type_StructLike* type,
        int size) :
        HeaderOrMetadata(srcInfo, type_name, name, type),
        size(size)
    { validate(); }
};
}
namespace IR {
class Metadata : public HeaderOrMetadata {
 public:
# 60 "../ir/v1.def"
 Metadata(IR::ID n, const Type_Struct *t) : HeaderOrMetadata(n, t) {}
# 4310 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Metadata&a) const {
        return HeaderOrMetadata::operator==(a);
    }
    cstring node_type_name() const override { return "Metadata"; }
    static cstring static_type_name() { return "Metadata"; }
    public: Metadata *clone() const override { return new Metadata(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Metadata(Util::SourceInfo srcInfo,
        IR::ID type_name,
        IR::ID name,
        const Type_StructLike* type) :
        HeaderOrMetadata(srcInfo, type_name, name, type)
    { validate(); }
};
}
namespace IR {
class HeaderRef : public Expression {
 public:
# 68 "../ir/v1.def"
 HeaderRef() {}
    HeaderRef(Util::SourceInfo si) : Expression(si) {}
    HeaderRef(Util::SourceInfo si, const Type_StructLike *ht) : Expression(si, ht) {}
# 4332 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const HeaderRef&a) const {
        return Expression::operator==(a);
    }
    cstring node_type_name() const override { return "HeaderRef"; }
    static cstring static_type_name() { return "HeaderRef"; }
    public: HeaderRef *clone() const override = 0; public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
};
}
namespace IR {
class ConcreteHeaderRef : public HeaderRef {
 public:
    const HeaderOrMetadata* ref = nullptr;
# 78 "../ir/v1.def"
 ConcreteHeaderRef(Util::SourceInfo si, const HeaderOrMetadata *r)
    : HeaderRef(si, r->type), ref(r) {}
    ConcreteHeaderRef(const HeaderOrMetadata *r) : HeaderRef(Util::SourceInfo(), r->type), ref(r) {}
# 4349 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 82 "../ir/v1.def"
 cstring toString() const override { return ref->name; }
# 4352 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 83 "../ir/v1.def"
 void dbprint(std::ostream &out) const override { out << ref->name; }
# 4355 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const ConcreteHeaderRef&a) const {
        return HeaderRef::operator==(a)
        && ref == a.ref;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((ref) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 4362, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "4362" ": Null " "ref"); } while (0); } while (0); }
    cstring node_type_name() const override { return "ConcreteHeaderRef"; }
    static cstring static_type_name() { return "ConcreteHeaderRef"; }
    public: ConcreteHeaderRef *clone() const override { return new ConcreteHeaderRef(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
};
}
namespace IR {
class HeaderStackItemRef : public HeaderRef {
 public:
    const Expression* base_ = nullptr;
    const Expression* index_ = nullptr;
# 91 "../ir/v1.def"
 HeaderStackItemRef(Util::SourceInfo si, const Type_Header *t, const Expression *b,
                       const Expression *i)
    : HeaderRef(si, t), base_(b), index_(i) {}
    HeaderStackItemRef(Util::SourceInfo si, const Expression *b, const Expression *i)
    : HeaderRef(si), base_(b), index_(i) {}
    const Expression* base() const { return base_; }
    const Expression* index() const { return index_; }
    void set_base(const Expression *b) { base_ = b; }
# 4383 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 100 "../ir/v1.def"
 cstring toString() const override { return base_->toString() + "[" + index_->toString() + "]"; }
# 4386 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const HeaderStackItemRef&a) const {
        return HeaderRef::operator==(a)
        && base_ == a.base_
        && index_ == a.index_;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((base_) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 4394, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "4394" ": Null " "base_"); } while (0); } while (0);
        do { if ((index_) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 4395, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "4395" ": Null " "index_"); } while (0); } while (0); }
    cstring node_type_name() const override { return "HeaderStackItemRef"; }
    static cstring static_type_name() { return "HeaderStackItemRef"; }
    void dbprint(std::ostream &out) const override ;
    public: HeaderStackItemRef *clone() const override { return new HeaderStackItemRef(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
};
}
namespace IR {
class NamedRef : public Expression {
 public:
    ID name;
# 106 "../ir/v1.def"
 explicit NamedRef(ID n) : name(n) {}
    NamedRef(const Type *t, ID n) : Expression(t), name(n) {}
# 4410 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 109 "../ir/v1.def"
 cstring toString() const override { return name; }
# 4413 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const NamedRef&a) const {
        return Expression::operator==(a)
        && name == a.name;
    }
    cstring node_type_name() const override { return "NamedRef"; }
    static cstring static_type_name() { return "NamedRef"; }
    void dbprint(std::ostream &out) const override ;
    void dump_fields(std::ostream& out) const override;
    public: NamedRef *clone() const override { return new NamedRef(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    NamedRef(Util::SourceInfo srcInfo,
        ID name) :
        Expression(srcInfo),
        name(name)
    { validate(); }
};
}
namespace IR {
class If : public Expression {
 public:
    const Expression* pred = nullptr;
    const Vector<Expression>* ifTrue = nullptr;
    const Vector<Expression>* ifFalse = nullptr;
# 117 "../ir/v1.def"
 If(const Expression *p, const Vector<Expression> *T, const Vector<Expression> *F)
            : pred(p), ifTrue(T), ifFalse(F) { validate(); }
# 4439 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    bool operator==(const If&a) const {
        return Expression::operator==(a)
        && pred == a.pred
        && ifTrue == a.ifTrue
        && ifFalse == a.ifFalse;
    }
    void validate() const override {
        do { if ((pred) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 4448, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "4448" ": Null " "pred"); } while (0); } while (0); }
    cstring node_type_name() const override { return "If"; }
    static cstring static_type_name() { return "If"; }
    void dbprint(std::ostream &out) const override ;
    public: If *clone() const override { return new If(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    If(Util::SourceInfo srcInfo,
        const Expression* pred,
        const Vector<Expression>* ifTrue,
        const Vector<Expression>* ifFalse) :
        Expression(srcInfo),
        pred(pred),
        ifTrue(ifTrue),
        ifFalse(ifFalse)
    { validate(); }
};
}
namespace IR {
class NamedCond : public If {
 public:
    cstring name;
# 134 "../ir/v1.def"
 static cstring unique_name();
    NamedCond(const Expression *p, const Vector<Expression> *T,
       const Vector<Expression> *F) : If(p, T, F), name(unique_name()) {}
    explicit NamedCond(const If &i) : If(i), name(unique_name()) {}
# 4474 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 139 "../ir/v1.def"
 bool operator==(const NamedCond&a) const { return If::operator==(a); }
# 4477 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 cstring node_type_name() const override { return "NamedCond"; }
    static cstring static_type_name() { return "NamedCond"; }
    void dump_fields(std::ostream& out) const override;
    public: NamedCond *clone() const override { return new NamedCond(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
};
}
namespace IR {
class Apply : public Expression {
 public:
    ID name;
    NameMap<Vector<Expression>> actions;
# 148 "../ir/v1.def"
 Apply() = default;
    explicit Apply(ID n) : name(n) {}
    Apply(const Util::SourceInfo &si, ID n) : Expression(si), name(n) {}
# 4493 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    bool operator==(const Apply&a) const {
        return Expression::operator==(a)
        && name == a.name
        && actions == a.actions;
    }
    void validate() const override {
        actions.validate(); }
    cstring node_type_name() const override { return "Apply"; }
    static cstring static_type_name() { return "Apply"; }
    void dbprint(std::ostream &out) const override ;
    void dump_fields(std::ostream& out) const override;
    public: Apply *clone() const override { return new Apply(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
};
}
namespace IR {
class Primitive : public Operation {
 public:
    cstring name;
    Vector<Expression> operands;
# 175 "../ir/v1.def"
 explicit Primitive(cstring n) : name(n) {}
    Primitive(Util::SourceInfo si, cstring n) : Operation(si), name(n) {}
    Primitive(cstring n, const Vector<Expression> *l) : name(n) {
        if (l) for (auto e : *l) operands.push_back(e); }
    Primitive(Util::SourceInfo si, cstring n, const Vector<Expression> *l)
    : Operation(si), name(n) {
        if (l) for (auto e : *l) operands.push_back(e); }
    Primitive(cstring n, const Expression *a1) : name(n) {
        operands.push_back(a1); }
    Primitive(Util::SourceInfo si, cstring n, const Expression *a1) : Operation(si), name(n) {
        operands.push_back(a1); }
    Primitive(cstring n, const Expression *a1, const Expression *a2) : name(n) {
        operands.push_back(a1); operands.push_back(a2); }
    Primitive(Util::SourceInfo si, cstring n, const Expression *a1, const Expression *a2)
    : Operation(si), name(n) {
        operands.push_back(a1); operands.push_back(a2); }
    Primitive(cstring n, const Expression *a1, const Vector<Expression> *a2) : name(n) {
        operands.push_back(a1);
        if (a2) for (auto e : *a2) operands.push_back(e); }
    Primitive(Util::SourceInfo si, cstring n, const Expression *a1, const Vector<Expression> *a2)
    : Operation(si), name(n) {
        operands.push_back(a1);
        if (a2) for (auto e : *a2) operands.push_back(e); }
    Primitive(cstring n, const Expression *a1, const Expression *a2, const Expression *a3)
    : name(n) {
        operands.push_back(a1); operands.push_back(a2); operands.push_back(a3); }
    Primitive(Util::SourceInfo si, cstring n, const Expression *a1, const Expression *a2,
              const Expression *a3) : Operation(si), name(n) {
        operands.push_back(a1); operands.push_back(a2); operands.push_back(a3); }
    virtual bool isOutput(int operand_index) const;
    virtual unsigned inferOperandTypes() const;
    virtual void typecheck() const;
# 4548 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 const Primitive *apply(Visitor &v) const; const Primitive *apply(Visitor &&v) const { return apply(v); }
    cstring getStringOp() const { return name; }
    int getPrecedence() const { return DBPrint::Prec_Postfix; }
    bool operator==(const Primitive&a) const {
        return Operation::operator==(a)
        && name == a.name
        && operands == a.operands;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        operands.validate(); }
    cstring node_type_name() const override { return "Primitive"; }
    static cstring static_type_name() { return "Primitive"; }
    void dbprint(std::ostream &out) const override ;
    void dump_fields(std::ostream& out) const override;
    public: Primitive *clone() const override { return new Primitive(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Primitive(Util::SourceInfo srcInfo,
        cstring name,
        Vector<Expression> operands) :
        Operation(srcInfo),
        name(name),
        operands(operands)
    { validate(); }
};
}
namespace IR {
class FieldList : public Node {
 public:
    ID name;
    bool payload;
    Vector<Expression> fields;
# 219 "../ir/v1.def"
 FieldList() = default;
# 4583 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const FieldList&a) const {
        return typeid(*this) == typeid(a)
        && name == a.name
        && payload == a.payload
        && fields == a.fields;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        fields.validate(); }
    cstring node_type_name() const override { return "FieldList"; }
    static cstring static_type_name() { return "FieldList"; }
    void dbprint(std::ostream &out) const override ;
    void dump_fields(std::ostream& out) const override;
    public: FieldList *clone() const override { return new FieldList(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
};
}
namespace IR {
class FieldListCalculation : public Node {
 public:
    ID name;
    const NameList* input = nullptr;
    ID algorithm;
    int output_width;
# 230 "../ir/v1.def"
 FieldListCalculation() = default;
# 4610 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const FieldListCalculation&a) const {
        return typeid(*this) == typeid(a)
        && name == a.name
        && input == a.input
        && algorithm == a.algorithm
        && output_width == a.output_width;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((input) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 4620, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "4620" ": Null " "input"); } while (0); } while (0); }
    cstring node_type_name() const override { return "FieldListCalculation"; }
    static cstring static_type_name() { return "FieldListCalculation"; }
    void dbprint(std::ostream &out) const override ;
    void dump_fields(std::ostream& out) const override;
    public: FieldListCalculation *clone() const override { return new FieldListCalculation(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
};
}
namespace IR {
class CalculatedField : public Node {
 public:
    const Expression* field = nullptr;
# 238 "../ir/v1.def"
 CalculatedField() = default;
    struct update_or_verify {
        Util::SourceInfo srcInfo;
        bool update;
        ID name;
        const Expression *cond;
        update_or_verify(Util::SourceInfo si, bool u, ID n, const Expression *c)
        : srcInfo(si), update(u), name(n), cond(c) {}
        bool operator==(const update_or_verify &a) const { return update == a.update &&
            name == a.name && cond == a.cond; }
    };
# 4645 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 vector<update_or_verify> specs;
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    bool operator==(const CalculatedField&a) const {
        return typeid(*this) == typeid(a)
        && field == a.field
        && specs == a.specs;
    }
    void validate() const override {
        do { if ((field) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 4654, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "4654" ": Null " "field"); } while (0); } while (0); }
    cstring node_type_name() const override { return "CalculatedField"; }
    static cstring static_type_name() { return "CalculatedField"; }
    void dbprint(std::ostream &out) const override ;
    public: CalculatedField *clone() const override { return new CalculatedField(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
};
}
namespace IR {
class CaseEntry : public Node {
 public:
    vector<std::pair<const Constant *, const Constant *>> values;
    ID action;
# 258 "../ir/v1.def"
 CaseEntry() = default;
# 4669 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const CaseEntry&a) const {
        return typeid(*this) == typeid(a)
        && values == a.values
        && action == a.action;
    }
    cstring node_type_name() const override { return "CaseEntry"; }
    static cstring static_type_name() { return "CaseEntry"; }
    void dbprint(std::ostream &out) const override ;
    void dump_fields(std::ostream& out) const override;
    public: CaseEntry *clone() const override { return new CaseEntry(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    CaseEntry(Util::SourceInfo srcInfo,
        vector<std::pair<const Constant *, const Constant *>> values,
        ID action) :
        Node(srcInfo),
        values(values),
        action(action)
    { validate(); }
};
}
namespace IR {
class V1Parser : public Node {
 public:
    ID name;
    Vector<Expression> stmts;
    const Vector<Expression>* select = nullptr;
    const Vector<CaseEntry>* cases = nullptr;
    ID default_return;
    ID parse_error;
    bool drop;
# 272 "../ir/v1.def"
 V1Parser() = default;
# 4701 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 274 "../ir/v1.def"
 cstring toString() const override { return node_type_name() + " " + name; }
# 4704 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const V1Parser&a) const {
        return typeid(*this) == typeid(a)
        && name == a.name
        && stmts == a.stmts
        && select == a.select
        && cases == a.cases
        && default_return == a.default_return
        && parse_error == a.parse_error
        && drop == a.drop;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        stmts.validate(); }
    cstring node_type_name() const override { return "V1Parser"; }
    static cstring static_type_name() { return "V1Parser"; }
    void dbprint(std::ostream &out) const override ;
    void dump_fields(std::ostream& out) const override;
    public: V1Parser *clone() const override { return new V1Parser(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
};
}
namespace IR {
class ParserException : public Node {
 public:
    bool operator==(const ParserException&a) const {
        return typeid(*this) == typeid(a);
    }
    cstring node_type_name() const override { return "ParserException"; }
    static cstring static_type_name() { return "ParserException"; }
    void dbprint(std::ostream &out) const override ;
    public: ParserException *clone() const override { return new ParserException(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    ParserException(Util::SourceInfo srcInfo) :
        Node(srcInfo)
    { validate(); }
};
}
namespace IR {
class Attached : public Node {
 public:
    ID name;
# 282 "../ir/v1.def"
 Attached() = default;
    virtual const char *kind() const = 0;
    virtual bool indexed() const { return false; }
    Attached *clone_rename(const char *ext) const {
        Attached *rv = clone();
        rv->name = IR::ID(Util::SourceInfo(), rv->name.name + ext);
        return rv; }
# 4753 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 290 "../ir/v1.def"
 void dbprint(std::ostream &out) const override { out << node_type_name() << " " << name; }
# 4756 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 291 "../ir/v1.def"
 cstring toString() const override { return node_type_name() + " " + name; }
# 4759 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Attached&a) const {
        return typeid(*this) == typeid(a)
        && name == a.name;
    }
    cstring node_type_name() const override { return "Attached"; }
    static cstring static_type_name() { return "Attached"; }
    void dump_fields(std::ostream& out) const override;
    public: Attached *clone() const override = 0; public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
 protected:
    Attached(Util::SourceInfo srcInfo,
        ID name) :
        Node(srcInfo),
        name(name)
    { validate(); }
 public:
};
}
namespace IR {
class Stateful : public Attached {
 public:
    ID table;
    bool direct;
    bool saturating;
    int instance_count = -1;
# 300 "../ir/v1.def"
 Stateful() = default;
    virtual bool indexed() const { return !direct; }
# 4787 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Stateful&a) const {
        return Attached::operator==(a)
        && table == a.table
        && direct == a.direct
        && saturating == a.saturating
        && instance_count == a.instance_count;
    }
    cstring node_type_name() const override { return "Stateful"; }
    static cstring static_type_name() { return "Stateful"; }
    void dump_fields(std::ostream& out) const override;
    public: Stateful *clone() const override = 0; public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
 protected:
    Stateful(Util::SourceInfo srcInfo,
        ID name,
        ID table,
        bool direct,
        bool saturating,
        int instance_count) :
        Attached(srcInfo, name),
        table(table),
        direct(direct),
        saturating(saturating),
        instance_count(instance_count)
    { validate(); }
 public:
};
}
namespace IR {
class CounterOrMeter : public Stateful {
 public:
    CounterType type;
# 308 "../ir/v1.def"
 CounterOrMeter() = default;
    void settype(cstring t) {
        if (t == "packets") type = CounterType::PACKETS;
        else if (t == "bytes") type = CounterType::BYTES;
        else if (t == "packets_and_bytes") type = CounterType::BOTH;
        else error("%s: Unknown type %s", srcInfo, t); }
# 4826 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const CounterOrMeter&a) const {
        return Stateful::operator==(a)
        && type == a.type;
    }
    cstring node_type_name() const override { return "CounterOrMeter"; }
    static cstring static_type_name() { return "CounterOrMeter"; }
    void dump_fields(std::ostream& out) const override;
    public: CounterOrMeter *clone() const override = 0; public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
 protected:
    CounterOrMeter(Util::SourceInfo srcInfo,
        ID name,
        ID table,
        bool direct,
        bool saturating,
        int instance_count,
        CounterType type) :
        Stateful(srcInfo, name, table, direct, saturating, instance_count),
        type(type)
    { validate(); }
 public:
};
}
namespace IR {
class Counter : public CounterOrMeter {
 public:
    int max_width = -1;
    int min_width = -1;
# 321 "../ir/v1.def"
 Counter() = default;
    const char *kind() const { return "stats"; }
# 4857 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Counter&a) const {
        return CounterOrMeter::operator==(a)
        && max_width == a.max_width
        && min_width == a.min_width;
    }
    cstring node_type_name() const override { return "Counter"; }
    static cstring static_type_name() { return "Counter"; }
    void dbprint(std::ostream &out) const override ;
    void dump_fields(std::ostream& out) const override;
    public: Counter *clone() const override { return new Counter(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Counter(Util::SourceInfo srcInfo,
        ID name,
        ID table,
        bool direct,
        bool saturating,
        int instance_count,
        CounterType type,
        int max_width,
        int min_width) :
        CounterOrMeter(srcInfo, name, table, direct, saturating, instance_count, type),
        max_width(max_width),
        min_width(min_width)
    { validate(); }
};
}
namespace IR {
class Meter : public CounterOrMeter {
 public:
    const Expression* result = nullptr;
    const Expression* pre_color = nullptr;
    ID implementation;
# 331 "../ir/v1.def"
 Meter() = default;
    const char *kind() const { return "meter"; }
# 4892 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Meter&a) const {
        return CounterOrMeter::operator==(a)
        && result == a.result
        && pre_color == a.pre_color
        && implementation == a.implementation;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    cstring node_type_name() const override { return "Meter"; }
    static cstring static_type_name() { return "Meter"; }
    void dbprint(std::ostream &out) const override ;
    void dump_fields(std::ostream& out) const override;
    public: Meter *clone() const override { return new Meter(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Meter(Util::SourceInfo srcInfo,
        ID name,
        ID table,
        bool direct,
        bool saturating,
        int instance_count,
        CounterType type,
        const Expression* result,
        const Expression* pre_color,
        ID implementation) :
        CounterOrMeter(srcInfo, name, table, direct, saturating, instance_count, type),
        result(result),
        pre_color(pre_color),
        implementation(implementation)
    { validate(); }
};
}
namespace IR {
class Register : public Stateful {
 public:
    ID layout;
    int width = -1;
    bool signed_;
# 342 "../ir/v1.def"
 Register() = default;
    const char *kind() const { return "register"; }
# 4932 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Register&a) const {
        return Stateful::operator==(a)
        && layout == a.layout
        && width == a.width
        && signed_ == a.signed_;
    }
    cstring node_type_name() const override { return "Register"; }
    static cstring static_type_name() { return "Register"; }
    void dbprint(std::ostream &out) const override ;
    void dump_fields(std::ostream& out) const override;
    public: Register *clone() const override { return new Register(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    Register(Util::SourceInfo srcInfo,
        ID name,
        ID table,
        bool direct,
        bool saturating,
        int instance_count,
        ID layout,
        int width,
        bool signed_) :
        Stateful(srcInfo, name, table, direct, saturating, instance_count),
        layout(layout),
        width(width),
        signed_(signed_)
    { validate(); }
};
}
namespace IR {
class PrimitiveAction : public Node {
 public:
    bool operator==(const PrimitiveAction&a) const {
        return typeid(*this) == typeid(a);
    }
    cstring node_type_name() const override { return "PrimitiveAction"; }
    static cstring static_type_name() { return "PrimitiveAction"; }
    void dbprint(std::ostream &out) const override ;
    public: PrimitiveAction *clone() const override { return new PrimitiveAction(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    PrimitiveAction(Util::SourceInfo srcInfo) :
        Node(srcInfo)
    { validate(); }
};
}
namespace IR {
class NameList : public Node {
 public:
    vector<ID> names;
# 352 "../ir/v1.def"
 NameList() = default;
    NameList(Util::SourceInfo si, cstring n) { names.emplace_back(si, n); }
# 4982 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const NameList&a) const {
        return typeid(*this) == typeid(a)
        && names == a.names;
    }
    cstring node_type_name() const override { return "NameList"; }
    static cstring static_type_name() { return "NameList"; }
    void dbprint(std::ostream &out) const override ;
    public: NameList *clone() const override { return new NameList(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    NameList(Util::SourceInfo srcInfo,
        vector<ID> names) :
        Node(srcInfo),
        names(names)
    { validate(); }
};
}
namespace IR {
class ActionArg : public Expression {
 public:
    ID name;
    bool read = false;
    bool write = false;
# 362 "../ir/v1.def"
 explicit ActionArg(const ID &n) : Expression(n.srcInfo), name(n) {}
    ActionArg(Util::SourceInfo si, const Type *t, const ID &n) : Expression(si, t), name(n) {}
# 5007 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 365 "../ir/v1.def"
 void dbprint(std::ostream &out) const override { out << name; }
# 5010 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 366 "../ir/v1.def"
 cstring toString() const override { return name.name; }
# 5013 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const ActionArg&a) const {
        return Expression::operator==(a)
        && name == a.name
        && read == a.read
        && write == a.write;
    }
    cstring node_type_name() const override { return "ActionArg"; }
    static cstring static_type_name() { return "ActionArg"; }
    void dump_fields(std::ostream& out) const override;
    public: ActionArg *clone() const override { return new ActionArg(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    ActionArg(Util::SourceInfo srcInfo,
        ID name,
        bool read,
        bool write) :
        Expression(srcInfo),
        name(name),
        read(read),
        write(write)
    { validate(); }
};
}
namespace IR {
class ActionFunction : public Node {
 public:
    ID name;
    Vector<Primitive> action;
    vector<const ActionArg *> args;
# 376 "../ir/v1.def"
 ActionFunction() = default;
    const ActionArg *arg(cstring n) const {
        for (auto a : args)
            if (a->name == n)
                return a;
        return nullptr; }
# 5048 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
# 389 "../ir/v1.def"
 cstring toString() const override {
        return cstring("action ") + name + " {\n" +
                 cstring::join(action.begin(), action.end(), ";\n") +
                 " }"; }
# 5056 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const ActionFunction&a) const {
        return typeid(*this) == typeid(a)
        && name == a.name
        && action == a.action
        && args == a.args;
    }
    void validate() const override {
        action.validate(); }
    cstring node_type_name() const override { return "ActionFunction"; }
    static cstring static_type_name() { return "ActionFunction"; }
    void dbprint(std::ostream &out) const override ;
    void dump_fields(std::ostream& out) const override;
    public: ActionFunction *clone() const override { return new ActionFunction(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
};
}
namespace IR {
class ActionProfile : public Attached {
 public:
    ID selector;
    vector<ID> actions;
    int size;
# 401 "../ir/v1.def"
 const char *kind() const { return "action_profile"; }
    bool indexed() const { return true; }
# 5081 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const ActionProfile&a) const {
        return Attached::operator==(a)
        && selector == a.selector
        && actions == a.actions
        && size == a.size;
    }
    cstring node_type_name() const override { return "ActionProfile"; }
    static cstring static_type_name() { return "ActionProfile"; }
    void dbprint(std::ostream &out) const override ;
    void dump_fields(std::ostream& out) const override;
    public: ActionProfile *clone() const override { return new ActionProfile(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
};
}
namespace IR {
class ActionSelector : public Attached {
 public:
    ID key;
    ID mode;
    ID type;
# 412 "../ir/v1.def"
 const char *kind() const { return "action_selector"; }
# 5103 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const ActionSelector&a) const {
        return Attached::operator==(a)
        && key == a.key
        && mode == a.mode
        && type == a.type;
    }
    cstring node_type_name() const override { return "ActionSelector"; }
    static cstring static_type_name() { return "ActionSelector"; }
    void dbprint(std::ostream &out) const override ;
    void dump_fields(std::ostream& out) const override;
    public: ActionSelector *clone() const override { return new ActionSelector(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
};
}
namespace IR {
class V1Table : public Node {
 public:
    ID name;
    const Vector<Expression>* reads = 0;
    vector<ID> reads_types;
    int min_size = 0;
    int max_size = 0;
    int size = 0;
    ID action_profile;
    vector<ID> actions;
    ID default_action;
    const Vector<Expression>* default_action_args = 0;
    TableProperties properties;
# 430 "../ir/v1.def"
 V1Table() = default;
# 5133 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 432 "../ir/v1.def"
 cstring toString() const override { return node_type_name() + " " + name; }
# 5136 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const V1Table&a) const {
        return typeid(*this) == typeid(a)
        && name == a.name
        && reads == a.reads
        && reads_types == a.reads_types
        && min_size == a.min_size
        && max_size == a.max_size
        && size == a.size
        && action_profile == a.action_profile
        && actions == a.actions
        && default_action == a.default_action
        && default_action_args == a.default_action_args
        && properties == a.properties;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((reads) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 5153, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "5153" ": Null " "reads"); } while (0); } while (0);
        properties.validate(); }
    cstring node_type_name() const override { return "V1Table"; }
    static cstring static_type_name() { return "V1Table"; }
    void dbprint(std::ostream &out) const override ;
    void dump_fields(std::ostream& out) const override;
    public: V1Table *clone() const override { return new V1Table(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
};
}
namespace IR {
class V1Control : public Node {
 public:
    ID name;
    const Vector<Expression>* code = nullptr;
# 439 "../ir/v1.def"
 explicit V1Control(ID n) : name(n), code(new Vector<Expression>()) {}
    V1Control(Util::SourceInfo si, ID n) : Node(si), name(n), code(new Vector<Expression>()) {}
# 5171 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 const V1Control *apply(Visitor &v) const; const V1Control *apply(Visitor &&v) const { return apply(v); }
# 443 "../ir/v1.def"
 cstring toString() const override { return node_type_name() + " " + name; }
# 5175 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const V1Control&a) const {
        return typeid(*this) == typeid(a)
        && name == a.name
        && code == a.code;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((code) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 5183, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "5183" ": Null " "code"); } while (0); } while (0); }
    cstring node_type_name() const override { return "V1Control"; }
    static cstring static_type_name() { return "V1Control"; }
    void dbprint(std::ostream &out) const override ;
    void dump_fields(std::ostream& out) const override;
    public: V1Control *clone() const override { return new V1Control(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    V1Control(Util::SourceInfo srcInfo,
        ID name,
        const Vector<Expression>* code) :
        Node(srcInfo),
        name(name),
        code(code)
    { validate(); }
};
}
# 447 "../ir/v1.def"
class CompilerOptions;
# 5201 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
namespace IR {
class V1Program : public Node {
 public:
    NameMap<Node, std::multimap> scope;
# 454 "../ir/v1.def"
 V1Program(const CompilerOptions &);
    template<class T> const T *get(cstring name) const { return scope.get<T>(name); }
    void add(cstring name, const Node *n) { scope.add(name, n); }
# 5210 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 const V1Program *apply(Visitor &v) const; const V1Program *apply(Visitor &&v) const { return apply(v); }
    bool operator==(const V1Program&a) const {
        return typeid(*this) == typeid(a)
        && scope == a.scope;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        scope.validate(); }
    cstring node_type_name() const override { return "V1Program"; }
    static cstring static_type_name() { return "V1Program"; }
    void dbprint(std::ostream &out) const override ;
    public: V1Program *clone() const override { return new V1Program(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
};
}
namespace IR {
class v1HeaderType : public Node {
 public:
    ID name;
    const Type_Struct* as_metadata = nullptr;
    const Type_Header* as_header = nullptr;
# 7 "../frontends/p4v1/ir-v1.def"
 v1HeaderType(const Type_Struct *m, const Type_Header *h = nullptr)
    : v1HeaderType(Util::SourceInfo(), m->name, m, h) {}
# 5235 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const v1HeaderType&a) const {
        return typeid(*this) == typeid(a)
        && name == a.name
        && as_metadata == a.as_metadata
        && as_header == a.as_header;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((as_metadata) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 5244, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "5244" ": Null " "as_metadata"); } while (0); } while (0); }
    cstring node_type_name() const override { return "v1HeaderType"; }
    static cstring static_type_name() { return "v1HeaderType"; }
    void dump_fields(std::ostream& out) const override;
    public: v1HeaderType *clone() const override { return new v1HeaderType(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    v1HeaderType(Util::SourceInfo srcInfo,
        ID name,
        const Type_Struct* as_metadata,
        const Type_Header* as_header) :
        Node(srcInfo),
        name(name),
        as_metadata(as_metadata),
        as_header(as_header)
    { validate(); }
};
}
namespace IR {
class IntMod : public Operation_Unary {
 public:
    unsigned width;
    cstring getStringOp() const { return "><"; }
    int getPrecedence() const { return DBPrint::Prec_Low; }
    bool operator==(const IntMod&a) const {
        return Operation_Unary::operator==(a)
        && width == a.width;
    }
    cstring node_type_name() const override { return "IntMod"; }
    static cstring static_type_name() { return "IntMod"; }
    void dump_fields(std::ostream& out) const override;
    public: IntMod *clone() const override { return new IntMod(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    IntMod(Util::SourceInfo srcInfo,
        const Expression* expr,
        unsigned width) :
        Operation_Unary(srcInfo, expr),
        width(width)
    { validate(); }
};
}
# 2 "../extensions/tofino/ir/tofino.def"
enum gress_t { INGRESS, EGRESS };
struct StageUse {
    static constexpr int MAX_STAGES = 12;
    static constexpr int MAX_LOGICAL_IDS = 16;
    static constexpr int MAX_SRAMS = 80;
    static constexpr int MAX_TCAMS = 24;
    static constexpr int MAX_MAPRAMS = 48;
    static constexpr int MAX_IXBAR_BYTES = 128;
    static constexpr int MAX_TERNARY_GROUPS = 12;
};
inline std::ostream &operator<<(std::ostream &out, gress_t gress) {
    return out << (gress ? "egress" : "ingress"); }
# 5296 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
namespace IR {
namespace Tofino {
class Pipe : public Node {
 public:
    const Metadata* standard_metadata = nullptr;
# 24 "../extensions/tofino/ir/tofino.def"
 struct thread_t {
        const Tofino::Parser *parser;
        const MAU::TableSeq *mau;
        const Tofino::Deparser *deparser;
        bool operator==(const thread_t &a) const {
            return parser == a.parser && mau == a.mau && deparser == a.deparser; }
    } thread[2] = { { nullptr, nullptr, nullptr } };
# 5310 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 const Pipe *apply(Visitor &v) const; const Pipe *apply(Visitor &&v) const { return apply(v); }
# 33 "../extensions/tofino/ir/tofino.def"
 bool operator==(const Pipe&a) const { return standard_metadata == a.standard_metadata &&
                        thread[0] == a.thread[0] && thread[1] == a.thread[1]; }
# 5315 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((standard_metadata) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 5318, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "5318" ": Null " "standard_metadata"); } while (0); } while (0); }
    cstring node_type_name() const override { return "Tofino::Pipe"; }
    static cstring static_type_name() { return "Tofino::Pipe"; }
    void dbprint(std::ostream &out) const override ;
    public: Pipe *clone() const override { return new Pipe(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
};
}
}
namespace IR {
class InstanceRef : public HeaderRef {
 public:
    const HeaderOrMetadata* obj = nullptr;
    NameMap<InstanceRef> nested;
# 52 "../extensions/tofino/ir/tofino.def"
 InstanceRef(ID n, const Type *t);
# 5334 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 54 "../extensions/tofino/ir/tofino.def"
 cstring toString() const override { return obj->name; }
# 5337 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 55 "../extensions/tofino/ir/tofino.def"
 void dbprint(std::ostream &out) const override { out << obj; }
# 5340 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const InstanceRef&a) const {
        return HeaderRef::operator==(a)
        && obj == a.obj
        && nested == a.nested;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((obj) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 5348, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "5348" ": Null " "obj"); } while (0); } while (0);
        nested.validate(); }
    cstring node_type_name() const override { return "InstanceRef"; }
    static cstring static_type_name() { return "InstanceRef"; }
    public: InstanceRef *clone() const override { return new InstanceRef(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
};
}
namespace IR {
class HeaderSliceRef : public Slice {
 public:
# 62 "../extensions/tofino/ir/tofino.def"
 HeaderSliceRef(Util::SourceInfo si, const IR::HeaderRef* header_ref,
                 const int &msb, const int &lsb) :
    Slice(si, header_ref, new IR::Constant(msb), new IR::Constant(lsb)) {
    ((lsb <= msb) ? static_cast<void> (0) : __assert_fail ("lsb <= msb", "../extensions/tofino/ir/tofino.def", 65, __PRETTY_FUNCTION__));
    type = Type_Bits::get(si, msb - lsb + 1); }
  HeaderSliceRef(const Member *fr) :
    Slice(fr->srcInfo, fr->expr, new Constant(fr->msb()), new Constant(fr->lsb())) {
    ((fr->lsb() <= fr->msb()) ? static_cast<void> (0) : __assert_fail ("fr->lsb() <= fr->msb()", "../extensions/tofino/ir/tofino.def", 69, __PRETTY_FUNCTION__));
    type = Type_Bits::get(fr->srcInfo, fr->msb() - fr->lsb() + 1); }
  const HeaderRef* header_ref() const {
    return e0->to<const HeaderRef>(); }
  Vector<Member> fields() const {
    Vector<Member> rv;
    for (auto field : *header_ref()->type->to<IR::Type_StructLike>()->getEnumerator()) {
      const IR::Member fr(srcInfo, field->type, header_ref(), field->name);
      if (fr.lsb() >= lsb() && fr.msb() <= msb())
        rv.push_back(new Member(fr));
    }
    return rv; }
  int offset_bits() const { return e2->to<const Constant>()->asInt(); }
  int lsb() const { return offset_bits(); }
  int msb() const { return offset_bits() + type->width_bits() - 1; }
# 5382 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const HeaderSliceRef&a) const {
        return Slice::operator==(a);
    }
    cstring node_type_name() const override { return "HeaderSliceRef"; }
    static cstring static_type_name() { return "HeaderSliceRef"; }
    public: HeaderSliceRef *clone() const override { return new HeaderSliceRef(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
};
}
# 4 "../extensions/tofino/ir/mau.def"
struct TableResourceAlloc;
# 5393 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
namespace IR {
namespace MAU {
class Table : public Node {
 public:
    cstring name;
    gress_t gress;
    int logical_id = -1;
    vector<std::pair<const Expression *, cstring>> gateway_rows;
    const ActionFunction* gateway_payload = nullptr;
    const IR::V1Table* match_table = nullptr;
    Vector<Attached> attached;
    NameMap<ActionFunction, ordered_map> actions;
    NameMap<TableSeq> next;
# 33 "../extensions/tofino/ir/mau.def"
 struct Layout {

        int entries = 0;
        bool gateway = false, ternary = false;
        int ixbar_bytes = 0;
        int match_width_bits = 0;
        int action_data_bytes = 0;
        int action_data_bytes_in_overhead = 0;
        int overhead_bits = 0;
        Layout() { memset(this, 0, sizeof(*this)); }
        bool operator==(const Layout &a) const {
            return memcmp(this, &a, sizeof(Layout)) == 0; }
        Layout &operator+=(const Layout &a);
    } layout;
    struct Way {

        int match_groups = 0;
        int entries = 0;
        int width = 0;
        Way() { memset(this, 0, sizeof(*this)); }
        bool operator==(const Way &a) const {
            return memcmp(this, &a, sizeof(Way)) == 0; }
    };
    std::vector<Way> ways;
    const TableResourceAlloc *resources = nullptr;

    Table(cstring n, gress_t gr, const IR::V1Table *t)
    : Node(t->srcInfo), name(n), gress(gr), match_table(t) {}
    Table(cstring n, gress_t gr, const Expression *gw)
    : Node(gw->srcInfo), name(n), gress(gr), gateway_rows{ std::make_pair(gw, "true"),
                                                           std::make_pair(nullptr, "false") } {}

    int logical_order() const { return logical_id + gress * 4096; }
    Table *clone_rename(const char *ext) const {
        Table *rv = clone();
        rv->name += ext;
        for (auto &at : rv->attached) at = at->clone_rename(ext);
        return rv; }
    bool operator==(const Table &a) const;
    bool uses_gateway() const { return !gateway_rows.empty(); }
    int stage() const { return logical_id < 0 ? -1 : logical_id / StageUse::MAX_LOGICAL_IDS; }
# 5449 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 75 "../extensions/tofino/ir/mau.def"
 void validate() const override {
        attached.validate();
        actions.validate();
        next.validate();{
        std::set<cstring> gw_next;
        for (auto &gw : gateway_rows) {
            if (&gw != &gateway_rows.back())
                do { if ((gw.first) == nullptr) do { throw Util::CompilerBug("../extensions/tofino/ir/mau.def", 82, "../extensions/tofino/ir/mau.def" ":" "82" ": Null " "gw.first"); } while (0); } while (0);
            else if (gw.first)
                gw_next.emplace(cstring());
            gw_next.emplace(gw.second); }
        if (!match_table && !uses_gateway())
            do { throw Util::CompilerBug("../extensions/tofino/ir/mau.def", 87, "table with no gateway or match table"); } while (0);
        if (!match_table && gw_next.count(cstring()))
            do { throw Util::CompilerBug("../extensions/tofino/ir/mau.def", 89, "gateway with no match table wants to run match table"); } while (0);
        if (match_table && uses_gateway() && !gw_next.count(cstring()))
            do { throw Util::CompilerBug("../extensions/tofino/ir/mau.def", 91, "gateway always overrides match table"); } while (0);
        for (auto &nxt : next) {
            if (nxt.first == "default") {
            } else if (nxt.first == "$hit" || nxt.first == "$miss") {
                if (!match_table)
                    do { throw Util::CompilerBug("../extensions/tofino/ir/mau.def", 96, "%s next on table with no match_table", nxt.first); } while (0);
            } else if (!gw_next.count(nxt.first) && !actions.count(nxt.first)) {
                do { throw Util::CompilerBug("../extensions/tofino/ir/mau.def", 98, "%s next on table with no such action or gw result", nxt.first); } while (0); } } } }
# 5475 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    cstring node_type_name() const override { return "MAU::Table"; }
    static cstring static_type_name() { return "MAU::Table"; }
    void dbprint(std::ostream &out) const override ;
    void dump_fields(std::ostream& out) const override;
    public: Table *clone() const override { return new Table(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
};
}
}
namespace IR {
namespace MAU {
class TernaryIndirect : public Attached {
 public:
# 137 "../extensions/tofino/ir/mau.def"
 explicit TernaryIndirect(cstring tbl_name) { name = IR::ID(tbl_name + "$tind"); }
    const char *kind() const { return "indirect"; }
# 5493 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const TernaryIndirect&a) const {
        return Attached::operator==(a);
    }
    cstring node_type_name() const override { return "MAU::TernaryIndirect"; }
    static cstring static_type_name() { return "MAU::TernaryIndirect"; }
    public: TernaryIndirect *clone() const override { return new TernaryIndirect(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
};
}
}
namespace IR {
namespace MAU {
class ActionData : public Attached {
 public:
    bool direct = true;
# 147 "../extensions/tofino/ir/mau.def"
 explicit ActionData(cstring tbl_name) { name = IR::ID(tbl_name + "$action"); }
    const char *kind() const { return "action"; }
    bool indexed() const { return !direct; }
# 5512 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const ActionData&a) const {
        return Attached::operator==(a)
        && direct == a.direct;
    }
    cstring node_type_name() const override { return "MAU::ActionData"; }
    static cstring static_type_name() { return "MAU::ActionData"; }
    void dump_fields(std::ostream& out) const override;
    public: ActionData *clone() const override { return new ActionData(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
};
}
}
namespace IR {
namespace MAU {
class TableSeq : public Node {
 public:
    Vector<Table> tables;
    LTBitMatrix deps;
# 160 "../extensions/tofino/ir/mau.def"
 TableSeq() = default;
    explicit TableSeq(const Table *a) { if (a) tables.push_back(a); }
    TableSeq(const Table *a, const Table *b) {
        if (a) tables.push_back(a);
        if (b) tables.push_back(b); }
    TableSeq(const TableSeq *a, const Table *b) {
        if (a) tables.insert(tables.end(), a->tables.begin(), a->tables.end());
        if (b) tables.push_back(b); }
    bool empty() const { return tables.empty(); }
    const Table *front() const { return tables.empty() ? nullptr : tables.front(); }
# 5541 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 const TableSeq *apply(Visitor &v) const; const TableSeq *apply(Visitor &&v) const { return apply(v); }
    bool operator==(const TableSeq&a) const {
        return typeid(*this) == typeid(a)
        && tables == a.tables
        && deps == a.deps;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        tables.validate(); }
    cstring node_type_name() const override { return "MAU::TableSeq"; }
    static cstring static_type_name() { return "MAU::TableSeq"; }
    void dbprint(std::ostream &out) const override ;
    void dump_fields(std::ostream& out) const override;
    public: TableSeq *clone() const override { return new TableSeq(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
    TableSeq(Util::SourceInfo srcInfo,
        Vector<Table> tables,
        LTBitMatrix deps) :
        Node(srcInfo),
        tables(tables),
        deps(deps)
    { validate(); }
};
}
}
namespace IR {
namespace MAU {
class Instruction : public Primitive {
 public:
# 185 "../extensions/tofino/ir/mau.def"
 using Primitive::Primitive;
    explicit Instruction(const Primitive &p) : Primitive(p) {}
    bool isOutput(int operand_index) const { return operand_index == 0; }
# 5575 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Instruction&a) const {
        return Primitive::operator==(a);
    }
    cstring node_type_name() const override { return "MAU::Instruction"; }
    static cstring static_type_name() { return "MAU::Instruction"; }
    public: Instruction *clone() const override { return new Instruction(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
};
}
}
namespace IR {
namespace Tofino {
class ParserMatch : public Node {
 public:
    match_t value;
    int shift;
    Vector<Expression> stmts;
    const ParserState* next = nullptr;
    const ParserException* except = nullptr;
# 11 "../extensions/tofino/ir/parde.def"
 ParserMatch(match_t v, const Vector<Expression> &e)
  : value(v), shift(-1), stmts(e), next(0), except(0) {}
  ParserMatch(match_t v, int sh, const std::initializer_list<const Expression *> &st,
                     const ParserState *n, const ParserException *ex = nullptr)
  : value(v), shift(sh), stmts(st), next(n), except(ex) {}
# 5600 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const ParserMatch&a) const {
        return typeid(*this) == typeid(a)
        && value == a.value
        && shift == a.shift
        && stmts == a.stmts
        && next == a.next
        && except == a.except;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        stmts.validate(); }
    cstring node_type_name() const override { return "Tofino::ParserMatch"; }
    static cstring static_type_name() { return "Tofino::ParserMatch"; }
    void dbprint(std::ostream &out) const override ;
    void dump_fields(std::ostream& out) const override;
    public: ParserMatch *clone() const override { return new ParserMatch(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
};
}
}
namespace IR {
namespace Tofino {
class ParserState : public Node {
 public:
    cstring name;
    Vector<Expression> select;
    Vector<ParserMatch> match;
# 25 "../extensions/tofino/ir/parde.def"
 const IR::Node *p4state = 0;
  explicit ParserState(const IR::Node *);
  ParserState(cstring n, const std::initializer_list<const Expression *> &sel,
              const std::initializer_list<const ParserMatch *> &m)
  : name(n), select(sel), match(m) {}
# 5634 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
# 31 "../extensions/tofino/ir/parde.def"
 cstring toString() const override { return name; }
# 5637 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const ParserState&a) const {
        return typeid(*this) == typeid(a)
        && name == a.name
        && select == a.select
        && match == a.match;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        select.validate();
        match.validate(); }
    cstring node_type_name() const override { return "Tofino::ParserState"; }
    static cstring static_type_name() { return "Tofino::ParserState"; }
    void dbprint(std::ostream &out) const override ;
    void dump_fields(std::ostream& out) const override;
    public: ParserState *clone() const override { return new ParserState(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
};
}
}
namespace IR {
namespace Tofino {
class Parser : public Node {
 public:
    gress_t gress;
    const ParserState* start = nullptr;
# 39 "../extensions/tofino/ir/parde.def"
 Parser(gress_t gr, const ParserState *s) : gress(gr), start(s) {}
# 5665 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 const Parser *apply(Visitor &v) const; const Parser *apply(Visitor &&v) const { return apply(v); }
# 42 "../extensions/tofino/ir/parde.def"
 cstring toString() const override { return gress ? "egress parser" : "ingress parser"; }
# 5669 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Parser&a) const {
        return typeid(*this) == typeid(a)
        && gress == a.gress
        && start == a.start;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        do { if ((start) == nullptr) do { throw Util::CompilerBug("/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h", 5677, "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h" ":" "5677" ": Null " "start"); } while (0); } while (0); }
    cstring node_type_name() const override { return "Tofino::Parser"; }
    static cstring static_type_name() { return "Tofino::Parser"; }
    void dbprint(std::ostream &out) const override ;
    void dump_fields(std::ostream& out) const override;
    public: Parser *clone() const override { return new Parser(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
};
}
}
namespace IR {
namespace Tofino {
class Deparser : public Node {
 public:
    gress_t gress;
    Vector<Expression> emits;
    const Expression* egress_port = nullptr;
# 51 "../extensions/tofino/ir/parde.def"
 Deparser(gress_t gr, const Parser *s);
# 5696 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 const Deparser *apply(Visitor &v) const; const Deparser *apply(Visitor &&v) const { return apply(v); }
# 54 "../extensions/tofino/ir/parde.def"
 cstring toString() const override { return gress ? "egress deparser" : "ingress deparser"; }
# 5700 "/home/mbudiu/barefoot/git/p4c/build/ir/ir-generated.h"
 bool operator==(const Deparser&a) const {
        return typeid(*this) == typeid(a)
        && gress == a.gress
        && emits == a.emits
        && egress_port == a.egress_port;
    }
    void visit_children(Visitor &v) override;
    void visit_children(Visitor &v) const override;
    void validate() const override {
        emits.validate(); }
    cstring node_type_name() const override { return "Tofino::Deparser"; }
    static cstring static_type_name() { return "Tofino::Deparser"; }
    void dbprint(std::ostream &out) const override ;
    void dump_fields(std::ostream& out) const override;
    public: Deparser *clone() const override { return new Deparser(*this); } public: inline bool operator==(const Node &n) const override; bool apply_visitor_preorder(Modifier &v) override; void apply_visitor_postorder(Modifier &v) override; bool apply_visitor_preorder(Inspector &v) const override; void apply_visitor_postorder(Inspector &v) const override; const Node *apply_visitor_preorder(Transform &v) override; const Node *apply_visitor_postorder(Transform &v) override;
};
}
}
# 31 "../ir/ir.h" 2

# 1 "../ir/pass_manager.h" 1



# 1 "../ir/visitor.h" 1






# 1 "../ir/ir.h" 1
# 8 "../ir/visitor.h" 2


class Visitor {
 public:
    struct Context {




        const Context *parent;
        const IR::Node *node, *original;
        mutable int child_index;
        mutable const char *child_name;
        int depth;
    };
    class profile_t {


        Visitor &v;
        uint64_t start;
        explicit profile_t(Visitor &);
        profile_t() = delete;
        profile_t(const profile_t &) = delete;
        profile_t &operator=(const profile_t &) = delete;
        profile_t &operator= (profile_t &&) = delete;
        friend class Visitor;
     public:
        ~profile_t();
        profile_t(profile_t &&);
    };
    virtual ~Visitor() = default;






    virtual profile_t init_apply(const IR::Node *root);


    virtual void end_apply(const IR::Node* root);




    virtual const IR::Node *apply_visitor(const IR::Node *n, const char *name = 0) = 0;
    void visit(const IR::Node *&n, const char *name = 0) { n = apply_visitor(n, name); }
    void visit(const IR::Node *const &n, const char *name = 0) {
        auto t = apply_visitor(n, name);
        if (t != n) visitor_const_error(); }
    void visit(IR::Node *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 58, "Can't visit non-const pointer"); } while (0); }




    void visit(const IR::Type *&n, const char *name = 0); void visit(const IR::Type *const &n, const char *name = 0); void visit(IR::Type *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Type_Base *&n, const char *name = 0); void visit(const IR::Type_Base *const &n, const char *name = 0); void visit(IR::Type_Base *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Type_Unknown *&n, const char *name = 0); void visit(const IR::Type_Unknown *const &n, const char *name = 0); void visit(IR::Type_Unknown *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::StatOrDecl *&n, const char *name = 0); void visit(const IR::StatOrDecl *const &n, const char *name = 0); void visit(IR::StatOrDecl *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Declaration *&n, const char *name = 0); void visit(const IR::Declaration *const &n, const char *name = 0); void visit(IR::Declaration *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Type_Declaration *&n, const char *name = 0); void visit(const IR::Type_Declaration *const &n, const char *name = 0); void visit(IR::Type_Declaration *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Expression *&n, const char *name = 0); void visit(const IR::Expression *const &n, const char *name = 0); void visit(IR::Expression *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Operation *&n, const char *name = 0); void visit(const IR::Operation *const &n, const char *name = 0); void visit(IR::Operation *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::PathPrefix *&n, const char *name = 0); void visit(const IR::PathPrefix *const &n, const char *name = 0); void visit(IR::PathPrefix *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Path *&n, const char *name = 0); void visit(const IR::Path *const &n, const char *name = 0); void visit(IR::Path *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Annotation *&n, const char *name = 0); void visit(const IR::Annotation *const &n, const char *name = 0); void visit(IR::Annotation *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Annotations *&n, const char *name = 0); void visit(const IR::Annotations *const &n, const char *name = 0); void visit(IR::Annotations *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Type_Boolean *&n, const char *name = 0); void visit(const IR::Type_Boolean *const &n, const char *name = 0); void visit(IR::Type_Boolean *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Type_State *&n, const char *name = 0); void visit(const IR::Type_State *const &n, const char *name = 0); void visit(IR::Type_State *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Type_Bits *&n, const char *name = 0); void visit(const IR::Type_Bits *const &n, const char *name = 0); void visit(IR::Type_Bits *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Type_Varbits *&n, const char *name = 0); void visit(const IR::Type_Varbits *const &n, const char *name = 0); void visit(IR::Type_Varbits *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Parameter *&n, const char *name = 0); void visit(const IR::Parameter *const &n, const char *name = 0); void visit(IR::Parameter *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::ParameterList *&n, const char *name = 0); void visit(const IR::ParameterList *const &n, const char *name = 0); void visit(IR::ParameterList *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Type_Var *&n, const char *name = 0); void visit(const IR::Type_Var *const &n, const char *name = 0); void visit(IR::Type_Var *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Type_InfInt *&n, const char *name = 0); void visit(const IR::Type_InfInt *const &n, const char *name = 0); void visit(IR::Type_InfInt *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Type_Dontcare *&n, const char *name = 0); void visit(const IR::Type_Dontcare *const &n, const char *name = 0); void visit(IR::Type_Dontcare *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Type_Void *&n, const char *name = 0); void visit(const IR::Type_Void *const &n, const char *name = 0); void visit(IR::Type_Void *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Type_Error *&n, const char *name = 0); void visit(const IR::Type_Error *const &n, const char *name = 0); void visit(IR::Type_Error *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Type_MatchKind *&n, const char *name = 0); void visit(const IR::Type_MatchKind *const &n, const char *name = 0); void visit(IR::Type_MatchKind *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::TypeParameters *&n, const char *name = 0); void visit(const IR::TypeParameters *const &n, const char *name = 0); void visit(IR::TypeParameters *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::StructField *&n, const char *name = 0); void visit(const IR::StructField *const &n, const char *name = 0); void visit(IR::StructField *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Type_StructLike *&n, const char *name = 0); void visit(const IR::Type_StructLike *const &n, const char *name = 0); void visit(IR::Type_StructLike *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Type_Struct *&n, const char *name = 0); void visit(const IR::Type_Struct *const &n, const char *name = 0); void visit(IR::Type_Struct *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Type_Union *&n, const char *name = 0); void visit(const IR::Type_Union *const &n, const char *name = 0); void visit(IR::Type_Union *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Type_Header *&n, const char *name = 0); void visit(const IR::Type_Header *const &n, const char *name = 0); void visit(IR::Type_Header *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Type_Set *&n, const char *name = 0); void visit(const IR::Type_Set *const &n, const char *name = 0); void visit(IR::Type_Set *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Type_Tuple *&n, const char *name = 0); void visit(const IR::Type_Tuple *const &n, const char *name = 0); void visit(IR::Type_Tuple *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Type_ArchBlock *&n, const char *name = 0); void visit(const IR::Type_ArchBlock *const &n, const char *name = 0); void visit(IR::Type_ArchBlock *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Type_Package *&n, const char *name = 0); void visit(const IR::Type_Package *const &n, const char *name = 0); void visit(IR::Type_Package *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Type_Parser *&n, const char *name = 0); void visit(const IR::Type_Parser *const &n, const char *name = 0); void visit(IR::Type_Parser *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Type_Control *&n, const char *name = 0); void visit(const IR::Type_Control *const &n, const char *name = 0); void visit(IR::Type_Control *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Type_Name *&n, const char *name = 0); void visit(const IR::Type_Name *const &n, const char *name = 0); void visit(IR::Type_Name *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Type_Stack *&n, const char *name = 0); void visit(const IR::Type_Stack *const &n, const char *name = 0); void visit(IR::Type_Stack *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Type_Specialized *&n, const char *name = 0); void visit(const IR::Type_Specialized *const &n, const char *name = 0); void visit(IR::Type_Specialized *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Type_SpecializedCanonical *&n, const char *name = 0); void visit(const IR::Type_SpecializedCanonical *const &n, const char *name = 0); void visit(IR::Type_SpecializedCanonical *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Declaration_ID *&n, const char *name = 0); void visit(const IR::Declaration_ID *const &n, const char *name = 0); void visit(IR::Declaration_ID *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Type_Enum *&n, const char *name = 0); void visit(const IR::Type_Enum *const &n, const char *name = 0); void visit(IR::Type_Enum *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Type_Table *&n, const char *name = 0); void visit(const IR::Type_Table *const &n, const char *name = 0); void visit(IR::Type_Table *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Type_ActionEnum *&n, const char *name = 0); void visit(const IR::Type_ActionEnum *const &n, const char *name = 0); void visit(IR::Type_ActionEnum *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Type_MethodBase *&n, const char *name = 0); void visit(const IR::Type_MethodBase *const &n, const char *name = 0); void visit(IR::Type_MethodBase *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Type_Method *&n, const char *name = 0); void visit(const IR::Type_Method *const &n, const char *name = 0); void visit(IR::Type_Method *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::ArgumentInfo *&n, const char *name = 0); void visit(const IR::ArgumentInfo *const &n, const char *name = 0); void visit(IR::ArgumentInfo *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Type_MethodCall *&n, const char *name = 0); void visit(const IR::Type_MethodCall *const &n, const char *name = 0); void visit(IR::Type_MethodCall *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Type_Action *&n, const char *name = 0); void visit(const IR::Type_Action *const &n, const char *name = 0); void visit(IR::Type_Action *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Method *&n, const char *name = 0); void visit(const IR::Method *const &n, const char *name = 0); void visit(IR::Method *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Type_Typedef *&n, const char *name = 0); void visit(const IR::Type_Typedef *const &n, const char *name = 0); void visit(IR::Type_Typedef *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Type_Extern *&n, const char *name = 0); void visit(const IR::Type_Extern *const &n, const char *name = 0); void visit(IR::Type_Extern *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Operation_Unary *&n, const char *name = 0); void visit(const IR::Operation_Unary *const &n, const char *name = 0); void visit(IR::Operation_Unary *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Neg *&n, const char *name = 0); void visit(const IR::Neg *const &n, const char *name = 0); void visit(IR::Neg *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Cmpl *&n, const char *name = 0); void visit(const IR::Cmpl *const &n, const char *name = 0); void visit(IR::Cmpl *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::LNot *&n, const char *name = 0); void visit(const IR::LNot *const &n, const char *name = 0); void visit(IR::LNot *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Operation_Binary *&n, const char *name = 0); void visit(const IR::Operation_Binary *const &n, const char *name = 0); void visit(IR::Operation_Binary *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Operation_Ternary *&n, const char *name = 0); void visit(const IR::Operation_Ternary *const &n, const char *name = 0); void visit(IR::Operation_Ternary *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Operation_Relation *&n, const char *name = 0); void visit(const IR::Operation_Relation *const &n, const char *name = 0); void visit(IR::Operation_Relation *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Mul *&n, const char *name = 0); void visit(const IR::Mul *const &n, const char *name = 0); void visit(IR::Mul *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Div *&n, const char *name = 0); void visit(const IR::Div *const &n, const char *name = 0); void visit(IR::Div *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Mod *&n, const char *name = 0); void visit(const IR::Mod *const &n, const char *name = 0); void visit(IR::Mod *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Add *&n, const char *name = 0); void visit(const IR::Add *const &n, const char *name = 0); void visit(IR::Add *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Sub *&n, const char *name = 0); void visit(const IR::Sub *const &n, const char *name = 0); void visit(IR::Sub *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Shl *&n, const char *name = 0); void visit(const IR::Shl *const &n, const char *name = 0); void visit(IR::Shl *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Shr *&n, const char *name = 0); void visit(const IR::Shr *const &n, const char *name = 0); void visit(IR::Shr *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Equ *&n, const char *name = 0); void visit(const IR::Equ *const &n, const char *name = 0); void visit(IR::Equ *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Neq *&n, const char *name = 0); void visit(const IR::Neq *const &n, const char *name = 0); void visit(IR::Neq *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Lss *&n, const char *name = 0); void visit(const IR::Lss *const &n, const char *name = 0); void visit(IR::Lss *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Leq *&n, const char *name = 0); void visit(const IR::Leq *const &n, const char *name = 0); void visit(IR::Leq *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Grt *&n, const char *name = 0); void visit(const IR::Grt *const &n, const char *name = 0); void visit(IR::Grt *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Geq *&n, const char *name = 0); void visit(const IR::Geq *const &n, const char *name = 0); void visit(IR::Geq *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::BAnd *&n, const char *name = 0); void visit(const IR::BAnd *const &n, const char *name = 0); void visit(IR::BAnd *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::BOr *&n, const char *name = 0); void visit(const IR::BOr *const &n, const char *name = 0); void visit(IR::BOr *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::BXor *&n, const char *name = 0); void visit(const IR::BXor *const &n, const char *name = 0); void visit(IR::BXor *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::LAnd *&n, const char *name = 0); void visit(const IR::LAnd *const &n, const char *name = 0); void visit(IR::LAnd *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::LOr *&n, const char *name = 0); void visit(const IR::LOr *const &n, const char *name = 0); void visit(IR::LOr *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Constant *&n, const char *name = 0); void visit(const IR::Constant *const &n, const char *name = 0); void visit(IR::Constant *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::BoolLiteral *&n, const char *name = 0); void visit(const IR::BoolLiteral *const &n, const char *name = 0); void visit(IR::BoolLiteral *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::StringLiteral *&n, const char *name = 0); void visit(const IR::StringLiteral *const &n, const char *name = 0); void visit(IR::StringLiteral *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::PathExpression *&n, const char *name = 0); void visit(const IR::PathExpression *const &n, const char *name = 0); void visit(IR::PathExpression *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::TypeNameExpression *&n, const char *name = 0); void visit(const IR::TypeNameExpression *const &n, const char *name = 0); void visit(IR::TypeNameExpression *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Slice *&n, const char *name = 0); void visit(const IR::Slice *const &n, const char *name = 0); void visit(IR::Slice *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Member *&n, const char *name = 0); void visit(const IR::Member *const &n, const char *name = 0); void visit(IR::Member *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Concat *&n, const char *name = 0); void visit(const IR::Concat *const &n, const char *name = 0); void visit(IR::Concat *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::ArrayIndex *&n, const char *name = 0); void visit(const IR::ArrayIndex *const &n, const char *name = 0); void visit(IR::ArrayIndex *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Range *&n, const char *name = 0); void visit(const IR::Range *const &n, const char *name = 0); void visit(IR::Range *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Mask *&n, const char *name = 0); void visit(const IR::Mask *const &n, const char *name = 0); void visit(IR::Mask *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Mux *&n, const char *name = 0); void visit(const IR::Mux *const &n, const char *name = 0); void visit(IR::Mux *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::DefaultExpression *&n, const char *name = 0); void visit(const IR::DefaultExpression *const &n, const char *name = 0); void visit(IR::DefaultExpression *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::This *&n, const char *name = 0); void visit(const IR::This *const &n, const char *name = 0); void visit(IR::This *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Cast *&n, const char *name = 0); void visit(const IR::Cast *const &n, const char *name = 0); void visit(IR::Cast *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::SelectExpression *&n, const char *name = 0); void visit(const IR::SelectExpression *const &n, const char *name = 0); void visit(IR::SelectExpression *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::MethodCallExpression *&n, const char *name = 0); void visit(const IR::MethodCallExpression *const &n, const char *name = 0); void visit(IR::MethodCallExpression *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::ConstructorCallExpression *&n, const char *name = 0); void visit(const IR::ConstructorCallExpression *const &n, const char *name = 0); void visit(IR::ConstructorCallExpression *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::ListExpression *&n, const char *name = 0); void visit(const IR::ListExpression *const &n, const char *name = 0); void visit(IR::ListExpression *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::SelectCase *&n, const char *name = 0); void visit(const IR::SelectCase *const &n, const char *name = 0); void visit(IR::SelectCase *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::ParserState *&n, const char *name = 0); void visit(const IR::ParserState *const &n, const char *name = 0); void visit(IR::ParserState *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::P4Parser *&n, const char *name = 0); void visit(const IR::P4Parser *const &n, const char *name = 0); void visit(IR::P4Parser *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::P4Control *&n, const char *name = 0); void visit(const IR::P4Control *const &n, const char *name = 0); void visit(IR::P4Control *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::P4Action *&n, const char *name = 0); void visit(const IR::P4Action *const &n, const char *name = 0); void visit(IR::P4Action *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Declaration_Errors *&n, const char *name = 0); void visit(const IR::Declaration_Errors *const &n, const char *name = 0); void visit(IR::Declaration_Errors *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Declaration_MatchKind *&n, const char *name = 0); void visit(const IR::Declaration_MatchKind *const &n, const char *name = 0); void visit(IR::Declaration_MatchKind *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::PropertyValue *&n, const char *name = 0); void visit(const IR::PropertyValue *const &n, const char *name = 0); void visit(IR::PropertyValue *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::ExpressionValue *&n, const char *name = 0); void visit(const IR::ExpressionValue *const &n, const char *name = 0); void visit(IR::ExpressionValue *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::ActionListElement *&n, const char *name = 0); void visit(const IR::ActionListElement *const &n, const char *name = 0); void visit(IR::ActionListElement *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::ActionList *&n, const char *name = 0); void visit(const IR::ActionList *const &n, const char *name = 0); void visit(IR::ActionList *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::KeyElement *&n, const char *name = 0); void visit(const IR::KeyElement *const &n, const char *name = 0); void visit(IR::KeyElement *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Key *&n, const char *name = 0); void visit(const IR::Key *const &n, const char *name = 0); void visit(IR::Key *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::TableProperty *&n, const char *name = 0); void visit(const IR::TableProperty *const &n, const char *name = 0); void visit(IR::TableProperty *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::TableProperties *&n, const char *name = 0); void visit(const IR::TableProperties *const &n, const char *name = 0); void visit(IR::TableProperties *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::P4Table *&n, const char *name = 0); void visit(const IR::P4Table *const &n, const char *name = 0); void visit(IR::P4Table *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Declaration_Variable *&n, const char *name = 0); void visit(const IR::Declaration_Variable *const &n, const char *name = 0); void visit(IR::Declaration_Variable *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Declaration_Constant *&n, const char *name = 0); void visit(const IR::Declaration_Constant *const &n, const char *name = 0); void visit(IR::Declaration_Constant *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Declaration_Instance *&n, const char *name = 0); void visit(const IR::Declaration_Instance *const &n, const char *name = 0); void visit(IR::Declaration_Instance *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::P4Program *&n, const char *name = 0); void visit(const IR::P4Program *const &n, const char *name = 0); void visit(IR::P4Program *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Statement *&n, const char *name = 0); void visit(const IR::Statement *const &n, const char *name = 0); void visit(IR::Statement *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::ExitStatement *&n, const char *name = 0); void visit(const IR::ExitStatement *const &n, const char *name = 0); void visit(IR::ExitStatement *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::ReturnStatement *&n, const char *name = 0); void visit(const IR::ReturnStatement *const &n, const char *name = 0); void visit(IR::ReturnStatement *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::EmptyStatement *&n, const char *name = 0); void visit(const IR::EmptyStatement *const &n, const char *name = 0); void visit(IR::EmptyStatement *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::AssignmentStatement *&n, const char *name = 0); void visit(const IR::AssignmentStatement *const &n, const char *name = 0); void visit(IR::AssignmentStatement *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::IfStatement *&n, const char *name = 0); void visit(const IR::IfStatement *const &n, const char *name = 0); void visit(IR::IfStatement *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::BlockStatement *&n, const char *name = 0); void visit(const IR::BlockStatement *const &n, const char *name = 0); void visit(IR::BlockStatement *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::MethodCallStatement *&n, const char *name = 0); void visit(const IR::MethodCallStatement *const &n, const char *name = 0); void visit(IR::MethodCallStatement *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::SwitchCase *&n, const char *name = 0); void visit(const IR::SwitchCase *const &n, const char *name = 0); void visit(IR::SwitchCase *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::SwitchStatement *&n, const char *name = 0); void visit(const IR::SwitchStatement *const &n, const char *name = 0); void visit(IR::SwitchStatement *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Function *&n, const char *name = 0); void visit(const IR::Function *const &n, const char *name = 0); void visit(IR::Function *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Block *&n, const char *name = 0); void visit(const IR::Block *const &n, const char *name = 0); void visit(IR::Block *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::TableBlock *&n, const char *name = 0); void visit(const IR::TableBlock *const &n, const char *name = 0); void visit(IR::TableBlock *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::InstantiatedBlock *&n, const char *name = 0); void visit(const IR::InstantiatedBlock *const &n, const char *name = 0); void visit(IR::InstantiatedBlock *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::ParserBlock *&n, const char *name = 0); void visit(const IR::ParserBlock *const &n, const char *name = 0); void visit(IR::ParserBlock *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::ControlBlock *&n, const char *name = 0); void visit(const IR::ControlBlock *const &n, const char *name = 0); void visit(IR::ControlBlock *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::PackageBlock *&n, const char *name = 0); void visit(const IR::PackageBlock *const &n, const char *name = 0); void visit(IR::PackageBlock *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::ExternBlock *&n, const char *name = 0); void visit(const IR::ExternBlock *const &n, const char *name = 0); void visit(IR::ExternBlock *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::ToplevelBlock *&n, const char *name = 0); void visit(const IR::ToplevelBlock *const &n, const char *name = 0); void visit(IR::ToplevelBlock *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::HeaderOrMetadata *&n, const char *name = 0); void visit(const IR::HeaderOrMetadata *const &n, const char *name = 0); void visit(IR::HeaderOrMetadata *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Header *&n, const char *name = 0); void visit(const IR::Header *const &n, const char *name = 0); void visit(IR::Header *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::HeaderStack *&n, const char *name = 0); void visit(const IR::HeaderStack *const &n, const char *name = 0); void visit(IR::HeaderStack *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Metadata *&n, const char *name = 0); void visit(const IR::Metadata *const &n, const char *name = 0); void visit(IR::Metadata *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::HeaderRef *&n, const char *name = 0); void visit(const IR::HeaderRef *const &n, const char *name = 0); void visit(IR::HeaderRef *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::ConcreteHeaderRef *&n, const char *name = 0); void visit(const IR::ConcreteHeaderRef *const &n, const char *name = 0); void visit(IR::ConcreteHeaderRef *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::HeaderStackItemRef *&n, const char *name = 0); void visit(const IR::HeaderStackItemRef *const &n, const char *name = 0); void visit(IR::HeaderStackItemRef *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::NamedRef *&n, const char *name = 0); void visit(const IR::NamedRef *const &n, const char *name = 0); void visit(IR::NamedRef *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::If *&n, const char *name = 0); void visit(const IR::If *const &n, const char *name = 0); void visit(IR::If *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::NamedCond *&n, const char *name = 0); void visit(const IR::NamedCond *const &n, const char *name = 0); void visit(IR::NamedCond *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Apply *&n, const char *name = 0); void visit(const IR::Apply *const &n, const char *name = 0); void visit(IR::Apply *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Primitive *&n, const char *name = 0); void visit(const IR::Primitive *const &n, const char *name = 0); void visit(IR::Primitive *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::FieldList *&n, const char *name = 0); void visit(const IR::FieldList *const &n, const char *name = 0); void visit(IR::FieldList *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::FieldListCalculation *&n, const char *name = 0); void visit(const IR::FieldListCalculation *const &n, const char *name = 0); void visit(IR::FieldListCalculation *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::CalculatedField *&n, const char *name = 0); void visit(const IR::CalculatedField *const &n, const char *name = 0); void visit(IR::CalculatedField *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::CaseEntry *&n, const char *name = 0); void visit(const IR::CaseEntry *const &n, const char *name = 0); void visit(IR::CaseEntry *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::V1Parser *&n, const char *name = 0); void visit(const IR::V1Parser *const &n, const char *name = 0); void visit(IR::V1Parser *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::ParserException *&n, const char *name = 0); void visit(const IR::ParserException *const &n, const char *name = 0); void visit(IR::ParserException *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Attached *&n, const char *name = 0); void visit(const IR::Attached *const &n, const char *name = 0); void visit(IR::Attached *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Stateful *&n, const char *name = 0); void visit(const IR::Stateful *const &n, const char *name = 0); void visit(IR::Stateful *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::CounterOrMeter *&n, const char *name = 0); void visit(const IR::CounterOrMeter *const &n, const char *name = 0); void visit(IR::CounterOrMeter *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Counter *&n, const char *name = 0); void visit(const IR::Counter *const &n, const char *name = 0); void visit(IR::Counter *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Meter *&n, const char *name = 0); void visit(const IR::Meter *const &n, const char *name = 0); void visit(IR::Meter *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Register *&n, const char *name = 0); void visit(const IR::Register *const &n, const char *name = 0); void visit(IR::Register *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::PrimitiveAction *&n, const char *name = 0); void visit(const IR::PrimitiveAction *const &n, const char *name = 0); void visit(IR::PrimitiveAction *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::NameList *&n, const char *name = 0); void visit(const IR::NameList *const &n, const char *name = 0); void visit(IR::NameList *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::ActionArg *&n, const char *name = 0); void visit(const IR::ActionArg *const &n, const char *name = 0); void visit(IR::ActionArg *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::ActionFunction *&n, const char *name = 0); void visit(const IR::ActionFunction *const &n, const char *name = 0); void visit(IR::ActionFunction *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::ActionProfile *&n, const char *name = 0); void visit(const IR::ActionProfile *const &n, const char *name = 0); void visit(IR::ActionProfile *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::ActionSelector *&n, const char *name = 0); void visit(const IR::ActionSelector *const &n, const char *name = 0); void visit(IR::ActionSelector *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::V1Table *&n, const char *name = 0); void visit(const IR::V1Table *const &n, const char *name = 0); void visit(IR::V1Table *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::V1Control *&n, const char *name = 0); void visit(const IR::V1Control *const &n, const char *name = 0); void visit(IR::V1Control *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::V1Program *&n, const char *name = 0); void visit(const IR::V1Program *const &n, const char *name = 0); void visit(IR::V1Program *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::v1HeaderType *&n, const char *name = 0); void visit(const IR::v1HeaderType *const &n, const char *name = 0); void visit(IR::v1HeaderType *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::IntMod *&n, const char *name = 0); void visit(const IR::IntMod *const &n, const char *name = 0); void visit(IR::IntMod *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Tofino::Pipe *&n, const char *name = 0); void visit(const IR::Tofino::Pipe *const &n, const char *name = 0); void visit(IR::Tofino::Pipe *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::InstanceRef *&n, const char *name = 0); void visit(const IR::InstanceRef *const &n, const char *name = 0); void visit(IR::InstanceRef *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::HeaderSliceRef *&n, const char *name = 0); void visit(const IR::HeaderSliceRef *const &n, const char *name = 0); void visit(IR::HeaderSliceRef *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::MAU::Table *&n, const char *name = 0); void visit(const IR::MAU::Table *const &n, const char *name = 0); void visit(IR::MAU::Table *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::MAU::TernaryIndirect *&n, const char *name = 0); void visit(const IR::MAU::TernaryIndirect *const &n, const char *name = 0); void visit(IR::MAU::TernaryIndirect *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::MAU::ActionData *&n, const char *name = 0); void visit(const IR::MAU::ActionData *const &n, const char *name = 0); void visit(IR::MAU::ActionData *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::MAU::TableSeq *&n, const char *name = 0); void visit(const IR::MAU::TableSeq *const &n, const char *name = 0); void visit(IR::MAU::TableSeq *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::MAU::Instruction *&n, const char *name = 0); void visit(const IR::MAU::Instruction *const &n, const char *name = 0); void visit(IR::MAU::Instruction *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Tofino::ParserMatch *&n, const char *name = 0); void visit(const IR::Tofino::ParserMatch *const &n, const char *name = 0); void visit(IR::Tofino::ParserMatch *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Tofino::ParserState *&n, const char *name = 0); void visit(const IR::Tofino::ParserState *const &n, const char *name = 0); void visit(IR::Tofino::ParserState *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Tofino::Parser *&n, const char *name = 0); void visit(const IR::Tofino::Parser *const &n, const char *name = 0); void visit(IR::Tofino::Parser *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Tofino::Deparser *&n, const char *name = 0); void visit(const IR::Tofino::Deparser *const &n, const char *name = 0); void visit(IR::Tofino::Deparser *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Vector<IR::Node> *&n, const char *name = 0); void visit(const IR::Vector<IR::Node> *const &n, const char *name = 0); void visit(IR::Vector<IR::Node> *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Vector<IR::Type> *&n, const char *name = 0); void visit(const IR::Vector<IR::Type> *const &n, const char *name = 0); void visit(IR::Vector<IR::Type> *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Vector<IR::StatOrDecl> *&n, const char *name = 0); void visit(const IR::Vector<IR::StatOrDecl> *const &n, const char *name = 0); void visit(IR::Vector<IR::StatOrDecl> *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::IndexedVector<IR::StatOrDecl> *&n, const char *name = 0); void visit(const IR::IndexedVector<IR::StatOrDecl> *const &n, const char *name = 0); void visit(IR::IndexedVector<IR::StatOrDecl> *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Vector<IR::Declaration> *&n, const char *name = 0); void visit(const IR::Vector<IR::Declaration> *const &n, const char *name = 0); void visit(IR::Vector<IR::Declaration> *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Vector<IR::Expression> *&n, const char *name = 0); void visit(const IR::Vector<IR::Expression> *const &n, const char *name = 0); void visit(IR::Vector<IR::Expression> *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Vector<IR::Annotation> *&n, const char *name = 0); void visit(const IR::Vector<IR::Annotation> *const &n, const char *name = 0); void visit(IR::Vector<IR::Annotation> *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Vector<IR::ArgumentInfo> *&n, const char *name = 0); void visit(const IR::Vector<IR::ArgumentInfo> *const &n, const char *name = 0); void visit(IR::Vector<IR::ArgumentInfo> *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Vector<IR::Method> *&n, const char *name = 0); void visit(const IR::Vector<IR::Method> *const &n, const char *name = 0); void visit(IR::Vector<IR::Method> *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Vector<IR::SelectCase> *&n, const char *name = 0); void visit(const IR::Vector<IR::SelectCase> *const &n, const char *name = 0); void visit(IR::Vector<IR::SelectCase> *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Vector<IR::ParserState> *&n, const char *name = 0); void visit(const IR::Vector<IR::ParserState> *const &n, const char *name = 0); void visit(IR::Vector<IR::ParserState> *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Vector<IR::ActionListElement> *&n, const char *name = 0); void visit(const IR::Vector<IR::ActionListElement> *const &n, const char *name = 0); void visit(IR::Vector<IR::ActionListElement> *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Vector<IR::KeyElement> *&n, const char *name = 0); void visit(const IR::Vector<IR::KeyElement> *const &n, const char *name = 0); void visit(IR::Vector<IR::KeyElement> *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Vector<IR::SwitchCase> *&n, const char *name = 0); void visit(const IR::Vector<IR::SwitchCase> *const &n, const char *name = 0); void visit(IR::Vector<IR::SwitchCase> *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Vector<IR::Primitive> *&n, const char *name = 0); void visit(const IR::Vector<IR::Primitive> *const &n, const char *name = 0); void visit(IR::Vector<IR::Primitive> *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Vector<IR::CaseEntry> *&n, const char *name = 0); void visit(const IR::Vector<IR::CaseEntry> *const &n, const char *name = 0); void visit(IR::Vector<IR::CaseEntry> *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Vector<IR::Attached> *&n, const char *name = 0); void visit(const IR::Vector<IR::Attached> *const &n, const char *name = 0); void visit(IR::Vector<IR::Attached> *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Vector<IR::MAU::Table> *&n, const char *name = 0); void visit(const IR::Vector<IR::MAU::Table> *const &n, const char *name = 0); void visit(IR::Vector<IR::MAU::Table> *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); } void visit(const IR::Vector<IR::Tofino::ParserMatch> *&n, const char *name = 0); void visit(const IR::Vector<IR::Tofino::ParserMatch> *const &n, const char *name = 0); void visit(IR::Vector<IR::Tofino::ParserMatch> *&, const char * = 0) { do { throw Util::CompilerBug("../ir/visitor.h", 63, "Can't visit non-const pointer"); } while (0); }



    virtual Visitor &flow_clone() { return *this; }
    virtual void flow_merge(Visitor &) { }

    virtual const char *name() const { return typeid(*this).name(); }
    void print_context() const;






    const IR::Node* getOriginal() const { return ctxt->original; }
    template <class T>
    const T* getOriginal() const {
        do { if ((ctxt->original) == nullptr) do { throw Util::CompilerBug("../ir/visitor.h", 81, "../ir/visitor.h" ":" "81" ": Null " "ctxt->original"); } while (0); } while (0);
        auto result = ctxt->original->to<T>();
        do { if ((result) == nullptr) do { throw Util::CompilerBug("../ir/visitor.h", 83, "../ir/visitor.h" ":" "83" ": Null " "result"); } while (0); } while (0);
        return result; }
    const Context *getContext() const { return ctxt->parent; }
    int getChildrenVisited() const { return ctxt->child_index; }
    int getContextDepth() const { return ctxt->depth - 1; }
    template <class T> inline const T *findContext(const Context *&c) const {
        if (!c) c = ctxt;
        while ((c = c->parent))
            if (auto *rv = dynamic_cast<const T *>(c->node)) return rv;
        return nullptr; }
    template <class T> inline const T *findContext() const {
        const Context *c = ctxt;
        return findContext<T>(c); }
    template <class T> inline const T *findOrigCtxt(const Context *&c) const {
        if (!c) c = ctxt;
        while ((c = c->parent))
            if (auto *rv = dynamic_cast<const T *>(c->original)) return rv;
        return nullptr; }
    template <class T> inline const T *findOrigCtxt() const {
        const Context *c = ctxt;
        return findOrigCtxt<T>(c); }

 protected:




    bool visitDagOnce = true;
    bool dontForwardChildrenBeforePreorder = false;
    void visit_children(const IR::Node *, std::function<void()> fn) { fn(); }
    class ChangeTracker;

 private:
    virtual void visitor_const_error();
    const Context *ctxt = nullptr;
    friend class Inspector;
    friend class Modifier;
    friend class Transform;
    friend class ControlFlowVisitor;
};

class Modifier : public virtual Visitor {
    ChangeTracker *visited = nullptr;
    void visitor_const_error();
 public:
    profile_t init_apply(const IR::Node *root) override;
    const IR::Node *apply_visitor(const IR::Node *n, const char *name = 0) override;
    virtual bool preorder(IR::Node *) { return true; }
    virtual void postorder(IR::Node *) {}



    virtual bool preorder(IR::Type *); virtual void postorder(IR::Type *); virtual bool preorder(IR::Type_Base *); virtual void postorder(IR::Type_Base *); virtual bool preorder(IR::Type_Unknown *); virtual void postorder(IR::Type_Unknown *); virtual bool preorder(IR::StatOrDecl *); virtual void postorder(IR::StatOrDecl *); virtual bool preorder(IR::Declaration *); virtual void postorder(IR::Declaration *); virtual bool preorder(IR::Type_Declaration *); virtual void postorder(IR::Type_Declaration *); virtual bool preorder(IR::Expression *); virtual void postorder(IR::Expression *); virtual bool preorder(IR::Operation *); virtual void postorder(IR::Operation *); virtual bool preorder(IR::PathPrefix *); virtual void postorder(IR::PathPrefix *); virtual bool preorder(IR::Path *); virtual void postorder(IR::Path *); virtual bool preorder(IR::Annotation *); virtual void postorder(IR::Annotation *); virtual bool preorder(IR::Annotations *); virtual void postorder(IR::Annotations *); virtual bool preorder(IR::Type_Boolean *); virtual void postorder(IR::Type_Boolean *); virtual bool preorder(IR::Type_State *); virtual void postorder(IR::Type_State *); virtual bool preorder(IR::Type_Bits *); virtual void postorder(IR::Type_Bits *); virtual bool preorder(IR::Type_Varbits *); virtual void postorder(IR::Type_Varbits *); virtual bool preorder(IR::Parameter *); virtual void postorder(IR::Parameter *); virtual bool preorder(IR::ParameterList *); virtual void postorder(IR::ParameterList *); virtual bool preorder(IR::Type_Var *); virtual void postorder(IR::Type_Var *); virtual bool preorder(IR::Type_InfInt *); virtual void postorder(IR::Type_InfInt *); virtual bool preorder(IR::Type_Dontcare *); virtual void postorder(IR::Type_Dontcare *); virtual bool preorder(IR::Type_Void *); virtual void postorder(IR::Type_Void *); virtual bool preorder(IR::Type_Error *); virtual void postorder(IR::Type_Error *); virtual bool preorder(IR::Type_MatchKind *); virtual void postorder(IR::Type_MatchKind *); virtual bool preorder(IR::TypeParameters *); virtual void postorder(IR::TypeParameters *); virtual bool preorder(IR::StructField *); virtual void postorder(IR::StructField *); virtual bool preorder(IR::Type_StructLike *); virtual void postorder(IR::Type_StructLike *); virtual bool preorder(IR::Type_Struct *); virtual void postorder(IR::Type_Struct *); virtual bool preorder(IR::Type_Union *); virtual void postorder(IR::Type_Union *); virtual bool preorder(IR::Type_Header *); virtual void postorder(IR::Type_Header *); virtual bool preorder(IR::Type_Set *); virtual void postorder(IR::Type_Set *); virtual bool preorder(IR::Type_Tuple *); virtual void postorder(IR::Type_Tuple *); virtual bool preorder(IR::Type_ArchBlock *); virtual void postorder(IR::Type_ArchBlock *); virtual bool preorder(IR::Type_Package *); virtual void postorder(IR::Type_Package *); virtual bool preorder(IR::Type_Parser *); virtual void postorder(IR::Type_Parser *); virtual bool preorder(IR::Type_Control *); virtual void postorder(IR::Type_Control *); virtual bool preorder(IR::Type_Name *); virtual void postorder(IR::Type_Name *); virtual bool preorder(IR::Type_Stack *); virtual void postorder(IR::Type_Stack *); virtual bool preorder(IR::Type_Specialized *); virtual void postorder(IR::Type_Specialized *); virtual bool preorder(IR::Type_SpecializedCanonical *); virtual void postorder(IR::Type_SpecializedCanonical *); virtual bool preorder(IR::Declaration_ID *); virtual void postorder(IR::Declaration_ID *); virtual bool preorder(IR::Type_Enum *); virtual void postorder(IR::Type_Enum *); virtual bool preorder(IR::Type_Table *); virtual void postorder(IR::Type_Table *); virtual bool preorder(IR::Type_ActionEnum *); virtual void postorder(IR::Type_ActionEnum *); virtual bool preorder(IR::Type_MethodBase *); virtual void postorder(IR::Type_MethodBase *); virtual bool preorder(IR::Type_Method *); virtual void postorder(IR::Type_Method *); virtual bool preorder(IR::ArgumentInfo *); virtual void postorder(IR::ArgumentInfo *); virtual bool preorder(IR::Type_MethodCall *); virtual void postorder(IR::Type_MethodCall *); virtual bool preorder(IR::Type_Action *); virtual void postorder(IR::Type_Action *); virtual bool preorder(IR::Method *); virtual void postorder(IR::Method *); virtual bool preorder(IR::Type_Typedef *); virtual void postorder(IR::Type_Typedef *); virtual bool preorder(IR::Type_Extern *); virtual void postorder(IR::Type_Extern *); virtual bool preorder(IR::Operation_Unary *); virtual void postorder(IR::Operation_Unary *); virtual bool preorder(IR::Neg *); virtual void postorder(IR::Neg *); virtual bool preorder(IR::Cmpl *); virtual void postorder(IR::Cmpl *); virtual bool preorder(IR::LNot *); virtual void postorder(IR::LNot *); virtual bool preorder(IR::Operation_Binary *); virtual void postorder(IR::Operation_Binary *); virtual bool preorder(IR::Operation_Ternary *); virtual void postorder(IR::Operation_Ternary *); virtual bool preorder(IR::Operation_Relation *); virtual void postorder(IR::Operation_Relation *); virtual bool preorder(IR::Mul *); virtual void postorder(IR::Mul *); virtual bool preorder(IR::Div *); virtual void postorder(IR::Div *); virtual bool preorder(IR::Mod *); virtual void postorder(IR::Mod *); virtual bool preorder(IR::Add *); virtual void postorder(IR::Add *); virtual bool preorder(IR::Sub *); virtual void postorder(IR::Sub *); virtual bool preorder(IR::Shl *); virtual void postorder(IR::Shl *); virtual bool preorder(IR::Shr *); virtual void postorder(IR::Shr *); virtual bool preorder(IR::Equ *); virtual void postorder(IR::Equ *); virtual bool preorder(IR::Neq *); virtual void postorder(IR::Neq *); virtual bool preorder(IR::Lss *); virtual void postorder(IR::Lss *); virtual bool preorder(IR::Leq *); virtual void postorder(IR::Leq *); virtual bool preorder(IR::Grt *); virtual void postorder(IR::Grt *); virtual bool preorder(IR::Geq *); virtual void postorder(IR::Geq *); virtual bool preorder(IR::BAnd *); virtual void postorder(IR::BAnd *); virtual bool preorder(IR::BOr *); virtual void postorder(IR::BOr *); virtual bool preorder(IR::BXor *); virtual void postorder(IR::BXor *); virtual bool preorder(IR::LAnd *); virtual void postorder(IR::LAnd *); virtual bool preorder(IR::LOr *); virtual void postorder(IR::LOr *); virtual bool preorder(IR::Constant *); virtual void postorder(IR::Constant *); virtual bool preorder(IR::BoolLiteral *); virtual void postorder(IR::BoolLiteral *); virtual bool preorder(IR::StringLiteral *); virtual void postorder(IR::StringLiteral *); virtual bool preorder(IR::PathExpression *); virtual void postorder(IR::PathExpression *); virtual bool preorder(IR::TypeNameExpression *); virtual void postorder(IR::TypeNameExpression *); virtual bool preorder(IR::Slice *); virtual void postorder(IR::Slice *); virtual bool preorder(IR::Member *); virtual void postorder(IR::Member *); virtual bool preorder(IR::Concat *); virtual void postorder(IR::Concat *); virtual bool preorder(IR::ArrayIndex *); virtual void postorder(IR::ArrayIndex *); virtual bool preorder(IR::Range *); virtual void postorder(IR::Range *); virtual bool preorder(IR::Mask *); virtual void postorder(IR::Mask *); virtual bool preorder(IR::Mux *); virtual void postorder(IR::Mux *); virtual bool preorder(IR::DefaultExpression *); virtual void postorder(IR::DefaultExpression *); virtual bool preorder(IR::This *); virtual void postorder(IR::This *); virtual bool preorder(IR::Cast *); virtual void postorder(IR::Cast *); virtual bool preorder(IR::SelectExpression *); virtual void postorder(IR::SelectExpression *); virtual bool preorder(IR::MethodCallExpression *); virtual void postorder(IR::MethodCallExpression *); virtual bool preorder(IR::ConstructorCallExpression *); virtual void postorder(IR::ConstructorCallExpression *); virtual bool preorder(IR::ListExpression *); virtual void postorder(IR::ListExpression *); virtual bool preorder(IR::SelectCase *); virtual void postorder(IR::SelectCase *); virtual bool preorder(IR::ParserState *); virtual void postorder(IR::ParserState *); virtual bool preorder(IR::P4Parser *); virtual void postorder(IR::P4Parser *); virtual bool preorder(IR::P4Control *); virtual void postorder(IR::P4Control *); virtual bool preorder(IR::P4Action *); virtual void postorder(IR::P4Action *); virtual bool preorder(IR::Declaration_Errors *); virtual void postorder(IR::Declaration_Errors *); virtual bool preorder(IR::Declaration_MatchKind *); virtual void postorder(IR::Declaration_MatchKind *); virtual bool preorder(IR::PropertyValue *); virtual void postorder(IR::PropertyValue *); virtual bool preorder(IR::ExpressionValue *); virtual void postorder(IR::ExpressionValue *); virtual bool preorder(IR::ActionListElement *); virtual void postorder(IR::ActionListElement *); virtual bool preorder(IR::ActionList *); virtual void postorder(IR::ActionList *); virtual bool preorder(IR::KeyElement *); virtual void postorder(IR::KeyElement *); virtual bool preorder(IR::Key *); virtual void postorder(IR::Key *); virtual bool preorder(IR::TableProperty *); virtual void postorder(IR::TableProperty *); virtual bool preorder(IR::TableProperties *); virtual void postorder(IR::TableProperties *); virtual bool preorder(IR::P4Table *); virtual void postorder(IR::P4Table *); virtual bool preorder(IR::Declaration_Variable *); virtual void postorder(IR::Declaration_Variable *); virtual bool preorder(IR::Declaration_Constant *); virtual void postorder(IR::Declaration_Constant *); virtual bool preorder(IR::Declaration_Instance *); virtual void postorder(IR::Declaration_Instance *); virtual bool preorder(IR::P4Program *); virtual void postorder(IR::P4Program *); virtual bool preorder(IR::Statement *); virtual void postorder(IR::Statement *); virtual bool preorder(IR::ExitStatement *); virtual void postorder(IR::ExitStatement *); virtual bool preorder(IR::ReturnStatement *); virtual void postorder(IR::ReturnStatement *); virtual bool preorder(IR::EmptyStatement *); virtual void postorder(IR::EmptyStatement *); virtual bool preorder(IR::AssignmentStatement *); virtual void postorder(IR::AssignmentStatement *); virtual bool preorder(IR::IfStatement *); virtual void postorder(IR::IfStatement *); virtual bool preorder(IR::BlockStatement *); virtual void postorder(IR::BlockStatement *); virtual bool preorder(IR::MethodCallStatement *); virtual void postorder(IR::MethodCallStatement *); virtual bool preorder(IR::SwitchCase *); virtual void postorder(IR::SwitchCase *); virtual bool preorder(IR::SwitchStatement *); virtual void postorder(IR::SwitchStatement *); virtual bool preorder(IR::Function *); virtual void postorder(IR::Function *); virtual bool preorder(IR::Block *); virtual void postorder(IR::Block *); virtual bool preorder(IR::TableBlock *); virtual void postorder(IR::TableBlock *); virtual bool preorder(IR::InstantiatedBlock *); virtual void postorder(IR::InstantiatedBlock *); virtual bool preorder(IR::ParserBlock *); virtual void postorder(IR::ParserBlock *); virtual bool preorder(IR::ControlBlock *); virtual void postorder(IR::ControlBlock *); virtual bool preorder(IR::PackageBlock *); virtual void postorder(IR::PackageBlock *); virtual bool preorder(IR::ExternBlock *); virtual void postorder(IR::ExternBlock *); virtual bool preorder(IR::ToplevelBlock *); virtual void postorder(IR::ToplevelBlock *); virtual bool preorder(IR::HeaderOrMetadata *); virtual void postorder(IR::HeaderOrMetadata *); virtual bool preorder(IR::Header *); virtual void postorder(IR::Header *); virtual bool preorder(IR::HeaderStack *); virtual void postorder(IR::HeaderStack *); virtual bool preorder(IR::Metadata *); virtual void postorder(IR::Metadata *); virtual bool preorder(IR::HeaderRef *); virtual void postorder(IR::HeaderRef *); virtual bool preorder(IR::ConcreteHeaderRef *); virtual void postorder(IR::ConcreteHeaderRef *); virtual bool preorder(IR::HeaderStackItemRef *); virtual void postorder(IR::HeaderStackItemRef *); virtual bool preorder(IR::NamedRef *); virtual void postorder(IR::NamedRef *); virtual bool preorder(IR::If *); virtual void postorder(IR::If *); virtual bool preorder(IR::NamedCond *); virtual void postorder(IR::NamedCond *); virtual bool preorder(IR::Apply *); virtual void postorder(IR::Apply *); virtual bool preorder(IR::Primitive *); virtual void postorder(IR::Primitive *); virtual bool preorder(IR::FieldList *); virtual void postorder(IR::FieldList *); virtual bool preorder(IR::FieldListCalculation *); virtual void postorder(IR::FieldListCalculation *); virtual bool preorder(IR::CalculatedField *); virtual void postorder(IR::CalculatedField *); virtual bool preorder(IR::CaseEntry *); virtual void postorder(IR::CaseEntry *); virtual bool preorder(IR::V1Parser *); virtual void postorder(IR::V1Parser *); virtual bool preorder(IR::ParserException *); virtual void postorder(IR::ParserException *); virtual bool preorder(IR::Attached *); virtual void postorder(IR::Attached *); virtual bool preorder(IR::Stateful *); virtual void postorder(IR::Stateful *); virtual bool preorder(IR::CounterOrMeter *); virtual void postorder(IR::CounterOrMeter *); virtual bool preorder(IR::Counter *); virtual void postorder(IR::Counter *); virtual bool preorder(IR::Meter *); virtual void postorder(IR::Meter *); virtual bool preorder(IR::Register *); virtual void postorder(IR::Register *); virtual bool preorder(IR::PrimitiveAction *); virtual void postorder(IR::PrimitiveAction *); virtual bool preorder(IR::NameList *); virtual void postorder(IR::NameList *); virtual bool preorder(IR::ActionArg *); virtual void postorder(IR::ActionArg *); virtual bool preorder(IR::ActionFunction *); virtual void postorder(IR::ActionFunction *); virtual bool preorder(IR::ActionProfile *); virtual void postorder(IR::ActionProfile *); virtual bool preorder(IR::ActionSelector *); virtual void postorder(IR::ActionSelector *); virtual bool preorder(IR::V1Table *); virtual void postorder(IR::V1Table *); virtual bool preorder(IR::V1Control *); virtual void postorder(IR::V1Control *); virtual bool preorder(IR::V1Program *); virtual void postorder(IR::V1Program *); virtual bool preorder(IR::v1HeaderType *); virtual void postorder(IR::v1HeaderType *); virtual bool preorder(IR::IntMod *); virtual void postorder(IR::IntMod *); virtual bool preorder(IR::Tofino::Pipe *); virtual void postorder(IR::Tofino::Pipe *); virtual bool preorder(IR::InstanceRef *); virtual void postorder(IR::InstanceRef *); virtual bool preorder(IR::HeaderSliceRef *); virtual void postorder(IR::HeaderSliceRef *); virtual bool preorder(IR::MAU::Table *); virtual void postorder(IR::MAU::Table *); virtual bool preorder(IR::MAU::TernaryIndirect *); virtual void postorder(IR::MAU::TernaryIndirect *); virtual bool preorder(IR::MAU::ActionData *); virtual void postorder(IR::MAU::ActionData *); virtual bool preorder(IR::MAU::TableSeq *); virtual void postorder(IR::MAU::TableSeq *); virtual bool preorder(IR::MAU::Instruction *); virtual void postorder(IR::MAU::Instruction *); virtual bool preorder(IR::Tofino::ParserMatch *); virtual void postorder(IR::Tofino::ParserMatch *); virtual bool preorder(IR::Tofino::ParserState *); virtual void postorder(IR::Tofino::ParserState *); virtual bool preorder(IR::Tofino::Parser *); virtual void postorder(IR::Tofino::Parser *); virtual bool preorder(IR::Tofino::Deparser *); virtual void postorder(IR::Tofino::Deparser *); virtual bool preorder(IR::Vector<IR::Node> *); virtual void postorder(IR::Vector<IR::Node> *); virtual bool preorder(IR::Vector<IR::Type> *); virtual void postorder(IR::Vector<IR::Type> *); virtual bool preorder(IR::Vector<IR::StatOrDecl> *); virtual void postorder(IR::Vector<IR::StatOrDecl> *); virtual bool preorder(IR::IndexedVector<IR::StatOrDecl> *); virtual void postorder(IR::IndexedVector<IR::StatOrDecl> *); virtual bool preorder(IR::Vector<IR::Declaration> *); virtual void postorder(IR::Vector<IR::Declaration> *); virtual bool preorder(IR::Vector<IR::Expression> *); virtual void postorder(IR::Vector<IR::Expression> *); virtual bool preorder(IR::Vector<IR::Annotation> *); virtual void postorder(IR::Vector<IR::Annotation> *); virtual bool preorder(IR::Vector<IR::ArgumentInfo> *); virtual void postorder(IR::Vector<IR::ArgumentInfo> *); virtual bool preorder(IR::Vector<IR::Method> *); virtual void postorder(IR::Vector<IR::Method> *); virtual bool preorder(IR::Vector<IR::SelectCase> *); virtual void postorder(IR::Vector<IR::SelectCase> *); virtual bool preorder(IR::Vector<IR::ParserState> *); virtual void postorder(IR::Vector<IR::ParserState> *); virtual bool preorder(IR::Vector<IR::ActionListElement> *); virtual void postorder(IR::Vector<IR::ActionListElement> *); virtual bool preorder(IR::Vector<IR::KeyElement> *); virtual void postorder(IR::Vector<IR::KeyElement> *); virtual bool preorder(IR::Vector<IR::SwitchCase> *); virtual void postorder(IR::Vector<IR::SwitchCase> *); virtual bool preorder(IR::Vector<IR::Primitive> *); virtual void postorder(IR::Vector<IR::Primitive> *); virtual bool preorder(IR::Vector<IR::CaseEntry> *); virtual void postorder(IR::Vector<IR::CaseEntry> *); virtual bool preorder(IR::Vector<IR::Attached> *); virtual void postorder(IR::Vector<IR::Attached> *); virtual bool preorder(IR::Vector<IR::MAU::Table> *); virtual void postorder(IR::Vector<IR::MAU::Table> *); virtual bool preorder(IR::Vector<IR::Tofino::ParserMatch> *); virtual void postorder(IR::Vector<IR::Tofino::ParserMatch> *);

};

class Inspector : public virtual Visitor {
    typedef unordered_map<const IR::Node *, bool> visited_t;
    visited_t *visited = nullptr;
 public:
    profile_t init_apply(const IR::Node *root) override;
    const IR::Node *apply_visitor(const IR::Node *, const char *name = 0) override;
    virtual bool preorder(const IR::Node *) { return true; }
    virtual void postorder(const IR::Node *) {}



    virtual bool preorder(const IR::Type *); virtual void postorder(const IR::Type *); virtual bool preorder(const IR::Type_Base *); virtual void postorder(const IR::Type_Base *); virtual bool preorder(const IR::Type_Unknown *); virtual void postorder(const IR::Type_Unknown *); virtual bool preorder(const IR::StatOrDecl *); virtual void postorder(const IR::StatOrDecl *); virtual bool preorder(const IR::Declaration *); virtual void postorder(const IR::Declaration *); virtual bool preorder(const IR::Type_Declaration *); virtual void postorder(const IR::Type_Declaration *); virtual bool preorder(const IR::Expression *); virtual void postorder(const IR::Expression *); virtual bool preorder(const IR::Operation *); virtual void postorder(const IR::Operation *); virtual bool preorder(const IR::PathPrefix *); virtual void postorder(const IR::PathPrefix *); virtual bool preorder(const IR::Path *); virtual void postorder(const IR::Path *); virtual bool preorder(const IR::Annotation *); virtual void postorder(const IR::Annotation *); virtual bool preorder(const IR::Annotations *); virtual void postorder(const IR::Annotations *); virtual bool preorder(const IR::Type_Boolean *); virtual void postorder(const IR::Type_Boolean *); virtual bool preorder(const IR::Type_State *); virtual void postorder(const IR::Type_State *); virtual bool preorder(const IR::Type_Bits *); virtual void postorder(const IR::Type_Bits *); virtual bool preorder(const IR::Type_Varbits *); virtual void postorder(const IR::Type_Varbits *); virtual bool preorder(const IR::Parameter *); virtual void postorder(const IR::Parameter *); virtual bool preorder(const IR::ParameterList *); virtual void postorder(const IR::ParameterList *); virtual bool preorder(const IR::Type_Var *); virtual void postorder(const IR::Type_Var *); virtual bool preorder(const IR::Type_InfInt *); virtual void postorder(const IR::Type_InfInt *); virtual bool preorder(const IR::Type_Dontcare *); virtual void postorder(const IR::Type_Dontcare *); virtual bool preorder(const IR::Type_Void *); virtual void postorder(const IR::Type_Void *); virtual bool preorder(const IR::Type_Error *); virtual void postorder(const IR::Type_Error *); virtual bool preorder(const IR::Type_MatchKind *); virtual void postorder(const IR::Type_MatchKind *); virtual bool preorder(const IR::TypeParameters *); virtual void postorder(const IR::TypeParameters *); virtual bool preorder(const IR::StructField *); virtual void postorder(const IR::StructField *); virtual bool preorder(const IR::Type_StructLike *); virtual void postorder(const IR::Type_StructLike *); virtual bool preorder(const IR::Type_Struct *); virtual void postorder(const IR::Type_Struct *); virtual bool preorder(const IR::Type_Union *); virtual void postorder(const IR::Type_Union *); virtual bool preorder(const IR::Type_Header *); virtual void postorder(const IR::Type_Header *); virtual bool preorder(const IR::Type_Set *); virtual void postorder(const IR::Type_Set *); virtual bool preorder(const IR::Type_Tuple *); virtual void postorder(const IR::Type_Tuple *); virtual bool preorder(const IR::Type_ArchBlock *); virtual void postorder(const IR::Type_ArchBlock *); virtual bool preorder(const IR::Type_Package *); virtual void postorder(const IR::Type_Package *); virtual bool preorder(const IR::Type_Parser *); virtual void postorder(const IR::Type_Parser *); virtual bool preorder(const IR::Type_Control *); virtual void postorder(const IR::Type_Control *); virtual bool preorder(const IR::Type_Name *); virtual void postorder(const IR::Type_Name *); virtual bool preorder(const IR::Type_Stack *); virtual void postorder(const IR::Type_Stack *); virtual bool preorder(const IR::Type_Specialized *); virtual void postorder(const IR::Type_Specialized *); virtual bool preorder(const IR::Type_SpecializedCanonical *); virtual void postorder(const IR::Type_SpecializedCanonical *); virtual bool preorder(const IR::Declaration_ID *); virtual void postorder(const IR::Declaration_ID *); virtual bool preorder(const IR::Type_Enum *); virtual void postorder(const IR::Type_Enum *); virtual bool preorder(const IR::Type_Table *); virtual void postorder(const IR::Type_Table *); virtual bool preorder(const IR::Type_ActionEnum *); virtual void postorder(const IR::Type_ActionEnum *); virtual bool preorder(const IR::Type_MethodBase *); virtual void postorder(const IR::Type_MethodBase *); virtual bool preorder(const IR::Type_Method *); virtual void postorder(const IR::Type_Method *); virtual bool preorder(const IR::ArgumentInfo *); virtual void postorder(const IR::ArgumentInfo *); virtual bool preorder(const IR::Type_MethodCall *); virtual void postorder(const IR::Type_MethodCall *); virtual bool preorder(const IR::Type_Action *); virtual void postorder(const IR::Type_Action *); virtual bool preorder(const IR::Method *); virtual void postorder(const IR::Method *); virtual bool preorder(const IR::Type_Typedef *); virtual void postorder(const IR::Type_Typedef *); virtual bool preorder(const IR::Type_Extern *); virtual void postorder(const IR::Type_Extern *); virtual bool preorder(const IR::Operation_Unary *); virtual void postorder(const IR::Operation_Unary *); virtual bool preorder(const IR::Neg *); virtual void postorder(const IR::Neg *); virtual bool preorder(const IR::Cmpl *); virtual void postorder(const IR::Cmpl *); virtual bool preorder(const IR::LNot *); virtual void postorder(const IR::LNot *); virtual bool preorder(const IR::Operation_Binary *); virtual void postorder(const IR::Operation_Binary *); virtual bool preorder(const IR::Operation_Ternary *); virtual void postorder(const IR::Operation_Ternary *); virtual bool preorder(const IR::Operation_Relation *); virtual void postorder(const IR::Operation_Relation *); virtual bool preorder(const IR::Mul *); virtual void postorder(const IR::Mul *); virtual bool preorder(const IR::Div *); virtual void postorder(const IR::Div *); virtual bool preorder(const IR::Mod *); virtual void postorder(const IR::Mod *); virtual bool preorder(const IR::Add *); virtual void postorder(const IR::Add *); virtual bool preorder(const IR::Sub *); virtual void postorder(const IR::Sub *); virtual bool preorder(const IR::Shl *); virtual void postorder(const IR::Shl *); virtual bool preorder(const IR::Shr *); virtual void postorder(const IR::Shr *); virtual bool preorder(const IR::Equ *); virtual void postorder(const IR::Equ *); virtual bool preorder(const IR::Neq *); virtual void postorder(const IR::Neq *); virtual bool preorder(const IR::Lss *); virtual void postorder(const IR::Lss *); virtual bool preorder(const IR::Leq *); virtual void postorder(const IR::Leq *); virtual bool preorder(const IR::Grt *); virtual void postorder(const IR::Grt *); virtual bool preorder(const IR::Geq *); virtual void postorder(const IR::Geq *); virtual bool preorder(const IR::BAnd *); virtual void postorder(const IR::BAnd *); virtual bool preorder(const IR::BOr *); virtual void postorder(const IR::BOr *); virtual bool preorder(const IR::BXor *); virtual void postorder(const IR::BXor *); virtual bool preorder(const IR::LAnd *); virtual void postorder(const IR::LAnd *); virtual bool preorder(const IR::LOr *); virtual void postorder(const IR::LOr *); virtual bool preorder(const IR::Constant *); virtual void postorder(const IR::Constant *); virtual bool preorder(const IR::BoolLiteral *); virtual void postorder(const IR::BoolLiteral *); virtual bool preorder(const IR::StringLiteral *); virtual void postorder(const IR::StringLiteral *); virtual bool preorder(const IR::PathExpression *); virtual void postorder(const IR::PathExpression *); virtual bool preorder(const IR::TypeNameExpression *); virtual void postorder(const IR::TypeNameExpression *); virtual bool preorder(const IR::Slice *); virtual void postorder(const IR::Slice *); virtual bool preorder(const IR::Member *); virtual void postorder(const IR::Member *); virtual bool preorder(const IR::Concat *); virtual void postorder(const IR::Concat *); virtual bool preorder(const IR::ArrayIndex *); virtual void postorder(const IR::ArrayIndex *); virtual bool preorder(const IR::Range *); virtual void postorder(const IR::Range *); virtual bool preorder(const IR::Mask *); virtual void postorder(const IR::Mask *); virtual bool preorder(const IR::Mux *); virtual void postorder(const IR::Mux *); virtual bool preorder(const IR::DefaultExpression *); virtual void postorder(const IR::DefaultExpression *); virtual bool preorder(const IR::This *); virtual void postorder(const IR::This *); virtual bool preorder(const IR::Cast *); virtual void postorder(const IR::Cast *); virtual bool preorder(const IR::SelectExpression *); virtual void postorder(const IR::SelectExpression *); virtual bool preorder(const IR::MethodCallExpression *); virtual void postorder(const IR::MethodCallExpression *); virtual bool preorder(const IR::ConstructorCallExpression *); virtual void postorder(const IR::ConstructorCallExpression *); virtual bool preorder(const IR::ListExpression *); virtual void postorder(const IR::ListExpression *); virtual bool preorder(const IR::SelectCase *); virtual void postorder(const IR::SelectCase *); virtual bool preorder(const IR::ParserState *); virtual void postorder(const IR::ParserState *); virtual bool preorder(const IR::P4Parser *); virtual void postorder(const IR::P4Parser *); virtual bool preorder(const IR::P4Control *); virtual void postorder(const IR::P4Control *); virtual bool preorder(const IR::P4Action *); virtual void postorder(const IR::P4Action *); virtual bool preorder(const IR::Declaration_Errors *); virtual void postorder(const IR::Declaration_Errors *); virtual bool preorder(const IR::Declaration_MatchKind *); virtual void postorder(const IR::Declaration_MatchKind *); virtual bool preorder(const IR::PropertyValue *); virtual void postorder(const IR::PropertyValue *); virtual bool preorder(const IR::ExpressionValue *); virtual void postorder(const IR::ExpressionValue *); virtual bool preorder(const IR::ActionListElement *); virtual void postorder(const IR::ActionListElement *); virtual bool preorder(const IR::ActionList *); virtual void postorder(const IR::ActionList *); virtual bool preorder(const IR::KeyElement *); virtual void postorder(const IR::KeyElement *); virtual bool preorder(const IR::Key *); virtual void postorder(const IR::Key *); virtual bool preorder(const IR::TableProperty *); virtual void postorder(const IR::TableProperty *); virtual bool preorder(const IR::TableProperties *); virtual void postorder(const IR::TableProperties *); virtual bool preorder(const IR::P4Table *); virtual void postorder(const IR::P4Table *); virtual bool preorder(const IR::Declaration_Variable *); virtual void postorder(const IR::Declaration_Variable *); virtual bool preorder(const IR::Declaration_Constant *); virtual void postorder(const IR::Declaration_Constant *); virtual bool preorder(const IR::Declaration_Instance *); virtual void postorder(const IR::Declaration_Instance *); virtual bool preorder(const IR::P4Program *); virtual void postorder(const IR::P4Program *); virtual bool preorder(const IR::Statement *); virtual void postorder(const IR::Statement *); virtual bool preorder(const IR::ExitStatement *); virtual void postorder(const IR::ExitStatement *); virtual bool preorder(const IR::ReturnStatement *); virtual void postorder(const IR::ReturnStatement *); virtual bool preorder(const IR::EmptyStatement *); virtual void postorder(const IR::EmptyStatement *); virtual bool preorder(const IR::AssignmentStatement *); virtual void postorder(const IR::AssignmentStatement *); virtual bool preorder(const IR::IfStatement *); virtual void postorder(const IR::IfStatement *); virtual bool preorder(const IR::BlockStatement *); virtual void postorder(const IR::BlockStatement *); virtual bool preorder(const IR::MethodCallStatement *); virtual void postorder(const IR::MethodCallStatement *); virtual bool preorder(const IR::SwitchCase *); virtual void postorder(const IR::SwitchCase *); virtual bool preorder(const IR::SwitchStatement *); virtual void postorder(const IR::SwitchStatement *); virtual bool preorder(const IR::Function *); virtual void postorder(const IR::Function *); virtual bool preorder(const IR::Block *); virtual void postorder(const IR::Block *); virtual bool preorder(const IR::TableBlock *); virtual void postorder(const IR::TableBlock *); virtual bool preorder(const IR::InstantiatedBlock *); virtual void postorder(const IR::InstantiatedBlock *); virtual bool preorder(const IR::ParserBlock *); virtual void postorder(const IR::ParserBlock *); virtual bool preorder(const IR::ControlBlock *); virtual void postorder(const IR::ControlBlock *); virtual bool preorder(const IR::PackageBlock *); virtual void postorder(const IR::PackageBlock *); virtual bool preorder(const IR::ExternBlock *); virtual void postorder(const IR::ExternBlock *); virtual bool preorder(const IR::ToplevelBlock *); virtual void postorder(const IR::ToplevelBlock *); virtual bool preorder(const IR::HeaderOrMetadata *); virtual void postorder(const IR::HeaderOrMetadata *); virtual bool preorder(const IR::Header *); virtual void postorder(const IR::Header *); virtual bool preorder(const IR::HeaderStack *); virtual void postorder(const IR::HeaderStack *); virtual bool preorder(const IR::Metadata *); virtual void postorder(const IR::Metadata *); virtual bool preorder(const IR::HeaderRef *); virtual void postorder(const IR::HeaderRef *); virtual bool preorder(const IR::ConcreteHeaderRef *); virtual void postorder(const IR::ConcreteHeaderRef *); virtual bool preorder(const IR::HeaderStackItemRef *); virtual void postorder(const IR::HeaderStackItemRef *); virtual bool preorder(const IR::NamedRef *); virtual void postorder(const IR::NamedRef *); virtual bool preorder(const IR::If *); virtual void postorder(const IR::If *); virtual bool preorder(const IR::NamedCond *); virtual void postorder(const IR::NamedCond *); virtual bool preorder(const IR::Apply *); virtual void postorder(const IR::Apply *); virtual bool preorder(const IR::Primitive *); virtual void postorder(const IR::Primitive *); virtual bool preorder(const IR::FieldList *); virtual void postorder(const IR::FieldList *); virtual bool preorder(const IR::FieldListCalculation *); virtual void postorder(const IR::FieldListCalculation *); virtual bool preorder(const IR::CalculatedField *); virtual void postorder(const IR::CalculatedField *); virtual bool preorder(const IR::CaseEntry *); virtual void postorder(const IR::CaseEntry *); virtual bool preorder(const IR::V1Parser *); virtual void postorder(const IR::V1Parser *); virtual bool preorder(const IR::ParserException *); virtual void postorder(const IR::ParserException *); virtual bool preorder(const IR::Attached *); virtual void postorder(const IR::Attached *); virtual bool preorder(const IR::Stateful *); virtual void postorder(const IR::Stateful *); virtual bool preorder(const IR::CounterOrMeter *); virtual void postorder(const IR::CounterOrMeter *); virtual bool preorder(const IR::Counter *); virtual void postorder(const IR::Counter *); virtual bool preorder(const IR::Meter *); virtual void postorder(const IR::Meter *); virtual bool preorder(const IR::Register *); virtual void postorder(const IR::Register *); virtual bool preorder(const IR::PrimitiveAction *); virtual void postorder(const IR::PrimitiveAction *); virtual bool preorder(const IR::NameList *); virtual void postorder(const IR::NameList *); virtual bool preorder(const IR::ActionArg *); virtual void postorder(const IR::ActionArg *); virtual bool preorder(const IR::ActionFunction *); virtual void postorder(const IR::ActionFunction *); virtual bool preorder(const IR::ActionProfile *); virtual void postorder(const IR::ActionProfile *); virtual bool preorder(const IR::ActionSelector *); virtual void postorder(const IR::ActionSelector *); virtual bool preorder(const IR::V1Table *); virtual void postorder(const IR::V1Table *); virtual bool preorder(const IR::V1Control *); virtual void postorder(const IR::V1Control *); virtual bool preorder(const IR::V1Program *); virtual void postorder(const IR::V1Program *); virtual bool preorder(const IR::v1HeaderType *); virtual void postorder(const IR::v1HeaderType *); virtual bool preorder(const IR::IntMod *); virtual void postorder(const IR::IntMod *); virtual bool preorder(const IR::Tofino::Pipe *); virtual void postorder(const IR::Tofino::Pipe *); virtual bool preorder(const IR::InstanceRef *); virtual void postorder(const IR::InstanceRef *); virtual bool preorder(const IR::HeaderSliceRef *); virtual void postorder(const IR::HeaderSliceRef *); virtual bool preorder(const IR::MAU::Table *); virtual void postorder(const IR::MAU::Table *); virtual bool preorder(const IR::MAU::TernaryIndirect *); virtual void postorder(const IR::MAU::TernaryIndirect *); virtual bool preorder(const IR::MAU::ActionData *); virtual void postorder(const IR::MAU::ActionData *); virtual bool preorder(const IR::MAU::TableSeq *); virtual void postorder(const IR::MAU::TableSeq *); virtual bool preorder(const IR::MAU::Instruction *); virtual void postorder(const IR::MAU::Instruction *); virtual bool preorder(const IR::Tofino::ParserMatch *); virtual void postorder(const IR::Tofino::ParserMatch *); virtual bool preorder(const IR::Tofino::ParserState *); virtual void postorder(const IR::Tofino::ParserState *); virtual bool preorder(const IR::Tofino::Parser *); virtual void postorder(const IR::Tofino::Parser *); virtual bool preorder(const IR::Tofino::Deparser *); virtual void postorder(const IR::Tofino::Deparser *); virtual bool preorder(const IR::Vector<IR::Node> *); virtual void postorder(const IR::Vector<IR::Node> *); virtual bool preorder(const IR::Vector<IR::Type> *); virtual void postorder(const IR::Vector<IR::Type> *); virtual bool preorder(const IR::Vector<IR::StatOrDecl> *); virtual void postorder(const IR::Vector<IR::StatOrDecl> *); virtual bool preorder(const IR::IndexedVector<IR::StatOrDecl> *); virtual void postorder(const IR::IndexedVector<IR::StatOrDecl> *); virtual bool preorder(const IR::Vector<IR::Declaration> *); virtual void postorder(const IR::Vector<IR::Declaration> *); virtual bool preorder(const IR::Vector<IR::Expression> *); virtual void postorder(const IR::Vector<IR::Expression> *); virtual bool preorder(const IR::Vector<IR::Annotation> *); virtual void postorder(const IR::Vector<IR::Annotation> *); virtual bool preorder(const IR::Vector<IR::ArgumentInfo> *); virtual void postorder(const IR::Vector<IR::ArgumentInfo> *); virtual bool preorder(const IR::Vector<IR::Method> *); virtual void postorder(const IR::Vector<IR::Method> *); virtual bool preorder(const IR::Vector<IR::SelectCase> *); virtual void postorder(const IR::Vector<IR::SelectCase> *); virtual bool preorder(const IR::Vector<IR::ParserState> *); virtual void postorder(const IR::Vector<IR::ParserState> *); virtual bool preorder(const IR::Vector<IR::ActionListElement> *); virtual void postorder(const IR::Vector<IR::ActionListElement> *); virtual bool preorder(const IR::Vector<IR::KeyElement> *); virtual void postorder(const IR::Vector<IR::KeyElement> *); virtual bool preorder(const IR::Vector<IR::SwitchCase> *); virtual void postorder(const IR::Vector<IR::SwitchCase> *); virtual bool preorder(const IR::Vector<IR::Primitive> *); virtual void postorder(const IR::Vector<IR::Primitive> *); virtual bool preorder(const IR::Vector<IR::CaseEntry> *); virtual void postorder(const IR::Vector<IR::CaseEntry> *); virtual bool preorder(const IR::Vector<IR::Attached> *); virtual void postorder(const IR::Vector<IR::Attached> *); virtual bool preorder(const IR::Vector<IR::MAU::Table> *); virtual void postorder(const IR::Vector<IR::MAU::Table> *); virtual bool preorder(const IR::Vector<IR::Tofino::ParserMatch> *); virtual void postorder(const IR::Vector<IR::Tofino::ParserMatch> *);

};

class Transform : public virtual Visitor {
    ChangeTracker *visited = nullptr;
    bool prune_flag = false;
    void visitor_const_error();
 public:
    profile_t init_apply(const IR::Node *root) override;
    const IR::Node *apply_visitor(const IR::Node *, const char *name = 0) override;
    virtual const IR::Node *preorder(IR::Node *n) {return n;}
    virtual const IR::Node *postorder(IR::Node *n) {return n;}



    virtual const IR::Node *preorder(IR::Type *); virtual const IR::Node *postorder(IR::Type *); virtual const IR::Node *preorder(IR::Type_Base *); virtual const IR::Node *postorder(IR::Type_Base *); virtual const IR::Node *preorder(IR::Type_Unknown *); virtual const IR::Node *postorder(IR::Type_Unknown *); virtual const IR::Node *preorder(IR::StatOrDecl *); virtual const IR::Node *postorder(IR::StatOrDecl *); virtual const IR::Node *preorder(IR::Declaration *); virtual const IR::Node *postorder(IR::Declaration *); virtual const IR::Node *preorder(IR::Type_Declaration *); virtual const IR::Node *postorder(IR::Type_Declaration *); virtual const IR::Node *preorder(IR::Expression *); virtual const IR::Node *postorder(IR::Expression *); virtual const IR::Node *preorder(IR::Operation *); virtual const IR::Node *postorder(IR::Operation *); virtual const IR::Node *preorder(IR::PathPrefix *); virtual const IR::Node *postorder(IR::PathPrefix *); virtual const IR::Node *preorder(IR::Path *); virtual const IR::Node *postorder(IR::Path *); virtual const IR::Node *preorder(IR::Annotation *); virtual const IR::Node *postorder(IR::Annotation *); virtual const IR::Node *preorder(IR::Annotations *); virtual const IR::Node *postorder(IR::Annotations *); virtual const IR::Node *preorder(IR::Type_Boolean *); virtual const IR::Node *postorder(IR::Type_Boolean *); virtual const IR::Node *preorder(IR::Type_State *); virtual const IR::Node *postorder(IR::Type_State *); virtual const IR::Node *preorder(IR::Type_Bits *); virtual const IR::Node *postorder(IR::Type_Bits *); virtual const IR::Node *preorder(IR::Type_Varbits *); virtual const IR::Node *postorder(IR::Type_Varbits *); virtual const IR::Node *preorder(IR::Parameter *); virtual const IR::Node *postorder(IR::Parameter *); virtual const IR::Node *preorder(IR::ParameterList *); virtual const IR::Node *postorder(IR::ParameterList *); virtual const IR::Node *preorder(IR::Type_Var *); virtual const IR::Node *postorder(IR::Type_Var *); virtual const IR::Node *preorder(IR::Type_InfInt *); virtual const IR::Node *postorder(IR::Type_InfInt *); virtual const IR::Node *preorder(IR::Type_Dontcare *); virtual const IR::Node *postorder(IR::Type_Dontcare *); virtual const IR::Node *preorder(IR::Type_Void *); virtual const IR::Node *postorder(IR::Type_Void *); virtual const IR::Node *preorder(IR::Type_Error *); virtual const IR::Node *postorder(IR::Type_Error *); virtual const IR::Node *preorder(IR::Type_MatchKind *); virtual const IR::Node *postorder(IR::Type_MatchKind *); virtual const IR::Node *preorder(IR::TypeParameters *); virtual const IR::Node *postorder(IR::TypeParameters *); virtual const IR::Node *preorder(IR::StructField *); virtual const IR::Node *postorder(IR::StructField *); virtual const IR::Node *preorder(IR::Type_StructLike *); virtual const IR::Node *postorder(IR::Type_StructLike *); virtual const IR::Node *preorder(IR::Type_Struct *); virtual const IR::Node *postorder(IR::Type_Struct *); virtual const IR::Node *preorder(IR::Type_Union *); virtual const IR::Node *postorder(IR::Type_Union *); virtual const IR::Node *preorder(IR::Type_Header *); virtual const IR::Node *postorder(IR::Type_Header *); virtual const IR::Node *preorder(IR::Type_Set *); virtual const IR::Node *postorder(IR::Type_Set *); virtual const IR::Node *preorder(IR::Type_Tuple *); virtual const IR::Node *postorder(IR::Type_Tuple *); virtual const IR::Node *preorder(IR::Type_ArchBlock *); virtual const IR::Node *postorder(IR::Type_ArchBlock *); virtual const IR::Node *preorder(IR::Type_Package *); virtual const IR::Node *postorder(IR::Type_Package *); virtual const IR::Node *preorder(IR::Type_Parser *); virtual const IR::Node *postorder(IR::Type_Parser *); virtual const IR::Node *preorder(IR::Type_Control *); virtual const IR::Node *postorder(IR::Type_Control *); virtual const IR::Node *preorder(IR::Type_Name *); virtual const IR::Node *postorder(IR::Type_Name *); virtual const IR::Node *preorder(IR::Type_Stack *); virtual const IR::Node *postorder(IR::Type_Stack *); virtual const IR::Node *preorder(IR::Type_Specialized *); virtual const IR::Node *postorder(IR::Type_Specialized *); virtual const IR::Node *preorder(IR::Type_SpecializedCanonical *); virtual const IR::Node *postorder(IR::Type_SpecializedCanonical *); virtual const IR::Node *preorder(IR::Declaration_ID *); virtual const IR::Node *postorder(IR::Declaration_ID *); virtual const IR::Node *preorder(IR::Type_Enum *); virtual const IR::Node *postorder(IR::Type_Enum *); virtual const IR::Node *preorder(IR::Type_Table *); virtual const IR::Node *postorder(IR::Type_Table *); virtual const IR::Node *preorder(IR::Type_ActionEnum *); virtual const IR::Node *postorder(IR::Type_ActionEnum *); virtual const IR::Node *preorder(IR::Type_MethodBase *); virtual const IR::Node *postorder(IR::Type_MethodBase *); virtual const IR::Node *preorder(IR::Type_Method *); virtual const IR::Node *postorder(IR::Type_Method *); virtual const IR::Node *preorder(IR::ArgumentInfo *); virtual const IR::Node *postorder(IR::ArgumentInfo *); virtual const IR::Node *preorder(IR::Type_MethodCall *); virtual const IR::Node *postorder(IR::Type_MethodCall *); virtual const IR::Node *preorder(IR::Type_Action *); virtual const IR::Node *postorder(IR::Type_Action *); virtual const IR::Node *preorder(IR::Method *); virtual const IR::Node *postorder(IR::Method *); virtual const IR::Node *preorder(IR::Type_Typedef *); virtual const IR::Node *postorder(IR::Type_Typedef *); virtual const IR::Node *preorder(IR::Type_Extern *); virtual const IR::Node *postorder(IR::Type_Extern *); virtual const IR::Node *preorder(IR::Operation_Unary *); virtual const IR::Node *postorder(IR::Operation_Unary *); virtual const IR::Node *preorder(IR::Neg *); virtual const IR::Node *postorder(IR::Neg *); virtual const IR::Node *preorder(IR::Cmpl *); virtual const IR::Node *postorder(IR::Cmpl *); virtual const IR::Node *preorder(IR::LNot *); virtual const IR::Node *postorder(IR::LNot *); virtual const IR::Node *preorder(IR::Operation_Binary *); virtual const IR::Node *postorder(IR::Operation_Binary *); virtual const IR::Node *preorder(IR::Operation_Ternary *); virtual const IR::Node *postorder(IR::Operation_Ternary *); virtual const IR::Node *preorder(IR::Operation_Relation *); virtual const IR::Node *postorder(IR::Operation_Relation *); virtual const IR::Node *preorder(IR::Mul *); virtual const IR::Node *postorder(IR::Mul *); virtual const IR::Node *preorder(IR::Div *); virtual const IR::Node *postorder(IR::Div *); virtual const IR::Node *preorder(IR::Mod *); virtual const IR::Node *postorder(IR::Mod *); virtual const IR::Node *preorder(IR::Add *); virtual const IR::Node *postorder(IR::Add *); virtual const IR::Node *preorder(IR::Sub *); virtual const IR::Node *postorder(IR::Sub *); virtual const IR::Node *preorder(IR::Shl *); virtual const IR::Node *postorder(IR::Shl *); virtual const IR::Node *preorder(IR::Shr *); virtual const IR::Node *postorder(IR::Shr *); virtual const IR::Node *preorder(IR::Equ *); virtual const IR::Node *postorder(IR::Equ *); virtual const IR::Node *preorder(IR::Neq *); virtual const IR::Node *postorder(IR::Neq *); virtual const IR::Node *preorder(IR::Lss *); virtual const IR::Node *postorder(IR::Lss *); virtual const IR::Node *preorder(IR::Leq *); virtual const IR::Node *postorder(IR::Leq *); virtual const IR::Node *preorder(IR::Grt *); virtual const IR::Node *postorder(IR::Grt *); virtual const IR::Node *preorder(IR::Geq *); virtual const IR::Node *postorder(IR::Geq *); virtual const IR::Node *preorder(IR::BAnd *); virtual const IR::Node *postorder(IR::BAnd *); virtual const IR::Node *preorder(IR::BOr *); virtual const IR::Node *postorder(IR::BOr *); virtual const IR::Node *preorder(IR::BXor *); virtual const IR::Node *postorder(IR::BXor *); virtual const IR::Node *preorder(IR::LAnd *); virtual const IR::Node *postorder(IR::LAnd *); virtual const IR::Node *preorder(IR::LOr *); virtual const IR::Node *postorder(IR::LOr *); virtual const IR::Node *preorder(IR::Constant *); virtual const IR::Node *postorder(IR::Constant *); virtual const IR::Node *preorder(IR::BoolLiteral *); virtual const IR::Node *postorder(IR::BoolLiteral *); virtual const IR::Node *preorder(IR::StringLiteral *); virtual const IR::Node *postorder(IR::StringLiteral *); virtual const IR::Node *preorder(IR::PathExpression *); virtual const IR::Node *postorder(IR::PathExpression *); virtual const IR::Node *preorder(IR::TypeNameExpression *); virtual const IR::Node *postorder(IR::TypeNameExpression *); virtual const IR::Node *preorder(IR::Slice *); virtual const IR::Node *postorder(IR::Slice *); virtual const IR::Node *preorder(IR::Member *); virtual const IR::Node *postorder(IR::Member *); virtual const IR::Node *preorder(IR::Concat *); virtual const IR::Node *postorder(IR::Concat *); virtual const IR::Node *preorder(IR::ArrayIndex *); virtual const IR::Node *postorder(IR::ArrayIndex *); virtual const IR::Node *preorder(IR::Range *); virtual const IR::Node *postorder(IR::Range *); virtual const IR::Node *preorder(IR::Mask *); virtual const IR::Node *postorder(IR::Mask *); virtual const IR::Node *preorder(IR::Mux *); virtual const IR::Node *postorder(IR::Mux *); virtual const IR::Node *preorder(IR::DefaultExpression *); virtual const IR::Node *postorder(IR::DefaultExpression *); virtual const IR::Node *preorder(IR::This *); virtual const IR::Node *postorder(IR::This *); virtual const IR::Node *preorder(IR::Cast *); virtual const IR::Node *postorder(IR::Cast *); virtual const IR::Node *preorder(IR::SelectExpression *); virtual const IR::Node *postorder(IR::SelectExpression *); virtual const IR::Node *preorder(IR::MethodCallExpression *); virtual const IR::Node *postorder(IR::MethodCallExpression *); virtual const IR::Node *preorder(IR::ConstructorCallExpression *); virtual const IR::Node *postorder(IR::ConstructorCallExpression *); virtual const IR::Node *preorder(IR::ListExpression *); virtual const IR::Node *postorder(IR::ListExpression *); virtual const IR::Node *preorder(IR::SelectCase *); virtual const IR::Node *postorder(IR::SelectCase *); virtual const IR::Node *preorder(IR::ParserState *); virtual const IR::Node *postorder(IR::ParserState *); virtual const IR::Node *preorder(IR::P4Parser *); virtual const IR::Node *postorder(IR::P4Parser *); virtual const IR::Node *preorder(IR::P4Control *); virtual const IR::Node *postorder(IR::P4Control *); virtual const IR::Node *preorder(IR::P4Action *); virtual const IR::Node *postorder(IR::P4Action *); virtual const IR::Node *preorder(IR::Declaration_Errors *); virtual const IR::Node *postorder(IR::Declaration_Errors *); virtual const IR::Node *preorder(IR::Declaration_MatchKind *); virtual const IR::Node *postorder(IR::Declaration_MatchKind *); virtual const IR::Node *preorder(IR::PropertyValue *); virtual const IR::Node *postorder(IR::PropertyValue *); virtual const IR::Node *preorder(IR::ExpressionValue *); virtual const IR::Node *postorder(IR::ExpressionValue *); virtual const IR::Node *preorder(IR::ActionListElement *); virtual const IR::Node *postorder(IR::ActionListElement *); virtual const IR::Node *preorder(IR::ActionList *); virtual const IR::Node *postorder(IR::ActionList *); virtual const IR::Node *preorder(IR::KeyElement *); virtual const IR::Node *postorder(IR::KeyElement *); virtual const IR::Node *preorder(IR::Key *); virtual const IR::Node *postorder(IR::Key *); virtual const IR::Node *preorder(IR::TableProperty *); virtual const IR::Node *postorder(IR::TableProperty *); virtual const IR::Node *preorder(IR::TableProperties *); virtual const IR::Node *postorder(IR::TableProperties *); virtual const IR::Node *preorder(IR::P4Table *); virtual const IR::Node *postorder(IR::P4Table *); virtual const IR::Node *preorder(IR::Declaration_Variable *); virtual const IR::Node *postorder(IR::Declaration_Variable *); virtual const IR::Node *preorder(IR::Declaration_Constant *); virtual const IR::Node *postorder(IR::Declaration_Constant *); virtual const IR::Node *preorder(IR::Declaration_Instance *); virtual const IR::Node *postorder(IR::Declaration_Instance *); virtual const IR::Node *preorder(IR::P4Program *); virtual const IR::Node *postorder(IR::P4Program *); virtual const IR::Node *preorder(IR::Statement *); virtual const IR::Node *postorder(IR::Statement *); virtual const IR::Node *preorder(IR::ExitStatement *); virtual const IR::Node *postorder(IR::ExitStatement *); virtual const IR::Node *preorder(IR::ReturnStatement *); virtual const IR::Node *postorder(IR::ReturnStatement *); virtual const IR::Node *preorder(IR::EmptyStatement *); virtual const IR::Node *postorder(IR::EmptyStatement *); virtual const IR::Node *preorder(IR::AssignmentStatement *); virtual const IR::Node *postorder(IR::AssignmentStatement *); virtual const IR::Node *preorder(IR::IfStatement *); virtual const IR::Node *postorder(IR::IfStatement *); virtual const IR::Node *preorder(IR::BlockStatement *); virtual const IR::Node *postorder(IR::BlockStatement *); virtual const IR::Node *preorder(IR::MethodCallStatement *); virtual const IR::Node *postorder(IR::MethodCallStatement *); virtual const IR::Node *preorder(IR::SwitchCase *); virtual const IR::Node *postorder(IR::SwitchCase *); virtual const IR::Node *preorder(IR::SwitchStatement *); virtual const IR::Node *postorder(IR::SwitchStatement *); virtual const IR::Node *preorder(IR::Function *); virtual const IR::Node *postorder(IR::Function *); virtual const IR::Node *preorder(IR::Block *); virtual const IR::Node *postorder(IR::Block *); virtual const IR::Node *preorder(IR::TableBlock *); virtual const IR::Node *postorder(IR::TableBlock *); virtual const IR::Node *preorder(IR::InstantiatedBlock *); virtual const IR::Node *postorder(IR::InstantiatedBlock *); virtual const IR::Node *preorder(IR::ParserBlock *); virtual const IR::Node *postorder(IR::ParserBlock *); virtual const IR::Node *preorder(IR::ControlBlock *); virtual const IR::Node *postorder(IR::ControlBlock *); virtual const IR::Node *preorder(IR::PackageBlock *); virtual const IR::Node *postorder(IR::PackageBlock *); virtual const IR::Node *preorder(IR::ExternBlock *); virtual const IR::Node *postorder(IR::ExternBlock *); virtual const IR::Node *preorder(IR::ToplevelBlock *); virtual const IR::Node *postorder(IR::ToplevelBlock *); virtual const IR::Node *preorder(IR::HeaderOrMetadata *); virtual const IR::Node *postorder(IR::HeaderOrMetadata *); virtual const IR::Node *preorder(IR::Header *); virtual const IR::Node *postorder(IR::Header *); virtual const IR::Node *preorder(IR::HeaderStack *); virtual const IR::Node *postorder(IR::HeaderStack *); virtual const IR::Node *preorder(IR::Metadata *); virtual const IR::Node *postorder(IR::Metadata *); virtual const IR::Node *preorder(IR::HeaderRef *); virtual const IR::Node *postorder(IR::HeaderRef *); virtual const IR::Node *preorder(IR::ConcreteHeaderRef *); virtual const IR::Node *postorder(IR::ConcreteHeaderRef *); virtual const IR::Node *preorder(IR::HeaderStackItemRef *); virtual const IR::Node *postorder(IR::HeaderStackItemRef *); virtual const IR::Node *preorder(IR::NamedRef *); virtual const IR::Node *postorder(IR::NamedRef *); virtual const IR::Node *preorder(IR::If *); virtual const IR::Node *postorder(IR::If *); virtual const IR::Node *preorder(IR::NamedCond *); virtual const IR::Node *postorder(IR::NamedCond *); virtual const IR::Node *preorder(IR::Apply *); virtual const IR::Node *postorder(IR::Apply *); virtual const IR::Node *preorder(IR::Primitive *); virtual const IR::Node *postorder(IR::Primitive *); virtual const IR::Node *preorder(IR::FieldList *); virtual const IR::Node *postorder(IR::FieldList *); virtual const IR::Node *preorder(IR::FieldListCalculation *); virtual const IR::Node *postorder(IR::FieldListCalculation *); virtual const IR::Node *preorder(IR::CalculatedField *); virtual const IR::Node *postorder(IR::CalculatedField *); virtual const IR::Node *preorder(IR::CaseEntry *); virtual const IR::Node *postorder(IR::CaseEntry *); virtual const IR::Node *preorder(IR::V1Parser *); virtual const IR::Node *postorder(IR::V1Parser *); virtual const IR::Node *preorder(IR::ParserException *); virtual const IR::Node *postorder(IR::ParserException *); virtual const IR::Node *preorder(IR::Attached *); virtual const IR::Node *postorder(IR::Attached *); virtual const IR::Node *preorder(IR::Stateful *); virtual const IR::Node *postorder(IR::Stateful *); virtual const IR::Node *preorder(IR::CounterOrMeter *); virtual const IR::Node *postorder(IR::CounterOrMeter *); virtual const IR::Node *preorder(IR::Counter *); virtual const IR::Node *postorder(IR::Counter *); virtual const IR::Node *preorder(IR::Meter *); virtual const IR::Node *postorder(IR::Meter *); virtual const IR::Node *preorder(IR::Register *); virtual const IR::Node *postorder(IR::Register *); virtual const IR::Node *preorder(IR::PrimitiveAction *); virtual const IR::Node *postorder(IR::PrimitiveAction *); virtual const IR::Node *preorder(IR::NameList *); virtual const IR::Node *postorder(IR::NameList *); virtual const IR::Node *preorder(IR::ActionArg *); virtual const IR::Node *postorder(IR::ActionArg *); virtual const IR::Node *preorder(IR::ActionFunction *); virtual const IR::Node *postorder(IR::ActionFunction *); virtual const IR::Node *preorder(IR::ActionProfile *); virtual const IR::Node *postorder(IR::ActionProfile *); virtual const IR::Node *preorder(IR::ActionSelector *); virtual const IR::Node *postorder(IR::ActionSelector *); virtual const IR::Node *preorder(IR::V1Table *); virtual const IR::Node *postorder(IR::V1Table *); virtual const IR::Node *preorder(IR::V1Control *); virtual const IR::Node *postorder(IR::V1Control *); virtual const IR::Node *preorder(IR::V1Program *); virtual const IR::Node *postorder(IR::V1Program *); virtual const IR::Node *preorder(IR::v1HeaderType *); virtual const IR::Node *postorder(IR::v1HeaderType *); virtual const IR::Node *preorder(IR::IntMod *); virtual const IR::Node *postorder(IR::IntMod *); virtual const IR::Node *preorder(IR::Tofino::Pipe *); virtual const IR::Node *postorder(IR::Tofino::Pipe *); virtual const IR::Node *preorder(IR::InstanceRef *); virtual const IR::Node *postorder(IR::InstanceRef *); virtual const IR::Node *preorder(IR::HeaderSliceRef *); virtual const IR::Node *postorder(IR::HeaderSliceRef *); virtual const IR::Node *preorder(IR::MAU::Table *); virtual const IR::Node *postorder(IR::MAU::Table *); virtual const IR::Node *preorder(IR::MAU::TernaryIndirect *); virtual const IR::Node *postorder(IR::MAU::TernaryIndirect *); virtual const IR::Node *preorder(IR::MAU::ActionData *); virtual const IR::Node *postorder(IR::MAU::ActionData *); virtual const IR::Node *preorder(IR::MAU::TableSeq *); virtual const IR::Node *postorder(IR::MAU::TableSeq *); virtual const IR::Node *preorder(IR::MAU::Instruction *); virtual const IR::Node *postorder(IR::MAU::Instruction *); virtual const IR::Node *preorder(IR::Tofino::ParserMatch *); virtual const IR::Node *postorder(IR::Tofino::ParserMatch *); virtual const IR::Node *preorder(IR::Tofino::ParserState *); virtual const IR::Node *postorder(IR::Tofino::ParserState *); virtual const IR::Node *preorder(IR::Tofino::Parser *); virtual const IR::Node *postorder(IR::Tofino::Parser *); virtual const IR::Node *preorder(IR::Tofino::Deparser *); virtual const IR::Node *postorder(IR::Tofino::Deparser *); virtual const IR::Node *preorder(IR::Vector<IR::Node> *); virtual const IR::Node *postorder(IR::Vector<IR::Node> *); virtual const IR::Node *preorder(IR::Vector<IR::Type> *); virtual const IR::Node *postorder(IR::Vector<IR::Type> *); virtual const IR::Node *preorder(IR::Vector<IR::StatOrDecl> *); virtual const IR::Node *postorder(IR::Vector<IR::StatOrDecl> *); virtual const IR::Node *preorder(IR::IndexedVector<IR::StatOrDecl> *); virtual const IR::Node *postorder(IR::IndexedVector<IR::StatOrDecl> *); virtual const IR::Node *preorder(IR::Vector<IR::Declaration> *); virtual const IR::Node *postorder(IR::Vector<IR::Declaration> *); virtual const IR::Node *preorder(IR::Vector<IR::Expression> *); virtual const IR::Node *postorder(IR::Vector<IR::Expression> *); virtual const IR::Node *preorder(IR::Vector<IR::Annotation> *); virtual const IR::Node *postorder(IR::Vector<IR::Annotation> *); virtual const IR::Node *preorder(IR::Vector<IR::ArgumentInfo> *); virtual const IR::Node *postorder(IR::Vector<IR::ArgumentInfo> *); virtual const IR::Node *preorder(IR::Vector<IR::Method> *); virtual const IR::Node *postorder(IR::Vector<IR::Method> *); virtual const IR::Node *preorder(IR::Vector<IR::SelectCase> *); virtual const IR::Node *postorder(IR::Vector<IR::SelectCase> *); virtual const IR::Node *preorder(IR::Vector<IR::ParserState> *); virtual const IR::Node *postorder(IR::Vector<IR::ParserState> *); virtual const IR::Node *preorder(IR::Vector<IR::ActionListElement> *); virtual const IR::Node *postorder(IR::Vector<IR::ActionListElement> *); virtual const IR::Node *preorder(IR::Vector<IR::KeyElement> *); virtual const IR::Node *postorder(IR::Vector<IR::KeyElement> *); virtual const IR::Node *preorder(IR::Vector<IR::SwitchCase> *); virtual const IR::Node *postorder(IR::Vector<IR::SwitchCase> *); virtual const IR::Node *preorder(IR::Vector<IR::Primitive> *); virtual const IR::Node *postorder(IR::Vector<IR::Primitive> *); virtual const IR::Node *preorder(IR::Vector<IR::CaseEntry> *); virtual const IR::Node *postorder(IR::Vector<IR::CaseEntry> *); virtual const IR::Node *preorder(IR::Vector<IR::Attached> *); virtual const IR::Node *postorder(IR::Vector<IR::Attached> *); virtual const IR::Node *preorder(IR::Vector<IR::MAU::Table> *); virtual const IR::Node *postorder(IR::Vector<IR::MAU::Table> *); virtual const IR::Node *preorder(IR::Vector<IR::Tofino::ParserMatch> *); virtual const IR::Node *postorder(IR::Vector<IR::Tofino::ParserMatch> *);

 protected:

    void prune() { prune_flag = true; }
    const IR::Node *transform_child(const IR::Node *child) {
        auto *rv = apply_visitor(child);
        prune_flag = true;
        return rv; }
};

class ControlFlowVisitor : public virtual Visitor {
 protected:
    virtual ControlFlowVisitor *clone() const = 0;
    ControlFlowVisitor &flow_clone() override { return *clone(); }
};

class Backtrack : public virtual Visitor {
 public:
    struct trigger {
        enum type_t { OK, OTHER } type;
        explicit trigger(type_t t) : type(t) {}
    };
    virtual bool backtrack(trigger &trig) = 0;
};

class P4WriteContext : public virtual Visitor {
 public:
    bool isWrite();
};
# 5 "../ir/pass_manager.h" 2

typedef std::function<void(const char* manager, unsigned seqNo,
                           const char* pass, const IR::Node* node)> DebugHook;

class PassManager : virtual public Visitor {
 protected:
    const char* managerName = nullptr;
    vector<DebugHook> debugHooks;
    vector<Visitor *> passes;

    bool stop_on_error = true;
    unsigned seqNo = 0;
    void addPasses(const std::initializer_list<Visitor *> &init) {
        for (auto p : init) if (p) passes.emplace_back(p); }
    void runDebugHooks(const char* visitorName, const IR::Node* node);
 public:
    void setName(const char* name) { managerName = name; }
    PassManager() = default;
    PassManager(const std::initializer_list<Visitor *> &init) : stop_on_error(false)
    { addPasses(init); }
    const IR::Node *apply_visitor(const IR::Node *, const char * = 0) override;
    void setStopOnError(bool stop) { stop_on_error = stop; }
    void addDebugHook(DebugHook h) { debugHooks.push_back(h); }
    const char* name() const override
    { return managerName != nullptr ? managerName : Visitor::name(); }
};


class PassRepeated : virtual public PassManager {
    unsigned repeats;
 public:
    PassRepeated(const std::initializer_list<Visitor *> &init) :
            PassManager(init), repeats(0) { setStopOnError(true); }
    const IR::Node *apply_visitor(const IR::Node *, const char * = 0) override;
    void setRepeats(unsigned repeats) { this->repeats = repeats; }
};

class VisitFunctor : virtual public Visitor {
    std::function<const IR::Node *(const IR::Node *)> fn;
    const IR::Node *apply_visitor(const IR::Node *n, const char * = 0) override { return fn(n); }
 public:
    explicit VisitFunctor(std::function<const IR::Node *(const IR::Node *)> f) : fn(f) {}
    explicit VisitFunctor(std::function<void()> f)
    : fn([f](const IR::Node *n)->const IR::Node *{ f(); return n; }) {}
};

class DynamicVisitor : virtual public Visitor {
    Visitor *visitor;
    profile_t init_apply(const IR::Node *root) {
        if (visitor) return visitor->init_apply(root);
        return Visitor::init_apply(root); }
    void end_apply(const IR::Node *root) {
        if (visitor) visitor->end_apply(root); }
    const IR::Node *apply_visitor(const IR::Node *root, const char *name = 0) override {
        if (visitor) return visitor->apply_visitor(root, name);
        return root; }
 public:
    DynamicVisitor() : visitor(nullptr) {}
    explicit DynamicVisitor(Visitor *v) : visitor(v) {}
    void setVisitor(Visitor *v) { visitor = v; }
};
# 33 "../ir/ir.h" 2
# 1 "../ir/ir-inline.h" 1
# 10 "../ir/ir-inline.h"
    inline bool IR::Type ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Type&>(n); } inline bool IR::Type_Base ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Type_Base&>(n); } inline bool IR::Type_Unknown ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Type_Unknown&>(n); } inline bool IR::StatOrDecl ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const StatOrDecl&>(n); } inline bool IR::Declaration ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Declaration&>(n); } inline bool IR::Type_Declaration ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Type_Declaration&>(n); } inline bool IR::Expression ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Expression&>(n); } inline bool IR::Operation ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Operation&>(n); } inline bool IR::PathPrefix ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const PathPrefix&>(n); } inline bool IR::Path ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Path&>(n); } inline bool IR::Annotation ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Annotation&>(n); } inline bool IR::Annotations ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Annotations&>(n); } inline bool IR::Type_Boolean ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Type_Boolean&>(n); } inline bool IR::Type_State ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Type_State&>(n); } inline bool IR::Type_Bits ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Type_Bits&>(n); } inline bool IR::Type_Varbits ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Type_Varbits&>(n); } inline bool IR::Parameter ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Parameter&>(n); } inline bool IR::ParameterList ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const ParameterList&>(n); } inline bool IR::Type_Var ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Type_Var&>(n); } inline bool IR::Type_InfInt ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Type_InfInt&>(n); } inline bool IR::Type_Dontcare ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Type_Dontcare&>(n); } inline bool IR::Type_Void ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Type_Void&>(n); } inline bool IR::Type_Error ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Type_Error&>(n); } inline bool IR::Type_MatchKind ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Type_MatchKind&>(n); } inline bool IR::TypeParameters ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const TypeParameters&>(n); } inline bool IR::StructField ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const StructField&>(n); } inline bool IR::Type_StructLike ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Type_StructLike&>(n); } inline bool IR::Type_Struct ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Type_Struct&>(n); } inline bool IR::Type_Union ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Type_Union&>(n); } inline bool IR::Type_Header ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Type_Header&>(n); } inline bool IR::Type_Set ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Type_Set&>(n); } inline bool IR::Type_Tuple ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Type_Tuple&>(n); } inline bool IR::Type_ArchBlock ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Type_ArchBlock&>(n); } inline bool IR::Type_Package ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Type_Package&>(n); } inline bool IR::Type_Parser ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Type_Parser&>(n); } inline bool IR::Type_Control ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Type_Control&>(n); } inline bool IR::Type_Name ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Type_Name&>(n); } inline bool IR::Type_Stack ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Type_Stack&>(n); } inline bool IR::Type_Specialized ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Type_Specialized&>(n); } inline bool IR::Type_SpecializedCanonical ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Type_SpecializedCanonical&>(n); } inline bool IR::Declaration_ID ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Declaration_ID&>(n); } inline bool IR::Type_Enum ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Type_Enum&>(n); } inline bool IR::Type_Table ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Type_Table&>(n); } inline bool IR::Type_ActionEnum ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Type_ActionEnum&>(n); } inline bool IR::Type_MethodBase ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Type_MethodBase&>(n); } inline bool IR::Type_Method ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Type_Method&>(n); } inline bool IR::ArgumentInfo ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const ArgumentInfo&>(n); } inline bool IR::Type_MethodCall ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Type_MethodCall&>(n); } inline bool IR::Type_Action ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Type_Action&>(n); } inline bool IR::Method ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Method&>(n); } inline bool IR::Type_Typedef ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Type_Typedef&>(n); } inline bool IR::Type_Extern ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Type_Extern&>(n); } inline bool IR::Operation_Unary ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Operation_Unary&>(n); } inline bool IR::Neg ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Neg&>(n); } inline bool IR::Cmpl ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Cmpl&>(n); } inline bool IR::LNot ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const LNot&>(n); } inline bool IR::Operation_Binary ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Operation_Binary&>(n); } inline bool IR::Operation_Ternary ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Operation_Ternary&>(n); } inline bool IR::Operation_Relation ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Operation_Relation&>(n); } inline bool IR::Mul ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Mul&>(n); } inline bool IR::Div ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Div&>(n); } inline bool IR::Mod ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Mod&>(n); } inline bool IR::Add ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Add&>(n); } inline bool IR::Sub ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Sub&>(n); } inline bool IR::Shl ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Shl&>(n); } inline bool IR::Shr ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Shr&>(n); } inline bool IR::Equ ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Equ&>(n); } inline bool IR::Neq ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Neq&>(n); } inline bool IR::Lss ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Lss&>(n); } inline bool IR::Leq ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Leq&>(n); } inline bool IR::Grt ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Grt&>(n); } inline bool IR::Geq ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Geq&>(n); } inline bool IR::BAnd ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const BAnd&>(n); } inline bool IR::BOr ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const BOr&>(n); } inline bool IR::BXor ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const BXor&>(n); } inline bool IR::LAnd ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const LAnd&>(n); } inline bool IR::LOr ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const LOr&>(n); } inline bool IR::Constant ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Constant&>(n); } inline bool IR::BoolLiteral ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const BoolLiteral&>(n); } inline bool IR::StringLiteral ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const StringLiteral&>(n); } inline bool IR::PathExpression ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const PathExpression&>(n); } inline bool IR::TypeNameExpression ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const TypeNameExpression&>(n); } inline bool IR::Slice ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Slice&>(n); } inline bool IR::Member ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Member&>(n); } inline bool IR::Concat ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Concat&>(n); } inline bool IR::ArrayIndex ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const ArrayIndex&>(n); } inline bool IR::Range ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Range&>(n); } inline bool IR::Mask ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Mask&>(n); } inline bool IR::Mux ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Mux&>(n); } inline bool IR::DefaultExpression ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const DefaultExpression&>(n); } inline bool IR::This ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const This&>(n); } inline bool IR::Cast ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Cast&>(n); } inline bool IR::SelectExpression ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const SelectExpression&>(n); } inline bool IR::MethodCallExpression ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const MethodCallExpression&>(n); } inline bool IR::ConstructorCallExpression ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const ConstructorCallExpression&>(n); } inline bool IR::ListExpression ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const ListExpression&>(n); } inline bool IR::SelectCase ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const SelectCase&>(n); } inline bool IR::ParserState ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const ParserState&>(n); } inline bool IR::P4Parser ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const P4Parser&>(n); } inline bool IR::P4Control ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const P4Control&>(n); } inline bool IR::P4Action ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const P4Action&>(n); } inline bool IR::Declaration_Errors ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Declaration_Errors&>(n); } inline bool IR::Declaration_MatchKind ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Declaration_MatchKind&>(n); } inline bool IR::PropertyValue ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const PropertyValue&>(n); } inline bool IR::ExpressionValue ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const ExpressionValue&>(n); } inline bool IR::ActionListElement ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const ActionListElement&>(n); } inline bool IR::ActionList ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const ActionList&>(n); } inline bool IR::KeyElement ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const KeyElement&>(n); } inline bool IR::Key ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Key&>(n); } inline bool IR::TableProperty ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const TableProperty&>(n); } inline bool IR::TableProperties ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const TableProperties&>(n); } inline bool IR::P4Table ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const P4Table&>(n); } inline bool IR::Declaration_Variable ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Declaration_Variable&>(n); } inline bool IR::Declaration_Constant ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Declaration_Constant&>(n); } inline bool IR::Declaration_Instance ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Declaration_Instance&>(n); } inline bool IR::P4Program ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const P4Program&>(n); } inline bool IR::Statement ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Statement&>(n); } inline bool IR::ExitStatement ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const ExitStatement&>(n); } inline bool IR::ReturnStatement ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const ReturnStatement&>(n); } inline bool IR::EmptyStatement ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const EmptyStatement&>(n); } inline bool IR::AssignmentStatement ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const AssignmentStatement&>(n); } inline bool IR::IfStatement ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const IfStatement&>(n); } inline bool IR::BlockStatement ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const BlockStatement&>(n); } inline bool IR::MethodCallStatement ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const MethodCallStatement&>(n); } inline bool IR::SwitchCase ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const SwitchCase&>(n); } inline bool IR::SwitchStatement ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const SwitchStatement&>(n); } inline bool IR::Function ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Function&>(n); } inline bool IR::Block ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Block&>(n); } inline bool IR::TableBlock ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const TableBlock&>(n); } inline bool IR::InstantiatedBlock ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const InstantiatedBlock&>(n); } inline bool IR::ParserBlock ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const ParserBlock&>(n); } inline bool IR::ControlBlock ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const ControlBlock&>(n); } inline bool IR::PackageBlock ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const PackageBlock&>(n); } inline bool IR::ExternBlock ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const ExternBlock&>(n); } inline bool IR::ToplevelBlock ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const ToplevelBlock&>(n); } inline bool IR::HeaderOrMetadata ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const HeaderOrMetadata&>(n); } inline bool IR::Header ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Header&>(n); } inline bool IR::HeaderStack ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const HeaderStack&>(n); } inline bool IR::Metadata ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Metadata&>(n); } inline bool IR::HeaderRef ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const HeaderRef&>(n); } inline bool IR::ConcreteHeaderRef ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const ConcreteHeaderRef&>(n); } inline bool IR::HeaderStackItemRef ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const HeaderStackItemRef&>(n); } inline bool IR::NamedRef ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const NamedRef&>(n); } inline bool IR::If ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const If&>(n); } inline bool IR::NamedCond ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const NamedCond&>(n); } inline bool IR::Apply ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Apply&>(n); } inline bool IR::Primitive ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Primitive&>(n); } inline bool IR::FieldList ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const FieldList&>(n); } inline bool IR::FieldListCalculation ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const FieldListCalculation&>(n); } inline bool IR::CalculatedField ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const CalculatedField&>(n); } inline bool IR::CaseEntry ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const CaseEntry&>(n); } inline bool IR::V1Parser ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const V1Parser&>(n); } inline bool IR::ParserException ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const ParserException&>(n); } inline bool IR::Attached ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Attached&>(n); } inline bool IR::Stateful ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Stateful&>(n); } inline bool IR::CounterOrMeter ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const CounterOrMeter&>(n); } inline bool IR::Counter ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Counter&>(n); } inline bool IR::Meter ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Meter&>(n); } inline bool IR::Register ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Register&>(n); } inline bool IR::PrimitiveAction ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const PrimitiveAction&>(n); } inline bool IR::NameList ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const NameList&>(n); } inline bool IR::ActionArg ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const ActionArg&>(n); } inline bool IR::ActionFunction ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const ActionFunction&>(n); } inline bool IR::ActionProfile ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const ActionProfile&>(n); } inline bool IR::ActionSelector ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const ActionSelector&>(n); } inline bool IR::V1Table ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const V1Table&>(n); } inline bool IR::V1Control ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const V1Control&>(n); } inline bool IR::V1Program ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const V1Program&>(n); } inline bool IR::v1HeaderType ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const v1HeaderType&>(n); } inline bool IR::IntMod ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const IntMod&>(n); } inline bool IR::Tofino::Pipe ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Tofino::Pipe&>(n); } inline bool IR::InstanceRef ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const InstanceRef&>(n); } inline bool IR::HeaderSliceRef ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const HeaderSliceRef&>(n); } inline bool IR::MAU::Table ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const MAU::Table&>(n); } inline bool IR::MAU::TernaryIndirect ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const MAU::TernaryIndirect&>(n); } inline bool IR::MAU::ActionData ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const MAU::ActionData&>(n); } inline bool IR::MAU::TableSeq ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const MAU::TableSeq&>(n); } inline bool IR::MAU::Instruction ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const MAU::Instruction&>(n); } inline bool IR::Tofino::ParserMatch ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Tofino::ParserMatch&>(n); } inline bool IR::Tofino::ParserState ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Tofino::ParserState&>(n); } inline bool IR::Tofino::Parser ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Tofino::Parser&>(n); } inline bool IR::Tofino::Deparser ::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Tofino::Deparser&>(n); }
    template<class T> inline bool IR::Vector <T>::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const Vector&>(n); } template<class T> inline bool IR::IndexedVector <T>::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const IndexedVector&>(n); } template<class T, template<class, class, class, class> class MAP , class COMP , class ALLOC > inline bool IR::NameMap <T, MAP, COMP, ALLOC>::operator ==(const IR::Node &n) const { if (this == &n) return true; if (typeid(*this) != typeid(n)) return false; return *this == dynamic_cast<const NameMap&>(n); }
# 27 "../ir/ir-inline.h"
    inline bool IR::Type ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Type ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Type ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Type ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Type ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Type ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Type_Base ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Type_Base ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Type_Base ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Type_Base ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Type_Base ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Type_Base ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Type_Unknown ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Type_Unknown ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Type_Unknown ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Type_Unknown ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Type_Unknown ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Type_Unknown ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::StatOrDecl ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::StatOrDecl ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::StatOrDecl ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::StatOrDecl ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::StatOrDecl ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::StatOrDecl ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Declaration ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Declaration ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Declaration ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Declaration ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Declaration ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Declaration ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Type_Declaration ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Type_Declaration ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Type_Declaration ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Type_Declaration ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Type_Declaration ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Type_Declaration ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Expression ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Expression ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Expression ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Expression ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Expression ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Expression ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Operation ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Operation ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Operation ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Operation ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Operation ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Operation ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::PathPrefix ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::PathPrefix ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::PathPrefix ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::PathPrefix ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::PathPrefix ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::PathPrefix ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Path ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Path ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Path ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Path ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Path ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Path ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Annotation ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Annotation ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Annotation ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Annotation ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Annotation ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Annotation ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Annotations ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Annotations ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Annotations ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Annotations ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Annotations ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Annotations ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Type_Boolean ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Type_Boolean ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Type_Boolean ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Type_Boolean ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Type_Boolean ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Type_Boolean ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Type_State ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Type_State ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Type_State ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Type_State ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Type_State ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Type_State ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Type_Bits ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Type_Bits ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Type_Bits ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Type_Bits ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Type_Bits ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Type_Bits ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Type_Varbits ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Type_Varbits ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Type_Varbits ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Type_Varbits ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Type_Varbits ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Type_Varbits ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Parameter ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Parameter ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Parameter ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Parameter ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Parameter ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Parameter ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::ParameterList ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::ParameterList ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::ParameterList ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::ParameterList ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::ParameterList ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::ParameterList ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Type_Var ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Type_Var ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Type_Var ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Type_Var ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Type_Var ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Type_Var ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Type_InfInt ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Type_InfInt ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Type_InfInt ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Type_InfInt ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Type_InfInt ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Type_InfInt ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Type_Dontcare ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Type_Dontcare ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Type_Dontcare ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Type_Dontcare ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Type_Dontcare ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Type_Dontcare ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Type_Void ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Type_Void ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Type_Void ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Type_Void ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Type_Void ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Type_Void ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Type_Error ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Type_Error ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Type_Error ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Type_Error ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Type_Error ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Type_Error ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Type_MatchKind ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Type_MatchKind ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Type_MatchKind ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Type_MatchKind ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Type_MatchKind ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Type_MatchKind ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::TypeParameters ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::TypeParameters ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::TypeParameters ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::TypeParameters ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::TypeParameters ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::TypeParameters ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::StructField ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::StructField ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::StructField ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::StructField ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::StructField ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::StructField ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Type_StructLike ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Type_StructLike ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Type_StructLike ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Type_StructLike ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Type_StructLike ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Type_StructLike ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Type_Struct ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Type_Struct ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Type_Struct ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Type_Struct ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Type_Struct ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Type_Struct ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Type_Union ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Type_Union ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Type_Union ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Type_Union ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Type_Union ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Type_Union ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Type_Header ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Type_Header ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Type_Header ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Type_Header ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Type_Header ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Type_Header ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Type_Set ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Type_Set ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Type_Set ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Type_Set ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Type_Set ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Type_Set ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Type_Tuple ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Type_Tuple ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Type_Tuple ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Type_Tuple ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Type_Tuple ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Type_Tuple ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Type_ArchBlock ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Type_ArchBlock ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Type_ArchBlock ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Type_ArchBlock ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Type_ArchBlock ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Type_ArchBlock ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Type_Package ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Type_Package ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Type_Package ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Type_Package ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Type_Package ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Type_Package ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Type_Parser ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Type_Parser ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Type_Parser ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Type_Parser ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Type_Parser ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Type_Parser ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Type_Control ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Type_Control ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Type_Control ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Type_Control ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Type_Control ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Type_Control ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Type_Name ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Type_Name ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Type_Name ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Type_Name ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Type_Name ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Type_Name ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Type_Stack ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Type_Stack ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Type_Stack ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Type_Stack ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Type_Stack ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Type_Stack ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Type_Specialized ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Type_Specialized ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Type_Specialized ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Type_Specialized ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Type_Specialized ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Type_Specialized ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Type_SpecializedCanonical ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Type_SpecializedCanonical ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Type_SpecializedCanonical ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Type_SpecializedCanonical ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Type_SpecializedCanonical ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Type_SpecializedCanonical ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Declaration_ID ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Declaration_ID ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Declaration_ID ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Declaration_ID ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Declaration_ID ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Declaration_ID ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Type_Enum ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Type_Enum ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Type_Enum ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Type_Enum ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Type_Enum ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Type_Enum ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Type_Table ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Type_Table ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Type_Table ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Type_Table ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Type_Table ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Type_Table ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Type_ActionEnum ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Type_ActionEnum ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Type_ActionEnum ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Type_ActionEnum ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Type_ActionEnum ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Type_ActionEnum ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Type_MethodBase ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Type_MethodBase ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Type_MethodBase ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Type_MethodBase ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Type_MethodBase ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Type_MethodBase ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Type_Method ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Type_Method ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Type_Method ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Type_Method ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Type_Method ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Type_Method ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::ArgumentInfo ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::ArgumentInfo ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::ArgumentInfo ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::ArgumentInfo ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::ArgumentInfo ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::ArgumentInfo ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Type_MethodCall ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Type_MethodCall ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Type_MethodCall ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Type_MethodCall ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Type_MethodCall ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Type_MethodCall ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Type_Action ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Type_Action ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Type_Action ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Type_Action ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Type_Action ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Type_Action ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Method ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Method ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Method ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Method ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Method ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Method ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Type_Typedef ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Type_Typedef ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Type_Typedef ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Type_Typedef ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Type_Typedef ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Type_Typedef ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Type_Extern ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Type_Extern ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Type_Extern ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Type_Extern ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Type_Extern ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Type_Extern ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Operation_Unary ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Operation_Unary ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Operation_Unary ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Operation_Unary ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Operation_Unary ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Operation_Unary ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Neg ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Neg ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Neg ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Neg ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Neg ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Neg ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Cmpl ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Cmpl ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Cmpl ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Cmpl ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Cmpl ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Cmpl ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::LNot ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::LNot ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::LNot ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::LNot ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::LNot ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::LNot ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Operation_Binary ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Operation_Binary ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Operation_Binary ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Operation_Binary ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Operation_Binary ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Operation_Binary ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Operation_Ternary ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Operation_Ternary ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Operation_Ternary ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Operation_Ternary ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Operation_Ternary ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Operation_Ternary ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Operation_Relation ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Operation_Relation ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Operation_Relation ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Operation_Relation ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Operation_Relation ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Operation_Relation ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Mul ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Mul ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Mul ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Mul ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Mul ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Mul ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Div ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Div ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Div ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Div ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Div ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Div ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Mod ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Mod ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Mod ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Mod ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Mod ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Mod ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Add ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Add ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Add ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Add ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Add ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Add ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Sub ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Sub ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Sub ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Sub ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Sub ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Sub ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Shl ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Shl ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Shl ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Shl ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Shl ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Shl ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Shr ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Shr ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Shr ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Shr ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Shr ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Shr ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Equ ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Equ ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Equ ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Equ ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Equ ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Equ ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Neq ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Neq ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Neq ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Neq ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Neq ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Neq ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Lss ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Lss ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Lss ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Lss ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Lss ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Lss ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Leq ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Leq ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Leq ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Leq ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Leq ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Leq ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Grt ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Grt ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Grt ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Grt ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Grt ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Grt ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Geq ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Geq ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Geq ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Geq ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Geq ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Geq ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::BAnd ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::BAnd ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::BAnd ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::BAnd ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::BAnd ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::BAnd ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::BOr ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::BOr ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::BOr ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::BOr ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::BOr ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::BOr ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::BXor ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::BXor ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::BXor ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::BXor ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::BXor ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::BXor ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::LAnd ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::LAnd ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::LAnd ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::LAnd ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::LAnd ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::LAnd ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::LOr ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::LOr ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::LOr ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::LOr ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::LOr ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::LOr ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Constant ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Constant ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Constant ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Constant ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Constant ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Constant ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::BoolLiteral ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::BoolLiteral ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::BoolLiteral ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::BoolLiteral ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::BoolLiteral ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::BoolLiteral ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::StringLiteral ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::StringLiteral ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::StringLiteral ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::StringLiteral ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::StringLiteral ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::StringLiteral ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::PathExpression ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::PathExpression ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::PathExpression ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::PathExpression ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::PathExpression ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::PathExpression ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::TypeNameExpression ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::TypeNameExpression ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::TypeNameExpression ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::TypeNameExpression ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::TypeNameExpression ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::TypeNameExpression ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Slice ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Slice ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Slice ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Slice ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Slice ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Slice ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Member ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Member ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Member ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Member ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Member ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Member ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Concat ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Concat ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Concat ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Concat ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Concat ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Concat ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::ArrayIndex ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::ArrayIndex ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::ArrayIndex ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::ArrayIndex ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::ArrayIndex ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::ArrayIndex ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Range ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Range ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Range ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Range ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Range ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Range ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Mask ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Mask ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Mask ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Mask ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Mask ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Mask ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Mux ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Mux ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Mux ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Mux ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Mux ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Mux ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::DefaultExpression ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::DefaultExpression ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::DefaultExpression ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::DefaultExpression ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::DefaultExpression ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::DefaultExpression ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::This ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::This ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::This ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::This ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::This ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::This ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Cast ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Cast ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Cast ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Cast ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Cast ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Cast ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::SelectExpression ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::SelectExpression ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::SelectExpression ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::SelectExpression ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::SelectExpression ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::SelectExpression ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::MethodCallExpression ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::MethodCallExpression ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::MethodCallExpression ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::MethodCallExpression ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::MethodCallExpression ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::MethodCallExpression ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::ConstructorCallExpression ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::ConstructorCallExpression ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::ConstructorCallExpression ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::ConstructorCallExpression ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::ConstructorCallExpression ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::ConstructorCallExpression ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::ListExpression ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::ListExpression ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::ListExpression ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::ListExpression ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::ListExpression ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::ListExpression ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::SelectCase ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::SelectCase ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::SelectCase ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::SelectCase ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::SelectCase ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::SelectCase ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::ParserState ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::ParserState ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::ParserState ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::ParserState ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::ParserState ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::ParserState ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::P4Parser ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::P4Parser ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::P4Parser ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::P4Parser ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::P4Parser ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::P4Parser ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::P4Control ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::P4Control ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::P4Control ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::P4Control ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::P4Control ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::P4Control ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::P4Action ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::P4Action ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::P4Action ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::P4Action ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::P4Action ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::P4Action ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Declaration_Errors ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Declaration_Errors ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Declaration_Errors ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Declaration_Errors ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Declaration_Errors ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Declaration_Errors ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Declaration_MatchKind ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Declaration_MatchKind ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Declaration_MatchKind ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Declaration_MatchKind ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Declaration_MatchKind ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Declaration_MatchKind ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::PropertyValue ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::PropertyValue ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::PropertyValue ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::PropertyValue ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::PropertyValue ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::PropertyValue ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::ExpressionValue ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::ExpressionValue ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::ExpressionValue ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::ExpressionValue ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::ExpressionValue ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::ExpressionValue ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::ActionListElement ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::ActionListElement ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::ActionListElement ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::ActionListElement ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::ActionListElement ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::ActionListElement ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::ActionList ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::ActionList ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::ActionList ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::ActionList ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::ActionList ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::ActionList ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::KeyElement ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::KeyElement ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::KeyElement ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::KeyElement ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::KeyElement ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::KeyElement ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Key ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Key ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Key ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Key ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Key ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Key ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::TableProperty ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::TableProperty ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::TableProperty ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::TableProperty ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::TableProperty ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::TableProperty ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::TableProperties ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::TableProperties ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::TableProperties ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::TableProperties ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::TableProperties ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::TableProperties ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::P4Table ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::P4Table ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::P4Table ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::P4Table ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::P4Table ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::P4Table ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Declaration_Variable ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Declaration_Variable ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Declaration_Variable ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Declaration_Variable ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Declaration_Variable ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Declaration_Variable ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Declaration_Constant ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Declaration_Constant ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Declaration_Constant ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Declaration_Constant ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Declaration_Constant ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Declaration_Constant ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Declaration_Instance ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Declaration_Instance ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Declaration_Instance ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Declaration_Instance ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Declaration_Instance ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Declaration_Instance ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::P4Program ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::P4Program ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::P4Program ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::P4Program ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::P4Program ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::P4Program ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Statement ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Statement ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Statement ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Statement ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Statement ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Statement ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::ExitStatement ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::ExitStatement ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::ExitStatement ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::ExitStatement ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::ExitStatement ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::ExitStatement ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::ReturnStatement ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::ReturnStatement ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::ReturnStatement ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::ReturnStatement ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::ReturnStatement ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::ReturnStatement ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::EmptyStatement ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::EmptyStatement ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::EmptyStatement ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::EmptyStatement ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::EmptyStatement ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::EmptyStatement ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::AssignmentStatement ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::AssignmentStatement ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::AssignmentStatement ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::AssignmentStatement ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::AssignmentStatement ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::AssignmentStatement ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::IfStatement ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::IfStatement ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::IfStatement ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::IfStatement ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::IfStatement ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::IfStatement ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::BlockStatement ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::BlockStatement ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::BlockStatement ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::BlockStatement ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::BlockStatement ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::BlockStatement ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::MethodCallStatement ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::MethodCallStatement ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::MethodCallStatement ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::MethodCallStatement ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::MethodCallStatement ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::MethodCallStatement ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::SwitchCase ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::SwitchCase ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::SwitchCase ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::SwitchCase ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::SwitchCase ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::SwitchCase ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::SwitchStatement ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::SwitchStatement ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::SwitchStatement ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::SwitchStatement ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::SwitchStatement ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::SwitchStatement ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Function ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Function ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Function ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Function ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Function ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Function ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Block ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Block ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Block ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Block ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Block ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Block ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::TableBlock ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::TableBlock ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::TableBlock ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::TableBlock ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::TableBlock ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::TableBlock ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::InstantiatedBlock ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::InstantiatedBlock ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::InstantiatedBlock ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::InstantiatedBlock ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::InstantiatedBlock ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::InstantiatedBlock ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::ParserBlock ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::ParserBlock ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::ParserBlock ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::ParserBlock ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::ParserBlock ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::ParserBlock ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::ControlBlock ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::ControlBlock ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::ControlBlock ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::ControlBlock ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::ControlBlock ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::ControlBlock ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::PackageBlock ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::PackageBlock ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::PackageBlock ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::PackageBlock ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::PackageBlock ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::PackageBlock ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::ExternBlock ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::ExternBlock ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::ExternBlock ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::ExternBlock ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::ExternBlock ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::ExternBlock ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::ToplevelBlock ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::ToplevelBlock ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::ToplevelBlock ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::ToplevelBlock ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::ToplevelBlock ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::ToplevelBlock ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::HeaderOrMetadata ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::HeaderOrMetadata ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::HeaderOrMetadata ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::HeaderOrMetadata ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::HeaderOrMetadata ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::HeaderOrMetadata ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Header ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Header ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Header ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Header ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Header ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Header ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::HeaderStack ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::HeaderStack ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::HeaderStack ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::HeaderStack ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::HeaderStack ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::HeaderStack ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Metadata ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Metadata ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Metadata ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Metadata ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Metadata ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Metadata ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::HeaderRef ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::HeaderRef ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::HeaderRef ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::HeaderRef ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::HeaderRef ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::HeaderRef ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::ConcreteHeaderRef ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::ConcreteHeaderRef ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::ConcreteHeaderRef ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::ConcreteHeaderRef ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::ConcreteHeaderRef ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::ConcreteHeaderRef ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::HeaderStackItemRef ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::HeaderStackItemRef ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::HeaderStackItemRef ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::HeaderStackItemRef ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::HeaderStackItemRef ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::HeaderStackItemRef ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::NamedRef ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::NamedRef ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::NamedRef ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::NamedRef ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::NamedRef ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::NamedRef ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::If ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::If ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::If ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::If ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::If ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::If ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::NamedCond ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::NamedCond ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::NamedCond ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::NamedCond ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::NamedCond ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::NamedCond ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Apply ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Apply ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Apply ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Apply ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Apply ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Apply ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Primitive ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Primitive ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Primitive ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Primitive ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Primitive ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Primitive ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::FieldList ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::FieldList ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::FieldList ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::FieldList ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::FieldList ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::FieldList ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::FieldListCalculation ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::FieldListCalculation ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::FieldListCalculation ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::FieldListCalculation ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::FieldListCalculation ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::FieldListCalculation ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::CalculatedField ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::CalculatedField ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::CalculatedField ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::CalculatedField ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::CalculatedField ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::CalculatedField ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::CaseEntry ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::CaseEntry ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::CaseEntry ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::CaseEntry ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::CaseEntry ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::CaseEntry ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::V1Parser ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::V1Parser ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::V1Parser ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::V1Parser ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::V1Parser ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::V1Parser ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::ParserException ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::ParserException ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::ParserException ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::ParserException ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::ParserException ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::ParserException ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Attached ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Attached ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Attached ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Attached ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Attached ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Attached ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Stateful ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Stateful ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Stateful ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Stateful ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Stateful ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Stateful ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::CounterOrMeter ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::CounterOrMeter ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::CounterOrMeter ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::CounterOrMeter ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::CounterOrMeter ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::CounterOrMeter ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Counter ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Counter ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Counter ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Counter ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Counter ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Counter ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Meter ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Meter ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Meter ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Meter ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Meter ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Meter ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Register ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Register ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Register ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Register ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Register ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Register ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::PrimitiveAction ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::PrimitiveAction ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::PrimitiveAction ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::PrimitiveAction ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::PrimitiveAction ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::PrimitiveAction ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::NameList ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::NameList ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::NameList ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::NameList ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::NameList ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::NameList ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::ActionArg ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::ActionArg ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::ActionArg ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::ActionArg ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::ActionArg ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::ActionArg ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::ActionFunction ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::ActionFunction ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::ActionFunction ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::ActionFunction ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::ActionFunction ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::ActionFunction ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::ActionProfile ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::ActionProfile ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::ActionProfile ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::ActionProfile ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::ActionProfile ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::ActionProfile ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::ActionSelector ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::ActionSelector ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::ActionSelector ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::ActionSelector ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::ActionSelector ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::ActionSelector ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::V1Table ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::V1Table ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::V1Table ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::V1Table ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::V1Table ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::V1Table ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::V1Control ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::V1Control ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::V1Control ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::V1Control ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::V1Control ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::V1Control ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::V1Program ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::V1Program ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::V1Program ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::V1Program ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::V1Program ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::V1Program ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::v1HeaderType ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::v1HeaderType ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::v1HeaderType ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::v1HeaderType ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::v1HeaderType ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::v1HeaderType ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::IntMod ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::IntMod ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::IntMod ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::IntMod ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::IntMod ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::IntMod ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Tofino::Pipe ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Tofino::Pipe ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Tofino::Pipe ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Tofino::Pipe ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Tofino::Pipe ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Tofino::Pipe ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::InstanceRef ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::InstanceRef ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::InstanceRef ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::InstanceRef ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::InstanceRef ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::InstanceRef ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::HeaderSliceRef ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::HeaderSliceRef ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::HeaderSliceRef ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::HeaderSliceRef ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::HeaderSliceRef ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::HeaderSliceRef ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::MAU::Table ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::MAU::Table ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::MAU::Table ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::MAU::Table ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::MAU::Table ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::MAU::Table ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::MAU::TernaryIndirect ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::MAU::TernaryIndirect ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::MAU::TernaryIndirect ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::MAU::TernaryIndirect ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::MAU::TernaryIndirect ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::MAU::TernaryIndirect ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::MAU::ActionData ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::MAU::ActionData ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::MAU::ActionData ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::MAU::ActionData ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::MAU::ActionData ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::MAU::ActionData ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::MAU::TableSeq ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::MAU::TableSeq ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::MAU::TableSeq ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::MAU::TableSeq ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::MAU::TableSeq ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::MAU::TableSeq ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::MAU::Instruction ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::MAU::Instruction ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::MAU::Instruction ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::MAU::Instruction ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::MAU::Instruction ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::MAU::Instruction ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Tofino::ParserMatch ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Tofino::ParserMatch ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Tofino::ParserMatch ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Tofino::ParserMatch ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Tofino::ParserMatch ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Tofino::ParserMatch ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Tofino::ParserState ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Tofino::ParserState ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Tofino::ParserState ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Tofino::ParserState ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Tofino::ParserState ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Tofino::ParserState ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Tofino::Parser ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Tofino::Parser ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Tofino::Parser ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Tofino::Parser ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Tofino::Parser ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Tofino::Parser ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } inline bool IR::Tofino::Deparser ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Tofino::Deparser ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Tofino::Deparser ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Tofino::Deparser ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Tofino::Deparser ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Tofino::Deparser ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); }
    template<class T> inline bool IR::Vector <T>::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } template<class T> inline void IR::Vector <T>::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } template<class T> inline bool IR::Vector <T>::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } template<class T> inline void IR::Vector <T>::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } template<class T> inline const IR::Node *IR::Vector <T>::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } template<class T> inline const IR::Node *IR::Vector <T>::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } template<class T> inline bool IR::IndexedVector <T>::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } template<class T> inline void IR::IndexedVector <T>::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } template<class T> inline bool IR::IndexedVector <T>::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } template<class T> inline void IR::IndexedVector <T>::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } template<class T> inline const IR::Node *IR::IndexedVector <T>::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } template<class T> inline const IR::Node *IR::IndexedVector <T>::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); } template<class T, template<class, class, class, class> class MAP , class COMP , class ALLOC > inline bool IR::NameMap <T, MAP, COMP, ALLOC>::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } template<class T, template<class, class, class, class> class MAP , class COMP , class ALLOC > inline void IR::NameMap <T, MAP, COMP, ALLOC>::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } template<class T, template<class, class, class, class> class MAP , class COMP , class ALLOC > inline bool IR::NameMap <T, MAP, COMP, ALLOC>::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } template<class T, template<class, class, class, class> class MAP , class COMP , class ALLOC > inline void IR::NameMap <T, MAP, COMP, ALLOC>::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } template<class T, template<class, class, class, class> class MAP , class COMP , class ALLOC > inline const IR::Node *IR::NameMap <T, MAP, COMP, ALLOC>::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } template<class T, template<class, class, class, class> class MAP , class COMP , class ALLOC > inline const IR::Node *IR::NameMap <T, MAP, COMP, ALLOC>::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); }
    inline bool IR::Node ::apply_visitor_preorder(Modifier &v) { traceVisit("Mod pre"); return v.preorder(this); } inline void IR::Node ::apply_visitor_postorder(Modifier &v) { traceVisit("Mod post"); v.postorder(this); } inline bool IR::Node ::apply_visitor_preorder(Inspector &v) const { traceVisit("Insp pre"); return v.preorder(this); } inline void IR::Node ::apply_visitor_postorder(Inspector &v) const { traceVisit("Insp post"); v.postorder(this); } inline const IR::Node *IR::Node ::apply_visitor_preorder(Transform &v) { traceVisit("Trans pre"); return v.preorder(this); } inline const IR::Node *IR::Node ::apply_visitor_postorder(Transform &v) { traceVisit("Trans post"); return v.postorder(this); }
# 41 "../ir/ir-inline.h"
    inline void Visitor::visit(const IR::Type *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Type *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Type" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Type *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Type_Base *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Type_Base *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Type_Base" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Type_Base *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Type_Unknown *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Type_Unknown *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Type_Unknown" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Type_Unknown *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::StatOrDecl *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::StatOrDecl *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "StatOrDecl" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::StatOrDecl *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Declaration *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Declaration *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Declaration" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Declaration *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Type_Declaration *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Type_Declaration *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Type_Declaration" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Type_Declaration *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Expression *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Expression *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Expression" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Expression *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Operation *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Operation *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Operation" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Operation *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::PathPrefix *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::PathPrefix *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "PathPrefix" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::PathPrefix *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Path *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Path *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Path" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Path *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Annotation *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Annotation *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Annotation" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Annotation *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Annotations *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Annotations *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Annotations" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Annotations *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Type_Boolean *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Type_Boolean *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Type_Boolean" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Type_Boolean *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Type_State *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Type_State *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Type_State" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Type_State *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Type_Bits *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Type_Bits *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Type_Bits" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Type_Bits *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Type_Varbits *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Type_Varbits *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Type_Varbits" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Type_Varbits *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Parameter *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Parameter *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Parameter" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Parameter *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::ParameterList *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::ParameterList *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "ParameterList" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::ParameterList *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Type_Var *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Type_Var *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Type_Var" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Type_Var *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Type_InfInt *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Type_InfInt *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Type_InfInt" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Type_InfInt *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Type_Dontcare *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Type_Dontcare *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Type_Dontcare" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Type_Dontcare *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Type_Void *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Type_Void *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Type_Void" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Type_Void *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Type_Error *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Type_Error *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Type_Error" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Type_Error *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Type_MatchKind *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Type_MatchKind *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Type_MatchKind" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Type_MatchKind *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::TypeParameters *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::TypeParameters *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "TypeParameters" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::TypeParameters *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::StructField *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::StructField *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "StructField" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::StructField *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Type_StructLike *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Type_StructLike *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Type_StructLike" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Type_StructLike *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Type_Struct *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Type_Struct *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Type_Struct" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Type_Struct *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Type_Union *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Type_Union *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Type_Union" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Type_Union *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Type_Header *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Type_Header *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Type_Header" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Type_Header *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Type_Set *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Type_Set *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Type_Set" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Type_Set *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Type_Tuple *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Type_Tuple *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Type_Tuple" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Type_Tuple *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Type_ArchBlock *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Type_ArchBlock *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Type_ArchBlock" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Type_ArchBlock *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Type_Package *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Type_Package *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Type_Package" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Type_Package *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Type_Parser *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Type_Parser *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Type_Parser" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Type_Parser *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Type_Control *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Type_Control *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Type_Control" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Type_Control *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Type_Name *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Type_Name *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Type_Name" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Type_Name *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Type_Stack *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Type_Stack *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Type_Stack" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Type_Stack *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Type_Specialized *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Type_Specialized *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Type_Specialized" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Type_Specialized *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Type_SpecializedCanonical *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Type_SpecializedCanonical *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Type_SpecializedCanonical" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Type_SpecializedCanonical *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Declaration_ID *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Declaration_ID *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Declaration_ID" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Declaration_ID *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Type_Enum *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Type_Enum *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Type_Enum" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Type_Enum *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Type_Table *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Type_Table *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Type_Table" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Type_Table *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Type_ActionEnum *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Type_ActionEnum *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Type_ActionEnum" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Type_ActionEnum *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Type_MethodBase *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Type_MethodBase *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Type_MethodBase" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Type_MethodBase *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Type_Method *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Type_Method *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Type_Method" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Type_Method *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::ArgumentInfo *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::ArgumentInfo *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "ArgumentInfo" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::ArgumentInfo *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Type_MethodCall *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Type_MethodCall *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Type_MethodCall" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Type_MethodCall *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Type_Action *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Type_Action *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Type_Action" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Type_Action *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Method *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Method *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Method" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Method *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Type_Typedef *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Type_Typedef *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Type_Typedef" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Type_Typedef *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Type_Extern *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Type_Extern *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Type_Extern" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Type_Extern *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Operation_Unary *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Operation_Unary *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Operation_Unary" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Operation_Unary *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Neg *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Neg *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Neg" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Neg *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Cmpl *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Cmpl *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Cmpl" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Cmpl *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::LNot *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::LNot *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "LNot" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::LNot *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Operation_Binary *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Operation_Binary *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Operation_Binary" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Operation_Binary *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Operation_Ternary *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Operation_Ternary *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Operation_Ternary" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Operation_Ternary *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Operation_Relation *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Operation_Relation *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Operation_Relation" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Operation_Relation *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Mul *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Mul *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Mul" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Mul *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Div *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Div *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Div" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Div *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Mod *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Mod *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Mod" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Mod *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Add *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Add *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Add" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Add *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Sub *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Sub *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Sub" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Sub *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Shl *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Shl *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Shl" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Shl *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Shr *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Shr *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Shr" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Shr *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Equ *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Equ *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Equ" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Equ *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Neq *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Neq *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Neq" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Neq *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Lss *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Lss *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Lss" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Lss *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Leq *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Leq *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Leq" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Leq *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Grt *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Grt *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Grt" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Grt *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Geq *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Geq *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Geq" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Geq *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::BAnd *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::BAnd *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "BAnd" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::BAnd *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::BOr *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::BOr *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "BOr" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::BOr *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::BXor *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::BXor *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "BXor" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::BXor *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::LAnd *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::LAnd *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "LAnd" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::LAnd *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::LOr *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::LOr *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "LOr" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::LOr *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Constant *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Constant *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Constant" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Constant *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::BoolLiteral *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::BoolLiteral *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "BoolLiteral" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::BoolLiteral *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::StringLiteral *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::StringLiteral *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "StringLiteral" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::StringLiteral *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::PathExpression *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::PathExpression *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "PathExpression" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::PathExpression *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::TypeNameExpression *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::TypeNameExpression *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "TypeNameExpression" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::TypeNameExpression *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Slice *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Slice *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Slice" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Slice *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Member *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Member *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Member" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Member *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Concat *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Concat *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Concat" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Concat *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::ArrayIndex *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::ArrayIndex *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "ArrayIndex" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::ArrayIndex *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Range *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Range *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Range" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Range *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Mask *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Mask *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Mask" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Mask *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Mux *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Mux *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Mux" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Mux *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::DefaultExpression *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::DefaultExpression *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "DefaultExpression" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::DefaultExpression *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::This *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::This *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "This" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::This *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Cast *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Cast *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Cast" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Cast *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::SelectExpression *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::SelectExpression *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "SelectExpression" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::SelectExpression *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::MethodCallExpression *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::MethodCallExpression *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "MethodCallExpression" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::MethodCallExpression *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::ConstructorCallExpression *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::ConstructorCallExpression *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "ConstructorCallExpression" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::ConstructorCallExpression *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::ListExpression *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::ListExpression *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "ListExpression" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::ListExpression *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::SelectCase *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::SelectCase *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "SelectCase" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::SelectCase *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::ParserState *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::ParserState *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "ParserState" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::ParserState *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::P4Parser *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::P4Parser *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "P4Parser" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::P4Parser *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::P4Control *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::P4Control *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "P4Control" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::P4Control *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::P4Action *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::P4Action *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "P4Action" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::P4Action *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Declaration_Errors *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Declaration_Errors *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Declaration_Errors" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Declaration_Errors *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Declaration_MatchKind *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Declaration_MatchKind *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Declaration_MatchKind" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Declaration_MatchKind *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::PropertyValue *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::PropertyValue *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "PropertyValue" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::PropertyValue *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::ExpressionValue *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::ExpressionValue *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "ExpressionValue" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::ExpressionValue *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::ActionListElement *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::ActionListElement *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "ActionListElement" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::ActionListElement *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::ActionList *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::ActionList *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "ActionList" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::ActionList *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::KeyElement *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::KeyElement *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "KeyElement" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::KeyElement *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Key *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Key *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Key" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Key *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::TableProperty *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::TableProperty *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "TableProperty" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::TableProperty *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::TableProperties *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::TableProperties *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "TableProperties" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::TableProperties *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::P4Table *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::P4Table *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "P4Table" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::P4Table *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Declaration_Variable *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Declaration_Variable *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Declaration_Variable" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Declaration_Variable *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Declaration_Constant *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Declaration_Constant *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Declaration_Constant" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Declaration_Constant *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Declaration_Instance *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Declaration_Instance *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Declaration_Instance" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Declaration_Instance *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::P4Program *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::P4Program *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "P4Program" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::P4Program *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Statement *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Statement *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Statement" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Statement *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::ExitStatement *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::ExitStatement *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "ExitStatement" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::ExitStatement *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::ReturnStatement *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::ReturnStatement *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "ReturnStatement" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::ReturnStatement *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::EmptyStatement *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::EmptyStatement *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "EmptyStatement" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::EmptyStatement *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::AssignmentStatement *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::AssignmentStatement *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "AssignmentStatement" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::AssignmentStatement *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::IfStatement *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::IfStatement *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "IfStatement" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::IfStatement *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::BlockStatement *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::BlockStatement *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "BlockStatement" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::BlockStatement *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::MethodCallStatement *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::MethodCallStatement *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "MethodCallStatement" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::MethodCallStatement *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::SwitchCase *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::SwitchCase *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "SwitchCase" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::SwitchCase *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::SwitchStatement *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::SwitchStatement *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "SwitchStatement" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::SwitchStatement *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Function *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Function *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Function" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Function *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Block *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Block *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Block" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Block *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::TableBlock *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::TableBlock *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "TableBlock" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::TableBlock *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::InstantiatedBlock *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::InstantiatedBlock *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "InstantiatedBlock" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::InstantiatedBlock *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::ParserBlock *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::ParserBlock *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "ParserBlock" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::ParserBlock *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::ControlBlock *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::ControlBlock *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "ControlBlock" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::ControlBlock *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::PackageBlock *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::PackageBlock *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "PackageBlock" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::PackageBlock *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::ExternBlock *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::ExternBlock *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "ExternBlock" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::ExternBlock *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::ToplevelBlock *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::ToplevelBlock *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "ToplevelBlock" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::ToplevelBlock *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::HeaderOrMetadata *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::HeaderOrMetadata *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "HeaderOrMetadata" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::HeaderOrMetadata *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Header *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Header *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Header" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Header *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::HeaderStack *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::HeaderStack *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "HeaderStack" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::HeaderStack *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Metadata *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Metadata *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Metadata" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Metadata *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::HeaderRef *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::HeaderRef *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "HeaderRef" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::HeaderRef *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::ConcreteHeaderRef *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::ConcreteHeaderRef *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "ConcreteHeaderRef" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::ConcreteHeaderRef *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::HeaderStackItemRef *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::HeaderStackItemRef *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "HeaderStackItemRef" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::HeaderStackItemRef *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::NamedRef *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::NamedRef *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "NamedRef" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::NamedRef *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::If *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::If *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "If" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::If *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::NamedCond *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::NamedCond *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "NamedCond" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::NamedCond *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Apply *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Apply *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Apply" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Apply *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Primitive *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Primitive *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Primitive" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Primitive *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::FieldList *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::FieldList *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "FieldList" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::FieldList *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::FieldListCalculation *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::FieldListCalculation *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "FieldListCalculation" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::FieldListCalculation *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::CalculatedField *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::CalculatedField *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "CalculatedField" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::CalculatedField *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::CaseEntry *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::CaseEntry *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "CaseEntry" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::CaseEntry *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::V1Parser *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::V1Parser *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "V1Parser" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::V1Parser *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::ParserException *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::ParserException *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "ParserException" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::ParserException *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Attached *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Attached *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Attached" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Attached *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Stateful *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Stateful *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Stateful" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Stateful *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::CounterOrMeter *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::CounterOrMeter *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "CounterOrMeter" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::CounterOrMeter *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Counter *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Counter *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Counter" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Counter *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Meter *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Meter *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Meter" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Meter *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Register *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Register *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Register" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Register *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::PrimitiveAction *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::PrimitiveAction *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "PrimitiveAction" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::PrimitiveAction *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::NameList *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::NameList *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "NameList" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::NameList *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::ActionArg *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::ActionArg *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "ActionArg" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::ActionArg *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::ActionFunction *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::ActionFunction *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "ActionFunction" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::ActionFunction *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::ActionProfile *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::ActionProfile *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "ActionProfile" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::ActionProfile *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::ActionSelector *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::ActionSelector *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "ActionSelector" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::ActionSelector *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::V1Table *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::V1Table *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "V1Table" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::V1Table *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::V1Control *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::V1Control *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "V1Control" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::V1Control *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::V1Program *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::V1Program *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "V1Program" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::V1Program *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::v1HeaderType *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::v1HeaderType *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "v1HeaderType" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::v1HeaderType *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::IntMod *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::IntMod *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "IntMod" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::IntMod *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Tofino::Pipe *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Tofino::Pipe *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Tofino::Pipe" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Tofino::Pipe *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::InstanceRef *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::InstanceRef *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "InstanceRef" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::InstanceRef *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::HeaderSliceRef *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::HeaderSliceRef *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "HeaderSliceRef" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::HeaderSliceRef *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::MAU::Table *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::MAU::Table *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "MAU::Table" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::MAU::Table *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::MAU::TernaryIndirect *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::MAU::TernaryIndirect *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "MAU::TernaryIndirect" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::MAU::TernaryIndirect *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::MAU::ActionData *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::MAU::ActionData *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "MAU::ActionData" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::MAU::ActionData *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::MAU::TableSeq *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::MAU::TableSeq *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "MAU::TableSeq" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::MAU::TableSeq *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::MAU::Instruction *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::MAU::Instruction *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "MAU::Instruction" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::MAU::Instruction *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Tofino::ParserMatch *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Tofino::ParserMatch *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Tofino::ParserMatch" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Tofino::ParserMatch *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Tofino::ParserState *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Tofino::ParserState *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Tofino::ParserState" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Tofino::ParserState *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Tofino::Parser *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Tofino::Parser *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Tofino::Parser" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Tofino::Parser *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Tofino::Deparser *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Tofino::Deparser *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Tofino::Deparser" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Tofino::Deparser *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Vector<IR::Node> *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Vector<IR::Node> *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Vector<IR::Node>" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Vector<IR::Node> *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Vector<IR::Type> *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Vector<IR::Type> *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Vector<IR::Type>" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Vector<IR::Type> *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Vector<IR::StatOrDecl> *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Vector<IR::StatOrDecl> *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Vector<IR::StatOrDecl>" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Vector<IR::StatOrDecl> *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::IndexedVector<IR::StatOrDecl> *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::IndexedVector<IR::StatOrDecl> *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "IndexedVector<IR::StatOrDecl>" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::IndexedVector<IR::StatOrDecl> *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Vector<IR::Declaration> *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Vector<IR::Declaration> *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Vector<IR::Declaration>" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Vector<IR::Declaration> *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Vector<IR::Expression> *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Vector<IR::Expression> *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Vector<IR::Expression>" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Vector<IR::Expression> *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Vector<IR::Annotation> *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Vector<IR::Annotation> *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Vector<IR::Annotation>" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Vector<IR::Annotation> *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Vector<IR::ArgumentInfo> *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Vector<IR::ArgumentInfo> *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Vector<IR::ArgumentInfo>" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Vector<IR::ArgumentInfo> *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Vector<IR::Method> *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Vector<IR::Method> *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Vector<IR::Method>" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Vector<IR::Method> *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Vector<IR::SelectCase> *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Vector<IR::SelectCase> *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Vector<IR::SelectCase>" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Vector<IR::SelectCase> *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Vector<IR::ParserState> *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Vector<IR::ParserState> *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Vector<IR::ParserState>" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Vector<IR::ParserState> *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Vector<IR::ActionListElement> *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Vector<IR::ActionListElement> *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Vector<IR::ActionListElement>" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Vector<IR::ActionListElement> *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Vector<IR::KeyElement> *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Vector<IR::KeyElement> *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Vector<IR::KeyElement>" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Vector<IR::KeyElement> *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Vector<IR::SwitchCase> *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Vector<IR::SwitchCase> *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Vector<IR::SwitchCase>" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Vector<IR::SwitchCase> *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Vector<IR::Primitive> *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Vector<IR::Primitive> *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Vector<IR::Primitive>" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Vector<IR::Primitive> *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Vector<IR::CaseEntry> *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Vector<IR::CaseEntry> *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Vector<IR::CaseEntry>" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Vector<IR::CaseEntry> *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Vector<IR::Attached> *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Vector<IR::Attached> *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Vector<IR::Attached>" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Vector<IR::Attached> *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Vector<IR::MAU::Table> *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Vector<IR::MAU::Table> *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Vector<IR::MAU::Table>" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Vector<IR::MAU::Table> *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); } inline void Visitor::visit(const IR::Vector<IR::Tofino::ParserMatch> *&n, const char *name) { auto t = apply_visitor(n, name); n = dynamic_cast<const IR::Vector<IR::Tofino::ParserMatch> *>(t); if (t && !n) do { throw Util::CompilerBug("../ir/ir-inline.h", 41, "visitor returned non-" "Vector<IR::Tofino::ParserMatch>" " type: %1%", t); } while (0); } inline void Visitor::visit(const IR::Vector<IR::Tofino::ParserMatch> *const &n, const char *name) { visit(static_cast<const IR::Node *const &>(n), name); }


template<class T> void IR::Vector<T>::visit_children(Visitor &v) {
    for (auto i = vec.begin(); i != vec.end();) {
        auto n = v.apply_visitor(*i);
        if (!n) {
            i = erase(i);
        } else if (n == *i) {
            i++;
        } else if (auto l = dynamic_cast<const Vector *>(n)) {
            i = erase(i);
            i = insert(i, l->vec.begin(), l->vec.end());
            i += l->vec.size();
        } else if (auto v = dynamic_cast<const VectorBase *>(n)) {
            if (v->empty()) {
                i = erase(i);
            } else {
                i = insert(i, v->size() - 1, nullptr);
                for (auto el : *v) {
                    if (auto e = dynamic_cast<const T *>(el))
                        *i++ = e;
                    else
                        do { throw Util::CompilerBug("../ir/ir-inline.h", 65, "visitor returned invalid type %s for Vector<%s>", e->node_type_name(), T::static_type_name()); } while (0); } }

        } else if (auto e = dynamic_cast<const T *>(n)) {
            *i++ = e;
        } else {
            do { throw Util::CompilerBug("../ir/ir-inline.h", 70, "visitor returned invalid type %s for Vector<%s>", n->node_type_name(), T::static_type_name()); } while (0); } } }

template<class T> void IR::Vector<T>::visit_children(Visitor &v) const {
    for (auto &a : vec) v.visit(a); }
template<class T> const IR::Vector <T> *IR::Vector <T>::apply(Visitor &v) const { const Vector *tmp = this; auto prof = v.init_apply(tmp); v.visit(tmp); v.end_apply(tmp); return tmp; }

std::ostream &operator<<(std::ostream &out, const IR::Vector<IR::Expression> &v);
inline std::ostream &operator<<(std::ostream &out, const IR::Vector<IR::Expression> *v) {
    return v ? out << *v : out << "<null>"; }

template<class T> void IR::IndexedVector<T>::visit_children(Visitor &v) {
    for (auto i = begin(); i != end();) {
        auto n = v.apply_visitor(*i);
        if (!n) {
            i = erase(i);
        } else if (n == *i) {
            i++;
        } else if (auto l = dynamic_cast<const Vector<T> *>(n)) {
            i = erase(i);
            i = insert(i, l->begin(), l->end());
            i += l->Vector<T>::size();
        } else if (auto e = dynamic_cast<const T *>(n)) {
            *i++ = e;
        } else {
            do { throw Util::CompilerBug("../ir/ir-inline.h", 94, "visitor returned invalid type %s for IndexedVector<%s>", n->node_type_name(), T::static_type_name()); } while (0); } } }

template<class T> void IR::IndexedVector<T>::visit_children(Visitor &v) const {
    for (auto &a : *this) v.visit(a); }
template<class T> const IR::IndexedVector <T> *IR::IndexedVector <T>::apply(Visitor &v) const { const IndexedVector *tmp = this; auto prof = v.init_apply(tmp); v.visit(tmp); v.end_apply(tmp); return tmp; }


template <class MAP> static inline void
namemap_insert_helper(typename MAP::iterator, typename MAP::key_type k,
                      typename MAP::mapped_type v, MAP &, MAP &new_symbols) {
    new_symbols.emplace(std::move(k), std::move(v));
}

template <class MAP, class InputIterator> static inline void
namemap_insert_helper(typename MAP::iterator, InputIterator b, InputIterator e,
                      MAP &, MAP &new_symbols) {
    new_symbols.insert(b, e);
}

template <class T> static inline void
namemap_insert_helper(typename ordered_map<cstring, T>::iterator it, cstring k, T v,
                      ordered_map<cstring, T> &symbols, ordered_map<cstring, T> &) {
    symbols.emplace_hint(it, std::move(k), std::move(v));
}

template <class T, class InputIterator> static inline void
namemap_insert_helper(typename ordered_map<cstring, T>::iterator it,
                      InputIterator b, InputIterator e,
                      ordered_map<cstring, T> &symbols, ordered_map<cstring, T> &) {
    symbols.insert(it, b, e);
}

template<class T, template<class K, class V, class COMP, class ALLOC> class MAP ,
         class COMP ,
         class ALLOC >
void IR::NameMap<T, MAP, COMP, ALLOC>::visit_children(Visitor &v) {
    map_t new_symbols;
    for (auto i = symbols.begin(); i != symbols.end();) {
        auto n = v.apply_visitor(i->second, i->first);
        if (!n) {
            i = symbols.erase(i);
        } else if (n == i->second) {
            i++;
        } else if (auto m = dynamic_cast<const NameMap *>(n)) {
            namemap_insert_helper(i, m->symbols.begin(), m->symbols.end(), symbols, new_symbols);
            i = symbols.erase(i);
        } else if (auto s = dynamic_cast<const T *>(n)) {
            if (match_name(i->first, s)) {
                i->second = s;
                i++;
            } else {
                namemap_insert_helper(i, cstring(obj_name(s)), std::move(s), symbols, new_symbols);
                i = symbols.erase(i); }
        } else {
            do { throw Util::CompilerBug("../ir/ir-inline.h", 148, "visitor returned invalid type %s for NameMap<%s>", n->node_type_name(), T::static_type_name()); } while (0); } }

    symbols.insert(new_symbols.begin(), new_symbols.end()); }
template<class T, template<class K, class V, class COMP, class ALLOC> class MAP ,
         class COMP ,
         class ALLOC >
void IR::NameMap<T, MAP, COMP, ALLOC>::visit_children(Visitor &v) const {
    for (auto &k : symbols) v.visit(k.second, k.first); }

template<class KEY, class VALUE,
         template<class K, class V, class COMP, class ALLOC> class MAP ,
         class COMP ,
         class ALLOC >
void IR::NodeMap<KEY, VALUE, MAP, COMP, ALLOC>::visit_children(Visitor &v) {
    map_t new_symbols;
    for (auto i = symbols.begin(); i != symbols.end();) {
        auto nk = i->first;
        v.visit(nk);
        if (!nk) {
            i = symbols.erase(i);
        } else if (nk == i->first) {
            v.visit(i->second);
            if (i->second)
                ++i;
            else
                i = symbols.erase(i);
        } else {
            auto nv = i->second;
            v.visit(nv);
            if (nv) new_symbols.emplace(nk, nv);
            i = symbols.erase(i); } }
    symbols.insert(new_symbols.begin(), new_symbols.end()); }
template<class KEY, class VALUE,
         template<class K, class V, class COMP, class ALLOC> class MAP ,
         class COMP ,
         class ALLOC >
void IR::NodeMap<KEY, VALUE, MAP, COMP, ALLOC>::visit_children(Visitor &v) const {
    for (auto &k : symbols) { v.visit(k.first); v.visit(k.second); } }
# 34 "../ir/ir.h" 2
# 1 "../ir/dump.h" 1







void dump(std::ostream &out, const IR::Node *n);
void dump(std::ostream &out, const IR::Node *n, unsigned maxdepth);
void dump(const IR::Node *n);
void dump(const IR::Node *n, unsigned maxdepth);
void dump(uintptr_t p);
void dump(uintptr_t p, unsigned maxdepth);
std::string dumpToString(const IR::Node* n);

class Dump {
    const IR::Node *n;
    unsigned maxdepth;
    friend std::ostream &operator<<(std::ostream &, const Dump &);
 public:
    Dump(const IR::Node *n, unsigned maxdepth = ~0U) : n(n), maxdepth(maxdepth) {}
};

inline std::ostream &operator<<(std::ostream &out, const Dump &d) {
    dump(out, d.n, d.maxdepth);
    return out; }
# 35 "../ir/ir.h" 2
# 5 "../frontends/p4/validateParsedProgram.h" 2

namespace P4 {



class ValidateParsedProgram final : public Inspector {
    bool p4v1;
    using Inspector::postorder;

 public:
    explicit ValidateParsedProgram(bool p4v1) : p4v1(p4v1) {}
    void postorder(const IR::Constant* c) override;
    void postorder(const IR::Method* t) override;
    void postorder(const IR::StructField* f) override;
    void postorder(const IR::ParserState* s) override;
    void postorder(const IR::P4Table* t) override;
    void postorder(const IR::Type_Union* type) override;
    void postorder(const IR::Type_Bits* type) override;
    void postorder(const IR::ConstructorCallExpression* expression) override;
    void postorder(const IR::Declaration_Variable* decl) override;
    void postorder(const IR::Declaration_Constant* decl) override;
};

}
# 2 "../frontends/p4/validateParsedProgram.cpp" 2

namespace P4 {

void ValidateParsedProgram::postorder(const IR::Constant* c) {
    if (c->type != nullptr &&
        !c->type->is<IR::Type_Unknown>() &&
        !c->type->is<IR::Type_Bits>() &&
        !c->type->is<IR::Type_InfInt>())
        do { throw Util::CompilerBug("../frontends/p4/validateParsedProgram.cpp", 10, "Invalid type %1% for constant %2%", c->type, c); } while (0);
}

void ValidateParsedProgram::postorder(const IR::Method* m) {
    if (m->name.isDontCare())
        ::error("%1%: Illegal method/function name", m->name);
}

void ValidateParsedProgram::postorder(const IR::StructField* f) {
    if (f->name.isDontCare())
        ::error("%1%: Illegal field name", f->name);
}

void ValidateParsedProgram::postorder(const IR::Type_Union* type) {
    if (type->fields.size() == 0)
        ::error("%1%: empty union", type);
}

void ValidateParsedProgram::postorder(const IR::Type_Bits* type) {
    if (type->size <= 0)
        ::error("%1%: Illegal bit size", type);
    if (type->size == 1 && type->isSigned)
        ::error("%1%: Signed types cannot be 1-bit wide", type);
}

void ValidateParsedProgram::postorder(const IR::ParserState* s) {
    if (s->name == IR::ParserState::accept ||
        s->name == IR::ParserState::reject)
        ::error("%1%: parser state should not be implemented, it is built-in", s->name);
}

void ValidateParsedProgram::postorder(const IR::P4Table* t) {
    auto ac = t->properties->getProperty(IR::TableProperties::actionsPropertyName);
    if (ac == nullptr)
        ::error("Table %1% does not have an `%2%' property",
                t->name, IR::TableProperties::actionsPropertyName);
    auto da = t->properties->getProperty(IR::TableProperties::defaultActionPropertyName);
    if (!p4v1 && da == nullptr)
        ::warning("Table %1% does not have an `%2%' property",
                t->name, IR::TableProperties::defaultActionPropertyName);
}

void ValidateParsedProgram::postorder(const IR::ConstructorCallExpression* expression) {
    auto inAction = findContext<IR::P4Action>();
    if (inAction != nullptr)
        ::error("%1%: Constructor calls not allowed in actions", expression);
}

void ValidateParsedProgram::postorder(const IR::Declaration_Variable* decl) {
    if (decl->name.isDontCare())
        ::error("%1%: illegal variable name", decl);
}

void ValidateParsedProgram::postorder(const IR::Declaration_Constant* decl) {
    if (decl->name.isDontCare())
        ::error("%1%: illegal constant name", decl);
}

}
