<!-- HTML header for doxygen 1.13.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>P4 Compiler Documentation (P4C): TableFormat Struct Reference</title>
<link rel="icon" href="p4-fav.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!--  Add link to paragraphs   -->
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
  DoxygenAwesomeParagraphLink.init()
</script>
<!-- Add copy button to code fragments  -->
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
  DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add dark mode toggle -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
  DoxygenAwesomeDarkModeToggle.init()
</script>
<!-- Add interactive TOC -->
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
  DoxygenAwesomeInteractiveToc.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-interactive-toc.js" rel="stylesheet" type="text/css"/>
<link href="cards.css" rel="stylesheet" type="text/css"/>
<link href="flow.css" rel="stylesheet" type="text/css"/>
<link href="p4c_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="p4-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">P4C
   </div>
   <div id="projectbrief">The P4 Compiler</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('struct_table_format.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="struct_table_format-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">TableFormat Struct Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_table_format_1_1_use.html">Use</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aee911ab89d44d275a847ae03f6e4d7f4" id="r_aee911ab89d44d275a847ae03f6e4d7f4"><td class="memItemLeft" align="right" valign="top"><a id="aee911ab89d44d275a847ae03f6e4d7f4" name="aee911ab89d44d275a847ae03f6e4d7f4"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>type_t</b> { <br />
&#160;&#160;<b>MATCH</b>
, <b>NEXT</b>
, <b>ACTION</b>
, <b>IMMEDIATE</b>
, <br />
&#160;&#160;<b>VERS</b>
, <b>COUNTER</b>
, <b>COUNTER_PFE</b>
, <b>METER</b>
, <br />
&#160;&#160;<b>METER_PFE</b>
, <b>METER_TYPE</b>
, <b>INDIRECT_ACTION</b>
, <b>SEL_LEN_MOD</b>
, <br />
&#160;&#160;<b>SEL_LEN_SHIFT</b>
, <b>VALID</b>
, <b>ENTRY_TYPES</b>
, <b>INTERLEAVED_MATCH</b>
<br />
 }</td></tr>
<tr class="separator:aee911ab89d44d275a847ae03f6e4d7f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abc382439736997a1b3fab48e80f1ce5a" id="r_abc382439736997a1b3fab48e80f1ce5a"><td class="memItemLeft" align="right" valign="top"><a id="abc382439736997a1b3fab48e80f1ce5a" name="abc382439736997a1b3fab48e80f1ce5a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TableFormat</b> (const <a class="el" href="class_layout_option.html">LayoutOption</a> &amp;l, const <a class="el" href="struct_i_x_bar_1_1_use.html">IXBar::Use</a> *mi, const <a class="el" href="struct_i_x_bar_1_1_use.html">IXBar::Use</a> *phi, const IR::MAU::Table *t, const <a class="el" href="class_p4_1_1bitvec.html">bitvec</a> im, bool gl, <a class="el" href="class_find_payload_candidates.html">FindPayloadCandidates</a> &amp;fpc, const <a class="el" href="class_phv_info.html">PhvInfo</a> &amp;phv)</td></tr>
<tr class="separator:abc382439736997a1b3fab48e80f1ce5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18cf389255d0d87c91073cc445ad9b88" id="r_a18cf389255d0d87c91073cc445ad9b88"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18cf389255d0d87c91073cc445ad9b88">find_format</a> (<a class="el" href="struct_table_format_1_1_use.html">Use</a> *u)</td></tr>
<tr class="separator:a18cf389255d0d87c91073cc445ad9b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a69224767f688c97d5bf3bd404c37e" id="r_aa1a69224767f688c97d5bf3bd404c37e"><td class="memItemLeft" align="right" valign="top"><a id="aa1a69224767f688c97d5bf3bd404c37e" name="aa1a69224767f688c97d5bf3bd404c37e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>verify</b> ()</td></tr>
<tr class="separator:aa1a69224767f688c97d5bf3bd404c37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a45dde66e76719c0afd964943c1d91dc2" id="r_a45dde66e76719c0afd964943c1d91dc2"><td class="memItemLeft" align="right" valign="top"><a id="a45dde66e76719c0afd964943c1d91dc2" name="a45dde66e76719c0afd964943c1d91dc2"></a>
static <a class="el" href="struct_table_format.html">TableFormat</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>create</b> (const <a class="el" href="class_layout_option.html">LayoutOption</a> &amp;l, const <a class="el" href="struct_i_x_bar_1_1_use.html">IXBar::Use</a> *mi, const <a class="el" href="struct_i_x_bar_1_1_use.html">IXBar::Use</a> *phi, const IR::MAU::Table *t, const <a class="el" href="class_p4_1_1bitvec.html">bitvec</a> im, bool gl, <a class="el" href="class_find_payload_candidates.html">FindPayloadCandidates</a> &amp;fpc, const <a class="el" href="class_phv_info.html">PhvInfo</a> &amp;phv)</td></tr>
<tr class="separator:a45dde66e76719c0afd964943c1d91dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a432073059ba45f7f36108ec30f9c9014" id="r_a432073059ba45f7f36108ec30f9c9014"><td class="memItemLeft" align="right" valign="top"><a id="a432073059ba45f7f36108ec30f9c9014" name="a432073059ba45f7f36108ec30f9c9014"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>FULL_IMEM_ADDRESS_BITS</b> = 6</td></tr>
<tr class="separator:a432073059ba45f7f36108ec30f9c9014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e6910c0c0c06d3459c5626e453efe8" id="r_ac8e6910c0c0c06d3459c5626e453efe8"><td class="memItemLeft" align="right" valign="top"><a id="ac8e6910c0c0c06d3459c5626e453efe8" name="ac8e6910c0c0c06d3459c5626e453efe8"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>FULL_NEXT_TABLE_BITS</b> = 8</td></tr>
<tr class="separator:ac8e6910c0c0c06d3459c5626e453efe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8906c46832851d37fe08e7944a9e13be" id="r_a8906c46832851d37fe08e7944a9e13be"><td class="memItemLeft" align="right" valign="top"><a id="a8906c46832851d37fe08e7944a9e13be" name="a8906c46832851d37fe08e7944a9e13be"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>GATEWAY_BYTES</b> = 4</td></tr>
<tr class="separator:a8906c46832851d37fe08e7944a9e13be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c3498e76cdbe8796389ea44f4d5b79" id="r_a54c3498e76cdbe8796389ea44f4d5b79"><td class="memItemLeft" align="right" valign="top"><a id="a54c3498e76cdbe8796389ea44f4d5b79" name="a54c3498e76cdbe8796389ea44f4d5b79"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>IMEM_MAP_TABLE_ENTRIES</b> = 8</td></tr>
<tr class="separator:a54c3498e76cdbe8796389ea44f4d5b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853908b24b549a445508765854c3188e" id="r_a853908b24b549a445508765854c3188e"><td class="memItemLeft" align="right" valign="top"><a id="a853908b24b549a445508765854c3188e" name="a853908b24b549a445508765854c3188e"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_GROUPS_PER_LAMB</b> = 4</td></tr>
<tr class="separator:a853908b24b549a445508765854c3188e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfabb19bbb2092ff9d67f48fca0de4d1" id="r_acfabb19bbb2092ff9d67f48fca0de4d1"><td class="memItemLeft" align="right" valign="top"><a id="acfabb19bbb2092ff9d67f48fca0de4d1" name="acfabb19bbb2092ff9d67f48fca0de4d1"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_GROUPS_PER_RAM</b> = 5</td></tr>
<tr class="separator:acfabb19bbb2092ff9d67f48fca0de4d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5646b74ad76b56d8981c7452ac91125" id="r_ab5646b74ad76b56d8981c7452ac91125"><td class="memItemLeft" align="right" valign="top"><a id="ab5646b74ad76b56d8981c7452ac91125" name="ab5646b74ad76b56d8981c7452ac91125"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_SHARED_GROUPS</b> = 2</td></tr>
<tr class="separator:ab5646b74ad76b56d8981c7452ac91125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbabe855fc1b46ab7dfc218ecf963808" id="r_adbabe855fc1b46ab7dfc218ecf963808"><td class="memItemLeft" align="right" valign="top"><a id="adbabe855fc1b46ab7dfc218ecf963808" name="adbabe855fc1b46ab7dfc218ecf963808"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>MID_BYTE_HI</b> = 1</td></tr>
<tr class="separator:adbabe855fc1b46ab7dfc218ecf963808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0490833b17c41b6bb0f4148a996ad2b6" id="r_a0490833b17c41b6bb0f4148a996ad2b6"><td class="memItemLeft" align="right" valign="top"><a id="a0490833b17c41b6bb0f4148a996ad2b6" name="a0490833b17c41b6bb0f4148a996ad2b6"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>MID_BYTE_LO</b> = 0</td></tr>
<tr class="separator:a0490833b17c41b6bb0f4148a996ad2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a79c20812ee40bc05dd9d8c3b672bd4" id="r_a3a79c20812ee40bc05dd9d8c3b672bd4"><td class="memItemLeft" align="right" valign="top"><a id="a3a79c20812ee40bc05dd9d8c3b672bd4" name="a3a79c20812ee40bc05dd9d8c3b672bd4"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>MID_BYTE_VERS</b> = 3</td></tr>
<tr class="separator:a3a79c20812ee40bc05dd9d8c3b672bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad415ae8ca774fcdcd0dbbf96bfc33bca" id="r_ad415ae8ca774fcdcd0dbbf96bfc33bca"><td class="memItemLeft" align="right" valign="top"><a id="ad415ae8ca774fcdcd0dbbf96bfc33bca" name="ad415ae8ca774fcdcd0dbbf96bfc33bca"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>NEXT_MAP_TABLE_ENTRIES</b> = 8</td></tr>
<tr class="separator:ad415ae8ca774fcdcd0dbbf96bfc33bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26bff01fc0b358aea382c7602369e484" id="r_a26bff01fc0b358aea382c7602369e484"><td class="memItemLeft" align="right" valign="top"><a id="a26bff01fc0b358aea382c7602369e484" name="a26bff01fc0b358aea382c7602369e484"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>OVERHEAD_BITS</b> = 64</td></tr>
<tr class="separator:a26bff01fc0b358aea382c7602369e484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9429a84970b51ce37ff95321340c0618" id="r_a9429a84970b51ce37ff95321340c0618"><td class="memItemLeft" align="right" valign="top"><a id="a9429a84970b51ce37ff95321340c0618" name="a9429a84970b51ce37ff95321340c0618"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>RAM_GHOST_BITS</b> = IXBar::RAM_LINE_SELECT_BITS</td></tr>
<tr class="separator:a9429a84970b51ce37ff95321340c0618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f3b7fa84e14c4bf2ffd88aa63d6381" id="r_a92f3b7fa84e14c4bf2ffd88aa63d6381"><td class="memItemLeft" align="right" valign="top"><a id="a92f3b7fa84e14c4bf2ffd88aa63d6381" name="a92f3b7fa84e14c4bf2ffd88aa63d6381"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>SELECTOR_LENGTH_MAX_BIT</b> = 16</td></tr>
<tr class="separator:a92f3b7fa84e14c4bf2ffd88aa63d6381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037ec2db5d12e0f587a1fd6234e98a0b" id="r_a037ec2db5d12e0f587a1fd6234e98a0b"><td class="memItemLeft" align="right" valign="top"><a id="a037ec2db5d12e0f587a1fd6234e98a0b" name="a037ec2db5d12e0f587a1fd6234e98a0b"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>SINGLE_RAM_BITS</b> = 128</td></tr>
<tr class="separator:a037ec2db5d12e0f587a1fd6234e98a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b10d485a0892c081d663d9af59d303" id="r_a84b10d485a0892c081d663d9af59d303"><td class="memItemLeft" align="right" valign="top"><a id="a84b10d485a0892c081d663d9af59d303" name="a84b10d485a0892c081d663d9af59d303"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>SINGLE_RAM_BYTES</b> = 16</td></tr>
<tr class="separator:a84b10d485a0892c081d663d9af59d303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa00cde9ede1438d9ee335f1a66d096a5" id="r_aa00cde9ede1438d9ee335f1a66d096a5"><td class="memItemLeft" align="right" valign="top"><a id="aa00cde9ede1438d9ee335f1a66d096a5" name="aa00cde9ede1438d9ee335f1a66d096a5"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>VERSION_BITS</b> = 4</td></tr>
<tr class="separator:aa00cde9ede1438d9ee335f1a66d096a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31051bd6731215f49a9dc12c273bac89" id="r_a31051bd6731215f49a9dc12c273bac89"><td class="memItemLeft" align="right" valign="top"><a id="a31051bd6731215f49a9dc12c273bac89" name="a31051bd6731215f49a9dc12c273bac89"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>VERSION_BYTES</b> = 14</td></tr>
<tr class="separator:a31051bd6731215f49a9dc12c273bac89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748ae6e62931cbafed383f2d04be4eb1" id="r_a748ae6e62931cbafed383f2d04be4eb1"><td class="memItemLeft" align="right" valign="top"><a id="a748ae6e62931cbafed383f2d04be4eb1" name="a748ae6e62931cbafed383f2d04be4eb1"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>VERSION_NIBBLES</b> = 4</td></tr>
<tr class="separator:a748ae6e62931cbafed383f2d04be4eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a29233c2a2009425d1fb2ffe5103d8654" id="r_a29233c2a2009425d1fb2ffe5103d8654"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29233c2a2009425d1fb2ffe5103d8654">allocate_full_fits</a> (int width_sect, int group=-1)</td></tr>
<tr class="separator:a29233c2a2009425d1fb2ffe5103d8654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43efeaaabe3b10855dcc47ef011bcf33" id="r_a43efeaaabe3b10855dcc47ef011bcf33"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43efeaaabe3b10855dcc47ef011bcf33">allocate_overhead</a> (bool alloc_match=false)</td></tr>
<tr class="separator:a43efeaaabe3b10855dcc47ef011bcf33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8187d45893cccb5d8677685f31bb01" id="r_abf8187d45893cccb5d8677685f31bb01"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf8187d45893cccb5d8677685f31bb01">analyze_layout_option</a> ()</td></tr>
<tr class="separator:abf8187d45893cccb5d8677685f31bb01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcee8d561e64061048a3ff567346ba1a" id="r_adcee8d561e64061048a3ff567346ba1a"><td class="memItemLeft" align="right" valign="top"><a id="adcee8d561e64061048a3ff567346ba1a" name="adcee8d561e64061048a3ff567346ba1a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>bits_necessary</b> (type_t type) const</td></tr>
<tr class="separator:adcee8d561e64061048a3ff567346ba1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f60132fdab33c65d16cfe0ba1c30e4d" id="r_a9f60132fdab33c65d16cfe0ba1c30e4d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f60132fdab33c65d16cfe0ba1c30e4d">choose_ghost_bits</a> (<a class="el" href="class_p4_1_1safe__vector.html">safe_vector</a>&lt; std::pair&lt; <a class="el" href="struct_i_x_bar_1_1_use_1_1_byte.html">IXBar::Use::Byte</a>, <a class="el" href="class_p4_1_1bitvec.html">bitvec</a> &gt; &gt; &amp;potential_ghost)</td></tr>
<tr class="separator:a9f60132fdab33c65d16cfe0ba1c30e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab510bdd0563b14d50ef466552d71ce52" id="r_ab510bdd0563b14d50ef466552d71ce52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab510bdd0563b14d50ef466552d71ce52">fill_out_use</a> (int group, const <a class="el" href="class_p4_1_1safe__vector.html">safe_vector</a>&lt; <a class="el" href="struct_byte_info.html">ByteInfo</a> &gt; &amp;alloced, <a class="el" href="class_p4_1_1bitvec.html">bitvec</a> &amp;version_loc)</td></tr>
<tr class="separator:ab510bdd0563b14d50ef466552d71ce52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8afceb36dc9fce6e2a7163e33a3445e" id="r_ad8afceb36dc9fce6e2a7163e33a3445e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8afceb36dc9fce6e2a7163e33a3445e">get_potential_ghost_byte</a> (const <a class="el" href="struct_i_x_bar_1_1_use_1_1_byte.html">IXBar::Use::Byte</a> byte, const std::map&lt; <a class="el" href="class_p4_1_1cstring.html">cstring</a>, <a class="el" href="class_p4_1_1bitvec.html">bitvec</a> &gt; &amp;hash_masks, <a class="el" href="class_p4_1_1safe__vector.html">safe_vector</a>&lt; std::pair&lt; <a class="el" href="struct_i_x_bar_1_1_use_1_1_byte.html">IXBar::Use::Byte</a>, <a class="el" href="class_p4_1_1bitvec.html">bitvec</a> &gt; &gt; &amp;potential_ghost)</td></tr>
<tr class="separator:ad8afceb36dc9fce6e2a7163e33a3445e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55157f8994c52022ad748c2054d90124" id="r_a55157f8994c52022ad748c2054d90124"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55157f8994c52022ad748c2054d90124">initialize_byte</a> (int byte_offset, int width_sect, const <a class="el" href="struct_byte_info.html">ByteInfo</a> &amp;<a class="el" href="namespace_p4.html#ac88f69b11f3155bdc0cabc0b2d684eb9">info</a>, <a class="el" href="class_p4_1_1safe__vector.html">safe_vector</a>&lt; <a class="el" href="struct_byte_info.html">ByteInfo</a> &gt; &amp;alloced, <a class="el" href="class_p4_1_1bitvec.html">bitvec</a> &amp;byte_attempt, <a class="el" href="class_p4_1_1bitvec.html">bitvec</a> &amp;bit_attempted)</td></tr>
<tr class="separator:a55157f8994c52022ad748c2054d90124"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:af05f67c44600cb996ef06a5f9454b7ac" id="r_af05f67c44600cb996ef06a5f9454b7ac"><td class="memItemLeft" align="right" valign="top"><a id="af05f67c44600cb996ef06a5f9454b7ac" name="af05f67c44600cb996ef06a5f9454b7ac"></a>
<a class="el" href="class_p4_1_1safe__vector.html">safe_vector</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>full_match_groups_per_RAM</b></td></tr>
<tr class="separator:af05f67c44600cb996ef06a5f9454b7ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7815e731869b0642da9cbfa0985e3856" id="r_a7815e731869b0642da9cbfa0985e3856"><td class="memItemLeft" align="right" valign="top"><a id="a7815e731869b0642da9cbfa0985e3856" name="a7815e731869b0642da9cbfa0985e3856"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ghost_bits_count</b> = 0</td></tr>
<tr class="separator:a7815e731869b0642da9cbfa0985e3856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991ab63aac5d3f3ef9e65cd03f2415b4" id="r_a991ab63aac5d3f3ef9e65cd03f2415b4"><td class="memItemLeft" align="right" valign="top"><a id="a991ab63aac5d3f3ef9e65cd03f2415b4" name="a991ab63aac5d3f3ef9e65cd03f2415b4"></a>
<a class="el" href="class_p4_1_1safe__vector.html">safe_vector</a>&lt; <a class="el" href="struct_byte_info.html">ByteInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ghost_bytes</b></td></tr>
<tr class="separator:a991ab63aac5d3f3ef9e65cd03f2415b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae636a7869585b95637f8fff402e5d8c" id="r_aae636a7869585b95637f8fff402e5d8c"><td class="memItemLeft" align="right" valign="top"><a id="aae636a7869585b95637f8fff402e5d8c" name="aae636a7869585b95637f8fff402e5d8c"></a>
<a class="el" href="class_p4_1_1bitvec.html">bitvec</a>&#160;</td><td class="memItemRight" valign="bottom"><b>interleaved_match_byte_use</b></td></tr>
<tr class="separator:aae636a7869585b95637f8fff402e5d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b0ca4c120dd6195e0e1001f5af14f1" id="r_a42b0ca4c120dd6195e0e1001f5af14f1"><td class="memItemLeft" align="right" valign="top"><a id="a42b0ca4c120dd6195e0e1001f5af14f1" name="a42b0ca4c120dd6195e0e1001f5af14f1"></a>
const <a class="el" href="class_layout_option.html">LayoutOption</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>layout_option</b></td></tr>
<tr class="separator:a42b0ca4c120dd6195e0e1001f5af14f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab53ae17135ce7899ef38109464747b" id="r_adab53ae17135ce7899ef38109464747b"><td class="memItemLeft" align="right" valign="top"><a id="adab53ae17135ce7899ef38109464747b" name="adab53ae17135ce7899ef38109464747b"></a>
<a class="el" href="class_p4_1_1bitvec.html">bitvec</a>&#160;</td><td class="memItemRight" valign="bottom"><b>match_byte_use</b></td></tr>
<tr class="separator:adab53ae17135ce7899ef38109464747b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5318d6c4be5d89338d6596a0712304" id="r_a7c5318d6c4be5d89338d6596a0712304"><td class="memItemLeft" align="right" valign="top"><a id="a7c5318d6c4be5d89338d6596a0712304" name="a7c5318d6c4be5d89338d6596a0712304"></a>
<a class="el" href="class_p4_1_1safe__vector.html">safe_vector</a>&lt; <a class="el" href="struct_byte_info.html">ByteInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>match_bytes</b></td></tr>
<tr class="separator:a7c5318d6c4be5d89338d6596a0712304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3fd81b03e6107fa488ffb573026457" id="r_a3c3fd81b03e6107fa488ffb573026457"><td class="memItemLeft" align="right" valign="top"><a id="a3c3fd81b03e6107fa488ffb573026457" name="a3c3fd81b03e6107fa488ffb573026457"></a>
const <a class="el" href="struct_i_x_bar_1_1_use.html">IXBar::Use</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>match_ixbar</b></td></tr>
<tr class="separator:a3c3fd81b03e6107fa488ffb573026457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de337396d640474f95a13ec7d826e48" id="r_a6de337396d640474f95a13ec7d826e48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p4_1_1safe__vector.html">safe_vector</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6de337396d640474f95a13ec7d826e48">overhead_groups_per_RAM</a></td></tr>
<tr class="memdesc:a6de337396d640474f95a13ec7d826e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Which RAM sections contain the match groups.  <br /></td></tr>
<tr class="separator:a6de337396d640474f95a13ec7d826e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcdb2b601e3245531ff065334b2bbd8f" id="r_adcdb2b601e3245531ff065334b2bbd8f"><td class="memItemLeft" align="right" valign="top"><a id="adcdb2b601e3245531ff065334b2bbd8f" name="adcdb2b601e3245531ff065334b2bbd8f"></a>
<a class="el" href="class_p4_1_1safe__vector.html">safe_vector</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>search_bus_per_width</b></td></tr>
<tr class="memdesc:adcdb2b601e3245531ff065334b2bbd8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifically which search bus coordinates to which RAM. <br /></td></tr>
<tr class="separator:adcdb2b601e3245531ff065334b2bbd8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5769ac77a407c47c1aaf9267c7551d" id="r_aba5769ac77a407c47c1aaf9267c7551d"><td class="memItemLeft" align="right" valign="top"><a id="aba5769ac77a407c47c1aaf9267c7551d" name="aba5769ac77a407c47c1aaf9267c7551d"></a>
<a class="el" href="class_p4_1_1safe__vector.html">safe_vector</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>shared_groups_per_RAM</b></td></tr>
<tr class="separator:aba5769ac77a407c47c1aaf9267c7551d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9491b073342526cdcd5894bc91298ac8" id="r_a9491b073342526cdcd5894bc91298ac8"><td class="memItemLeft" align="right" valign="top"><a id="a9491b073342526cdcd5894bc91298ac8" name="a9491b073342526cdcd5894bc91298ac8"></a>
<a class="el" href="class_p4_1_1safe__vector.html">safe_vector</a>&lt; <a class="el" href="struct_i_x_bar_1_1_use_1_1_byte.html">IXBar::Use::Byte</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>single_match</b></td></tr>
<tr class="separator:a9491b073342526cdcd5894bc91298ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611c4c8f7699f57ac69066ecdd00fec1" id="r_a611c4c8f7699f57ac69066ecdd00fec1"><td class="memItemLeft" align="right" valign="top"><a id="a611c4c8f7699f57ac69066ecdd00fec1" name="a611c4c8f7699f57ac69066ecdd00fec1"></a>
const IR::MAU::Table *&#160;</td><td class="memItemRight" valign="bottom"><b>tbl</b></td></tr>
<tr class="separator:a611c4c8f7699f57ac69066ecdd00fec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4340d5c2d6e7256f5d0837b448374565" id="r_a4340d5c2d6e7256f5d0837b448374565"><td class="memItemLeft" align="right" valign="top"><a id="a4340d5c2d6e7256f5d0837b448374565" name="a4340d5c2d6e7256f5d0837b448374565"></a>
<a class="el" href="class_p4_1_1bitvec.html">bitvec</a>&#160;</td><td class="memItemRight" valign="bottom"><b>total_use</b></td></tr>
<tr class="separator:a4340d5c2d6e7256f5d0837b448374565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c529f8b067e7c94f66a6838c305b47a" id="r_a8c529f8b067e7c94f66a6838c305b47a"><td class="memItemLeft" align="right" valign="top"><a id="a8c529f8b067e7c94f66a6838c305b47a" name="a8c529f8b067e7c94f66a6838c305b47a"></a>
<a class="el" href="struct_table_format_1_1_use.html">Use</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>use</b> = nullptr</td></tr>
<tr class="separator:a8c529f8b067e7c94f66a6838c305b47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a29233c2a2009425d1fb2ffe5103d8654" name="a29233c2a2009425d1fb2ffe5103d8654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29233c2a2009425d1fb2ffe5103d8654">&#9670;&#160;</a></span>allocate_full_fits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TableFormat::allocate_full_fits </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>width_sect</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>group</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a number of overhead entries, this algorithm determines how many match groups can fully fit into that particular RAM. It both allocates match and version, as both of those have to be placed in order for the entry to fit.</p>
<p>For wide matches, this ensures that the entirety of the search bus is placed, but not necessarily version, as version can be placed in any of the wide match sections. </p>

</div>
</div>
<a id="a43efeaaabe3b10855dcc47ef011bcf33" name="a43efeaaabe3b10855dcc47ef011bcf33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43efeaaabe3b10855dcc47ef011bcf33">&#9670;&#160;</a></span>allocate_overhead()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TableFormat::allocate_overhead </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>alloc_match</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocate all overhead data that could head to match central. This includes the following information, if needed:</p><ol type="1">
<li>Next table, if the table has multiple next table choices and cannot be specified by the action alone</li>
<li>Instruction selection, the bits to indicate which action is to be run.</li>
<li>Indirect Pointers: addresses for indirect tables, such as counters, meters, action, etc. These needs are specified by the program</li>
<li>Immediate: Action data that is stored with the match rather than in a separate action data table.</li>
</ol>
<p>The current algorithm just packs as close to the bottom as it can, and does not leave any holes to put match data in. This could be optimized to pack match data. </p>

</div>
</div>
<a id="abf8187d45893cccb5d8677685f31bb01" name="abf8187d45893cccb5d8677685f31bb01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf8187d45893cccb5d8677685f31bb01">&#9670;&#160;</a></span>analyze_layout_option()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TableFormat::analyze_layout_option </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The goal of this code is to determine how to initial divide up the match data and the overhead, and which RAM correspond to which input xbar group.</p>
<p>If you look at section 6.2.3 Exact Match Row Vertical/Horizontal (VH) Xbars, one can the inputs to an individual RAM line. There are two search buses per line, which themselves are 128 bits wide, the same as an individual RAM row. Each search bus can select from one of 8 crossbar groups that come from the input crossbar. Thus, the number of input xbars groups needed is the number of search buses needed. (This is not entirely true, as in ATCAM a single xbar bytes is actually in multiple places on the RAM. This information is tracked through the search_bus field in each IXBar::Byte)</p>
<p>Thus the algorithm is divided into two types, skinny and wide. Skinny means that only one search bus is required, while wide means multiple search buses are required.</p>
<p>The analyze option assigns both a number of overhead entries per RAM as well as a search bus assigned to each width. Thus only bytes with that search_bus value can be found at that particular location. </p>

</div>
</div>
<a id="a9f60132fdab33c65d16cfe0ba1c30e4d" name="a9f60132fdab33c65d16cfe0ba1c30e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f60132fdab33c65d16cfe0ba1c30e4d">&#9670;&#160;</a></span>choose_ghost_bits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TableFormat::choose_ghost_bits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p4_1_1safe__vector.html">safe_vector</a>&lt; std::pair&lt; <a class="el" href="struct_i_x_bar_1_1_use_1_1_byte.html">IXBar::Use::Byte</a>, <a class="el" href="class_p4_1_1bitvec.html">bitvec</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>potential_ghost</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Ghost bits are bits that are used in the hash to find the location of the entry, but are not contained within the match. It is an optimization to save space on match bits.</p>
<p>The number of bits one can ghost is the minimum number of bits used to select a RAM row and a RAM on the hash bus. One automatically gets 10 bits, for the 10 bits of hash that determines the RAM row. Extra bits can be ghosted by the log2size of the minimum way.</p>
<p>This algorithm chooses which bits to ghost. If the match requires multiple search buses then the search bus which is going to have the overhead is preferred. Match requirements that don't require the full byte are preferred over bytes that require the full 8 bits. That way, the algorithm can eliminate more match bytes.</p>
<p>For examples, say the match has the following, which were all in separate PHV containers: 3 3 bit fields 1 1 bit field 4 8 bit fields</p>
<p>It would be optimal to ghost off the 3 3 bit fields, and the 1 bit fields, as it would remove 4 total PHV bytes to match on. </p><pre class="fragment">      Ghost bits selection now considers the mask specified with the @hash_mask
      annotation: bits that are masked off through the annotation are not selected
      to be part of ghost bits.
</pre> 
</div>
</div>
<a id="ab510bdd0563b14d50ef466552d71ce52" name="ab510bdd0563b14d50ef466552d71ce52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab510bdd0563b14d50ef466552d71ce52">&#9670;&#160;</a></span>fill_out_use()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TableFormat::fill_out_use </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1safe__vector.html">safe_vector</a>&lt; <a class="el" href="struct_byte_info.html">ByteInfo</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>alloced</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1bitvec.html">bitvec</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>version_loc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This fills out the use object, as well as the global structures for keeping track of the format. This does this for both match and version information. </p>

</div>
</div>
<a id="a18cf389255d0d87c91073cc445ad9b88" name="a18cf389255d0d87c91073cc445ad9b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18cf389255d0d87c91073cc445ad9b88">&#9670;&#160;</a></span>find_format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TableFormat::find_format </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_table_format_1_1_use.html">Use</a> *</td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The algorithm find_format is to determine how to best pack the RAMs of match tables. * For any table using SRAMs only (i.e. exact match/atcam), this means determining how the RAM line is filled. For tables using the TCAMs, (i.e. ternary), this is specifically for the ternary indirect packing.</p>
<p>The RAM is packed with two classes of information, match data and overhead. Match data is anything that is to be directly compared with packet data. Overhead is everything else. Overhead consists of anything that could go to match central as well as version bits.</p>
<p>When an entry hits within a table, the lower 64 bits of the RAM (or in the case of a wide match, one of the RAMs), are sent to match central for further processing. Thus any information that is needed by match central for later processing is considered overhead, and must fit within the lower 64 bits.</p>
<p>The exception to the previous paragraph is what we call version bits. These are bits that are matched not as part of the packet, but as a way to ensure that an entry is valid, and that all data is atomically written into the RAM. Version bits are then appended on before the match, and thus can be anywhere within the RAM line.</p>
<p>Data from the packet comes in through the input xbar. The algorithm is as follows.</p><ol type="1">
<li>Analyze the estimate and calculate initial set up information based on the input xbar allocation and the estimate.</li>
<li>Allocate all overhead that is not version bits</li>
<li>Allocate all match and version bits.</li>
<li>Verify that the algorithm works.</li>
</ol>
<p>The constraints for these individual pieces will be described above the function which are part of the algorithm.</p>
<p>FIXME: Noted weaknesses in the algorithm to address in the future:</p><ol type="1">
<li>Ghost bits could be worked in with overhead, so that holes in overhead could be filled with match data. Glass currently does not do this, so no support necessary yet. </li>
</ol>

</div>
</div>
<a id="ad8afceb36dc9fce6e2a7163e33a3445e" name="ad8afceb36dc9fce6e2a7163e33a3445e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8afceb36dc9fce6e2a7163e33a3445e">&#9670;&#160;</a></span>get_potential_ghost_byte()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TableFormat::get_potential_ghost_byte </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_i_x_bar_1_1_use_1_1_byte.html">IXBar::Use::Byte</a></td>          <td class="paramname"><span class="paramname"><em>byte</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="class_p4_1_1cstring.html">cstring</a>, <a class="el" href="class_p4_1_1bitvec.html">bitvec</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>hash_masks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1safe__vector.html">safe_vector</a>&lt; std::pair&lt; <a class="el" href="struct_i_x_bar_1_1_use_1_1_byte.html">IXBar::Use::Byte</a>, <a class="el" href="class_p4_1_1bitvec.html">bitvec</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>potential_ghost</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds the specified byte along with its mask to vector potential_ghost.</p>
<p>The mask originates from the @hash_mask() annotation specified with the match key in the P4 code. Bits that are masked off by @hash_mask() are excluded from the list of ghost bits candidates.</p>
<p>When @hash_mask() is not specified, the mask is set to byte.bit_use, allowing all bits to be candidates for ghost bits selection. </p>

</div>
</div>
<a id="a55157f8994c52022ad748c2054d90124" name="a55157f8994c52022ad748c2054d90124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55157f8994c52022ad748c2054d90124">&#9670;&#160;</a></span>initialize_byte()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TableFormat::initialize_byte </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>byte_offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>width_sect</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_byte_info.html">ByteInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>info</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1safe__vector.html">safe_vector</a>&lt; <a class="el" href="struct_byte_info.html">ByteInfo</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>alloced</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1bitvec.html">bitvec</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>byte_attempt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1bitvec.html">bitvec</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bit_attempt</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save information on a byte by byte basis so that fill out use can correctly be used. Note that each individual byte from PHV requires an individual byte in the match format, and cannot be reused by a separate entry. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a6de337396d640474f95a13ec7d826e48" name="a6de337396d640474f95a13ec7d826e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de337396d640474f95a13ec7d826e48">&#9670;&#160;</a></span>overhead_groups_per_RAM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p4_1_1safe__vector.html">safe_vector</a>&lt;int&gt; TableFormat::overhead_groups_per_RAM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Which RAM sections contain the match groups. </p>
<p>Which RAM sections contain overhead info </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="struct_table_format.html">TableFormat</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
