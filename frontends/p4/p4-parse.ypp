/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

%{ /* -*-C++-*- */
// some of these includes are needed by lex-generated file
// which is #included below (p4-lex.c)

#include <assert.h>
#include <limits.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>

#include <iostream>
#include <map>
#include <cerrno>

#include "lib/null.h"
#include "lib/error.h"
#include "lib/cstring.h"
#include "lib/gmputil.h"
#include "frontends/p4-14/p4-14-parse.h"
#include "lib/exceptions.h"
#include "lib/source_file.h"
#include "frontends/p4/symbol_table.h"
#include "frontends/common/constantParsing.h"

#undef PACKAGE  // autoconf wants to define this macro that we want to use as a token

#ifndef YYDEBUG
#define YYDEBUG 1
#endif

#define YYLTYPE Util::SourceInfo
#define YYLLOC_DEFAULT(Cur, Rhs, N)                                     \
    ((Cur) = (N) ? YYRHSLOC(Rhs, 1) + YYRHSLOC(Rhs, N)                  \
                 : Util::SourceInfo(YYRHSLOC(Rhs, 0).getEnd()))

// Program IR built here
static IR::IndexedVector<IR::Node> *declarations;
static void yyerror(const char *fmt, ...);
static void checkShift(Util::SourceInfo f, Util::SourceInfo r);

static Util::ProgramStructure structure;

namespace {  // anonymous namespace
static int yylex();

%}

%union {
    YYSTYPE() {}
    IR::IndexedVector<IR::Type_Var>       *nm;
    IR::IndexedVector<IR::Parameter>      *params;
    IR::IndexedVector<IR::StatOrDecl>     *statOrDecls;
    IR::IndexedVector<IR::Declaration>    *decls;
    IR::IndexedVector<IR::ParserState>    *parserStates;
    IR::IndexedVector<IR::StructField>    *structFields;
    IR::IndexedVector<IR::TableProperty>  *properties;
    IR::IndexedVector<IR::Declaration_ID> *ids;
    IR::IndexedVector<IR::ActionListElement> *actions;
    IR::Vector<IR::Annotation>  *annoVec;
    IR::Vector<IR::Expression>  *exprs;
    IR::Vector<IR::SelectCase>  *selectCases;
    IR::Vector<IR::SwitchCase>  *switchCases;
    IR::Vector<IR::Type>        *types;
    IR::Vector<IR::Method>      *methods;
    IR::Vector<IR::KeyElement>  *keyElements;
    IR::ID*                     id;
    cstring                     str;
    bool                        b;
    const IR::Type              *TypePtr;
    IR::Node                    *Node;
    IR::Annotations             *annos;
    IR::StringLiteral           *strlit;
    IR::ActionListElement       *ActionListElement;
    IR::Annotation              *Annotation;
    IR::BlockStatement          *BlockStatement;
    IR::Constant                *Constant;
    IR::Declaration             *Declaration;
    IR::Direction               dir;
    IR::Expression              *Expression;
    IR::IDeclaration            *decl;
    IR::KeyElement              *KeyElement;
    IR::Method                  *Method;
    IR::Function                *Function;
    IR::Parameter               *Parameter;
    IR::ParserState             *ParserState;
    IR::PathPrefix              *PathPrefix;
    IR::SelectCase              *SelectCase;
    IR::Statement               *Statement;
    IR::StatOrDecl              *StatOrDecl;
    IR::StructField             *StructField;
    IR::SwitchCase              *SwitchCase;
    IR::TableProperty           *TableProperty;
    IR::Type_Control            *Type_Control;
    IR::Type_Declaration        *Type_Declaration;
    IR::Type_Name               *Type_Name;
    IR::TypeParameters          *TypeParameters;
    IR::Type_Parser             *Type_Parser;
}

%token      LE GE SHL AND OR NE EQ
%token      TRUE FALSE THIS
%token      ABSTRACT ACTION ACTIONS APPLY BOOL BIT CONST CONTROL DATA
            DEFAULT DONTCARE ELSE ENUM T_ERROR  // There is an ERROR macro elsewhere
            EXIT EXTERN HEADER HEADER_UNION IF IN INOUT INT KEY MASK SELECT MATCH_KIND OUT
            PACKAGE PARSER RANGE RETURN STATE STRUCT SWITCH TABLE TRANSITION
            TUPLE TYPEDEF VARBIT VOID
%token<str> IDENTIFIER TYPE NAMESPACE STRING_LITERAL
%token<Constant>  INTEGER

%type<id>               name
%type<dir>              direction
%type<nm>               typeParameterList
%type<TypeParameters>   optTypeParameters
%type<Expression>       expression lvalue
                        keysetExpression selectExpression stateExpression optInitializer initializer
                        argument simpleKeysetExpression transitionStatement switchLabel
%type<PathPrefix>       pathPrefix relativePathPrefix nonEmptyRelativePathPrefix
%type<TypePtr>          baseType typeOrVoid specializedType headerStackType typeRef tupleType typeArg
%type<Type_Name>        typeName
%type<Parameter>        parameter
%type<annos>            optAnnotations
%type<annoVec>          annotations
%type<Annotation>       annotation
%type<params>           parameterList nonEmptyParameterList optConstructorParameters
%type<exprs>            argumentList nonEmptyArgList expressionList simpleExpressionList
                        tupleKeysetExpression
%type<ids>              identifierList
%type<id>               member
%type<SelectCase>       selectCase
%type<selectCases>      selectCaseList
%type<Statement>        statement emptyStatement returnStatement switchStatement exitStatement
                        assignmentOrMethodCallStatement conditionalStatement
%type<BlockStatement>   blockStatement controlBody objInitializer
%type<StatOrDecl>       statementOrDeclaration parserStatement
%type<statOrDecls>      objDeclarations statOrDeclList parserStatements
%type<SwitchCase>       switchCase
%type<switchCases>      switchCases
%type<types>            typeArgumentList
%type<ParserState>      parserState
%type<parserStates>     parserStates
%type<Declaration>      constantDeclaration actionDeclaration variableDeclaration
                        instantiation functionDeclaration objDeclaration
                        tableDeclaration controlLocalDeclaration parserLocalElement
%type<Type_Declaration> headerTypeDeclaration structTypeDeclaration headerUnionDeclaration
                        derivedTypeDeclaration parserDeclaration
                        controlDeclaration enumDeclaration typedefDeclaration
                        packageTypeDeclaration typeDeclaration
%type<Node>             errorDeclaration declaration externDeclaration matchKindDeclaration
%type<Type_Parser>      parserTypeDeclaration
%type<Type_Control>     controlTypeDeclaration
%type<decls>            parserLocalElements controlLocalDeclarations
%type<StructField>      structField
%type<structFields>     structFieldList
%type<Method>           methodPrototype functionPrototype
%type<methods>          methodPrototypes
%type<TableProperty>    tableProperty
%type<properties>       tablePropertyList
%type<KeyElement>       keyElement
%type<keyElements>      keyElementList
%type<ActionListElement> actionRef
%type<actions>          actionList

%error-verbose
%locations

%left ','
%nonassoc '?'
%nonassoc ':'
%left OR
%left AND
%left '|'
%left '^'
%left '&'
%left EQ NE
%left '<' '>' LE GE
%left SHL
%left PP
%left '+' '-'
%left '*' '/' '%'
%right PREFIX
%nonassoc ']' '(' '['
%left '.'

%right THEN ELSE /* THEN is a fake token */

%{
static void
symbol_print(FILE* file, int type, YYSTYPE value)
{
    switch (type)
    {
    case IDENTIFIER:
    case DONTCARE:
    case TYPE:
    case NAMESPACE:
        fprintf(file, "%s", value.str.c_str());
    default:
        break;
    }
}

#define YYPRINT(file, type, value)   symbol_print(file, type, value)
%}

%%

/*
   This grammar may look weird in some places, but a lot of effort was
   put into eliminating conflics.  This sometimes required having the
   grammar be more lenient than necessary.  Moreover, the grammar is
   context-sensitive, and it needs some rudiments of type information
   to properly perform parsing.  This is done with the help of the
   "structure" object, which keeps track which identifiers represent
   types, and which represent namespaces.
*/

input
    : /* epsilon */
    | input declaration       { declarations->push_back($2->getNode()); }
    | input ';'               {}   // empty declaration
    ;

declaration
    : constantDeclaration     { $$ = $1; }
    | externDeclaration       { $$ = $1; }
    | actionDeclaration       { $$ = $1; }
    | parserDeclaration       { $$ = $1; }
    | typeDeclaration         { $$ = $1; }
    | controlDeclaration      { $$ = $1; }
    | instantiation           { $$ = $1; }
    | errorDeclaration        { $$ = $1; }
    | matchKindDeclaration    { $$ = $1; }
    ;

name
    : IDENTIFIER  { $$ = new IR::ID(@1, $1); }
    | APPLY       { $$ = new IR::ID(@1, "apply"); }
    | KEY         { $$ = new IR::ID(@1, "key"); }
    | ACTIONS     { $$ = new IR::ID(@1, "actions"); }
    | STATE       { $$ = new IR::ID(@1, "state"); }
    ;

optAnnotations
    : /* empty */ { $$ = IR::Annotations::empty; }
    | annotations { $$ = new IR::Annotations(@1, $1); }
    ;

annotations
    : annotation  { $$ = new IR::Vector<IR::Annotation>(); $$->push_back($1); }
    | annotations annotation { $$ = $1; $$->push_back($2); }
    ;

annotation
    : '@' name                        { $$ = new IR::Annotation(@1, *$2, nullptr); }
    | '@' name '(' expression ')'     { $$ = new IR::Annotation(@1, *$2, $4); }
    ;

parameterList
    : /* empty */                        { $$ = new IR::IndexedVector<IR::Parameter>(); }
    | nonEmptyParameterList              { $$ = $1; }
    ;

nonEmptyParameterList
    : parameter                           { $$ = new IR::IndexedVector<IR::Parameter>();
                                            $$->push_back($1); }
    | nonEmptyParameterList ',' parameter { $$ = $1; $$->push_back($3); }
    ;

parameter
    : optAnnotations direction typeRef name { $$ = new IR::Parameter(@4, *$4, $1, $2, $3); }
    ;

direction
    : IN           { $$ = IR::Direction::In; }
    | OUT          { $$ = IR::Direction::Out; }
    | INOUT        { $$ = IR::Direction::InOut; }
    | /* empty */  { $$ = IR::Direction::None; }
    ;

packageTypeDeclaration
    : optAnnotations PACKAGE name { structure.pushContainerType(*$3, false); }
      optTypeParameters { structure.declareTypes($5->parameters); }
      '(' parameterList ')'                { auto pl = new IR::ParameterList(@8, $8);
                                             $$ = new IR::Type_Package(@3, *$3, $1, $5, pl); }
    ;

instantiation
      : annotations typeRef '(' argumentList ')' name ';'
                     { $$ = new IR::Declaration_Instance(@6, *$6, new IR::Annotations($1),
                                                         $2, $4, nullptr); }
      | typeRef '(' argumentList ')' name ';'
                     { $$ = new IR::Declaration_Instance(@5, *$5, IR::Annotations::empty,
                                                         $1, $3, nullptr); }
      | annotations typeRef '(' argumentList ')' name '=' objInitializer ';'
                     { $$ = new IR::Declaration_Instance(@6, *$6, new IR::Annotations($1),
                                                         $2, $4, $8); }
      | typeRef '(' argumentList ')' name '=' objInitializer ';'
                     { $$ = new IR::Declaration_Instance(@5, *$5, IR::Annotations::empty,
                                                         $1, $3, $7); }
    ;

/* experimental */
objInitializer
    : '{' objDeclarations '}'  { $$ = new IR::BlockStatement(@1+@3, IR::Annotations::empty, $2); }
    ;

objDeclarations
    : /* empty */              { $$ = new IR::IndexedVector<IR::StatOrDecl>(); }
    | objDeclarations objDeclaration { $$ = $1; $1->push_back($2); }
    ;

objDeclaration
    : functionDeclaration      { $$ = $1; }
    | instantiation            { $$ = $1; }
    ;

optConstructorParameters
    : /* empty */              { $$ = new IR::IndexedVector<IR::Parameter>(); }
    | '(' parameterList ')'    { $$ = $2; }
    ;

pathPrefix
    : '.' { structure.startAbsolutePath(); } relativePathPrefix
                               { structure.clearPath(); $$ = $3; $$->setAbsolute(); }
    | { structure.startRelativePath(); } nonEmptyRelativePathPrefix
                               { structure.clearPath(); $$ = $2; }
    ;

relativePathPrefix
    : /* empty */ { $$ = new IR::PathPrefix(); }
    | relativePathPrefix NAMESPACE '.' { structure.pathAppendNamespace($2);
                                         $$ = new IR::PathPrefix(@1 + @3, $1, IR::ID(@2, $2)); }
    ;

nonEmptyRelativePathPrefix
    : relativePathPrefix NAMESPACE '.' { structure.pathAppendNamespace($2);
                                         $$ = new IR::PathPrefix(@1 + @3, $1, IR::ID(@2, $2)); }
    ;

/**************************** PARSER ******************************/

parserDeclaration
    : parserTypeDeclaration optConstructorParameters
      '{' parserLocalElements parserStates '}'
                             { structure.pop();
                               auto pl = new IR::ParameterList(@2, $2);
                               $$ = new IR::P4Parser($1->name.srcInfo, $1->name,
                                                     $1, pl, $4, $5);}
    ;

parserLocalElements
    : /* empty */                     { $$ = new IR::IndexedVector<IR::Declaration>(); }
    | parserLocalElements parserLocalElement { $$ = $1; $$->push_back($2); }
    ;

parserLocalElement
    : constantDeclaration             { $$ = $1; }
    | instantiation                   { $$ = $1; }
    | variableDeclaration             { $$ = $1; }
    ;

parserTypeDeclaration
    : optAnnotations PARSER name      { structure.pushContainerType(*$3, false); }
                            optTypeParameters { structure.declareTypes($5->parameters); }
                            '(' parameterList ')'
                                      { auto pl = new IR::ParameterList(@8, $8);
                                        $$ = new IR::Type_Parser(@3, *$3, $1, $5, pl); }
    ;

parserStates
    : parserState                     { $$ = new IR::IndexedVector<IR::ParserState>();
                                        $$->push_back($1); }
    | parserStates parserState        { $$ = $1; $$->push_back($2); }
    ;

parserState
    : optAnnotations STATE name '{' parserStatements transitionStatement '}'
                                      { $$ = new IR::ParserState(@3, *$3, $1, $5, $6); }
    ;

parserStatements
    : /* empty */                     { $$ = new IR::IndexedVector<IR::StatOrDecl>(); }
    | parserStatements parserStatement { $$ = $1; $1->push_back($2); }
    ;

parserStatement
    : assignmentOrMethodCallStatement { $$ = $1; }
    | variableDeclaration             { $$ = $1; }
    ;

transitionStatement
    : /* empty */                 { $$ = nullptr; }
    | TRANSITION stateExpression  { $$ = $2; }
    ;

stateExpression
    : name ';'   { $$ = new IR::PathExpression(*$1); }
    | selectExpression  { $$ = $1; }
    ;

selectExpression
    : SELECT '(' expressionList ')' '{' selectCaseList '}'
                              { $$ = new IR::SelectExpression(@1 + @7,
                                      new IR::ListExpression(@3, $3), std::move(*$6)); }
    ;

selectCaseList
    : selectCase                 { $$ = new IR::Vector<IR::SelectCase>(); $$->push_back($1); }
    | selectCaseList selectCase  { $$ = $1; $$->push_back($2); }
    ;

selectCase
    : keysetExpression ':' name ';' { auto expr = new IR::PathExpression(*$3);
                                      $$ = new IR::SelectCase(@1 + @3, $1, expr); }
    ;

keysetExpression
    : tupleKeysetExpression     { $$ = new IR::ListExpression(@1, $1); }
    | simpleKeysetExpression    { $$ = $1; }
    ;

tupleKeysetExpression
    /* at least two elements in the tuple */
    : '(' simpleKeysetExpression ',' simpleExpressionList ')'
                                { $$ = $4; $4->insert($4->begin(), $2); }
    ;

simpleExpressionList
    : simpleKeysetExpression { $$ = new IR::Vector<IR::Expression>(); $$->push_back($1); }
    | simpleExpressionList ',' simpleKeysetExpression { $$ = $1; $$->push_back($3); }
    ;

simpleKeysetExpression
    : expression                  { $$ = $1; }
    | expression MASK expression  { $$ = new IR::Mask(@1 + @3, $1, $3); }
    | expression RANGE expression { $$ = new IR::Range(@1 + @3, $1, $3); }
    | DEFAULT                     { $$ = new IR::DefaultExpression(@1); }
    ;

/*************************** CONTROL ************************/

controlDeclaration
    : controlTypeDeclaration optConstructorParameters
      '{' controlLocalDeclarations APPLY controlBody '}'
                            { structure.pop();
                              auto pl = new IR::ParameterList(@2, $2);
                              $$ = new IR::P4Control($1->name.srcInfo, $1->name, $1, pl, $4, $6); }
    ;

controlTypeDeclaration
    : optAnnotations CONTROL name { structure.pushContainerType(*$3, false); }
                            optTypeParameters { structure.declareTypes($5->parameters); }
                            '(' parameterList ')'
                              { auto pl = new IR::ParameterList(@8, $8);
                                $$ = new IR::Type_Control(@3, *$3, $1, $5, pl); }
    ;

controlLocalDeclarations
    : /* empty */               { $$ = new IR::IndexedVector<IR::Declaration>(); }
    | controlLocalDeclarations controlLocalDeclaration { $$ = $1; $$->push_back($2); }
    ;

controlLocalDeclaration
    : constantDeclaration      { $$ = $1; }
    | actionDeclaration        { $$ = $1; }
    | tableDeclaration         { $$ = $1; }
    | instantiation            { $$ = $1; }
    | variableDeclaration      { $$ = $1; }
    ;

controlBody
    : blockStatement { $$ = $1; }
    ;

/*************************** EXTERN *************************/

externDeclaration
    : EXTERN name { structure.pushContainerType(*$2, true); }
                            optTypeParameters { structure.declareTypes($4->parameters); }
                            '{' methodPrototypes '}'
                                       { structure.pop();
                                         $$ = new IR::Type_Extern(@2, *$2, $4, $7); }
    | EXTERN functionPrototype ';'     { $$ = $2; }
    ;

methodPrototypes
    : /* empty */                      { $$ = new IR::Vector<IR::Method>(); }
    | methodPrototypes methodPrototype { $$ = $1; $1->push_back($2); }
    ;

functionPrototype
    : typeOrVoid name optTypeParameters { structure.pushNamespace("", @2, false);
                     structure.declareTypes($3->parameters); }
                     '(' parameterList ')' { structure.pop(); }
                                        { auto params = new IR::ParameterList(@6, $6);
                                          auto mt = new IR::Type_Method(@2, $3, $1, params);
                                          $$ = new IR::Method(@2, *$2, mt, false); }
    ;

methodPrototype
    : functionPrototype ';' { $$ = $1; }
    | ABSTRACT functionPrototype ';' { $$ = $2; $$->setAbstract(); }
    | TYPE optTypeParameters { structure.pushNamespace("", @1, false);
                     structure.declareTypes($2->parameters); }  // constructor
                     '(' parameterList ')' ';'               { structure.pop(); }
                                        { auto par = new IR::ParameterList(@5, $5);
                                          auto mt = new IR::Type_Method(@1, $2, nullptr, par);
                                          $$ = new IR::Method(@1, IR::ID(@1, $1), mt, false); }
    ;

/************************** TYPES ****************************/

typeRef
    : baseType                         { $$ = $1; }
    | typeName                         { $$ = $1; }
    | specializedType                  { $$ = $1; }
    | headerStackType                  { $$ = $1; }
    | tupleType                        { $$ = $1; }
    ;

typeName
    : TYPE                        { $$ = new IR::Type_Name(@1, new IR::Path(IR::ID(@1, $1))); }
    | pathPrefix TYPE             { $$ = new IR::Type_Name(@1, new IR::Path($1, IR::ID(@2, $2))); }
    ;

tupleType
    : TUPLE '<' typeArgumentList '>'   { $$ = new IR::Type_Tuple(@1+@4, $3); }
    ;

headerStackType
    : typeName '[' expression ']'      { $$ = new IR::Type_Stack(@1+@4, $1, $3); }
    ;

specializedType
    : pathPrefix TYPE '<' typeArgumentList '>'
                                       { auto id = IR::ID(@2, $2);
                                         auto type = new IR::Type_Name(@1, new IR::Path($1, id));
                                         $$ = new IR::Type_Specialized(@1 + @5, type, $4); }
    | TYPE '<' typeArgumentList '>'    { auto id = IR::ID(@1, $1);
                                         auto type = new IR::Type_Name(@1, new IR::Path(id));
                                         $$ = new IR::Type_Specialized(@1 + @4, type, $3); }
    ;

baseType
    : BOOL                             { $$ = IR::Type_Boolean::get(); }
    | T_ERROR                          { $$ = IR::Type_Error::get(); }
    | BIT                              { $$ = IR::Type::Bits::get(@1, 1); }
    | BIT '<' INTEGER '>'              { $$ = IR::Type::Bits::get(@3, $3->asInt(), false); }
    | INT '<' INTEGER '>'              { $$ = IR::Type::Bits::get(@3, $3->asInt(), true); }
    | VARBIT '<' INTEGER '>'           { $$ = IR::Type::Varbits::get(@3, $3->asInt()); }
    ;

typeOrVoid
    : typeRef                          { $$ = $1; }
    | VOID                             { $$ = IR::Type_Void::get(); }
    | name                             { $$ = new IR::Type_Name(@1, new IR::Path(*$1)); }
                      // This is necessary because template arguments may introduce the return type
    ;

optTypeParameters
    : /* empty */                  { $$ = new IR::TypeParameters(); }
    | '<' typeParameterList '>'    { $$ = new IR::TypeParameters(@1+@3, $2); }
    ;

typeParameterList
    : name                             { $$ = new IR::IndexedVector<IR::Type_Var>();
                                         $$->push_back(new IR::Type_Var(@1, *$1)); }
    | typeParameterList ',' name       { ($$=$1)->push_back(new IR::Type_Var(@3, *$3)); }
    ;

typeArg
    : typeRef                          { $$ = $1; }
    | DONTCARE                         { $$ = IR::Type_Dontcare::get(); }
    ;

typeArgumentList
    : typeArg                          { $$ = new IR::Vector<IR::Type>(); $$->push_back($1); }
    | typeArgumentList ',' typeArg     { $$ = $1; $$->push_back($3); }
    ;

typeDeclaration
    : derivedTypeDeclaration           { $$ = $1; }
    | typedefDeclaration ';'           { $$ = $1; }
    | parserTypeDeclaration ';'        { structure.pop(); $$ = $1; }
    | controlTypeDeclaration ';'       { structure.pop(); $$ = $1; }
    | packageTypeDeclaration ';'       { structure.pop(); $$ = $1; }
    ;

derivedTypeDeclaration
    : headerTypeDeclaration            { $$ = $1; }
    | headerUnionDeclaration           { $$ = $1; }
    | structTypeDeclaration            { $$ = $1; }
    | enumDeclaration                  { $$ = $1; }
    ;

headerTypeDeclaration
    : optAnnotations HEADER name       { structure.declareType(*$3); } '{' structFieldList '}'
                                       { $$ = new IR::Type_Header(@3, *$3, $1, $6); }
    ;

structTypeDeclaration
    : optAnnotations STRUCT name       { structure.declareType(*$3); } '{' structFieldList '}'
                                       { $$ = new IR::Type_Struct(@3, *$3, $1, $6); }
    ;

headerUnionDeclaration
    : optAnnotations HEADER_UNION name { structure.declareType(*$3); }
      '{' structFieldList '}'          { $$ = new IR::Type_Union(@3, *$3, $1, $6); }
    ;

structFieldList
    : /* empty */                      { $$ = new IR::IndexedVector<IR::StructField>(); }
    | structFieldList structField      { $$ = $1; $1->push_back($2); }
    ;

structField
    : optAnnotations typeRef name ';'  { $$ = new IR::StructField(@3, *$3, $1, $2); }
    | optAnnotations typeRef TYPE ';'  { $$ = new IR::StructField(@3, IR::ID(@3, $3), $1, $2); }
    ;

enumDeclaration
    : optAnnotations ENUM name          { structure.declareType(*$3); } '{' identifierList '}'
                                        { $$ = new IR::Type_Enum(@1 + @3, *$3, $6); }
    ;

errorDeclaration
    : T_ERROR '{' identifierList '}'    { $$ = new IR::Declaration_Errors(@1 + @4, $3); }
    ;

matchKindDeclaration
    : MATCH_KIND '{' identifierList '}' { $$ = new IR::Declaration_MatchKind(@1 + @4, $3); }
    ;

identifierList
    : name                              { $$ = new IR::IndexedVector<IR::Declaration_ID>();
                                          $$->push_back(new IR::Declaration_ID(@1, *$1));}
    | identifierList ',' name           { $$ = $1; $$->push_back(new IR::Declaration_ID(@3, *$3)); }
    ;

typedefDeclaration
    : annotations TYPEDEF typeRef name   { structure.declareType(*$4);
          $$ = new IR::Type_Typedef(@4, *$4, new IR::Annotations($1), $3); }
    | TYPEDEF typeRef name               { structure.declareType(*$3);
          $$ = new IR::Type_Typedef(@3, *$3, IR::Annotations::empty, $2); }
    | annotations TYPEDEF derivedTypeDeclaration name   { structure.declareType(*$4);
                        $$ = new IR::Type_Typedef(@4, *$4, new IR::Annotations($1), $3); }
    | TYPEDEF derivedTypeDeclaration name { structure.declareType(*$3);
                        $$ = new IR::Type_Typedef(@3, *$3, IR::Annotations::empty, $2); }
    ;

/*************************** STATEMENTS *************************/

assignmentOrMethodCallStatement
    // These rules are overly permissive, but they avoid some conflicts
    : lvalue '(' argumentList ')' ';'  { auto mc = new IR::MethodCallExpression(@1 + @4, $1,
                                                               new IR::Vector<IR::Type>(), $3);
                                         $$ = new IR::MethodCallStatement(@1 + @4, mc); }
    | lvalue '<' typeArgumentList '>' '(' argumentList ')' ';'
                                       { auto mc = new IR::MethodCallExpression(@1 + @7,
                                                                                $1, $3, $6);
                                         $$ = new IR::MethodCallStatement(@1 + @7, mc); }
    | lvalue '='  expression ';'       { $$ = new IR::AssignmentStatement(@2, $1, $3); }
    ;

emptyStatement
    : ';'                              { $$ = new IR::EmptyStatement(@1); }
    ;

exitStatement
    : EXIT ';'                         { $$ = new IR::ExitStatement(@1); }
    ;

returnStatement
    : RETURN ';'                       { $$ = new IR::ReturnStatement(@1, nullptr); }
    | RETURN expression ';'            { $$ = new IR::ReturnStatement(@1, $2); }
    ;

conditionalStatement
    : IF '(' expression ')' statement                          %prec THEN
                                       { $$ = new IR::IfStatement(@1, $3, $5, nullptr); }
    | IF '(' expression ')' statement ELSE statement           %prec THEN
                                       { $$ = new IR::IfStatement(@1, $3, $5, $7); }
    ;

statement
    : assignmentOrMethodCallStatement  { $$ = $1; }
    | conditionalStatement             { $$ = $1; }
    | emptyStatement                   { $$ = $1; }
    | blockStatement                   { $$ = $1; }
    | returnStatement                  { $$ = $1; }
    | exitStatement                    { $$ = $1; }
    | switchStatement                  { $$ = $1; }
    ;

blockStatement
    : optAnnotations '{' statOrDeclList '}' { $$ = new IR::BlockStatement(@1 + @4, $1, $3); }
    ;

statOrDeclList
    : /* empty */                           { $$ = new IR::IndexedVector<IR::StatOrDecl>(); }
    | statOrDeclList statementOrDeclaration { $$ = $1; $$->push_back($2); }
    ;

switchStatement
    : SWITCH '(' expression ')' '{' switchCases '}' {
            $$ = new IR::SwitchStatement(@1, $3, std::move(*$6)); }
    ;

switchCases
    : /* empty */              { $$ = new IR::Vector<IR::SwitchCase>(); }
    | switchCases switchCase   { $$ = $1; $$->push_back($2); }
    ;

switchCase
    : switchLabel ':' blockStatement { $$ = new IR::SwitchCase(@1 + @3, $1, $3); }
    | switchLabel ':' { $$ = new IR::SwitchCase(@1, $1, nullptr); }
    ;

switchLabel
    : name                     { $$ = new IR::PathExpression(*$1); }
    | DEFAULT                  { $$ = new IR::DefaultExpression(@1); }
    ;

statementOrDeclaration
    : variableDeclaration      { $$ = $1; }
    | constantDeclaration      { $$ = $1; }
    | statement                { $$ = $1; }
    | instantiation            { $$ = $1; }
    ;

/************************* TABLE *********************************/

tableDeclaration
    : optAnnotations TABLE name '(' parameterList ')' '{' tablePropertyList '}'
                                         { $$ = new IR::P4Table(@3, *$3, $1,
                                                     new IR::ParameterList(@5, $5),
                                                     new IR::TableProperties(@8, $8)); }
    | optAnnotations TABLE name '{' tablePropertyList '}'
                                         { $$ = new IR::P4Table(@3, *$3, $1,
                                                     new IR::ParameterList(),
                                                     new IR::TableProperties(@5, $5)); }
    ;

tablePropertyList
    : tableProperty                      { $$ = new IR::IndexedVector<IR::TableProperty>();
                                           $$->push_back($1); }
    | tablePropertyList tableProperty    { $$ = $1; $$->push_back($2); }
    ;

tableProperty
    : KEY '=' '{' keyElementList '}'     { auto v = new IR::Key(@4, $4);
                                           auto id = IR::ID(
                                               @1, IR::TableProperties::keyPropertyName);
                                           $$ = new IR::TableProperty(
                                               @1 + @5, id, IR::Annotations::empty, v, false); }
    | ACTIONS '=' '{' actionList '}'     { auto v = new IR::ActionList(@4, $4);
                                           auto id = IR::ID(
                                               @1, IR::TableProperties::actionsPropertyName);
                                           $$ = new IR::TableProperty(
                                               @1 + @5, id, IR::Annotations::empty, v, false); }
    | optAnnotations CONST IDENTIFIER '=' initializer ';'
                                         { auto v = new IR::ExpressionValue(@5, $5);
                                            auto id = IR::ID(@3, $3);
                                            $$ = new IR::TableProperty(@3, id, $1, v, true); }
    | optAnnotations IDENTIFIER '=' initializer ';'
                                         { auto v = new IR::ExpressionValue(@4, $4);
                                           auto id = IR::ID(@2, $2);
                                           $$ = new IR::TableProperty(@2, id, $1, v, false); }
    ;

keyElementList
    : /* empty */                        { $$ = new IR::Vector<IR::KeyElement>(); }
    | keyElementList keyElement          { $$ = $1; $$->push_back($2); }
    ;

keyElement
    : expression ':' name optAnnotations ';'
                                         { auto expr = new IR::PathExpression(*$3);
                                           $$ = new IR::KeyElement(@3, $4, $1, expr); }
    ;

actionList
    : actionRef ';'                      { $$ = new IR::IndexedVector<IR::ActionListElement>();
                                           $$->push_back($1); }
    | actionList actionRef ';'           { $$ = $1; $$->push_back($2); }
    ;

actionRef
    : optAnnotations name                { auto expr = new IR::PathExpression(*$2);
                                           $$ = new IR::ActionListElement(@2, $1, expr);}
    | optAnnotations name '(' argumentList ')'
                                         { auto method = new IR::PathExpression(*$2);
                                           auto mce = new IR::MethodCallExpression(
                                               @2+@4, method, new IR::Vector<IR::Type>(), $4);
                                           $$ = new IR::ActionListElement(@2, $1, mce); }
    ;

/************************* ACTION ********************************/

actionDeclaration
    : optAnnotations ACTION name '(' parameterList ')' '{' statOrDeclList '}'
                                         { auto pl = new IR::ParameterList(@5, $5);
                                           $$ = new IR::P4Action(
                                               @3, *$3, $1, pl, new IR::BlockStatement(
                                                   @8, IR::Annotations::empty, $8)); }
    ;

/************************* VARIABLES *****************************/

variableDeclaration
    : annotations typeRef name optInitializer ';'
                                     { auto ann = new IR::Annotations(@1, $1);
                                       $$ = new IR::Declaration_Variable(@1+@4, *$3, ann, $2, $4); }
    | typeRef name optInitializer ';'
                                     { $$ = new IR::Declaration_Variable(
                                         @1+@4, *$2, IR::Annotations::empty, $1, $3);}
    ;

constantDeclaration
    : optAnnotations CONST typeRef name '=' initializer ';'
                                     { $$ = new IR::Declaration_Constant(@1+@6, *$4, $1, $3, $6); }
    ;

optInitializer
    : /* empty */                         { $$ = nullptr; }
    | '=' initializer                     { $$ = $2; }
    ;

initializer
    : expression                          { $$ = $1; }
    ;

/**************** Expressions ****************/

functionDeclaration
    : functionPrototype blockStatement   { $$ = new IR::Function(@1+@2, $1->name, $1->type, $2); }
    ;

argumentList
    : /* empty */                        { $$ = new IR::Vector<IR::Expression>(); }
    | nonEmptyArgList                    { $$ = $1; }
    ;

nonEmptyArgList
    : argument                           { $$ = new IR::Vector<IR::Expression>();
                                           $$->push_back($1); }
    | nonEmptyArgList ',' argument       { $$ = $1; $$->push_back($3); }
    ;

argument
    : expression                         { $$ = $1; }
    ;

expressionList
    : expression                         { $$ = new IR::Vector<IR::Expression>();
                                           $$->push_back($1); }
    | expressionList ',' expression      { $$ = $1; $$->push_back($3); }
    ;

member
    : name
    | TYPE                               { $$ = new IR::ID(@1, $1); }
    ;

lvalue
    : name                               { $$ = new IR::PathExpression(*$1); }
    | THIS                               { $$ = new IR::This(@1); }
    | pathPrefix name                    { $$ = new IR::PathExpression(new IR::Path($1, *$2)); }
    | lvalue '.' member                  { $$ = new IR::Member(@1 + @3, $1, *$3); }
    | lvalue '[' expression ']'          { $$ = new IR::ArrayIndex(@1 + @3, $1, $3); }
    | lvalue '[' expression ':' expression ']' { $$ = new IR::Slice(@1 + @6, $1, $3, $5); }
    ;

expression
    : INTEGER                            { $$ = $1; }
    | STRING_LITERAL                     { $$ = new IR::StringLiteral(@1, $1); }
    | TRUE                               { $$ = new IR::BoolLiteral(@1, true); }
    | FALSE                              { $$ = new IR::BoolLiteral(@1, false); }
    | THIS                               { $$ = new IR::This(@1); }
    | name                               { $$ = new IR::PathExpression(*$1); }
    | pathPrefix name                    { $$ = new IR::PathExpression(new IR::Path($1, *$2)); }
    | expression '[' expression ']'      { $$ = new IR::ArrayIndex(@1 + @4, $1, $3); }
    | expression '[' expression ':' expression ']'   { $$ = new IR::Slice(@1 + @6, $1, $3, $5); }
    | '{' expressionList '}'             { $$ = new IR::ListExpression(@1 + @3, $2); }
    | '(' expression ')'                 { $$ = $2; }
    | '!' expression %prec PREFIX        { $$ = new IR::LNot(@1 + @2, $2); }
    | '~' expression %prec PREFIX        { $$ = new IR::Cmpl(@1 + @2, $2); }
    | '-' expression %prec PREFIX        { $$ = new IR::Neg(@1 + @2, $2); }
    | '+' expression %prec PREFIX        { $$ = $2; }
    | typeName '.' member                { $$ = new IR::Member(@1 + @3,
                                                               new IR::TypeNameExpression(@1, $1),
                                                               *$3); }
    | expression '.' member              { $$ = new IR::Member(@1 + @3, $1, *$3); }
    | expression '*' expression          { $$ = new IR::Mul(@1 + @3, $1, $3); }
    | expression '/' expression          { $$ = new IR::Div(@1 + @3, $1, $3); }
    | expression '%' expression          { $$ = new IR::Mod(@1 + @3, $1, $3); }
    | expression '+' expression          { $$ = new IR::Add(@1 + @3, $1, $3); }
    | expression '-' expression          { $$ = new IR::Sub(@1 + @3, $1, $3); }
    | expression SHL expression          { $$ = new IR::Shl(@1 + @3, $1, $3); }
    | expression '>''>' expression       { checkShift(@2, @3); $$ = new IR::Shr(@1 + @4, $1, $4); }
    | expression LE expression           { $$ = new IR::Leq(@1 + @3, $1, $3); }
    | expression GE expression           { $$ = new IR::Geq(@1 + @3, $1, $3); }
    | expression '<' expression          { $$ = new IR::Lss(@1 + @3, $1, $3); }
    | expression '>' expression          { $$ = new IR::Grt(@1 + @3, $1, $3); }
    | expression NE expression           { $$ = new IR::Neq(@1 + @3, $1, $3); }
    | expression EQ expression           { $$ = new IR::Equ(@1 + @3, $1, $3); }
    | expression '&' expression          { $$ = new IR::BAnd(@1 + @3, $1, $3); }
    | expression '^' expression          { $$ = new IR::BXor(@1 + @3, $1, $3); }
    | expression '|' expression          { $$ = new IR::BOr(@1 + @3, $1, $3); }
    | expression PP expression           { $$ = new IR::Concat(@1 + @3, $1, $3); }
    | expression AND expression          { $$ = new IR::LAnd(@1 + @2 + @3, $1, $3); }
    | expression OR expression           { $$ = new IR::LOr(@1 + @2 + @3, $1, $3); }
    | expression '?' expression ':' expression  { $$ = new IR::Mux(@1 + @5, $1, $3, $5); }
    | expression '<' typeArgumentList '>' '(' argumentList ')'
                                         { $$ = new IR::MethodCallExpression(@1 + @4, $1, $3, $6); }
    // FIXME: the previous rule has the wrong precedence, and parses with
    // precedence weaker than casts.  There is no easy way to fix this in bison.
    | expression '(' argumentList ')'    { $$ = new IR::MethodCallExpression(@1 + @4, $1,
                                                                  new IR::Vector<IR::Type>(), $3); }
    | typeRef '(' argumentList ')'       { $$ = new IR::ConstructorCallExpression(@1 + @4,
                                                                                  $1, $3); }
    | '(' typeRef ')' expression %prec PREFIX  { $$ = new IR::Cast(@1 + @4, $2, $4); }
    ;

/*****************************************************************************/

%%


#include "p4-lex.c"
}  // end anonymous namespace

static bool parsing = false;

void yyerror(const char *fmt, ...) {
    if (!strcmp(fmt, "syntax error, unexpected IDENTIFIER")) {
        ErrorReporter::instance.parser_error("syntax error, unexpected IDENTIFIER \"%s\"",
                                             yylval.str.c_str());
        return;
    }
    va_list args;
    va_start(args, fmt);
    ErrorReporter::instance.parser_error(fmt, args);
    va_end(args);
}

const IR::P4Program *parse_P4_16_file(const char *name, FILE *in) {
    extern int verbose;
    if (verbose)
        std::cout << "Parsing P4-16 program " << name << std::endl;

    int errors = 0;
#ifdef YYDEBUG
    if (const char *p = getenv("YYDEBUG"))
        yydebug = atoi(p);
    structure.setDebug(yydebug != 0);
#endif
    declarations = new IR::IndexedVector<IR::Node>();
    parsing = true;
    yyrestart(in);
    errors |= yyparse();
    parsing = false;
    if (errors) {
        return nullptr;
    } else {
        structure.endParse();
    }
    return new IR::P4Program(declarations->srcInfo, declarations);
}

// check that right shift >>
// has the two tokens at consecutive positions
// (not separated by anything else)
void checkShift(Util::SourceInfo l, Util::SourceInfo r)
{
    if (!l.isValid() || !r.isValid())
        BUG("Source position not available!");
    const Util::SourcePosition &f = l.getStart();
    const Util::SourcePosition &s = r.getStart();
    if (f.getLineNumber() != s.getLineNumber() ||
        f.getColumnNumber() != s.getColumnNumber() - 1)
        ::error("Syntax error at shift operator: %1%", l);
}
