/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Use Bison's C++ mode.
%skeleton "lalr1.cc" /* -*-C++-*- */
%require "3.0.4"

// Set up names.
%defines
%define api.namespace {V1}
%define parser_class_name {V1Parser}

// Use the C++-native variant representation of tokens.
%define api.token.constructor
%define api.value.type variant

// Add asserts to ensure that we use the API correctly.
%define parse.assert true

// Enable verbose error reporting.
%error-verbose

// Declare dependencies.
%code requires {
namespace V1 {
class V1Lexer;
class V1ParserDriver;

struct BBoxType {
    IR::Vector<IR::Method>* methods;
    IR::NameMap<IR::Attribute, ordered_map>* attribs;
};

struct HeaderType {
    IR::Vector<IR::Annotation>* annotations;
    IR::IndexedVector<IR::StructField>* fields;
};
}  // namespace V1

inline std::ostream& operator<<(std::ostream& out, const V1::BBoxType& bboxType) {
    out << "BBoxType(" << bboxType.methods << ',' << bboxType.attribs << ')';
    return out;
}

inline std::ostream& operator<<(std::ostream& out, const V1::HeaderType& headerType) {
    out << "HeaderType(" << headerType.annotations << ',' << headerType.fields << ')';
    return out;
}

typedef std::pair<const IR::Constant*, const IR::Constant*> CaseValue;

inline std::ostream& operator<<(std::ostream& out, const CaseValue& caseValue) {
    out << "CaseValue(" << caseValue.first << ',' << caseValue.second << ')';
    return out;
}

// Bison uses the types you provide to %type to make constructors for the
// variant type it uses under the hood, but its code generation is a little
// naive and it always prepends 'const' to the type. This is problematic when
// the symbol type we want is itself const, since duplicate const qualifiers are
// forbidden in C++. We avoid the problem using a typedef.
typedef const IR::Type ConstType;

#ifndef YYDEBUG
#define YYDEBUG 1
#endif

#define YY_NULLPTR nullptr

#include "frontends/common/constantParsing.h"
#include "lib/cstring.h"
#include "lib/error.h"
#include "lib/source_file.h"
}

%param { V1::V1ParserDriver& driver }
%parse-param { V1::V1Lexer& lexer }

// Use location tracking with our custom location type.
%locations
%define api.location.type {Util::SourceInfo}

%{ /* -*-C++-*- */
#include <iostream>  // NOLINT(build/include_order)

#include "frontends/parsers/parserDriver.h"
#include "frontends/parsers/v1/v1lexer.hpp"
#include "frontends/parsers/v1/v1parser.hpp"
#include "ir/ir.h"

#define YYLLOC_DEFAULT(Cur, Rhs, N)                                     \
    ((Cur) = (N) ? YYRHSLOC(Rhs, 1) + YYRHSLOC(Rhs, N)                  \
                 : Util::SourceInfo(YYRHSLOC(Rhs, 0).getEnd()))

#undef yylex
#define yylex lexer.yylex
%}

// Use iostreams to print all values. We have a number of semantic actions that
// produce null pointers, so we need to have two printers: one for non-pointer
// types, and another with null checking for pointer types.
%printer { yyoutput << $$; } <BBoxType> <CaseValue> <cstring> <HeaderType>
                             <int> <IR::Direction> <UnparsedConstant>
%printer {
    auto val = $$;
    if (val != nullptr) {
        yyoutput << val;
    } else {
        yyoutput << "(null)";
    }
} <*>

%define api.token.prefix {TOK_}
%token      END
%token      UNEXPECTED_TOKEN
%token      LE "<="
%token      GE ">="
%token      SHL "<<"
%token      SHR ">>"
%token      AND "&&"
%token      OR "||"
%token      NE "!="
%token      EQ "=="
%token      PLUS "+"
%token      MINUS "-"
%token      MUL "*"
%token      DIV "/"
%token      MOD "%"
%token      BIT_OR "|"
%token      BIT_AND "&"
%token      BIT_XOR "^"
%token      COMPLEMENT "~"
%token      L_BRACKET "["
%token      R_BRACKET "]"
%token      L_BRACE "{"
%token      R_BRACE "}"
%token      L_ANGLE "<"
%token      R_ANGLE ">"
%token      L_PAREN "("
%token      R_PAREN ")"
%token      NOT "!"
%token      COLON ":"
%token      COMMA ","
%token      DOT "."
%token      ASSIGN "="
%token      SEMICOLON ";"
%token      NEWLINE
%token<cstring> ACTION ACTIONS ACTION_PROFILE ACTION_SELECTOR ALGORITHM APPLY
                ATTRIBUTE ATTRIBUTES BIT BLACKBOX BLACKBOX_TYPE BLOCK BOOL
                CALCULATED_FIELD CONTROL COUNTER CURRENT DEFAULT DEFAULT_ACTION
                DIRECT DROP DYNAMIC_ACTION_SELECTION ELSE EXTRACT EXPRESSION
                EXPRESSION_LOCAL_VARIABLES FALSE FIELD_LIST FIELD_LIST_CALCULATION
                FIELDS HEADER HEADER_TYPE IF IMPLEMENTATION IN INPUT INSTANCE_COUNT
                INT LATEST LAYOUT LENGTH MASK MAX_LENGTH MAX_SIZE MAX_WIDTH METADATA
                METER METHOD MIN_SIZE MIN_WIDTH OPTIONAL OUT OUTPUT_WIDTH PARSE_ERROR
                PARSER PARSER_EXCEPTION PAYLOAD PRAGMA PREFIX PRE_COLOR
                PRIMITIVE_ACTION READS REGISTER RESULT RETURN SATURATING SELECT
                SELECTION_KEY SELECTION_MODE SELECTION_TYPE SET_METADATA SIGNED SIZE
                STATIC STRING TABLE TRUE TYPE UPDATE VALID VERIFY WIDTH WRITES
%token<cstring> IDENTIFIER STRING_LITERAL
%token<UnparsedConstant> INTEGER

%left EXPRLIST
%right ASSIGN
%left OR
%left AND
%left BIT_OR
%left BIT_XOR
%left BIT_AND
%left EQ NE
%left L_ANGLE R_ANGLE LE GE
%left SHL SHR
%left PLUS MINUS
%left MUL DIV MOD
%right PREFIX

%type<int>                          opt_field_modifiers attributes attrib
%type<cstring>                      name
%type<IR::ActionFunction*>          action_function_body action_statement_list
%type<IR::ActionProfile*>           action_profile_body
%type<IR::ActionSelector*>          action_selector_body
%type<IR::Annotations*>             blackbox_method
%type<IR::Apply*>                   apply_case_list
%type<IR::Attribute*>               blackbox_attribute
%type<IR::AttribLocal*>             local_var
%type<IR::AttribLocals*>            locals_list opt_locals_list
%type<IR::Declaration_Instance*>    blackbox_config
%type<BBoxType>                     blackbox_body
%type<IR::CalculatedField*>         update_verify_spec_list
%type<CaseValue>                    case_value
%type<IR::CaseEntry*>               case_value_list
%type<IR::Vector<IR::CaseEntry>*>   case_entry_list
%type<IR::Constant*>                const_expression
%type<IR::Counter*>                 counter_spec_list
%type<IR::Direction>                inout
%type<IR::Expression*>              expression header_ref header_or_field_ref
                                    field_or_masked_ref opt_condition pragma_operand
%type<IR::Vector<IR::Expression>*>  expression_list opt_expression_list
                                    control_statement_list opt_else
                                    field_match_list expressions pragma_operands
%type<IR::FieldList*>               field_list_entries
%type<IR::FieldListCalculation*>    field_list_calculation_body
%type<IR::Member*>                  field_ref
%type<HeaderType>                   header_dec_body field_declarations
%type<IR::NameList*>                action_list name_list opt_name_list field_list_list
%type<IR::Meter*>                   meter_spec_list
%type<IR::Parameter*>               argument
%type<IR::ParameterList*>           opt_argument_list argument_list
%type<IR::V1Parser*>                parser_statement_list
%type<IR::Register*>                register_spec_list
%type<IR::V1Table*>                 table_body
%type<ConstType*>                   bit_width type

%%

program : input END { YYACCEPT; };

input: /* epsilon */
    | input header_type_declaration
    | input header_instance
    | input metadata_instance
    | input field_list_declaration
    | input field_list_calculation_declaration
    | input calculated_field_declaration
    | input parser_function_declaration
    | input parser_exception_declaration
    | input counter_declaration
    | input meter_declaration
    | input register_declaration
    | input primitive_action_declaration
    | input action_function_declaration
    | input action_profile_declaration
    | input action_selector_declaration
    | input table_declaration
    | input control_function_declaration
    | input blackbox_type_declaration
    | input blackbox_instantiation
    | input PRAGMA pragma_operands NEWLINE
          { driver.addPragma(new IR::Annotation(@2, $2, *$3)); }
    | input error
          { driver.clearPragmas(); }
;

/********************************/
/* 5.1 Header Type Declarations */
/********************************/

header_type_declaration: HEADER_TYPE name L_BRACE header_dec_body R_BRACE
      { $4.annotations->append(driver.takePragmasAsVector());
        driver.global->add($2, new IR::v1HeaderType(@1+@5, $2,
            new IR::Type_Struct(@1+@5, IR::ID(@2, $2),
                                new IR::Annotations(*$4.annotations), *$4.fields),
            new IR::Type_Header(@1+@5, IR::ID(@2, $2),
                                new IR::Annotations(*$4.annotations), *$4.fields))); }
;

header_dec_body: FIELDS L_BRACE field_declarations R_BRACE opt_length opt_max_length
      { $$ = $3; }
;

field_declarations: /* epsilon */
      { $$.annotations = new IR::Vector<IR::Annotation>;
        $$.fields = new IR::IndexedVector<IR::StructField>; }
    | field_declarations name COLON bit_width SEMICOLON
      { ($$=$1).fields->push_back(new IR::StructField(@2+@4, IR::ID(@2, $2), $4)); }
    | field_declarations type name SEMICOLON
      { ($$=$1).fields->push_back(new IR::StructField(@2+@4, IR::ID(@3, $3), $2)); }
;

bit_width:
      const_expression opt_field_modifiers
      { if ($1)
            $$ = IR::Type::Bits::get(@1, $1->asInt(), $2 & 1);
        else
            $$ = IR::Type::Unknown::get(); }
    | MUL opt_field_modifiers
      { $$ = IR::Type::Varbits::get(); }
;

opt_field_modifiers: /* epsilon */ { $$ = 0;}
    | L_PAREN attributes R_PAREN { $$ = $2; }
;

attributes:
      attrib { $$ = $1; }
    | attributes COMMA attrib { $$ = $1 | $3; }
;

attrib:
      SIGNED     { $$ = 1; }
      // TODO: these seem to be currently ignored
    | SATURATING { $$ = 2; }
;

opt_length: /* epsilon */
    | LENGTH COLON expression SEMICOLON  /* const_expression or name */
      { $<HeaderType>-1.annotations->emplace_back(@1+@4, "length",
              IR::Vector<IR::Expression>($3)); }
    ;

opt_max_length: /* epsilon */
    | MAX_LENGTH COLON const_expression SEMICOLON
      { $<HeaderType>-2.annotations->emplace_back(@1+@4, "max_length",
              IR::Vector<IR::Expression>($3)); }
    ;

type: BIT { $$ = IR::Type::Bits::get(@1, 1); }
    | BIT L_ANGLE INTEGER R_ANGLE
      { $$ = IR::Type::Bits::get(@3, parseConstant(@3, $3, 0)->asInt()); }
    | BLOCK { $$ = IR::Type_Block::get(); }
    | BOOL { $$ = IR::Type_Boolean::get(); }
    | COUNTER { $$ = IR::Type_Counter::get(); }
    | EXPRESSION { $$ = IR::Type_Expression::get(); }
    | FIELD_LIST_CALCULATION { $$ = IR::Type_FieldListCalculation::get(); }
    | INT { $$ = new IR::Type_InfInt; }
    | INT L_ANGLE INTEGER R_ANGLE
      { $$ = IR::Type::Bits::get(@3, parseConstant(@3, $3, 0)->asInt(), true); }
    | METER { $$ = IR::Type_Meter::get(); }
    | STRING { $$ = IR::Type_String::get(); }
    | REGISTER { $$ = IR::Type_Register::get(); }
    | TABLE { $$ = IR::Type_AnyTable::get(); }
;

/************************************/
/* 5.2 Header and Metadata instance */
/************************************/

header_instance:
      HEADER name name SEMICOLON
      { driver.global->add($3, new IR::Header(@1+@4, IR::ID(@2, $2), IR::ID(@3, $3),
                                              driver.takePragmasAsAnnotations())); }
    | HEADER name name L_BRACKET const_expression R_BRACKET SEMICOLON
      { driver.global->add($3, new IR::HeaderStack(@1+@7, IR::ID(@2, $2), IR::ID(@3, $3),
                                                   driver.takePragmasAsAnnotations(),
                                                   $5 ? $5->asLong() : 0));
        $5 = nullptr; }
    ;

metadata_instance:
      METADATA name name opt_metadata_initializer SEMICOLON
      { driver.global->add($3, new IR::Metadata(@1+@5, IR::ID(@2, $2), IR::ID(@3, $3),
                                                driver.takePragmasAsAnnotations())); }
    ;

opt_metadata_initializer: /* epsilon */
    | L_BRACE metadata_field_init_list R_BRACE
    ;

metadata_field_init_list: /* empty */
    | metadata_field_init_list name COLON const_expression SEMICOLON
      { $4 = nullptr; }
    ;

/*******************/
/* 5.4 Field Lists */
/*******************/

field_list_declaration:
      FIELD_LIST name L_BRACE field_list_entries R_BRACE
      { $4->name = IR::ID(@2, $2); $4->srcInfo = @1 + @5; driver.global->add($2, $4); }
    | FIELD_LIST name SEMICOLON
      /* FIXME -- empty field list? or (unneeded) forward declaration? */
;

field_list_entries:
      /* epsilon */ { $$ = new IR::FieldList(driver.takePragmasAsAnnotations()); }
    | field_list_entries expression SEMICOLON /* const_expression or field_ref or name */
      { ($$=$1)->fields.push_back($2); }
    | field_list_entries PAYLOAD SEMICOLON
      { ($$=$1)->payload = true; }
    ;

/***************************************************/
/* 6  Checksums and Hash-based Selection Functions */
/***************************************************/

field_list_calculation_declaration:
      FIELD_LIST_CALCULATION name L_BRACE field_list_calculation_body R_BRACE
      { $4->name = IR::ID(@2, $2); $4->srcInfo = @1 + @5; driver.global->add($2, $4); }
;

field_list_calculation_body: /* epsilon */
      { $$ = new IR::FieldListCalculation(driver.takePragmasAsAnnotations()); }
    | field_list_calculation_body INPUT L_BRACE field_list_list R_BRACE
      { if ($1->input)
            ::error("%s: multiple 'input' in field_list_calculation", @2);
        ($$=$1)->input = $4; }
    | field_list_calculation_body ALGORITHM COLON name SEMICOLON
      { if ($1->algorithm)
            ::error("%s: multiple 'algorithm' in field_list_calculation", @2);
        ($$=$1)->algorithm = IR::ID(@4, $4); }
    | field_list_calculation_body OUTPUT_WIDTH COLON const_expression SEMICOLON
      { if ($1->output_width)
            ::error("%s: multiple 'output_width' in field_list_calculation", @2);
        ($$=$1)->output_width = $4 ? $4->asInt() : 0; }
    | field_list_calculation_body error SEMICOLON { $$ = $1; }
    | field_list_calculation_body error { $$ = $1; }
;

field_list_list: /* epsilon */
      { $$ = new IR::NameList; }
    | field_list_list name SEMICOLON
      { ($$=$1)->names.emplace_back(@2, $2); }
;

calculated_field_declaration:
      CALCULATED_FIELD field_ref L_BRACE update_verify_spec_list R_BRACE
      { $4->field = $2; $4->srcInfo = @1 + @5; driver.global->add($2->toString(), $4); }
;

update_verify_spec_list: /* epsilon */
      { $$ = new IR::CalculatedField(driver.takePragmasAsAnnotations()); }
    | update_verify_spec_list UPDATE name opt_condition SEMICOLON
      { ($$=$1)->specs.emplace_back(@1+@3, true, IR::ID(@3, $3), $4); }
    | update_verify_spec_list VERIFY name opt_condition SEMICOLON
      { ($$=$1)->specs.emplace_back(@1+@3, false, IR::ID(@3, $3), $4); }
    | update_verify_spec_list error SEMICOLON { $$ = $1; }
    | update_verify_spec_list error { $$ = $1; }
;

opt_condition: /* epsilon */ { $$ = nullptr; }
    | IF L_PAREN expression R_PAREN { $$ = $3; }
;

/************************/
/* 7.4 Parser Functions */
/************************/

parser_function_declaration:
      PARSER name L_BRACE parser_statement_list R_BRACE
      { $4->name = IR::ID(@2, $2); $4->srcInfo = @1 + @5; driver.global->add($2, $4); }
;

parser_statement_list: /* epsilon */
      { $$ = new IR::V1Parser(driver.takePragmasAsAnnotations()); }
    | parser_statement_list EXTRACT L_PAREN header_ref R_PAREN SEMICOLON
      { ($$=$1)->stmts.push_back(new IR::Primitive(@2+@5, $2, $4)); }
    | parser_statement_list SET_METADATA L_PAREN field_ref COMMA expression R_PAREN SEMICOLON
      { ($$=$1)->stmts.push_back(new IR::Primitive(@2+@7, $2, $4, $6)); }
    | parser_statement_list field_ref ASSIGN expression SEMICOLON
      { ($$=$1)->stmts.push_back(new IR::Primitive(@3, "set_metadata", $2, $4)); }
    | parser_statement_list RETURN name SEMICOLON
      { ($$=$1)->default_return = IR::ID(@3, $3); }
    | parser_statement_list RETURN SELECT L_PAREN expression_list R_PAREN
      L_BRACE case_entry_list R_BRACE
        { ($$=$1)->select = $5; $$->cases = $8; }
    | parser_statement_list PARSE_ERROR name SEMICOLON
      { ($$=$1)->parse_error = IR::ID(@3, $3); }
    | parser_statement_list DROP SEMICOLON
      { ($$=$1)->drop = true; }
    | parser_statement_list error SEMICOLON { $$ = $1; }
    | parser_statement_list error { $$ = $1; }
;

case_entry_list: /* epsilon */ { $$ = new IR::Vector<IR::CaseEntry>; }
    | case_entry_list case_value_list COLON name SEMICOLON
      { $2->action = IR::ID(@4, $4); $1->srcInfo += @2 + @4; ($$=$1)->push_back($2); }
    | case_entry_list case_value_list COLON PARSE_ERROR SEMICOLON
      { $2->action = IR::ID(@4, $4); $1->srcInfo += @2 + @4; ($$=$1)->push_back($2); }
;

case_value_list:
      case_value { $$ = new IR::CaseEntry(@1);
                   $$->values.emplace_back($1); }
    | case_value_list COMMA case_value { ($$=$1)->values.emplace_back($3);
                                         $$->srcInfo += @3; }
    ;

case_value:
      const_expression
      { $$ = CaseValue($1 ? $1 : new IR::Constant(-1), new IR::Constant(-1)); }
    | const_expression MASK const_expression
      { $$ = CaseValue($1 ? $1 : new IR::Constant(-1), $3 ? $3 : new IR::Constant(0)); }
    | DEFAULT
      { $$ = CaseValue(new IR::Constant(0), new IR::Constant(0)); }
    ;

/*************************/
/* 7.6 Parser Exceptions */
/*************************/

parser_exception_declaration:
      PARSER_EXCEPTION name L_BRACE parser_statement_list R_BRACE
        { driver.clearPragmas(); }
;

/*****************/
/* 10.1 Counters */
/*****************/

counter_declaration: COUNTER name L_BRACE counter_spec_list R_BRACE
      { $4->name = IR::ID(@2, $2); $4->srcInfo = @1 + @5; driver.global->add($2, $4); }
;

counter_spec_list:
      TYPE COLON name SEMICOLON
      { ($$ = new IR::Counter(driver.takePragmasAsAnnotations()))->settype($3); }
    | counter_spec_list DIRECT COLON name SEMICOLON
      { if (($$=$1)->table)
            ::error("%s: Can't attach counter to two tables", @2+@4);
        $$->table = IR::ID(@4, $4);
        $$->direct = true; }
    | counter_spec_list STATIC COLON name SEMICOLON
      { if (($$=$1)->table)
            ::error("%s: Can't attach counter to two tables", @2+@4);
        $$->table = IR::ID(@4, $4);
        $$->direct = false; }
    | counter_spec_list INSTANCE_COUNT COLON const_expression SEMICOLON
      { ($$=$1)->instance_count = $4 ? $4->asLong() : 0; $4 = nullptr; }
    | counter_spec_list MAX_WIDTH COLON const_expression SEMICOLON
      { ($$=$1)->max_width = $4 ? $4->asLong() : 0; $4 = nullptr; }
    | counter_spec_list MIN_WIDTH COLON const_expression SEMICOLON
      { ($$=$1)->min_width = $4 ? $4->asLong() : 0; $4 = nullptr; }
    | counter_spec_list SATURATING SEMICOLON
      { ($$=$1)->saturating = true; }
    | counter_spec_list error SEMICOLON { $$ = $1; }
    | counter_spec_list error { $$ = $1; }
;

/***************/
/* 10.2 Meters */
/***************/

meter_declaration : METER name L_BRACE meter_spec_list R_BRACE
      { $4->name = IR::ID(@2, $2); $4->srcInfo = @1 + @5;
        driver.global->add($2, $4); }
;

meter_spec_list:
      TYPE COLON name SEMICOLON
      { ($$ = new IR::Meter(driver.takePragmasAsAnnotations()))->settype($3); }
    | meter_spec_list RESULT COLON field_ref SEMICOLON
      { ($$=$1)->result = $4; }
    | meter_spec_list PRE_COLOR COLON field_ref SEMICOLON
      { ($$=$1)->pre_color = $4; }
    | meter_spec_list DIRECT COLON name SEMICOLON
      { if (($$=$1)->table)
            ::error("%s: Can't attach meter to two tables", @2+@4);
        $$->table = IR::ID(@4, $4);
        $$->direct = true; }
    | meter_spec_list STATIC COLON name SEMICOLON
      { if (($$=$1)->table)
            ::error("%s: Can't attach meter to two tables", @2+@4);
        $$->table = IR::ID(@4, $4);
        $$->direct = false; }
    | meter_spec_list INSTANCE_COUNT COLON const_expression SEMICOLON
      { ($$=$1)->instance_count = $4 ? $4->asLong() : 0; $4 = nullptr; }
    | meter_spec_list IMPLEMENTATION COLON name SEMICOLON
      { ($$=$1)->implementation = IR::ID(@4, $4); }
    | meter_spec_list error SEMICOLON { $$ = $1; }
    | meter_spec_list error { $$ = $1; }
;

/******************/
/* 10.2 Registers */
/******************/

register_declaration: REGISTER name L_BRACE register_spec_list R_BRACE
      { $4->name = IR::ID(@2, $2);
        $4->srcInfo = @1 + @5;
        driver.global->add($2, $4); }
;

register_spec_list:
      WIDTH COLON const_expression SEMICOLON
      { $$ = new IR::Register(driver.takePragmasAsAnnotations());
        $$->width = $3 ? $3->asLong() : 0;
        $3 = nullptr; }
    | LAYOUT COLON name SEMICOLON
      { $$ = new IR::Register(driver.takePragmasAsAnnotations());
        $$->layout = IR::ID(@3, $3); }
    | register_spec_list DIRECT COLON name SEMICOLON
      { if (($$=$1)->table)
            ::error("%s: Can't attach register to two tables", @2+@4);
        $$->table = IR::ID(@4, $4);
        $$->direct = true; }
    | register_spec_list STATIC COLON name SEMICOLON
      { if (($$=$1)->table)
            ::error("%s: Can't attach register to two tables", @2+@4);
        $$->table = IR::ID(@4, $4);
        $$->direct = false; }
    | register_spec_list INSTANCE_COUNT COLON const_expression SEMICOLON
      { ($$=$1)->instance_count = $4 ? $4->asLong() : 0; $4 = nullptr; }
    | register_spec_list ATTRIBUTES COLON attributes SEMICOLON
      { ($$=$1)->signed_ = ($4 & 1) ? true : false;
        $1->saturating = ($4 & 2) ? true : false; }
    | register_spec_list error SEMICOLON { $$ = $1; }
    | register_spec_list error { $$ = $1; }
;

/**************************/
/* 12.1 Primitive Actions */
/**************************/

primitive_action_declaration:
    PRIMITIVE_ACTION name L_PAREN name_list R_PAREN SEMICOLON
      { driver.clearPragmas(); $4 = nullptr; }
;

name_list: name { $$ = new IR::NameList(@1, $1); }
    | name_list COMMA name { ($$=$1)->names.emplace_back(@3, $3);
                             $$->srcInfo = @1 + @3; }
    ;

opt_name_list: /* epsilon */ { $$ = nullptr; }
    | name_list { $$ = $1; }
    ;

/***************************/
/* 12.2 Action Definitions */
/***************************/

action_function_declaration:
      ACTION name L_PAREN opt_name_list R_PAREN action_function_body
      { $6->name = IR::ID(@2, $2);
        if ($4) for (auto &arg : $4->names)
            $6->args.push_back(new IR::ActionArg($2, arg));
        $4 = nullptr;
        $6->srcInfo = @1 + @6;
        driver.global->add($2, $6); }
;

action_function_body:
      L_BRACE action_statement_list R_BRACE  { $$ = $2; }
    | L_BRACE action_statement_list error R_BRACE  { $$ = $2; }
;

action_statement_list: /* epsilon */
      { $$ = new IR::ActionFunction(driver.takePragmasAsAnnotations()); }
    | action_statement_list name L_PAREN opt_expression_list R_PAREN SEMICOLON
      { ($$ = $1)->action.push_back(new IR::Primitive(@2+@5, $2, $4)); }
    | action_statement_list field_ref ASSIGN expression SEMICOLON
      { ($$ = $1)->action.push_back(new IR::Primitive(@3, "modify_field", $2, $4)); }
    | action_statement_list field_ref L_PAREN opt_expression_list R_PAREN SEMICOLON
      { ($$ = $1)->action.push_back(new IR::Primitive(@2+@5, $2->member, $2->expr, $4)); }
    | action_statement_list error SEMICOLON
      { $$ = $1; }
;

/***************************/
/* Action Profile Definitions */
/***************************/

action_profile_declaration: ACTION_PROFILE name L_BRACE action_profile_body R_BRACE
      { $4->name = IR::ID(@2, $2); $4->srcInfo = @1 + @5; driver.global->add($2, $4); }
    ;

action_profile_body: /* epsilon */
      { $$ = new IR::ActionProfile(driver.takePragmasAsAnnotations()); }
    | action_profile_body ACTIONS L_BRACE action_list R_BRACE
      { ($$=$1)->actions = $4->names; $4 = nullptr; }
    | action_profile_body SIZE COLON const_expression SEMICOLON
      { ($$=$1)->size = $4 ? $4->asLong() : 0; $4 = nullptr; }
    | action_profile_body DYNAMIC_ACTION_SELECTION COLON name SEMICOLON
      { ($$=$1)->selector = IR::ID(@4, $4); }
    ;

action_selector_declaration: ACTION_SELECTOR name L_BRACE action_selector_body R_BRACE
      { $4->name = IR::ID(@2, $2); $4->srcInfo = @1 + @5; driver.global->add($2, $4); }
    ;

action_selector_body: /* epsilon */
      { $$ = new IR::ActionSelector(driver.takePragmasAsAnnotations()); }
    | action_selector_body SELECTION_KEY COLON name SEMICOLON
      { ($$=$1)->key = IR::ID(@4, $4); }
    | action_selector_body SELECTION_MODE COLON name SEMICOLON
      { ($$=$1)->mode = IR::ID(@4, $4); }
    | action_selector_body SELECTION_TYPE COLON name SEMICOLON
      { ($$=$1)->type = IR::ID(@4, $4); }
    ;

/*************************/
/* 13 Table Declarations */
/*************************/

table_declaration: TABLE name L_BRACE table_body R_BRACE
      { $4->name = IR::ID(@2, $2);
        $4->srcInfo = @1 + @5;
        driver.global->add($2, $4); }
;

table_body: /* epsilon */
      { $$ = new IR::V1Table(driver.takePragmasAsAnnotations()); }
    | table_body READS L_BRACE field_match_list R_BRACE
      { ($$=$1)->reads = $4; }
    | table_body ACTIONS L_BRACE action_list R_BRACE
      { ($$=$1)->actions = $4->names; $4 = nullptr; }
    | table_body ACTION_PROFILE COLON name SEMICOLON
      { ($$=$1)->action_profile = IR::ID(@4, $4); }
    | table_body MIN_SIZE COLON const_expression SEMICOLON
      { ($$=$1)->min_size = $4 ? $4->asLong() : 0; $4 = nullptr; }
    | table_body MAX_SIZE COLON const_expression SEMICOLON
      { ($$=$1)->max_size = $4 ? $4->asLong() : 0; $4 = nullptr; }
    | table_body SIZE COLON const_expression SEMICOLON
      { ($$=$1)->size = $4 ? $4->asLong() : 0; $4 = nullptr; }
    | table_body DEFAULT_ACTION COLON name SEMICOLON
      { ($$=$1)->default_action = IR::ID(@4, $4); }
    | table_body DEFAULT_ACTION COLON name
      L_PAREN opt_expression_list R_PAREN SEMICOLON
        { ($$=$1)->default_action = IR::ID(@4, $4);
          $$->default_action_args = $6; }
    | table_body IDENTIFIER COLON expression SEMICOLON
      { auto exp = new IR::ExpressionValue(@4, $4);
        auto prop = new IR::Property(@2, IR::ID(@2, $2), exp, false);
        $1->addProperty(prop);
        $$ = $1; }
    | table_body error SEMICOLON { $$=$1; }
    | table_body error { $$=$1; }
;

field_match_list: /* epsilon */ { $$ = new IR::Vector<IR::Expression>(); }
    | field_match_list field_or_masked_ref COLON name SEMICOLON
      { ($$=$1)->push_back($2);
        $$->srcInfo += @2 + @4;
        $<IR::V1Table*>-2->reads_types.push_back(IR::ID(@4, $4)); }
    | field_match_list header_ref COLON VALID SEMICOLON
      { ($$=$1)->push_back(new IR::Primitive(@2+@4, $4, $2));
        $$->srcInfo += @2 + @4;
        $<IR::V1Table*>-2->reads_types.push_back(IR::ID(@4, $4)); }
    | field_match_list error SEMICOLON { $$ = $1; }
    | field_match_list error { $$ = $1; }
;

field_or_masked_ref:
      field_ref { $$ = $1; }
    | field_ref MASK const_expression
      { $$ = new IR::Mask(@2, $1, $3); }
    | header_ref DOT VALID
      { $$ = new IR::Primitive(@1+@3, $3, $1); }
    | header_ref DOT VALID MASK const_expression
      { $$ = new IR::Mask(@4, new IR::Primitive(@1+@3, $3, $1), $5); }
;

action_list: /* epsilon */ { $$ = new IR::NameList(); }
    | action_list name SEMICOLON { ($$=$1)->names.emplace_back(@2, $2); }
;

/*****************************************/
/* 14 Packet Processing and Control Flow */
/*****************************************/

control_function_declaration: CONTROL name L_BRACE control_statement_list R_BRACE
      { driver.global->add($2, new IR::V1Control(@1+@5, IR::ID(@2, $2), $4,
                                                 driver.takePragmasAsAnnotations())); }
;

control_statement_list: /* epsilon */ { $$ = new IR::Vector<IR::Expression>; }
    | control_statement_list APPLY L_PAREN name R_PAREN SEMICOLON
      { ($$=$1)->push_back(new IR::Apply(@2+@5, IR::ID(@4, $4))); }
    | control_statement_list APPLY L_PAREN name R_PAREN L_BRACE apply_case_list R_BRACE
      { $7->name = IR::ID(@4, $4); $7->srcInfo = @2+@5; ($$=$1)->push_back($7); }
    | control_statement_list IF L_PAREN expression R_PAREN
      L_BRACE control_statement_list R_BRACE opt_else
        { ($$=$1)->push_back(new IR::If(@2+@4, $4, $7, $9)); }
    | control_statement_list name L_PAREN R_PAREN SEMICOLON
      { ($$=$1)->push_back(new IR::Primitive(@2+@4, $2)); }
    | control_statement_list error SEMICOLON { $$ = $1; }
    | control_statement_list error { $$ = $1; }
;

opt_else: /* epsilon */ { $$ = nullptr; }
    | ELSE L_BRACE control_statement_list R_BRACE
      { $$ = $3; }
    | ELSE IF L_PAREN expression R_PAREN L_BRACE control_statement_list R_BRACE opt_else
      { $$ = new IR::Vector<IR::Expression>(new IR::If(@2+@5, $4, $7, $9)); }
;

apply_case_list: /* epsilon */ { $$ = new IR::Apply; }
    | apply_case_list name_list L_BRACE control_statement_list R_BRACE
        { for (auto name : $2->names)
              $1->actions[name] = $4;
          $$ = $1; }
    | apply_case_list DEFAULT L_BRACE control_statement_list R_BRACE
        { ($$=$1)->actions["default"] = $4; }
;

/************/
/* blackbox */
/************/

blackbox_type_declaration: BLACKBOX_TYPE name L_BRACE blackbox_body R_BRACE
      { driver.global->add($2,
          new IR::Type_Extern(@1+@5, IR::ID(@2, $2), *$4.methods,
                              *$4.attribs, driver.takePragmasAsAnnotations())); }
;

blackbox_body: /* epsilon */ {
            $$.methods = new IR::Vector<IR::Method>;
            $$.attribs = new IR::NameMap<IR::Attribute, ordered_map>; }
    | blackbox_body ATTRIBUTE name L_BRACE blackbox_attribute R_BRACE
          { ($$=$1).attribs->addUnique($3, $5); }
    | blackbox_body METHOD name L_PAREN opt_argument_list R_PAREN SEMICOLON
          { ($$=$1).methods->push_back(new IR::Method(@2+@3, $3,
                new IR::Type_Method(@4+@6, IR::Type::Void::get(), $5))); }
    | blackbox_body METHOD name L_PAREN opt_argument_list R_PAREN
      L_BRACE blackbox_method R_BRACE
          { ($$=$1).methods->push_back(new IR::Method(@2+@3, $3,
                new IR::Type_Method(@4+@6, IR::Type::Void::get(), $5), $8)); }
    | blackbox_body error { $$ = $1; }
;

blackbox_attribute: /* epsilon */ { $$ = new IR::Attribute(@-1, $<cstring>-1); }
    | blackbox_attribute TYPE COLON type SEMICOLON { ($$=$1)->type = $4; }
    | blackbox_attribute EXPRESSION_LOCAL_VARIABLES L_BRACE opt_locals_list R_BRACE
        { ($$=$1)->locals = $4; }
    | blackbox_attribute OPTIONAL SEMICOLON
        { ($$=$1)->optional = true; }
    | blackbox_attribute error SEMICOLON { $$ = $1; }
    | blackbox_attribute error { $$ = $1; }
;

blackbox_method: { $$ = new IR::Annotations; }
    | blackbox_method READS L_BRACE opt_name_list R_BRACE
        { ($$=$1)->add(new IR::Annotation(@2, $2, driver.makeExpressionList($4))); }
    | blackbox_method WRITES L_BRACE opt_name_list R_BRACE
        { ($$=$1)->add(new IR::Annotation(@2, $2, driver.makeExpressionList($4))); }
;

opt_argument_list:
      /* epsilon */ { $$ = new IR::ParameterList; }
    | argument_list { $$ = $1; }
;

argument_list:
      argument                          { $$ = new IR::ParameterList({$1}); }
    | argument_list COMMA argument      { ($$=$1)->push_back($3); }
;

argument:
      inout type name
        { $$ = new IR::Parameter(@3, $3, $1, $2); }
    | OPTIONAL argument
        { ($$ = $2)->annotations = $2->annotations->add(new IR::Annotation(@1, $1, {})); }
;

inout: IN { $$ = IR::Direction::In; } | OUT { $$ = IR::Direction::Out; } ;

opt_locals_list: { $$ = nullptr; } | locals_list ;
locals_list:
      local_var  { ($$ = new IR::AttribLocals())->locals[$1->name] = $1; }
    | locals_list COMMA local_var  { ($$ = $1)->locals[$3->name] = $3; }
;
local_var:
      name              { $$ = new IR::AttribLocal(@1, $1); }
    | type name         { $$ = new IR::AttribLocal(@1+@2, $1, $2); }
;

blackbox_instantiation:
      BLACKBOX name name SEMICOLON
        { driver.global->add($3,
            new IR::Declaration_Instance(@3, $3, driver.takePragmasAsAnnotations(),
                                         new IR::Type_Name($2),
                                         new IR::Vector<IR::Expression>)); }
    | BLACKBOX name name L_BRACE
        { $<IR::Declaration_Instance*>$ =
            new IR::Declaration_Instance(@3, $3, driver.takePragmasAsAnnotations(),
                                         new IR::Type_Name($2),
                                         new IR::Vector<IR::Expression>); }
      blackbox_config R_BRACE
        { driver.global->add($3, $6); }
;

blackbox_config: /* epsilon */ { $$ = $<IR::Declaration_Instance*>0; }
    | blackbox_config name COLON expressions SEMICOLON
          { const IR::PropertyValue *pv;
            if ($4->size() == 1)
                pv = new IR::ExpressionValue($4->front());
            else
                pv = new IR::ExpressionListValue(std::move(*$4));
            ($$=$1)->properties.add($2, new IR::Property(@2+@4, $2, pv, false)); }
    | blackbox_config name L_BRACE expressions R_BRACE
          { auto *pv = new IR::ExpressionListValue(std::move(*$4));
            ($$=$1)->properties.add($2, new IR::Property(@2+@4, $2, pv, false)); }
    ;

expressions: /* epsilon */
      { $$ = new IR::Vector<IR::Expression>; }
    | expressions expression %prec EXPRLIST
      { ($$=$1)->push_back($2); $$->srcInfo += @2; }
    | expressions COMMA expression %prec EXPRLIST
      { ($$=$1)->push_back($3); $$->srcInfo += @3; }
;

pragma_operands: /* epsilon */
      { $$ = new IR::Vector<IR::Expression>; }
    | pragma_operands pragma_operand
      { ($$=$1)->push_back($2); $$->srcInfo += @2; }
    | pragma_operands COMMA pragma_operand
      { ($$=$1)->push_back($3); $$->srcInfo += @3; }
;

pragma_operand:
      INTEGER { $$ = parseConstant(@1, $1, 0); }
    | STRING_LITERAL { $$ = new IR::StringLiteral(@1, $1); }
    | name { $$ = new IR::StringLiteral(@1, $1); }
    | name DOT name { $$ = new IR::StringLiteral(@1+@3, $1 + '.' + $3); }
;

/***************/
/* Expressions */
/***************/

expression:
      VALID L_PAREN header_or_field_ref R_PAREN { $$ = new IR::Primitive(@1+@4, $1, $3); }
    | CURRENT L_PAREN const_expression COMMA const_expression R_PAREN
        { $$ = new IR::Primitive(@1+@6, $1, $3, $5); }
    | field_ref { $$ = $1; }
    | header_ref { $$ = $1; }
    | header_ref DOT VALID { $$ = new IR::Primitive(@1+@3, $3, $1); }
    | LATEST DOT name { $$ = new IR::Member(@1+@3,
                                            new IR::PathExpression(IR::ID(@1, $1)),
                                            IR::ID(@3, $3)); }
    | INTEGER                            { $$ = parseConstant(@1, $1, 0); }
    | L_PAREN expression R_PAREN         { $$ = $2; }
    | NOT expression %prec PREFIX        { $$ = new IR::LNot(@1, $2); }
    | COMPLEMENT expression %prec PREFIX { $$ = new IR::Cmpl(@1, $2); }
    | MINUS expression %prec PREFIX      { $$ = new IR::Neg(@1, $2); }
    | PLUS expression %prec PREFIX       { $$ = $2; }
    | expression MUL expression          { $$ = new IR::Mul(@2, $1, $3); }
    | expression DIV expression          { $$ = new IR::Div(@2, $1, $3); }
    | expression MOD expression          { $$ = new IR::Mod(@2, $1, $3); }
    | expression PLUS expression         { $$ = new IR::Add(@2, $1, $3); }
    | expression MINUS expression        { $$ = new IR::Sub(@2, $1, $3); }
    | expression SHL expression          { $$ = new IR::Shl(@2, $1, $3); }
    | expression SHR expression          { $$ = new IR::Shr(@2, $1, $3); }
    | expression LE expression           { $$ = new IR::Leq(@2, $1, $3); }
    | expression GE expression           { $$ = new IR::Geq(@2, $1, $3); }
    | expression L_ANGLE expression      { $$ = new IR::Lss(@2, $1, $3); }
    | expression R_ANGLE expression      { $$ = new IR::Grt(@2, $1, $3); }
    | expression NE expression           { $$ = new IR::Neq(@2, $1, $3); }
    | expression EQ expression           { $$ = new IR::Equ(@2, $1, $3); }
    | expression BIT_AND expression      { $$ = new IR::BAnd(@2, $1, $3); }
    | expression BIT_XOR expression      { $$ = new IR::BXor(@2, $1, $3); }
    | expression BIT_OR expression       { $$ = new IR::BOr(@2, $1, $3); }
    | expression AND expression          { $$ = new IR::LAnd(@2, $1, $3); }
    | expression OR expression           { $$ = new IR::LOr(@2, $1, $3); }
    | TRUE                               { $$ = new IR::BoolLiteral(@1, true); }
    | FALSE                              { $$ = new IR::BoolLiteral(@1, false); }
;

header_or_field_ref:
      header_ref { $$ = $1; }
    | field_ref { $$ = $1; }
;

header_ref:
      name      { $$ = new IR::PathExpression(IR::ID(@1, $1)); }
    | header_ref L_BRACKET expression R_BRACKET
        { $$ = new IR::HeaderStackItemRef(@1+@4, $1, $3); }
;

field_ref: header_ref DOT name
         { $$ = new IR::Member(@1+@3, $1, IR::ID(@3, $3)); }
;


const_expression: expression
        { if (!($$ = driver.constantFold(&*$1)))
                ::error("%s: Non constant expression", @1); }
;

expression_list:
      expression { $$ = new IR::Vector<IR::Expression>($1); $$->srcInfo = @1; }
    | expression_list COMMA expression { ($$=$1)->push_back($3); $$->srcInfo += @3; }
    ;

opt_expression_list: /* epsilon */ { $$ = nullptr; } | expression_list { $$ = $1; }

name: IDENTIFIER { $$ = $1; }
    | ACTION { $$ = $1; }
    | ACTIONS { $$ = $1; }
    | ACTION_PROFILE { $$ = $1; }
    | ACTION_SELECTOR { $$ = $1; }
    | ALGORITHM { $$ = $1; }
    | ATTRIBUTE { $$ = $1; }
    | ATTRIBUTES { $$ = $1; }
    | BIT { $$ = $1; }
    | BLACKBOX { $$ = $1; }
    | BLACKBOX_TYPE { $$ = $1; }
    | BLOCK { $$ = $1; }
    | BOOL { $$ = $1; }
    | CALCULATED_FIELD { $$ = $1; }
    | CONTROL { $$ = $1; }
    | COUNTER { $$ = $1; }
    | DEFAULT_ACTION { $$ = $1; }
    | DIRECT { $$ = $1; }
    | DROP { $$ = $1; }
    | DYNAMIC_ACTION_SELECTION { $$ = $1; }
    | EXPRESSION { $$ = $1; }
    | EXPRESSION_LOCAL_VARIABLES { $$ = $1; }
    | EXTRACT { $$ = $1; }
    | FIELD_LIST { $$ = $1; }
    | FIELD_LIST_CALCULATION { $$ = $1; }
    | FIELDS { $$ = $1; }
    | HEADER { $$ = $1; }
    | HEADER_TYPE { $$ = $1; }
    | IMPLEMENTATION { $$ = $1; }
    | IN { $$ = $1; }
    | INPUT { $$ = $1; }
    | INSTANCE_COUNT { $$ = $1; }
    | INT { $$ = $1; }
    | LAYOUT { $$ = $1; }
    | LENGTH { $$ = $1; }
    | MASK { $$ = $1; }
    | MAX_LENGTH { $$ = $1; }
    | MAX_SIZE { $$ = $1; }
    | MAX_WIDTH { $$ = $1; }
    | METADATA { $$ = $1; }
    | METER { $$ = $1; }
    | METHOD { $$ = $1; }
    | MIN_SIZE { $$ = $1; }
    | MIN_WIDTH { $$ = $1; }
    | OPTIONAL { $$ = $1; }
    | OUT { $$ = $1; }
    | OUTPUT_WIDTH { $$ = $1; }
    | PARSER { $$ = $1; }
    | PARSER_EXCEPTION { $$ = $1; }
    | PRE_COLOR { $$ = $1; }
    | PRIMITIVE_ACTION { $$ = $1; }
    | READS { $$ = $1; }
    | REGISTER { $$ = $1; }
    | RESULT { $$ = $1; }
    | RETURN { $$ = $1; }
    | SATURATING { $$ = $1; }
    | SELECTION_KEY { $$ = $1; }
    | SELECTION_MODE { $$ = $1; }
    | SELECTION_TYPE { $$ = $1; }
    | SET_METADATA { $$ = $1; }
    | SIGNED { $$ = $1; }
    | SIZE { $$ = $1; }
    | STATIC { $$ = $1; }
    | STRING { $$ = $1; }
    | TABLE { $$ = $1; }
    | TYPE { $$ = $1; }
    | UPDATE { $$ = $1; }
    | VERIFY { $$ = $1; }
    | WIDTH { $$ = $1; }
    | WRITES { $$ = $1; }
    ;

%%

void V1::V1Parser::error(const Util::SourceInfo& location,
                         const std::string& message) {
    driver.onParseError(location, message);
}
