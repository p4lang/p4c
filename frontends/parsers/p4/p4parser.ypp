/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Use Bison's C++ mode.
%skeleton "lalr1.cc" /* -*-C++-*- */
%require "3.0.0"

// Set up names.
%defines
%define api.namespace {P4}
%define parser_class_name {P4Parser}

// Use the C++-native variant representation of tokens.
%define api.token.constructor
%define api.value.type variant

// Add asserts to ensure that we use the API correctly.
%define parse.assert true

// Enable verbose error reporting.
%error-verbose

// Declare dependencies.
%code requires {
namespace P4 {
class P4Lexer;
class P4ParserDriver;

// This is a workaround for an UndefinedBehaviorSanitizer issue triggered by
// Bison's variant implementation. When variant::move() is used to move a value
// from an initialized instance of variant to an uninitialized instance, it uses
// placement new to initialize the uninitialized instance, then calls
// variant::swap(), then destroys the moved-from instance. The problem is that
// placement new does not perform any initialization for primitive types, and
// for bool or enum types that can result in a value that isn't a valid element
// of those types, which UndefinedBehaviorSanitizer doesn't like.
struct OptionalConst {
    OptionalConst() = default;
    explicit OptionalConst(bool isConst) : isConst(isConst) { }
    bool isConst = false;
};
}  // namespace P4

inline std::ostream& operator<<(std::ostream& out, const P4::OptionalConst& oc) {
    out << "OptionalConst(" << oc.isConst << ')';
    return out;
}

// Bison uses the types you provide to %type to make constructors for the
// variant type it uses under the hood, but its code generation is a little
// naive and it always prepends 'const' to the type. This is problematic when
// the symbol type we want is itself const, since duplicate const qualifiers are
// forbidden in C++. We avoid the problem using a typedef.
typedef const IR::Type ConstType;

#ifndef YYDEBUG
#define YYDEBUG 1
#endif

#define YY_NULLPTR nullptr

#include "frontends/common/constantParsing.h"
#include "lib/cstring.h"
#include "lib/source_file.h"
}

%param { P4::P4ParserDriver& driver }
%parse-param { P4::P4Lexer& lexer }

// Use location tracking with our custom location type.
%locations
%define api.location.type {Util::SourceInfo}

%{ /* -*-C++-*- */
#include <cassert>   // NOLINT(build/include_order)
#include <iostream>  // NOLINT(build/include_order)

#include "frontends/parsers/parserDriver.h"
#include "frontends/parsers/p4/p4lexer.hpp"
#include "frontends/parsers/p4/p4parser.hpp"
#include "ir/ir.h"

#define YYLLOC_DEFAULT(Cur, Rhs, N)                                             \
    ((Cur) = (N) ? YYRHSLOC(Rhs, 1) + YYRHSLOC(Rhs, N)                          \
                 : Util::SourceInfo(driver.sources, YYRHSLOC(Rhs, 0).getEnd()))

#undef yylex
#define yylex lexer.yylex

%}

// Use iostreams to print all values.
%printer { yyoutput << $$; } <*>;

%define api.token.prefix {TOK_}
%token      END
%token      UNEXPECTED_TOKEN
%token      LE "<="
%token      GE ">="
%token      SHL "<<"
%token      AND "&&"
%token      OR "||"
%token      NE "!="
%token      EQ "=="
%token      PLUS "+"
%token      MINUS "-"
%token      MUL "*"
%token      DIV "/"
%token      MOD "%"
%token      BIT_OR "|"
%token      BIT_AND "&"
%token      BIT_XOR "^"
%token      COMPLEMENT "~"
%token      L_BRACKET "["
%token      R_BRACKET "]"
%token      L_BRACE "{"
%token      R_BRACE "}"
%token      L_ANGLE "<"
%token      R_ANGLE ">"
%token      L_PAREN "("
%token      R_PAREN ")"
%token      NOT "!"
%token      COLON ":"
%token      COMMA ","
%token      QUESTION "?"
%token      DOT "."
%token      ASSIGN "="
%token      SEMICOLON ";"
%token      AT "@"
%token      PP "++"
%token      DONTCARE "_"
%token      MASK "&&&"
%token      RANGE ".."
%token      TRUE FALSE THIS
%token      ABSTRACT ACTION ACTIONS APPLY BOOL BIT CONST CONTROL DATA DEFAULT
            ELSE ENTRIES ENUM ERROR EXIT EXTERN HEADER HEADER_UNION IF IN INOUT
            INT KEY SELECT MATCH_KIND OUT PACKAGE PARSER RETURN STATE STRUCT
            SWITCH TABLE TRANSITION TUPLE TYPEDEF VARBIT VALUESET VOID

%token<cstring> IDENTIFIER TYPE STRING_LITERAL
%token<UnparsedConstant>  INTEGER

%type<IR::ID*>              name nonTypeName
%type<IR::Direction>        direction
%type<IR::Path*>            prefixedNonTypeName prefixedType
%type<IR::IndexedVector<IR::Type_Var>*>  typeParameterList
%type<IR::TypeParameters*>  optTypeParameters
%type<IR::Expression*>      expression lvalue keysetExpression selectExpression
                            stateExpression optInitializer initializer
                            simpleKeysetExpression transitionStatement switchLabel
%type<ConstType*>           baseType typeOrVoid specializedType headerStackType
                            typeRef tupleType typeArg realTypeArg namedType
%type<IR::Type_Name*>       typeName
%type<IR::Argument*>        argument
%type<IR::Vector<IR::Argument>*>  argumentList nonEmptyArgList
%type<IR::Parameter*>       parameter
%type<OptionalConst>        optCONST
%type<IR::Annotations*>     optAnnotations
%type<IR::Vector<IR::Annotation>*>  annotations
%type<IR::Annotation*>      annotation
%type<IR::IndexedVector<IR::Parameter>*>  parameterList nonEmptyParameterList
                                          optConstructorParameters
%type<IR::Vector<IR::Expression>*>        expressionList
                                          simpleExpressionList tupleKeysetExpression
%type<IR::IndexedVector<IR::Declaration_ID>*>  identifierList
%type<IR::SelectCase*>      selectCase
%type<IR::Vector<IR::SelectCase>*>  selectCaseList
%type<IR::Statement*>       statement emptyStatement returnStatement
                            switchStatement exitStatement
                            assignmentOrMethodCallStatement conditionalStatement
                            directApplication
%type<IR::BlockStatement*>  blockStatement parserBlockStatement controlBody
                            objInitializer
%type<IR::StatOrDecl*>      statementOrDeclaration parserStatement
%type<IR::IndexedVector<IR::StatOrDecl>*>  objDeclarations statOrDeclList
                                           parserStatements
%type<IR::SwitchCase*>      switchCase
%type<IR::Vector<IR::SwitchCase>*>  switchCases
%type<IR::Vector<IR::Type>*>  typeArgumentList realTypeArgumentList
%type<IR::ParserState*>     parserState
%type<IR::IndexedVector<IR::ParserState>*>  parserStates
%type<IR::Declaration*>     constantDeclaration actionDeclaration
                            variableDeclaration instantiation functionDeclaration
                            objDeclaration tableDeclaration controlLocalDeclaration
                            parserLocalElement valueSetDeclaration
%type<IR::Type_Declaration*>  headerTypeDeclaration structTypeDeclaration
                              headerUnionDeclaration derivedTypeDeclaration
                              parserDeclaration controlDeclaration enumDeclaration
                              typedefDeclaration packageTypeDeclaration typeDeclaration
%type<IR::Type_Error*>      errorDeclaration
%type<IR::Node*>            declaration externDeclaration matchKindDeclaration
%type<IR::Type_Parser*>     parserTypeDeclaration
%type<IR::Type_Control*>    controlTypeDeclaration
%type<IR::IndexedVector<IR::Declaration>*>  parserLocalElements controlLocalDeclarations
%type<IR::StructField*>     structField
%type<IR::IndexedVector<IR::StructField>*>  structFieldList
%type<IR::Method*>          methodPrototype functionPrototype
%type<IR::Vector<IR::Method>*>  methodPrototypes
%type<IR::Property*>        tableProperty
%type<IR::IndexedVector<IR::Property>*>  tablePropertyList
%type<IR::KeyElement*>      keyElement
%type<IR::Vector<IR::KeyElement>*>  keyElementList
%type<IR::ActionListElement*>  actionRef
%type<IR::IndexedVector<IR::ActionListElement>*>  actionList
%type<IR::Entry*>           entry
%type<IR::Vector<IR::Entry>*>  entriesList
%type<IR::MethodCallExpression*>  actionBinding

%left COMMA
%nonassoc QUESTION
%nonassoc COLON
%left OR
%left AND
%left EQ NE
%left L_ANGLE R_ANGLE LE GE
%left BIT_OR
%left BIT_XOR
%left BIT_AND
%left SHL
%left PP PLUS MINUS
%left MUL DIV MOD
%right PREFIX
%nonassoc R_BRACKET L_PAREN L_BRACKET
%left DOT

%right THEN ELSE /* THEN is a fake token */

%%

/*
   This grammar may look weird in some places, but a lot of effort was put into
   eliminating conflicts.  This sometimes required having the grammar be more
   lenient than necessary.  Moreover, the grammar is context-sensitive, and it
   needs some rudiments of type information to properly perform parsing.  This
   is done with the help of P4ParserDriver's "structure" object, which keeps
   track of which identifiers represent types, and which represent namespaces.
*/

program : input END { YYACCEPT; };

input
    : /* epsilon */
    | input declaration  { if ($2) driver.declarations->push_back($2->getNode()); }
    | input ";"          {}   // empty declaration
    ;

declaration
    : constantDeclaration     { $$ = $1; }
    | externDeclaration       { $$ = $1; }
    | actionDeclaration       { $$ = $1; }
    | parserDeclaration       { $$ = $1; }
    | typeDeclaration         { $$ = $1; }
    | controlDeclaration      { $$ = $1; }
    | instantiation           { $$ = $1; }
    | errorDeclaration        { driver.onReadErrorDeclaration($1); $$ = nullptr; }
    | matchKindDeclaration    { $$ = $1; }
    ;

nonTypeName
    : IDENTIFIER  { $$ = new IR::ID(@1, $1); }
    | APPLY       { $$ = new IR::ID(@1, "apply"); }
    | KEY         { $$ = new IR::ID(@1, "key"); }
    | ACTIONS     { $$ = new IR::ID(@1, "actions"); }
    | STATE       { $$ = new IR::ID(@1, "state"); }
    | ENTRIES     { $$ = new IR::ID(@1, "entries"); }
    ;

name
    : nonTypeName { $$ = $1; }
    | TYPE        { $$ = new IR::ID(@1, $1); }
    ;

optCONST
    : /* empty */ { $$ = OptionalConst{false}; }
    | CONST       { $$ = OptionalConst{true}; }
    ;

optAnnotations
    : /* empty */ { $$ = IR::Annotations::empty; }
    | annotations { $$ = new IR::Annotations(@1, *$1); }
    ;

annotations
    : annotation  { $$ = new IR::Vector<IR::Annotation>(); $$->push_back($1); }
    | annotations annotation { $$ = $1; $$->push_back($2); }
    ;

annotation
    : "@" name                        { $$ = new IR::Annotation(@1, *$2, {}); }
    | "@" name "(" expressionList ")" { $$ = new IR::Annotation(@1, *$2, *$4); }
    ;

parameterList
    : /* empty */                        { $$ = new IR::IndexedVector<IR::Parameter>(); }
    | nonEmptyParameterList              { $$ = $1; }
    ;

nonEmptyParameterList
    : parameter                           { $$ = new IR::IndexedVector<IR::Parameter>();
                                            $$->push_back($1); }
    | nonEmptyParameterList "," parameter { $$ = $1; $$->push_back($3); }
    ;

parameter
    : optAnnotations direction typeRef name { $$ = new IR::Parameter(@4, *$4, $1, $2, $3); }
    ;

direction
    : IN           { $$ = IR::Direction::In; }
    | OUT          { $$ = IR::Direction::Out; }
    | INOUT        { $$ = IR::Direction::InOut; }
    | /* empty */  { $$ = IR::Direction::None; }
    ;

packageTypeDeclaration
    : optAnnotations PACKAGE name { driver.structure->pushContainerType(*$3, false); }
      optTypeParameters { driver.structure->declareTypes(&$5->parameters); }
      "(" parameterList ")"        { auto pl = new IR::ParameterList(@8, *$8);
                                     $$ = new IR::Type_Package(@3, *$3, $1, $5, pl); }
    ;

instantiation
      : annotations typeRef "(" argumentList ")" name ";"
                     { $$ = new IR::Declaration_Instance(@6, *$6, new IR::Annotations(*$1),
                                                         $2, $4);
                       driver.structure->declareObject(*$6); }
      | typeRef "(" argumentList ")" name ";"
                     { $$ = new IR::Declaration_Instance(@5, *$5, $1, $3);
                       driver.structure->declareObject(*$5); }
      /* experimental */
      | annotations typeRef "(" argumentList ")" name "=" objInitializer ";"
                     { $$ = new IR::Declaration_Instance(@6, *$6, new IR::Annotations(*$1),
                                                         $2, $4, $8);
                       driver.structure->declareObject(*$6); }
      /* experimental */
      | typeRef "(" argumentList ")" name "=" objInitializer ";"
                     { $$ = new IR::Declaration_Instance(@5, *$5, $1, $3, $7);
                       driver.structure->declareObject(*$5); }
    ;

/* experimental; includes the following 3 productions */
objInitializer
    : "{" { driver.structure->pushNamespace(@1, false); } objDeclarations "}"
                               { driver.structure->pop();
                                 $$ = new IR::BlockStatement(@1+@4, *$3); }
    ;

objDeclarations
    : /* empty */                    { $$ = new IR::IndexedVector<IR::StatOrDecl>(); }
    | objDeclarations objDeclaration { $$ = $1; $1->push_back($2); }
    ;

objDeclaration
    : functionDeclaration      { $$ = $1; }
    | instantiation            { $$ = $1; }
    ;

optConstructorParameters
    : /* empty */            { $$ = new IR::IndexedVector<IR::Parameter>(); }
    | "(" parameterList ")"  { $$ = $2; }
    ;

dotPrefix
    : "."                      { driver.structure->startAbsolutePath(); }
    ;

/**************************** PARSER ******************************/

parserDeclaration
    : parserTypeDeclaration optConstructorParameters
      "{" parserLocalElements parserStates "}"
                             { driver.structure->pop();
                               auto pl = new IR::ParameterList(@2, *$2);
                               $$ = new IR::P4Parser($1->name.srcInfo, $1->name,
                                                     $1, pl, *$4, *$5);}
    ;

parserLocalElements
    : /* empty */                     { $$ = new IR::IndexedVector<IR::Declaration>(); }
    | parserLocalElements parserLocalElement { $$ = $1; $$->push_back($2); }
    ;

parserLocalElement
    : constantDeclaration             { $$ = $1; }
    | instantiation                   { $$ = $1; }
    | variableDeclaration             { $$ = $1; }
    | valueSetDeclaration             { $$ = $1; }
    ;

parserTypeDeclaration
    : optAnnotations
        PARSER name       { driver.structure->pushContainerType(*$3, false); }
        optTypeParameters { driver.structure->declareTypes(&$5->parameters); }
        "(" parameterList ")" { auto pl = new IR::ParameterList(@8, *$8);
                                $$ = new IR::Type_Parser(@3, *$3, $1, $5, pl); }
    ;

parserStates
    : parserState                     { $$ = new IR::IndexedVector<IR::ParserState>();
                                        $$->push_back($1); }
    | parserStates parserState        { $$ = $1; $$->push_back($2); }
    ;

parserState
    : optAnnotations STATE name { driver.structure->pushContainerType(*$3, false); }
      "{" parserStatements transitionStatement "}"
                                      { driver.structure->pop();
                                        $$ = new IR::ParserState(@3, *$3, $1, *$6, $7); }
    ;

parserStatements
    : /* empty */                      { $$ = new IR::IndexedVector<IR::StatOrDecl>(); }
    | parserStatements parserStatement { $$ = $1; $1->push_back($2); }
    ;

parserStatement
    : assignmentOrMethodCallStatement { $$ = $1; }
    | directApplication               { $$ = $1; }
    | variableDeclaration             { $$ = $1; }
    | constantDeclaration             { $$ = $1; }
    | parserBlockStatement            { $$ = $1; }
    ;

parserBlockStatement
    : optAnnotations "{" parserStatements "}"
      { $$ = new IR::BlockStatement(@1+@4, $1, *$3); }
    ;

transitionStatement
    : /* empty */                 { $$ = nullptr; }
    | TRANSITION stateExpression  { $$ = $2; }
    ;

stateExpression
    : name ";"         { $$ = new IR::PathExpression(*$1); }
    | selectExpression { $$ = $1; }
    ;

selectExpression
    : SELECT "(" expressionList ")" "{" selectCaseList "}"
                              { $$ = new IR::SelectExpression(@1 + @7,
                                     new IR::ListExpression(@3, *$3), std::move(*$6)); }
    ;

selectCaseList
    : /* empty */                { $$ = new IR::Vector<IR::SelectCase>(); }
    | selectCaseList selectCase  { $$ = $1; $$->push_back($2); }
    ;

selectCase
    : keysetExpression ":" name ";"
      { auto expr = new IR::PathExpression(*$3);
        $$ = new IR::SelectCase(@1 + @3, $1, expr); }
    ;

keysetExpression
    : tupleKeysetExpression     { $$ = new IR::ListExpression(@1, *$1); }
    | simpleKeysetExpression    { $$ = $1; }
    ;

tupleKeysetExpression
    /* at least two elements in the tuple */
    : "(" simpleKeysetExpression "," simpleExpressionList ")"
                                { $$ = $4; $4->insert($4->begin(), $2); }
    ;

simpleExpressionList
    : simpleKeysetExpression { $$ = new IR::Vector<IR::Expression>(); $$->push_back($1); }
    | simpleExpressionList "," simpleKeysetExpression { $$ = $1; $$->push_back($3); }
    ;

simpleKeysetExpression
    : expression                  { $$ = $1; }
    | expression "&&&" expression { $$ = new IR::Mask(@1 + @3, $1, $3); }
    | expression ".." expression  { $$ = new IR::Range(@1 + @3, $1, $3); }
    | DEFAULT                     { $$ = new IR::DefaultExpression(@1); }
    | "_"                         { $$ = new IR::DefaultExpression(@1); }
    ;

// experimental
valueSetDeclaration
    : optAnnotations
        VALUESET "<" baseType ">" "(" expression ")" name ";"
        { $$ = new IR::P4ValueSet(@9, *$9, $1, $4, $7); }
    | optAnnotations
        VALUESET "<" tupleType ">" "(" expression ")" name ";"
        { $$ = new IR::P4ValueSet(@9, *$9, $1, $4, $7); }
    | optAnnotations
        VALUESET "<" typeName ">" "(" expression ")" name ";"
        { $$ = new IR::P4ValueSet(@9, *$9, $1, $4, $7); }
    ;

/*************************** CONTROL ************************/

controlDeclaration
    : controlTypeDeclaration optConstructorParameters
      "{" controlLocalDeclarations APPLY controlBody "}"
        { driver.structure->pop();
          auto pl = new IR::ParameterList(@2, *$2);
          $$ = new IR::P4Control($1->name.srcInfo, $1->name, $1, pl, *$4, $6); }
    ;

controlTypeDeclaration
    : optAnnotations
        CONTROL name { driver.structure->pushContainerType(*$3, false); }
        optTypeParameters { driver.structure->declareTypes(&$5->parameters); }
        "(" parameterList ")" { auto pl = new IR::ParameterList(@8, *$8);
                                $$ = new IR::Type_Control(@3, *$3, $1, $5, pl); }
    ;

controlLocalDeclarations
    : /* empty */               { $$ = new IR::IndexedVector<IR::Declaration>(); }
    | controlLocalDeclarations controlLocalDeclaration { $$ = $1; $$->push_back($2); }
    ;

controlLocalDeclaration
    : constantDeclaration      { $$ = $1; }
    | actionDeclaration        { $$ = $1; }
    | tableDeclaration         { $$ = $1; }
    | instantiation            { $$ = $1; }
    | variableDeclaration      { $$ = $1; }
    ;

controlBody
    : blockStatement { $$ = $1; }
    ;

/*************************** EXTERN *************************/

externDeclaration
    : optAnnotations
        EXTERN nonTypeName { driver.structure->pushContainerType(*$3, true); }
        optTypeParameters { driver.structure->declareTypes(&$5->parameters); }
        "{" methodPrototypes "}" { driver.structure->pop();
                                   $$ = new IR::Type_Extern(@3, *$3, $5, *$8, $1); }
    | optAnnotations EXTERN functionPrototype ";" { $$ = $3; $3->annotations = $1; }
    | optAnnotations EXTERN name ";" {
            // forward declaration;
            driver.structure->pushContainerType(*$3, true);
            driver.structure->pop();
            $$ = nullptr; }
    ;

methodPrototypes
    : /* empty */                      { $$ = new IR::Vector<IR::Method>(); }
    | methodPrototypes methodPrototype { $$ = $1; $1->push_back($2); }
    ;

functionPrototype
    : typeOrVoid
        name optTypeParameters { driver.structure->pushNamespace(@2, false);
                                 driver.structure->declareTypes(&$3->parameters); }
        "(" parameterList ")" { driver.structure->pop(); }
                           { auto params = new IR::ParameterList(@6, *$6);
                             auto mt = new IR::Type_Method(@2, $3, $1, params);
                             $$ = new IR::Method(@2, *$2, mt); }
    ;

methodPrototype
    : optAnnotations functionPrototype ";" { $$ = $2; $2->annotations = $1; }
    | optAnnotations ABSTRACT functionPrototype ";"    { $$ = $3; $$->setAbstract();
                                                         $3->annotations = $1; }  // experimental
    | optAnnotations TYPE "(" parameterList ")" ";"  // constructor
                                        { auto par = new IR::ParameterList(@4, *$4);
                                          auto mt = new IR::Type_Method(@2, par);
                                          $$ = new IR::Method(@2, IR::ID(@2, $2), mt, $1); }
    ;

/************************** TYPES ****************************/

typeRef
    : baseType                         { $$ = $1; }
    | typeName                         { $$ = $1; }
    | specializedType                  { $$ = $1; }
    | headerStackType                  { $$ = $1; }
    | tupleType                        { $$ = $1; }
    ;

namedType
    : typeName                         { $$ = $1; }
    | specializedType                  { $$ = $1; }
    ;

prefixedType
    : TYPE                             { $$ = new IR::Path(IR::ID(@1, $1)); }
    | dotPrefix TYPE                   { $$ = new IR::Path(IR::ID(@2, $2), true);
                                         driver.structure->clearPath(); }
    ;

typeName
    : prefixedType                     { $$ = new IR::Type_Name(@1, $1); }
    ;

tupleType
    : TUPLE "<" typeArgumentList ">"    { $$ = new IR::Type_Tuple(@1+@4, *$3); }
    ;

headerStackType
    : typeName "[" expression "]"       { $$ = new IR::Type_Stack(@1+@4, $1, $3); }
    ;

specializedType
    : typeName "<" typeArgumentList ">" { $$ = new IR::Type_Specialized(@1 + @4, $1, $3); }
    ;

baseType
    : BOOL   { $$ = IR::Type_Boolean::get(); }
    | ERROR  { $$ = new IR::Type_Name(@1, new IR::Path(IR::ID(@1, "error"))); }
    | BIT    { $$ = IR::Type::Bits::get(@1, 1); }
    | BIT "<" INTEGER ">"
      { $$ = IR::Type::Bits::get(@3, parseConstant(@3, $3, 0)->asInt(), false); }
    | INT "<" INTEGER ">"
      { $$ = IR::Type::Bits::get(@3, parseConstant(@3, $3, 0)->asInt(), true); }
    | VARBIT "<" INTEGER ">"
      { $$ = IR::Type::Varbits::get(@3, parseConstant(@3, $3, 0)->asInt()); }
    ;

typeOrVoid
    : typeRef                          { $$ = $1; }
    | VOID                             { $$ = IR::Type_Void::get(); }
    | nonTypeName                      { $$ = new IR::Type_Name(@1, new IR::Path(*$1)); }
        // This is necessary because template arguments may introduce the return type
    ;

optTypeParameters
    : /* empty */               { $$ = new IR::TypeParameters(); }
    | "<" typeParameterList ">" { $$ = new IR::TypeParameters(@1+@3, *$2); }
    ;

typeParameterList
    : name                           { $$ = new IR::IndexedVector<IR::Type_Var>();
                                       $$->push_back(new IR::Type_Var(@1, *$1)); }
    | typeParameterList "," name     { ($$=$1)->push_back(new IR::Type_Var(@3, *$3)); }
    ;

typeArg
    : typeRef                     { $$ = $1; }
    | nonTypeName                      { $$ = new IR::Type_Name(@1, new IR::Path(*$1)); }
        // This is necessary because template arguments may introduce the return type
    | "_"                         { $$ = new IR::Type_Dontcare(@1); }
    ;

typeArgumentList
    : typeArg                        { $$ = new IR::Vector<IR::Type>(); $$->push_back($1); }
    | typeArgumentList "," typeArg   { $$ = $1; $$->push_back($3); }
    ;

realTypeArg
    : typeRef                     { $$ = $1; }
    | "_"                         { $$ = new IR::Type_Dontcare(@1); }
    ;

// For use in contexts where the `<` might be a less-than rather than introducing a type
// argument list -- we only allow the token after `<` to be a TYPE, not an ID
realTypeArgumentList
    : realTypeArg                        { $$ = new IR::Vector<IR::Type>(); $$->push_back($1); }
    | realTypeArgumentList "," typeArg   { $$ = $1; $$->push_back($3); }
    ;

typeDeclaration
    : derivedTypeDeclaration     { $$ = $1; }
    | typedefDeclaration ";"     { $$ = $1; }
    | parserTypeDeclaration ";"  { driver.structure->pop(); $$ = $1; }
    | controlTypeDeclaration ";" { driver.structure->pop(); $$ = $1; }
    | packageTypeDeclaration ";" { driver.structure->pop(); $$ = $1; }
    ;

derivedTypeDeclaration
    : headerTypeDeclaration            { $$ = $1; }
    | headerUnionDeclaration           { $$ = $1; }
    | structTypeDeclaration            { $$ = $1; }
    | enumDeclaration                  { $$ = $1; }
    ;

headerTypeDeclaration
    : optAnnotations
        HEADER name { driver.structure->declareType(*$3); }
        "{" structFieldList "}" { $$ = new IR::Type_Header(@3, *$3, $1, *$6); }
    ;

structTypeDeclaration
    : optAnnotations
        STRUCT name { driver.structure->declareType(*$3); }
        "{" structFieldList "}" { $$ = new IR::Type_Struct(@3, *$3, $1, *$6); }
    ;

headerUnionDeclaration
    : optAnnotations
        HEADER_UNION name { driver.structure->declareType(*$3); }
        "{" structFieldList "}" { $$ = new IR::Type_HeaderUnion(@3, *$3, $1, *$6); }
    ;

structFieldList
    : /* empty */                      { $$ = new IR::IndexedVector<IR::StructField>(); }
    | structFieldList structField      { $$ = $1; $1->push_back($2); }
    ;

structField
    : optAnnotations typeRef name ";"  { $$ = new IR::StructField(@3, *$3, $1, $2); }
    ;

enumDeclaration
    : optAnnotations
        ENUM name { driver.structure->declareType(*$3); }
        "{" identifierList "}" { $$ = new IR::Type_Enum(@2, *$3, *$6); }
    ;

errorDeclaration
    : ERROR "{" identifierList "}"
        { $$ = new IR::Type_Error(@1 + @4, IR::ID(@1, "error"), *$3); }
    ;

matchKindDeclaration
    : MATCH_KIND "{" identifierList "}"
        { $$ = new IR::Declaration_MatchKind(@1 + @4, *$3); }
    ;

identifierList
    : name                    { $$ = new IR::IndexedVector<IR::Declaration_ID>();
                                $$->push_back(new IR::Declaration_ID(@1, *$1));}
    | identifierList "," name { $$ = $1; $$->push_back(new IR::Declaration_ID(@3, *$3)); }
    ;

typedefDeclaration
    : optAnnotations TYPEDEF typeRef name   { driver.structure->declareType(*$4);
          $$ = new IR::Type_Typedef(@4, *$4, new IR::Annotations(*$1), $3); }
    | optAnnotations TYPEDEF derivedTypeDeclaration name   { driver.structure->declareType(*$4);
                        $$ = new IR::Type_Typedef(@4, *$4, new IR::Annotations(*$1), $3); }
    ;

/*************************** STATEMENTS *************************/

assignmentOrMethodCallStatement
    // These rules are overly permissive, but they avoid some conflicts
    : lvalue "(" argumentList ")" ";"
        { auto mc = new IR::MethodCallExpression(@1 + @4, $1,
                                                 new IR::Vector<IR::Type>(), $3);
          $$ = new IR::MethodCallStatement(@1 + @4, mc); }

    | lvalue "<" typeArgumentList ">" "(" argumentList ")" ";"
        { auto mc = new IR::MethodCallExpression(@1 + @7,
                                                 $1, $3, $6);
          $$ = new IR::MethodCallStatement(@1 + @7, mc); }

    | lvalue "=" expression ";"
        { $$ = new IR::AssignmentStatement(@2, $1, $3); }

    ;

emptyStatement
    : ";"      { $$ = new IR::EmptyStatement(@1); }
    ;

exitStatement
    : EXIT ";" { $$ = new IR::ExitStatement(@1); }
    ;

returnStatement
    : RETURN ";"            { $$ = new IR::ReturnStatement(@1, nullptr); }
    | RETURN expression ";" { $$ = new IR::ReturnStatement(@1, $2); }
    ;

conditionalStatement
    : IF "(" expression ")" statement                 %prec THEN
        { $$ = new IR::IfStatement(@1, $3, $5, nullptr); }
    | IF "(" expression ")" statement ELSE statement  %prec THEN
        { $$ = new IR::IfStatement(@1, $3, $5, $7); }
    ;

// To support direct invocation of a control or parser without instantiation
directApplication
    : typeName "." APPLY "(" argumentList ")" ";" {
                                  auto method = new IR::Member(
                                      @1 + @3, new IR::TypeNameExpression($1), IR::ID(@3, "apply"));
                                  auto mce = new IR::MethodCallExpression(@1 + @6, method, $5);
                                  $$ = new IR::MethodCallStatement(@1 + @6, mce); }
    ;

statement
    : assignmentOrMethodCallStatement  { $$ = $1; }
    | directApplication                { $$ = $1; }
    | conditionalStatement             { $$ = $1; }
    | emptyStatement                   { $$ = $1; }
    | blockStatement                   { $$ = $1; }
    | returnStatement                  { $$ = $1; }
    | exitStatement                    { $$ = $1; }
    | switchStatement                  { $$ = $1; }
    ;

blockStatement
    : optAnnotations "{" { driver.structure->pushNamespace(@2, false); }
      statOrDeclList "}" { driver.structure->pop();
                           $$ = new IR::BlockStatement(@1 + @5, $1, *$4); }
    ;

statOrDeclList
    : /* empty */                           { $$ = new IR::IndexedVector<IR::StatOrDecl>(); }
    | statOrDeclList statementOrDeclaration { $$ = $1; $$->push_back($2); }
    ;

switchStatement
    : SWITCH "(" expression ")" "{" switchCases "}" {
            $$ = new IR::SwitchStatement(@1, $3, std::move(*$6)); }
    ;

switchCases
    : /* empty */              { $$ = new IR::Vector<IR::SwitchCase>(); }
    | switchCases switchCase   { $$ = $1; $$->push_back($2); }
    ;

switchCase
    : switchLabel ":" blockStatement { $$ = new IR::SwitchCase(@1 + @3, $1, $3); }
    | switchLabel ":" { $$ = new IR::SwitchCase(@1, $1, nullptr); }
    ;

switchLabel
    : name                     { $$ = new IR::PathExpression(*$1); }
    | DEFAULT                  { $$ = new IR::DefaultExpression(@1); }
    ;

statementOrDeclaration
    : variableDeclaration      { $$ = $1; }
    | constantDeclaration      { $$ = $1; }
    | statement                { $$ = $1; }
    | instantiation            { $$ = $1; }
    ;

/************************* TABLE *********************************/

tableDeclaration
    : optAnnotations
        TABLE name "{" tablePropertyList "}"
          { $$ = new IR::P4Table(@3, *$3, $1, new IR::TableProperties(@5, *$5)); }
    ;

tablePropertyList
    : tableProperty                      { $$ = new IR::IndexedVector<IR::Property>();
                                           $$->push_back($1); }
    | tablePropertyList tableProperty    { $$ = $1; $$->push_back($2); }
    ;

tableProperty
    : KEY "=" "{" keyElementList "}"
        { auto v = new IR::Key(@4, *$4);
          auto id = IR::ID(@1, "key");
          $$ = new IR::Property( @1 + @5, id, v, false); }
    | ACTIONS "=" "{" actionList "}"
        { auto v = new IR::ActionList(@4, *$4);
          auto id = IR::ID(@1, "actions");
          $$ = new IR::Property(@1 + @5, id, v, false); }
    | optAnnotations optCONST ENTRIES "=" "{" entriesList "}"
        { auto l = new IR::EntriesList(@3, *$6);
          auto id = IR::ID(@3+@7, "entries");
          $$ = new IR::Property(@3, id, $1, l, $2.isConst); }
    | optAnnotations optCONST IDENTIFIER "=" initializer ";"
        { auto v = new IR::ExpressionValue(@5, $5);
          auto id = IR::ID(@3, $3);
          $$ = new IR::Property(@3, id, $1, v, $2.isConst); }
    ;

keyElementList
    : /* empty */                        { $$ = new IR::Vector<IR::KeyElement>(); }
    | keyElementList keyElement          { $$ = $1; $$->push_back($2); }
    ;

keyElement
    : expression ":" name optAnnotations ";"
                                         { auto expr = new IR::PathExpression(*$3);
                                           $$ = new IR::KeyElement(@1, $4, $1, expr); }
    ;

actionList
    : /* empty */                        { $$ = new IR::IndexedVector<IR::ActionListElement>(); }
    | actionList actionRef ";"           { $$ = $1; $$->push_back($2); }
    ;

actionRef
    : optAnnotations name                { auto expr = new IR::PathExpression(*$2);
                                           $$ = new IR::ActionListElement(@2, $1, expr);}
    | optAnnotations name "(" argumentList ")"
                                         { auto method = new IR::PathExpression(*$2);
                                           auto mce = new IR::MethodCallExpression(
                                               @2+@4, method, $4);
                                           $$ = new IR::ActionListElement(@2, $1, mce); }
    ;

entry
    : keysetExpression ":" actionBinding optAnnotations ";"
                                         {
                                           assert($3->is<IR::MethodCallExpression>());
                                           if (auto l = $1->to<IR::ListExpression>())
                                             $$ = new IR::Entry(@1+@4, $4, l, $3);
                                           else {  // if not a tuple, make it a list of 1
                                             IR::Vector<IR::Expression> le($1);
                                             $$ = new IR::Entry(@1+@4, $4,
                                                                new IR::ListExpression(@1, le),
                                                                $3);
                                           }
                                         }
    ;

actionBinding
    : lvalue "(" argumentList ")"
        { $$ = new IR::MethodCallExpression(@1 + @4, $1,
                                            new IR::Vector<IR::Type>(), $3); }
    | lvalue "<" typeArgumentList ">" "(" argumentList ")"
        { $$ = new IR::MethodCallExpression(@1 + @7, $1, $3, $6); }

entriesList
    : entry                          { $$ = new IR::Vector<IR::Entry>(); $$->push_back($1); }
    | entriesList entry              { $$ = $1; $$->push_back($2); }
    ;

/************************* ACTION ********************************/

actionDeclaration
    : optAnnotations ACTION name "(" parameterList ")" blockStatement
        { auto pl = new IR::ParameterList(@5, *$5);
          $$ = new IR::P4Action(@3, *$3, $1, pl, $7); }
    ;

/************************* VARIABLES *****************************/

variableDeclaration
    : annotations typeRef name optInitializer ";"
                                     { auto ann = new IR::Annotations(@1, *$1);
                                       $$ = new IR::Declaration_Variable(@1+@4, *$3, ann, $2, $4);
                                       driver.structure->declareObject(*$3); }
    | typeRef name optInitializer ";"
                                     { $$ = new IR::Declaration_Variable(@1+@4, *$2, $1, $3);
                                       driver.structure->declareObject(*$2); }
    ;

constantDeclaration
    : optAnnotations CONST typeRef name "=" initializer ";"
                                     { $$ = new IR::Declaration_Constant(@1+@6, *$4, $1, $3, $6);
                                       driver.structure->declareObject(*$4); }
    ;

optInitializer
    : /* empty */                      { $$ = nullptr; }
    | "=" initializer                  { $$ = $2; }
    ;

initializer
    : expression                          { $$ = $1; }
    ;

/**************** Expressions ****************/

// experimental
functionDeclaration
    : functionPrototype blockStatement   { $$ = new IR::Function(@1+@2, $1->name, $1->type, $2); }
    ;

argumentList
    : /* empty */                        { $$ = new IR::Vector<IR::Argument>(); }
    | nonEmptyArgList                    { $$ = $1; }
    ;

nonEmptyArgList
    : argument                           { $$ = new IR::Vector<IR::Argument>();
                                           $$->push_back($1); }
    | nonEmptyArgList "," argument       { $$ = $1; $$->push_back($3); }
    ;

argument
    : expression                         { $$ = new IR::Argument(@1, $1); }
    | name "=" expression                { $$ = new IR::Argument(@1, *$1, $3); }
    | "_"                                { $$ = new IR::Argument(@1, new IR::DefaultExpression(@1)); }
    ;

expressionList
    : /* empty */                        { $$ = new IR::Vector<IR::Expression>(); }
    | expression                         { $$ = new IR::Vector<IR::Expression>();
                                           $$->push_back($1); }
    | expressionList "," expression      { $$ = $1; $$->push_back($3); }
    ;

prefixedNonTypeName
    : nonTypeName                        { $$ = new IR::Path(*$1); }
    | dotPrefix nonTypeName              { $$ = new IR::Path(*$2, true);
                                           driver.structure->clearPath(); }
    ;

lvalue
    : prefixedNonTypeName                { $$ = new IR::PathExpression($1); }
    | THIS                               { $$ = new IR::This(@1); }  // experimental
    | lvalue "." name                    { $$ = new IR::Member(@1 + @3, $1, *$3); }
    | lvalue "[" expression "]"          { $$ = new IR::ArrayIndex(@1 + @4, $1, $3); }
    | lvalue "[" expression ":" expression "]" { $$ = new IR::Slice(@1 + @6, $1, $3, $5); }
    ;

expression
    : INTEGER                            { $$ = parseConstant(@1, $1, 0); }
    | STRING_LITERAL                     { $$ = new IR::StringLiteral(@1, $1); }
    | TRUE                               { $$ = new IR::BoolLiteral(@1, true); }
    | FALSE                              { $$ = new IR::BoolLiteral(@1, false); }
    | THIS                               { $$ = new IR::This(@1); }  // experimental
    | nonTypeName                        { $$ = new IR::PathExpression(*$1); }
    | "." nonTypeName                    { $$ = new IR::PathExpression(new IR::Path(*$2, true)); }
    | expression "[" expression "]"      { $$ = new IR::ArrayIndex(@1 + @4, $1, $3); }
    | expression "[" expression ":" expression "]" { $$ = new IR::Slice(@1 + @6, $1, $3, $5); }
    | "{" expressionList "}"             { $$ = new IR::ListExpression(@1 + @3, *$2); }
    | "(" expression ")"                 { $$ = $2; }
    | "!" expression %prec PREFIX        { $$ = new IR::LNot(@1 + @2, $2); }
    | "~" expression %prec PREFIX        { $$ = new IR::Cmpl(@1 + @2, $2); }
    | "-" expression %prec PREFIX        { $$ = new IR::Neg(@1 + @2, $2); }
    | "+" expression %prec PREFIX        { $$ = $2; }
    | typeName "." name
        { $$ = new IR::Member(@1 + @3, new IR::TypeNameExpression(@1, $1), *$3); }
    | ERROR "." name
        { auto typeName = new IR::Type_Name(@1, new IR::Path(IR::ID(@1, "error")));
          $$ = new IR::Member(@1+@3, new IR::TypeNameExpression(@1+@3, typeName), *$3); }
    | expression "." name                { $$ = new IR::Member(@1 + @3, $1, *$3); }
    | expression "*" expression          { $$ = new IR::Mul(@1 + @3, $1, $3); }
    | expression "/" expression          { $$ = new IR::Div(@1 + @3, $1, $3); }
    | expression "%" expression          { $$ = new IR::Mod(@1 + @3, $1, $3); }
    | expression "+" expression          { $$ = new IR::Add(@1 + @3, $1, $3); }
    | expression "-" expression          { $$ = new IR::Sub(@1 + @3, $1, $3); }
    | expression "<<" expression         { $$ = new IR::Shl(@1 + @3, $1, $3); }
    | expression ">" ">" expression
        { driver.checkShift(@2, @3); $$ = new IR::Shr(@1 + @4, $1, $4); }
    | expression "<=" expression         { $$ = new IR::Leq(@1 + @3, $1, $3); }
    | expression ">=" expression         { $$ = new IR::Geq(@1 + @3, $1, $3); }
    | expression "<" expression          { $$ = new IR::Lss(@1 + @3, $1, $3); }
    | expression ">" expression          { $$ = new IR::Grt(@1 + @3, $1, $3); }
    | expression "!=" expression         { $$ = new IR::Neq(@1 + @3, $1, $3); }
    | expression "==" expression         { $$ = new IR::Equ(@1 + @3, $1, $3); }
    | expression "&" expression          { $$ = new IR::BAnd(@1 + @3, $1, $3); }
    | expression "^" expression          { $$ = new IR::BXor(@1 + @3, $1, $3); }
    | expression "|" expression          { $$ = new IR::BOr(@1 + @3, $1, $3); }
    | expression "++" expression         { $$ = new IR::Concat(@1 + @3, $1, $3); }
    | expression "&&" expression         { $$ = new IR::LAnd(@1 + @2 + @3, $1, $3); }
    | expression "||" expression         { $$ = new IR::LOr(@1 + @2 + @3, $1, $3); }
    | expression "?" expression ":" expression { $$ = new IR::Mux(@1 + @5, $1, $3, $5); }
    | expression "<" realTypeArgumentList ">" "(" argumentList ")"
        { $$ = new IR::MethodCallExpression(@1 + @4, $1, $3, $6); }
    // FIXME: the previous rule has the wrong precedence, and parses with
    // precedence weaker than casts.  There is no easy way to fix this in bison.
    | expression "(" argumentList ")"
        { $$ = new IR::MethodCallExpression(@1 + @4, $1, $3); }
    | namedType "(" argumentList ")"
        { $$ = new IR::ConstructorCallExpression(@1 + @4, $1, $3); }
    | "(" typeRef ")" expression %prec PREFIX { $$ = new IR::Cast(@1 + @4, $2, $4); }
    ;

/*****************************************************************************/

%%

void P4::P4Parser::error(const Util::SourceInfo& location,
                         const std::string& message) {
    driver.onParseError(location, message);
}
