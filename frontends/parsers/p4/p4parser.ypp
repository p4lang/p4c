/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Use Bison's C++ mode.
%skeleton "lalr1.cc" /* -*-C++-*- */
%require "3.0.4"

// Set up names.
%defines
%define api.namespace {P4}
%define parser_class_name {P4Parser}

// Use the C++-native variant representation of tokens.
%define api.token.constructor
%define api.value.type variant

// Add asserts to ensure that we use the API correctly.
%define parse.assert true

// Enable verbose error reporting.
%error-verbose

// Declare dependencies.
%code requires {
namespace P4 {
class P4Lexer;
class P4ParserDriver;
}  // namespace P4

// Bison uses the types you provide to %type to make constructors for the
// variant type it uses under the hood, but its code generation is a little
// naive and it always prepends 'const' to the type. This is problematic when
// the symbol type we want is itself const, since duplicate const qualifiers are
// forbidden in C++. We avoid the problem using a typedef.
typedef const IR::Type ConstType;

#ifndef YYDEBUG
#define YYDEBUG 1
#endif

#define YY_NULLPTR nullptr

#include "frontends/common/constantParsing.h"
#include "lib/cstring.h"
#include "lib/source_file.h"
}

%param { P4::P4ParserDriver& driver }
%parse-param { P4::P4Lexer& lexer }

// Use location tracking with our custom location type.
%locations
%define api.location.type {Util::SourceInfo}

%{ /* -*-C++-*- */
#include <cassert>   // NOLINT(build/include_order)
#include <iostream>  // NOLINT(build/include_order)

#include "frontends/parsers/parserDriver.h"
#include "frontends/parsers/p4/p4lexer.hpp"
#include "frontends/parsers/p4/p4parser.hpp"
#include "ir/ir.h"

#define YYLLOC_DEFAULT(Cur, Rhs, N)                                     \
    ((Cur) = (N) ? YYRHSLOC(Rhs, 1) + YYRHSLOC(Rhs, N)                  \
                 : Util::SourceInfo(YYRHSLOC(Rhs, 0).getEnd()))

#undef yylex
#define yylex lexer.yylex

%}

// Use iostreams to print all values.
%printer { yyoutput << $$; } <*>;

%define api.token.prefix {TOK_}
%token      END
%token      UNEXPECTED_TOKEN
%token      LE "<="
%token      GE ">="
%token      SHL "<<"
%token      AND "&&"
%token      OR "||"
%token      NE "!="
%token      EQ "=="
%token      PLUS "+"
%token      MINUS "-"
%token      MUL "*"
%token      DIV "/"
%token      MOD "%"
%token      BIT_OR "|"
%token      BIT_AND "&"
%token      BIT_XOR "^"
%token      COMPLEMENT "~"
%token      L_BRACKET "["
%token      R_BRACKET "]"
%token      L_BRACE "{"
%token      R_BRACE "}"
%token      L_ANGLE "<"
%token      R_ANGLE ">"
%token      L_PAREN "("
%token      R_PAREN ")"
%token      NOT "!"
%token      COLON ":"
%token      COMMA ","
%token      QUESTION "?"
%token      DOT "."
%token      ASSIGN "="
%token      SEMICOLON ";"
%token      AT "@"
%token      TRUE FALSE THIS
%token      ABSTRACT ACTION ACTIONS APPLY BOOL BIT CONST CONTROL DATA
            DEFAULT DONTCARE ELSE ENTRIES ENUM ERROR
            EXIT EXTERN HEADER HEADER_UNION IF IN INOUT INT KEY MASK SELECT MATCH_KIND OUT
            PACKAGE PARSER RANGE RETURN STATE STRUCT SWITCH TABLE TRANSITION
            TUPLE TYPEDEF VARBIT VOID

%token<cstring> IDENTIFIER TYPE STRING_LITERAL
%token<UnparsedConstant>  INTEGER

%type<IR::ID*>              name nonTypeName
%type<IR::Direction>        direction
%type<IR::Path*>            prefixedNonTypeName prefixedType
%type<IR::IndexedVector<IR::Type_Var>*>  typeParameterList
%type<IR::TypeParameters*>  optTypeParameters
%type<IR::Expression*>      expression lvalue
                            keysetExpression selectExpression
                            stateExpression optInitializer initializer
                            argument simpleKeysetExpression
                            transitionStatement switchLabel
%type<ConstType*>           baseType typeOrVoid specializedType headerStackType
                            typeRef tupleType typeArg
%type<IR::Type_Name*>       typeName
%type<IR::Parameter*>       parameter
%type<bool>                 optCONST
%type<IR::Annotations*>     optAnnotations
%type<IR::Vector<IR::Annotation>*>  annotations
%type<IR::Annotation*>      annotation
%type<IR::IndexedVector<IR::Parameter>*>  parameterList nonEmptyParameterList
                                          optConstructorParameters
%type<IR::Vector<IR::Expression>*>        argumentList nonEmptyArgList expressionList
                                          simpleExpressionList tupleKeysetExpression
%type<IR::IndexedVector<IR::Declaration_ID>*>  identifierList
%type<IR::SelectCase*>      selectCase
%type<IR::Vector<IR::SelectCase>*>  selectCaseList
%type<IR::Statement*>       statement emptyStatement returnStatement
                            switchStatement exitStatement
                            assignmentOrMethodCallStatement conditionalStatement
                            directApplication
%type<IR::BlockStatement*>  blockStatement parserBlockStatement controlBody
                            objInitializer
%type<IR::StatOrDecl*>      statementOrDeclaration parserStatement
%type<IR::IndexedVector<IR::StatOrDecl>*>  objDeclarations statOrDeclList
                                           parserStatements
%type<IR::SwitchCase*>      switchCase
%type<IR::Vector<IR::SwitchCase>*>  switchCases
%type<IR::Vector<IR::Type>*>  typeArgumentList
%type<IR::ParserState*>     parserState
%type<IR::IndexedVector<IR::ParserState>*>  parserStates
%type<IR::Declaration*>     constantDeclaration actionDeclaration
                            variableDeclaration instantiation functionDeclaration
                            objDeclaration tableDeclaration controlLocalDeclaration
                            parserLocalElement
%type<IR::Type_Declaration*>  headerTypeDeclaration structTypeDeclaration
                              headerUnionDeclaration derivedTypeDeclaration
                              parserDeclaration controlDeclaration enumDeclaration
                              typedefDeclaration packageTypeDeclaration typeDeclaration
%type<IR::Type_Error*>      errorDeclaration
%type<IR::Node*>            declaration externDeclaration matchKindDeclaration
%type<IR::Type_Parser*>     parserTypeDeclaration
%type<IR::Type_Control*>    controlTypeDeclaration
%type<IR::IndexedVector<IR::Declaration>*>  parserLocalElements controlLocalDeclarations
%type<IR::StructField*>     structField
%type<IR::IndexedVector<IR::StructField>*>  structFieldList
%type<IR::Method*>          methodPrototype functionPrototype
%type<IR::Vector<IR::Method>*>  methodPrototypes
%type<IR::Property*>        tableProperty
%type<IR::IndexedVector<IR::Property>*>  tablePropertyList
%type<IR::KeyElement*>      keyElement
%type<IR::Vector<IR::KeyElement>*>  keyElementList
%type<IR::ActionListElement*>  actionRef
%type<IR::IndexedVector<IR::ActionListElement>*>  actionList
%type<IR::Entry*>           entry
%type<IR::Vector<IR::Entry>*>  entriesList
%type<IR::MethodCallExpression*>  actionBinding

%left COMMA
%nonassoc QUESTION
%nonassoc COLON
%left OR
%left AND
%left BIT_OR
%left BIT_XOR
%left BIT_AND
%left EQ NE
%left L_ANGLE R_ANGLE LE GE
%left SHL
%left PP PLUS MINUS
%left MUL DIV MOD
%right PREFIX
%nonassoc R_BRACKET L_PAREN L_BRACKET
%left DOT

%right THEN ELSE /* THEN is a fake token */

%%

/*
   This grammar may look weird in some places, but a lot of effort was put into
   eliminating conflicts.  This sometimes required having the grammar be more
   lenient than necessary.  Moreover, the grammar is context-sensitive, and it
   needs some rudiments of type information to properly perform parsing.  This
   is done with the help of P4ParserDriver's "structure" object, which keeps
   track of which identifiers represent types, and which represent namespaces.
*/

program : input END { YYACCEPT; };

input
    : /* epsilon */
    | input declaration       { if ($2) driver.declarations->push_back($2->getNode()); }
    | input SEMICOLON         {}   // empty declaration
    ;

declaration
    : constantDeclaration     { $$ = $1; }
    | externDeclaration       { $$ = $1; }
    | actionDeclaration       { $$ = $1; }
    | parserDeclaration       { $$ = $1; }
    | typeDeclaration         { $$ = $1; }
    | controlDeclaration      { $$ = $1; }
    | instantiation           { $$ = $1; }
    | errorDeclaration        { driver.onReadErrorDeclaration($1); $$ = nullptr; }
    | matchKindDeclaration    { $$ = $1; }
    ;

nonTypeName
    : IDENTIFIER  { $$ = new IR::ID(@1, $1); }
    | APPLY       { $$ = new IR::ID(@1, "apply"); }
    | KEY         { $$ = new IR::ID(@1, "key"); }
    | ACTIONS     { $$ = new IR::ID(@1, "actions"); }
    | STATE       { $$ = new IR::ID(@1, "state"); }
    | ENTRIES     { $$ = new IR::ID(@1, "entries"); }
    ;

name
    : nonTypeName { $$ = $1; }
    | TYPE        { $$ = new IR::ID(@1, $1); }
    ;

optCONST
    : /* empty */ { $$ = false; }
    | CONST       { $$ = true; }
    ;

optAnnotations
    : /* empty */ { $$ = IR::Annotations::empty; }
    | annotations { $$ = new IR::Annotations(@1, *$1); }
    ;

annotations
    : annotation  { $$ = new IR::Vector<IR::Annotation>(); $$->push_back($1); }
    | annotations annotation { $$ = $1; $$->push_back($2); }
    ;

annotation
    : AT name                                { $$ = new IR::Annotation(@1, *$2, {}); }
    | AT name L_PAREN expressionList R_PAREN { $$ = new IR::Annotation(@1, *$2, *$4); }
    ;

parameterList
    : /* empty */                        { $$ = new IR::IndexedVector<IR::Parameter>(); }
    | nonEmptyParameterList              { $$ = $1; }
    ;

nonEmptyParameterList
    : parameter                           { $$ = new IR::IndexedVector<IR::Parameter>();
                                            $$->push_back($1); }
    | nonEmptyParameterList COMMA parameter { $$ = $1; $$->push_back($3); }
    ;

parameter
    : optAnnotations direction typeRef name { $$ = new IR::Parameter(@4, *$4, $1, $2, $3); }
    ;

direction
    : IN           { $$ = IR::Direction::In; }
    | OUT          { $$ = IR::Direction::Out; }
    | INOUT        { $$ = IR::Direction::InOut; }
    | /* empty */  { $$ = IR::Direction::None; }
    ;

packageTypeDeclaration
    : optAnnotations PACKAGE name { driver.structure->pushContainerType(*$3, false); }
      optTypeParameters { driver.structure->declareTypes(&$5->parameters); }
      L_PAREN parameterList R_PAREN        { auto pl = new IR::ParameterList(@8, *$8);
                                             $$ = new IR::Type_Package(@3, *$3, $1, $5, pl); }
    ;

instantiation
      : annotations typeRef L_PAREN argumentList R_PAREN name SEMICOLON
                     { $$ = new IR::Declaration_Instance(@6, *$6, new IR::Annotations(*$1),
                                                         $2, $4);
                       driver.structure->declareObject(*$6); }
      | typeRef L_PAREN argumentList R_PAREN name SEMICOLON
                     { $$ = new IR::Declaration_Instance(@5, *$5, $1, $3);
                       driver.structure->declareObject(*$5); }
      /* experimental */
      | annotations typeRef L_PAREN argumentList R_PAREN name ASSIGN objInitializer SEMICOLON
                     { $$ = new IR::Declaration_Instance(@6, *$6, new IR::Annotations(*$1),
                                                         $2, $4, $8);
                       driver.structure->declareObject(*$6); }
      /* experimental */
      | typeRef L_PAREN argumentList R_PAREN name ASSIGN objInitializer SEMICOLON
                     { $$ = new IR::Declaration_Instance(@5, *$5, $1, $3, $7);
                       driver.structure->declareObject(*$5); }
    ;

/* experimental; includes the following 3 productions */
objInitializer
    : L_BRACE { driver.structure->pushNamespace(@1, false); } objDeclarations R_BRACE
                               { driver.structure->pop();
                                 $$ = new IR::BlockStatement(@1+@4, *$3); }
    ;

objDeclarations
    : /* empty */                    { $$ = new IR::IndexedVector<IR::StatOrDecl>(); }
    | objDeclarations objDeclaration { $$ = $1; $1->push_back($2); }
    ;

objDeclaration
    : functionDeclaration      { $$ = $1; }
    | instantiation            { $$ = $1; }
    ;

optConstructorParameters
    : /* empty */                    { $$ = new IR::IndexedVector<IR::Parameter>(); }
    | L_PAREN parameterList R_PAREN  { $$ = $2; }
    ;

dotPrefix
    : DOT                      { driver.structure->startAbsolutePath(); }
    ;

/**************************** PARSER ******************************/

parserDeclaration
    : parserTypeDeclaration optConstructorParameters
      L_BRACE parserLocalElements parserStates R_BRACE
                             { driver.structure->pop();
                               auto pl = new IR::ParameterList(@2, *$2);
                               $$ = new IR::P4Parser($1->name.srcInfo, $1->name,
                                                     $1, pl, *$4, *$5);}
    ;

parserLocalElements
    : /* empty */                     { $$ = new IR::IndexedVector<IR::Declaration>(); }
    | parserLocalElements parserLocalElement { $$ = $1; $$->push_back($2); }
    ;

parserLocalElement
    : constantDeclaration             { $$ = $1; }
    | instantiation                   { $$ = $1; }
    | variableDeclaration             { $$ = $1; }
    ;

parserTypeDeclaration
    : optAnnotations
        PARSER name       { driver.structure->pushContainerType(*$3, false); }
        optTypeParameters { driver.structure->declareTypes(&$5->parameters); }
        L_PAREN parameterList R_PAREN { auto pl = new IR::ParameterList(@8, *$8);
                                        $$ = new IR::Type_Parser(@3, *$3, $1, $5, pl); }
    ;

parserStates
    : parserState                     { $$ = new IR::IndexedVector<IR::ParserState>();
                                        $$->push_back($1); }
    | parserStates parserState        { $$ = $1; $$->push_back($2); }
    ;

parserState
    : optAnnotations STATE name L_BRACE parserStatements transitionStatement R_BRACE
                                      { $$ = new IR::ParserState(@3, *$3, $1, *$5, $6); }
    ;

parserStatements
    : /* empty */                      { $$ = new IR::IndexedVector<IR::StatOrDecl>(); }
    | parserStatements parserStatement { $$ = $1; $1->push_back($2); }
    ;

parserStatement
    : assignmentOrMethodCallStatement { $$ = $1; }
    | directApplication               { $$ = $1; }
    | variableDeclaration             { $$ = $1; }
    | constantDeclaration             { $$ = $1; }
    | parserBlockStatement            { $$ = $1; }
    ;

parserBlockStatement
    : optAnnotations L_BRACE parserStatements R_BRACE
      { $$ = new IR::BlockStatement(@1+@4, $1, *$3); }
    ;

transitionStatement
    : /* empty */                 { $$ = nullptr; }
    | TRANSITION stateExpression  { $$ = $2; }
    ;

stateExpression
    : name SEMICOLON   { $$ = new IR::PathExpression(*$1); }
    | selectExpression { $$ = $1; }
    ;

selectExpression
    : SELECT L_PAREN expressionList R_PAREN L_BRACE selectCaseList R_BRACE
                              { $$ = new IR::SelectExpression(@1 + @7,
                                     new IR::ListExpression(@3, *$3), std::move(*$6)); }
    ;

selectCaseList
    : /* empty */                { $$ = new IR::Vector<IR::SelectCase>(); }
    | selectCaseList selectCase  { $$ = $1; $$->push_back($2); }
    ;

selectCase
    : keysetExpression COLON name SEMICOLON
      { auto expr = new IR::PathExpression(*$3);
        $$ = new IR::SelectCase(@1 + @3, $1, expr); }
    ;

keysetExpression
    : tupleKeysetExpression     { $$ = new IR::ListExpression(@1, *$1); }
    | simpleKeysetExpression    { $$ = $1; }
    ;

tupleKeysetExpression
    /* at least two elements in the tuple */
    : L_PAREN simpleKeysetExpression COMMA simpleExpressionList R_PAREN
                                { $$ = $4; $4->insert($4->begin(), $2); }
    ;

simpleExpressionList
    : simpleKeysetExpression { $$ = new IR::Vector<IR::Expression>(); $$->push_back($1); }
    | simpleExpressionList COMMA simpleKeysetExpression { $$ = $1; $$->push_back($3); }
    ;

simpleKeysetExpression
    : expression                  { $$ = $1; }
    | expression MASK expression  { $$ = new IR::Mask(@1 + @3, $1, $3); }
    | expression RANGE expression { $$ = new IR::Range(@1 + @3, $1, $3); }
    | DEFAULT                     { $$ = new IR::DefaultExpression(@1); }
    | DONTCARE                    { $$ = new IR::DefaultExpression(@1); }
    ;

/*************************** CONTROL ************************/

controlDeclaration
    : controlTypeDeclaration optConstructorParameters
      L_BRACE controlLocalDeclarations APPLY controlBody R_BRACE
        { driver.structure->pop();
          auto pl = new IR::ParameterList(@2, *$2);
          $$ = new IR::P4Control($1->name.srcInfo, $1->name, $1, pl, *$4, $6); }
    ;

controlTypeDeclaration
    : optAnnotations
        CONTROL name { driver.structure->pushContainerType(*$3, false); }
        optTypeParameters { driver.structure->declareTypes(&$5->parameters); }
        L_PAREN parameterList R_PAREN { auto pl = new IR::ParameterList(@8, *$8);
                                        $$ = new IR::Type_Control(@3, *$3, $1, $5, pl); }
    ;

controlLocalDeclarations
    : /* empty */               { $$ = new IR::IndexedVector<IR::Declaration>(); }
    | controlLocalDeclarations controlLocalDeclaration { $$ = $1; $$->push_back($2); }
    ;

controlLocalDeclaration
    : constantDeclaration      { $$ = $1; }
    | actionDeclaration        { $$ = $1; }
    | tableDeclaration         { $$ = $1; }
    | instantiation            { $$ = $1; }
    | variableDeclaration      { $$ = $1; }
    ;

controlBody
    : blockStatement { $$ = $1; }
    ;

/*************************** EXTERN *************************/

externDeclaration
    : optAnnotations
        EXTERN nonTypeName { driver.structure->pushContainerType(*$3, true); }
        optTypeParameters { driver.structure->declareTypes(&$5->parameters); }
        L_BRACE methodPrototypes R_BRACE { driver.structure->pop();
                                           $$ = new IR::Type_Extern(@3, *$3, $5, *$8, $1); }
    | optAnnotations EXTERN functionPrototype SEMICOLON { $$ = $3; $3->annotations = $1; }
    ;

methodPrototypes
    : /* empty */                      { $$ = new IR::Vector<IR::Method>(); }
    | methodPrototypes methodPrototype { $$ = $1; $1->push_back($2); }
    ;

functionPrototype
    : typeOrVoid
        name optTypeParameters { driver.structure->pushNamespace(@2, false);
                                 driver.structure->declareTypes(&$3->parameters); }
        L_PAREN parameterList R_PAREN { driver.structure->pop(); }
                           { auto params = new IR::ParameterList(@6, *$6);
                             auto mt = new IR::Type_Method(@2, $3, $1, params);
                             $$ = new IR::Method(@2, *$2, mt); }
    ;

methodPrototype
    : functionPrototype SEMICOLON { $$ = $1; }
    | ABSTRACT functionPrototype SEMICOLON    { $$ = $2; $$->setAbstract(); }  // experimental
    | TYPE L_PAREN parameterList R_PAREN SEMICOLON  // constructor
                                        { auto par = new IR::ParameterList(@3, *$3);
                                          auto mt = new IR::Type_Method(@1, par);
                                          $$ = new IR::Method(@1, IR::ID(@1, $1), mt); }
    ;

/************************** TYPES ****************************/

typeRef
    : baseType                         { $$ = $1; }
    | typeName                         { $$ = $1; }
    | specializedType                  { $$ = $1; }
    | headerStackType                  { $$ = $1; }
    | tupleType                        { $$ = $1; }
    ;

prefixedType
    : TYPE                             { $$ = new IR::Path(IR::ID(@1, $1)); }
    | dotPrefix TYPE                   { $$ = new IR::Path(IR::ID(@2, $2), true);
                                         driver.structure->clearPath(); }
    ;

typeName
    : prefixedType                     { $$ = new IR::Type_Name(@1, $1); }
    ;

tupleType
    : TUPLE L_ANGLE typeArgumentList R_ANGLE   { $$ = new IR::Type_Tuple(@1+@4, *$3); }
    ;

headerStackType
    : typeName L_BRACKET expression R_BRACKET      { $$ = new IR::Type_Stack(@1+@4, $1, $3); }
    ;

specializedType
    : typeName L_ANGLE typeArgumentList R_ANGLE
                                       { $$ = new IR::Type_Specialized(@1 + @4, $1, $3); }
    ;

baseType
    : BOOL   { $$ = IR::Type_Boolean::get(); }
    | ERROR  { $$ = new IR::Type_Name(@1, new IR::Path(IR::ID(@1, "error"))); }
    | BIT    { $$ = IR::Type::Bits::get(@1, 1); }
    | BIT L_ANGLE INTEGER R_ANGLE
      { $$ = IR::Type::Bits::get(@3, parseConstant(@3, $3, 0)->asInt(), false); }
    | INT L_ANGLE INTEGER R_ANGLE
      { $$ = IR::Type::Bits::get(@3, parseConstant(@3, $3, 0)->asInt(), true); }
    | VARBIT L_ANGLE INTEGER R_ANGLE
      { $$ = IR::Type::Varbits::get(@3, parseConstant(@3, $3, 0)->asInt()); }
    ;

typeOrVoid
    : typeRef                          { $$ = $1; }
    | VOID                             { $$ = IR::Type_Void::get(); }
    | nonTypeName                      { $$ = new IR::Type_Name(@1, new IR::Path(*$1)); }
        // This is necessary because template arguments may introduce the return type
    ;

optTypeParameters
    : /* empty */                       { $$ = new IR::TypeParameters(); }
    | L_ANGLE typeParameterList R_ANGLE { $$ = new IR::TypeParameters(@1+@3, *$2); }
    ;

typeParameterList
    : name                             { $$ = new IR::IndexedVector<IR::Type_Var>();
                                         $$->push_back(new IR::Type_Var(@1, *$1)); }
    | typeParameterList COMMA name     { ($$=$1)->push_back(new IR::Type_Var(@3, *$3)); }
    ;

typeArg
    : typeRef                          { $$ = $1; }
    | DONTCARE                         { $$ = IR::Type_Dontcare::get(); }
    ;

typeArgumentList
    : typeArg                          { $$ = new IR::Vector<IR::Type>(); $$->push_back($1); }
    | typeArgumentList COMMA typeArg   { $$ = $1; $$->push_back($3); }
    ;

typeDeclaration
    : derivedTypeDeclaration           { $$ = $1; }
    | typedefDeclaration SEMICOLON     { $$ = $1; }
    | parserTypeDeclaration SEMICOLON  { driver.structure->pop(); $$ = $1; }
    | controlTypeDeclaration SEMICOLON { driver.structure->pop(); $$ = $1; }
    | packageTypeDeclaration SEMICOLON { driver.structure->pop(); $$ = $1; }
    ;

derivedTypeDeclaration
    : headerTypeDeclaration            { $$ = $1; }
    | headerUnionDeclaration           { $$ = $1; }
    | structTypeDeclaration            { $$ = $1; }
    | enumDeclaration                  { $$ = $1; }
    ;

headerTypeDeclaration
    : optAnnotations
        HEADER name { driver.structure->declareType(*$3); }
        L_BRACE structFieldList R_BRACE { $$ = new IR::Type_Header(@3, *$3, $1, *$6); }
    ;

structTypeDeclaration
    : optAnnotations
        STRUCT name { driver.structure->declareType(*$3); }
        L_BRACE structFieldList R_BRACE { $$ = new IR::Type_Struct(@3, *$3, $1, *$6); }
    ;

// experimental
headerUnionDeclaration
    : optAnnotations
        HEADER_UNION name { driver.structure->declareType(*$3); }
        L_BRACE structFieldList R_BRACE { $$ = new IR::Type_Union(@3, *$3, $1, *$6); }
    ;

structFieldList
    : /* empty */                      { $$ = new IR::IndexedVector<IR::StructField>(); }
    | structFieldList structField      { $$ = $1; $1->push_back($2); }
    ;

structField
    : optAnnotations typeRef name SEMICOLON  { $$ = new IR::StructField(@3, *$3, $1, $2); }
    ;

enumDeclaration
    : optAnnotations
        ENUM name { driver.structure->declareType(*$3); }
        L_BRACE identifierList R_BRACE { $$ = new IR::Type_Enum(@2, *$3, *$6); }
    ;

errorDeclaration
    : ERROR L_BRACE identifierList R_BRACE
        { $$ = new IR::Type_Error(@1 + @4, IR::ID(@1, "error"), *$3); }
    ;

matchKindDeclaration
    : MATCH_KIND L_BRACE identifierList R_BRACE
        { $$ = new IR::Declaration_MatchKind(@1 + @4, *$3); }
    ;

identifierList
    : name                      { $$ = new IR::IndexedVector<IR::Declaration_ID>();
                                  $$->push_back(new IR::Declaration_ID(@1, *$1));}
    | identifierList COMMA name { $$ = $1; $$->push_back(new IR::Declaration_ID(@3, *$3)); }
    ;

typedefDeclaration
    : annotations TYPEDEF typeRef name   { driver.structure->declareType(*$4);
          $$ = new IR::Type_Typedef(@4, *$4, new IR::Annotations(*$1), $3); }
    | TYPEDEF typeRef name               { driver.structure->declareType(*$3);
          $$ = new IR::Type_Typedef(@3, *$3, $2); }
    | annotations TYPEDEF derivedTypeDeclaration name   { driver.structure->declareType(*$4);
                        $$ = new IR::Type_Typedef(@4, *$4, new IR::Annotations(*$1), $3); }
    | TYPEDEF derivedTypeDeclaration name { driver.structure->declareType(*$3);
                        $$ = new IR::Type_Typedef(@3, *$3, $2); }
    ;

/*************************** STATEMENTS *************************/

assignmentOrMethodCallStatement
    // These rules are overly permissive, but they avoid some conflicts
    : lvalue L_PAREN argumentList R_PAREN SEMICOLON
        { auto mc = new IR::MethodCallExpression(@1 + @4, $1,
                                                 new IR::Vector<IR::Type>(), $3);
          $$ = new IR::MethodCallStatement(@1 + @4, mc); }

    | lvalue L_ANGLE typeArgumentList R_ANGLE L_PAREN argumentList R_PAREN SEMICOLON
        { auto mc = new IR::MethodCallExpression(@1 + @7,
                                                 $1, $3, $6);
          $$ = new IR::MethodCallStatement(@1 + @7, mc); }

    | lvalue ASSIGN  expression SEMICOLON
        { $$ = new IR::AssignmentStatement(@2, $1, $3); }

    ;

emptyStatement
    : SEMICOLON      { $$ = new IR::EmptyStatement(@1); }
    ;

exitStatement
    : EXIT SEMICOLON { $$ = new IR::ExitStatement(@1); }
    ;

returnStatement
    : RETURN SEMICOLON            { $$ = new IR::ReturnStatement(@1, nullptr); }
    | RETURN expression SEMICOLON { $$ = new IR::ReturnStatement(@1, $2); }
    ;

conditionalStatement
    : IF L_PAREN expression R_PAREN statement                 %prec THEN
        { $$ = new IR::IfStatement(@1, $3, $5, nullptr); }
    | IF L_PAREN expression R_PAREN statement ELSE statement  %prec THEN
        { $$ = new IR::IfStatement(@1, $3, $5, $7); }
    ;

// To support direct invocation of a control or parser without instantiation
directApplication
    : typeName DOT APPLY L_PAREN argumentList R_PAREN SEMICOLON {
                                  auto method = new IR::Member(
                                      @1 + @3, new IR::TypeNameExpression($1), IR::ID(@3, "apply"));
                                  auto mce = new IR::MethodCallExpression(@1 + @6, method, $5);
                                  $$ = new IR::MethodCallStatement(@1 + @6, mce); }
    ;

statement
    : assignmentOrMethodCallStatement  { $$ = $1; }
    | directApplication                { $$ = $1; }
    | conditionalStatement             { $$ = $1; }
    | emptyStatement                   { $$ = $1; }
    | blockStatement                   { $$ = $1; }
    | returnStatement                  { $$ = $1; }
    | exitStatement                    { $$ = $1; }
    | switchStatement                  { $$ = $1; }
    ;

blockStatement
    : optAnnotations L_BRACE { driver.structure->pushNamespace(@2, false); }
      statOrDeclList R_BRACE { driver.structure->pop();
                               $$ = new IR::BlockStatement(@1 + @5, $1, *$4); }
    ;

statOrDeclList
    : /* empty */                           { $$ = new IR::IndexedVector<IR::StatOrDecl>(); }
    | statOrDeclList statementOrDeclaration { $$ = $1; $$->push_back($2); }
    ;

switchStatement
    : SWITCH L_PAREN expression R_PAREN L_BRACE switchCases R_BRACE {
            $$ = new IR::SwitchStatement(@1, $3, std::move(*$6)); }
    ;

switchCases
    : /* empty */              { $$ = new IR::Vector<IR::SwitchCase>(); }
    | switchCases switchCase   { $$ = $1; $$->push_back($2); }
    ;

switchCase
    : switchLabel COLON blockStatement { $$ = new IR::SwitchCase(@1 + @3, $1, $3); }
    | switchLabel COLON { $$ = new IR::SwitchCase(@1, $1, nullptr); }
    ;

switchLabel
    : name                     { $$ = new IR::PathExpression(*$1); }
    | DEFAULT                  { $$ = new IR::DefaultExpression(@1); }
    ;

statementOrDeclaration
    : variableDeclaration      { $$ = $1; }
    | constantDeclaration      { $$ = $1; }
    | statement                { $$ = $1; }
    | instantiation            { $$ = $1; }
    ;

/************************* TABLE *********************************/

tableDeclaration
    : optAnnotations
        TABLE name L_BRACE tablePropertyList R_BRACE
          { $$ = new IR::P4Table(@3, *$3, $1, new IR::TableProperties(@5, *$5)); }
    ;

tablePropertyList
    : tableProperty                      { $$ = new IR::IndexedVector<IR::Property>();
                                           $$->push_back($1); }
    | tablePropertyList tableProperty    { $$ = $1; $$->push_back($2); }
    ;

tableProperty
    : KEY ASSIGN L_BRACE keyElementList R_BRACE
        { auto v = new IR::Key(@4, *$4);
          auto id = IR::ID(@1, "key");
          $$ = new IR::Property( @1 + @5, id, v, false); }
    | ACTIONS ASSIGN L_BRACE actionList R_BRACE
        { auto v = new IR::ActionList(@4, *$4);
          auto id = IR::ID(@1, "actions");
          $$ = new IR::Property(@1 + @5, id, v, false); }
    | optAnnotations optCONST ENTRIES ASSIGN L_BRACE entriesList R_BRACE
        { auto l = new IR::EntriesList(@3, *$6);
          auto id = IR::ID(@3+@7, "entries");
          $$ = new IR::Property(@3, id, $1, l, $2); }
    | optAnnotations optCONST IDENTIFIER ASSIGN initializer SEMICOLON
        { auto v = new IR::ExpressionValue(@5, $5);
          auto id = IR::ID(@3, $3);
          $$ = new IR::Property(@3, id, $1, v, $2); }
    ;

keyElementList
    : /* empty */                        { $$ = new IR::Vector<IR::KeyElement>(); }
    | keyElementList keyElement          { $$ = $1; $$->push_back($2); }
    ;

keyElement
    : expression COLON name optAnnotations SEMICOLON
                                         { auto expr = new IR::PathExpression(*$3);
                                           $$ = new IR::KeyElement(@3, $4, $1, expr); }
    ;

actionList
    : actionRef SEMICOLON                { $$ = new IR::IndexedVector<IR::ActionListElement>();
                                           $$->push_back($1); }
    | actionList actionRef SEMICOLON     { $$ = $1; $$->push_back($2); }
    ;

actionRef
    : optAnnotations name                { auto expr = new IR::PathExpression(*$2);
                                           $$ = new IR::ActionListElement(@2, $1, expr);}
    | optAnnotations name L_PAREN argumentList R_PAREN
                                         { auto method = new IR::PathExpression(*$2);
                                           auto mce = new IR::MethodCallExpression(
                                               @2+@4, method, $4);
                                           $$ = new IR::ActionListElement(@2, $1, mce); }
    ;

entry
    : keysetExpression COLON actionBinding optAnnotations SEMICOLON
                                         {
                                           assert($3->is<IR::MethodCallExpression>());
                                           if (auto l = $1->to<IR::ListExpression>())
                                             $$ = new IR::Entry(@1+@4, $4, l, $3);
                                           else {  // if not a tuple, make it a list of 1
                                             IR::Vector<IR::Expression> le($1);
                                             $$ = new IR::Entry(@1+@4, $4,
                                                                new IR::ListExpression(@1, le),
                                                                $3);
                                           }
                                         }
    ;

actionBinding
    : lvalue L_PAREN argumentList R_PAREN
        { $$ = new IR::MethodCallExpression(@1 + @4, $1,
                                            new IR::Vector<IR::Type>(), $3); }
    | lvalue L_ANGLE typeArgumentList R_ANGLE L_PAREN argumentList R_PAREN
        { $$ = new IR::MethodCallExpression(@1 + @7, $1, $3, $6); }

entriesList
    : entry                          { $$ = new IR::Vector<IR::Entry>(); $$->push_back($1); }
    | entriesList entry              { $$ = $1; $$->push_back($2); }
    ;

/************************* ACTION ********************************/

actionDeclaration
    : optAnnotations ACTION name L_PAREN parameterList R_PAREN blockStatement
        { auto pl = new IR::ParameterList(@5, *$5);
          $$ = new IR::P4Action(@3, *$3, $1, pl, $7); }
    ;

/************************* VARIABLES *****************************/

variableDeclaration
    : annotations typeRef name optInitializer SEMICOLON
                                     { auto ann = new IR::Annotations(@1, *$1);
                                       $$ = new IR::Declaration_Variable(@1+@4, *$3, ann, $2, $4);
                                       driver.structure->declareObject(*$3); }
    | typeRef name optInitializer SEMICOLON
                                     { $$ = new IR::Declaration_Variable(@1+@4, *$2, $1, $3);
                                       driver.structure->declareObject(*$2); }
    ;

constantDeclaration
    : optAnnotations CONST typeRef name ASSIGN initializer SEMICOLON
                                     { $$ = new IR::Declaration_Constant(@1+@6, *$4, $1, $3, $6);
                                       driver.structure->declareObject(*$4); }
    ;

optInitializer
    : /* empty */                         { $$ = nullptr; }
    | ASSIGN initializer                  { $$ = $2; }
    ;

initializer
    : expression                          { $$ = $1; }
    ;

/**************** Expressions ****************/

// experimental
functionDeclaration
    : functionPrototype blockStatement   { $$ = new IR::Function(@1+@2, $1->name, $1->type, $2); }
    ;

argumentList
    : /* empty */                        { $$ = new IR::Vector<IR::Expression>(); }
    | nonEmptyArgList                    { $$ = $1; }
    ;

nonEmptyArgList
    : argument                           { $$ = new IR::Vector<IR::Expression>();
                                           $$->push_back($1); }
    | nonEmptyArgList COMMA argument     { $$ = $1; $$->push_back($3); }
    ;

argument
    : expression                         { $$ = $1; }
    ;

expressionList
    : expression                         { $$ = new IR::Vector<IR::Expression>();
                                           $$->push_back($1); }
    | expressionList COMMA expression    { $$ = $1; $$->push_back($3); }
    ;

prefixedNonTypeName
    : nonTypeName                        { $$ = new IR::Path(*$1); }
    | dotPrefix nonTypeName              { $$ = new IR::Path(*$2, true);
                                           driver.structure->clearPath(); }
    ;

lvalue
    : prefixedNonTypeName                { $$ = new IR::PathExpression($1); }
    | THIS                               { $$ = new IR::This(@1); }  // experimental
    | lvalue DOT name                    { $$ = new IR::Member(@1 + @3, $1, *$3); }
    | lvalue L_BRACKET expression R_BRACKET { $$ = new IR::ArrayIndex(@1 + @4, $1, $3); }
    | lvalue L_BRACKET expression COLON expression R_BRACKET
        { $$ = new IR::Slice(@1 + @6, $1, $3, $5); }
    ;

expression
    : INTEGER                            { $$ = parseConstant(@1, $1, 0); }
    | STRING_LITERAL                     { $$ = new IR::StringLiteral(@1, $1); }
    | TRUE                               { $$ = new IR::BoolLiteral(@1, true); }
    | FALSE                              { $$ = new IR::BoolLiteral(@1, false); }
    | THIS                               { $$ = new IR::This(@1); }  // experimental
    | nonTypeName                        { $$ = new IR::PathExpression(*$1); }
    | DOT nonTypeName                    { $$ = new IR::PathExpression(new IR::Path(*$2, true)); }
    | expression L_BRACKET expression R_BRACKET { $$ = new IR::ArrayIndex(@1 + @4, $1, $3); }
    | expression L_BRACKET expression COLON expression R_BRACKET
        { $$ = new IR::Slice(@1 + @6, $1, $3, $5); }
    | L_BRACE expressionList R_BRACE     { $$ = new IR::ListExpression(@1 + @3, *$2); }
    | L_PAREN expression R_PAREN         { $$ = $2; }
    | NOT expression %prec PREFIX        { $$ = new IR::LNot(@1 + @2, $2); }
    | COMPLEMENT expression %prec PREFIX { $$ = new IR::Cmpl(@1 + @2, $2); }
    | MINUS expression %prec PREFIX      { $$ = new IR::Neg(@1 + @2, $2); }
    | PLUS expression %prec PREFIX       { $$ = $2; }
    | typeName DOT name
        { $$ = new IR::Member(@1 + @3, new IR::TypeNameExpression(@1, $1), *$3); }
    | ERROR DOT name
        { auto typeName = new IR::Type_Name(@1, new IR::Path(IR::ID(@1, "error")));
          $$ = new IR::Member(@1+@3, new IR::TypeNameExpression(@1+@3, typeName), *$3); }
    | expression DOT name                { $$ = new IR::Member(@1 + @3, $1, *$3); }
    | expression MUL expression          { $$ = new IR::Mul(@1 + @3, $1, $3); }
    | expression DIV expression          { $$ = new IR::Div(@1 + @3, $1, $3); }
    | expression MOD expression          { $$ = new IR::Mod(@1 + @3, $1, $3); }
    | expression PLUS expression         { $$ = new IR::Add(@1 + @3, $1, $3); }
    | expression MINUS expression        { $$ = new IR::Sub(@1 + @3, $1, $3); }
    | expression SHL expression          { $$ = new IR::Shl(@1 + @3, $1, $3); }
    | expression R_ANGLE R_ANGLE expression
        { driver.checkShift(@2, @3); $$ = new IR::Shr(@1 + @4, $1, $4); }
    | expression LE expression           { $$ = new IR::Leq(@1 + @3, $1, $3); }
    | expression GE expression           { $$ = new IR::Geq(@1 + @3, $1, $3); }
    | expression L_ANGLE expression      { $$ = new IR::Lss(@1 + @3, $1, $3); }
    | expression R_ANGLE expression      { $$ = new IR::Grt(@1 + @3, $1, $3); }
    | expression NE expression           { $$ = new IR::Neq(@1 + @3, $1, $3); }
    | expression EQ expression           { $$ = new IR::Equ(@1 + @3, $1, $3); }
    | expression BIT_AND expression      { $$ = new IR::BAnd(@1 + @3, $1, $3); }
    | expression BIT_XOR expression      { $$ = new IR::BXor(@1 + @3, $1, $3); }
    | expression BIT_OR expression       { $$ = new IR::BOr(@1 + @3, $1, $3); }
    | expression PP expression           { $$ = new IR::Concat(@1 + @3, $1, $3); }
    | expression AND expression          { $$ = new IR::LAnd(@1 + @2 + @3, $1, $3); }
    | expression OR expression           { $$ = new IR::LOr(@1 + @2 + @3, $1, $3); }
    | expression QUESTION expression COLON expression { $$ = new IR::Mux(@1 + @5, $1, $3, $5); }
    | expression L_ANGLE typeArgumentList R_ANGLE L_PAREN argumentList R_PAREN
        { $$ = new IR::MethodCallExpression(@1 + @4, $1, $3, $6); }
    // FIXME: the previous rule has the wrong precedence, and parses with
    // precedence weaker than casts.  There is no easy way to fix this in bison.
    | expression L_PAREN argumentList R_PAREN
        { $$ = new IR::MethodCallExpression(@1 + @4, $1, $3); }
    | typeRef L_PAREN argumentList R_PAREN
        { $$ = new IR::ConstructorCallExpression(@1 + @4, $1, $3); }
    | L_PAREN typeRef R_PAREN expression %prec PREFIX { $$ = new IR::Cast(@1 + @4, $2, $4); }
    ;

/*****************************************************************************/

%%

void P4::P4Parser::error(const Util::SourceInfo& location,
                         const std::string& message) {
    driver.onParseError(location, message);
}
