/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Use Bison's C++ mode.
%skeleton "lalr1.cc" /* -*-C++-*- */
%require "3.0.0"

// Set up names.
%defines
%define api.namespace {P4}
%define parser_class_name {P4Parser}

// Use the C++-native variant representation of tokens.
%define api.token.constructor
%define api.value.type variant

// Add asserts to ensure that we use the API correctly.
%define parse.assert true

// Enable verbose error reporting.
%error-verbose

// Declare dependencies.
%code requires {
#include <cassert>   // NOLINT(build/include_order)
#include <iostream>  // NOLINT(build/include_order)

#include "frontends/common/constantParsing.h"
#include "ir/ir.h"
#include "lib/cstring.h"
#include "lib/source_file.h"

namespace P4 {
class AbstractP4Lexer;
class P4ParserDriver;

// This is a workaround for an UndefinedBehaviorSanitizer issue triggered by
// Bison's variant implementation. When variant::move() is used to move a value
// from an initialized instance of variant to an uninitialized instance, it uses
// placement new to initialize the uninitialized instance, then calls
// variant::swap(), then destroys the moved-from instance. The problem is that
// placement new does not perform any initialization for primitive types, and
// for bool or enum types that can result in a value that isn't a valid element
// of those types, which UndefinedBehaviorSanitizer doesn't like.
struct OptionalConst {
    OptionalConst() = default;
    explicit OptionalConst(bool isConst) : isConst(isConst) { }
    bool isConst = false;
};
}  // namespace P4

inline std::ostream& operator<<(std::ostream& out, const P4::OptionalConst& oc) {
    out << "OptionalConst(" << oc.isConst << ')';
    return out;
}

// Bison uses the types you provide to %type to make constructors for the
// variant type it uses under the hood, but its code generation is a little
// naive and it always prepends 'const' to the type. This is problematic when
// the symbol type we want is itself const, since duplicate const qualifiers are
// forbidden in C++. We avoid the problem using a typedef.
typedef const IR::Type ConstType;

#ifndef YYDEBUG
#define YYDEBUG 1
#endif

#define YY_NULLPTR nullptr

namespace P4 {
class Token {
 public:
    int type;
    cstring text;
    UnparsedConstant* unparsedConstant;

    explicit Token() { }
    explicit Token(int type, cstring text) : Token(type, text, nullptr) { }
    explicit Token(int type, UnparsedConstant unparsedConstant)
            : Token(type, unparsedConstant.text,
                    new UnparsedConstant(unparsedConstant)) { }

 private:
    explicit Token(int type, cstring text, UnparsedConstant* unparsedConstant)
            : type(type), text(text), unparsedConstant(unparsedConstant) { }
};

} // namespace P4

inline std::ostream& operator<<(std::ostream& out, const P4::Token& t) {
    out << t.text;
    return out;
}
}

%param { P4::P4ParserDriver& driver }
%parse-param { P4::AbstractP4Lexer& lexer }

// Use location tracking with our custom location type.
%locations
%define api.location.type {Util::SourceInfo}

%{ /* -*-C++-*- */
#include "frontends/parsers/parserDriver.h"
#include "frontends/parsers/p4/p4lexer.hpp"
#include "frontends/parsers/p4/p4parser.hpp"

#define YYLLOC_DEFAULT(Cur, Rhs, N)                                             \
    ((Cur) = (N) ? YYRHSLOC(Rhs, 1) + YYRHSLOC(Rhs, N)                          \
                 : Util::SourceInfo(driver.sources, YYRHSLOC(Rhs, 0).getEnd()))

#undef yylex
#define yylex lexer.yylex

%}

// Use iostreams to print all values.
%printer { yyoutput << $$; } <*>;

%define api.token.prefix {TOK_}
%token             START_PROGRAM
                   START_EXPRESSION_LIST START_KV_LIST
                   START_EXPRESSION START_INTEGER START_STRING_LITERAL
                   START_EXPRESSION_PAIR START_INTEGER_PAIR
                   START_STRING_LITERAL_PAIR
                   START_EXPRESSION_TRIPLE START_INTEGER_TRIPLE
                   START_STRING_LITERAL_TRIPLE
%token             END END_ANNOTATION


///////////////////////////////////////////////////////////////////////////////
//
// Language token definitions.
//
// NB: Tokens defined here should be added to the annotationToken production.
//
///////////////////////////////////////////////////////////////////////////////

%token<Token>      UNEXPECTED_TOKEN END_PRAGMA
%token<Token>      LE "<="
%token<Token>      GE ">="
%token<Token>      SHL "<<"
%token<Token>      AND "&&"
%token<Token>      OR "||"
%token<Token>      NE "!="
%token<Token>      EQ "=="
%token<Token>      PLUS "+"
%token<Token>      MINUS "-"
%token<Token>      PLUS_SAT "|+|"
%token<Token>      MINUS_SAT "|-|"
%token<Token>      MUL "*"
%token<Token>      DIV "/"
%token<Token>      MOD "%"
%token<Token>      BIT_OR "|"
%token<Token>      BIT_AND "&"
%token<Token>      BIT_XOR "^"
%token<Token>      COMPLEMENT "~"
%token<Token>      L_BRACKET "["
%token<Token>      R_BRACKET "]"
%token<Token>      L_BRACE "{"
%token<Token>      R_BRACE "}"
%token<Token>      L_ANGLE "<"
%token<Token>      R_ANGLE ">"
%token<Token>      L_PAREN "("
%token<Token>      R_PAREN ")"
%token<Token>      NOT "!"
%token<Token>      COLON ":"
%token<Token>      COMMA ","
%token<Token>      QUESTION "?"
%token<Token>      DOT "."
%token<Token>      ASSIGN "="
%token<Token>      SEMICOLON ";"
%token<Token>      AT "@"
%token<Token>      PP "++"
%token<Token>      DONTCARE "_"
%token<Token>      MASK "&&&"
%token<Token>      RANGE ".."
%token<Token>      TRUE FALSE THIS
%token<Token>      ABSTRACT ACTION ACTIONS APPLY BOOL BIT CONST CONTROL DEFAULT
                   ELSE ENTRIES ENUM ERROR EXIT EXTERN HEADER HEADER_UNION IF IN INOUT
                   INT KEY SELECT MATCH_KIND TYPE OUT PACKAGE PARSER PRAGMA RETURN STATE
                   STRUCT SWITCH TABLE TRANSITION TUPLE TYPEDEF VARBIT VALUESET VOID

%token<cstring> IDENTIFIER TYPE_IDENTIFIER STRING_LITERAL
%token<UnparsedConstant>  INTEGER

// End of token definitions ///////////////////////////////////////////////////


%type<IR::ID*>              name nonTypeName nonTableKwName
%type<IR::Direction>        direction
%type<IR::Path*>            prefixedNonTypeName prefixedType
%type<IR::IndexedVector<IR::Type_Var>*>  typeParameterList
%type<IR::TypeParameters*>  optTypeParameters
%type<IR::Expression*>      expression lvalue keysetExpression selectExpression
                            stateExpression optInitializer initializer
                            simpleKeysetExpression transitionStatement switchLabel
%type<ConstType*>           baseType typeOrVoid specializedType headerStackType
                            typeRef tupleType typeArg realTypeArg namedType
%type<IR::Type_Name*>       typeName
%type<IR::Argument*>        argument
%type<IR::Vector<IR::Argument>*>  argumentList nonEmptyArgList
%type<IR::Parameter*>       parameter
%type<OptionalConst>        optCONST
%type<IR::Annotations*>     optAnnotations
%type<IR::Vector<IR::Annotation>*>  annotations
%type<IR::Annotation*>      annotation
%type<IR::Vector<IR::AnnotationToken>*> annotationBody
%type<Token>                annotationToken
%type<IR::IndexedVector<IR::Parameter>*>  parameterList nonEmptyParameterList
                                          optConstructorParameters
%type<IR::Vector<IR::Expression>*>        expressionList
                                          simpleExpressionList tupleKeysetExpression
%type<IR::IndexedVector<IR::Declaration_ID>*>  identifierList
%type<IR::SelectCase*>      selectCase
%type<IR::Vector<IR::SelectCase>*>  selectCaseList
%type<IR::Statement*>       statement emptyStatement returnStatement
                            switchStatement exitStatement
                            assignmentOrMethodCallStatement conditionalStatement
                            directApplication
%type<IR::BlockStatement*>  blockStatement parserBlockStatement controlBody
                            objInitializer
%type<IR::StatOrDecl*>      statementOrDeclaration parserStatement
%type<IR::IndexedVector<IR::StatOrDecl>*>  objDeclarations statOrDeclList
                                           parserStatements
%type<IR::SwitchCase*>      switchCase
%type<IR::Vector<IR::SwitchCase>*>  switchCases
%type<IR::Vector<IR::Type>*>  typeArgumentList realTypeArgumentList
%type<IR::ParserState*>     parserState
%type<IR::IndexedVector<IR::ParserState>*>  parserStates
%type<IR::Declaration*>     constantDeclaration actionDeclaration
                            variableDeclaration instantiation functionDeclaration
                            objDeclaration tableDeclaration controlLocalDeclaration
                            parserLocalElement valueSetDeclaration
%type<IR::Type_Declaration*>  headerTypeDeclaration structTypeDeclaration
                              headerUnionDeclaration derivedTypeDeclaration
                              parserDeclaration controlDeclaration enumDeclaration
                              typedefDeclaration packageTypeDeclaration typeDeclaration
%type<IR::Type_Error*>      errorDeclaration
%type<IR::Node*>            fragment
%type<IR::Node*>            declaration externDeclaration matchKindDeclaration
%type<IR::Type_Parser*>     parserTypeDeclaration
%type<IR::Type_Control*>    controlTypeDeclaration
%type<IR::IndexedVector<IR::Declaration>*>  parserLocalElements controlLocalDeclarations
%type<IR::StructField*>     structField
%type<IR::IndexedVector<IR::StructField>*>  structFieldList
%type<IR::IndexedVector<IR::SerEnumMember>*> specifiedIdentifierList
%type<IR::SerEnumMember*>   specifiedIdentifier
%type<IR::Method*>          methodPrototype functionPrototype
%type<IR::Vector<IR::Method>*>  methodPrototypes
%type<IR::Property*>        tableProperty
%type<IR::IndexedVector<IR::Property>*>  tablePropertyList
%type<IR::KeyElement*>      keyElement
%type<IR::Vector<IR::KeyElement>*>  keyElementList
%type<IR::ActionListElement*>  actionRef
%type<IR::IndexedVector<IR::ActionListElement>*>  actionList
%type<IR::Entry*>           entry
%type<IR::Vector<IR::Entry>*>  entriesList
%type<IR::MethodCallExpression*>  actionBinding
%type<IR::IndexedVector<IR::NamedExpression>*> kvList
%type<IR::NamedExpression*> kvPair

%left COMMA
%nonassoc QUESTION
%nonassoc COLON
%left OR
%left AND
%left EQ NE
%left L_ANGLE R_ANGLE LE GE
%left BIT_OR
%left BIT_XOR
%left BIT_AND
%left SHL
%left PP PLUS MINUS PLUS_SAT MINUS_SAT
%left MUL DIV MOD
%right PREFIX
%nonassoc R_BRACKET L_PAREN L_BRACKET
%left DOT

%right THEN ELSE /* THEN is a fake token */

%%

/*
   This grammar may look weird in some places, but a lot of effort was put into
   eliminating conflicts.  This sometimes required having the grammar be more
   lenient than necessary.  Moreover, the grammar is context-sensitive, and it
   needs some rudiments of type information to properly perform parsing.  This
   is done with the help of P4ParserDriver's "structure" object, which keeps
   track of which identifiers represent types, and which represent namespaces.
*/

// Simulate multiple start symbols to allow the parser to be reused for
// annotation bodies.
start
    : fragment END_ANNOTATION { driver.nodes->push_back($1->getNode()); YYACCEPT; }
    | START_PROGRAM program
    ;

fragment
      // Lists
    : START_EXPRESSION_LIST expressionList { $$ = $2; }
    | START_KV_LIST kvList                 { $$ = $2; }

      // Singletons
    | START_EXPRESSION expression          { $$ = $2; }
    | START_INTEGER INTEGER                { $$ = parseConstant(@2, $2, 0); }
    | START_STRING_LITERAL STRING_LITERAL  { $$ = new IR::StringLiteral(@2, $2); }

      // Pairs
    | START_EXPRESSION_PAIR expression "," expression
        { auto* result = new IR::Vector<IR::Expression>();
          result->push_back($2);
          result->push_back($4);
          $$ = result; }
    | START_INTEGER_PAIR INTEGER "," INTEGER
        { auto* result = new IR::Vector<IR::Expression>();
          result->push_back(parseConstant(@2, $2, 0));
          result->push_back(parseConstant(@4, $4, 0));
          $$ = result; }
    | START_STRING_LITERAL_PAIR STRING_LITERAL "," STRING_LITERAL
        { auto* result = new IR::Vector<IR::Expression>();
          result->push_back(new IR::StringLiteral(@2, $2));
          result->push_back(new IR::StringLiteral(@4, $4));
          $$ = result; }

      // Triples
    | START_EXPRESSION_TRIPLE expression "," expression "," expression
        { auto* result = new IR::Vector<IR::Expression>();
          result->push_back($2);
          result->push_back($4);
          result->push_back($6);
          $$ = result; }
    | START_INTEGER_TRIPLE INTEGER "," INTEGER "," INTEGER
        { auto* result = new IR::Vector<IR::Expression>();
          result->push_back(parseConstant(@2, $2, 0));
          result->push_back(parseConstant(@4, $4, 0));
          result->push_back(parseConstant(@6, $6, 0));
          $$ = result; }
    | START_STRING_LITERAL_TRIPLE STRING_LITERAL "," STRING_LITERAL ","
      STRING_LITERAL
        { auto* result = new IR::Vector<IR::Expression>();
          result->push_back(new IR::StringLiteral(@2, $2));
          result->push_back(new IR::StringLiteral(@4, $4));
          result->push_back(new IR::StringLiteral(@6, $6));
          $$ = result; }
    ;

program : input END { YYACCEPT; };

input
    : /* epsilon */
    | input declaration  { if ($2) driver.nodes->push_back($2->getNode()); }
    | input ";"          {}   // empty declaration
    ;

declaration
    : constantDeclaration     { $$ = $1; }
    | externDeclaration       { $$ = $1; }
    | actionDeclaration       { $$ = $1; }
    | parserDeclaration       { $$ = $1; }
    | typeDeclaration         { $$ = $1; }
    | controlDeclaration      { $$ = $1; }
    | instantiation           { $$ = $1; }
    | errorDeclaration        { driver.onReadErrorDeclaration($1); $$ = nullptr; }
    | matchKindDeclaration    { $$ = $1; }
    | functionDeclaration     { $$ = $1; }
    ;

nonTypeName
    : IDENTIFIER  { $$ = new IR::ID(@1, $1); }
    | APPLY       { $$ = new IR::ID(@1, "apply"); }
    | KEY         { $$ = new IR::ID(@1, "key"); }
    | ACTIONS     { $$ = new IR::ID(@1, "actions"); }
    | STATE       { $$ = new IR::ID(@1, "state"); }
    | ENTRIES     { $$ = new IR::ID(@1, "entries"); }
    | TYPE        { $$ = new IR::ID(@1, "type"); }
    ;

name
    : nonTypeName { $$ = $1; }
    | TYPE_IDENTIFIER  { $$ = new IR::ID(@1, $1); }
    ;

nonTableKwName
    : IDENTIFIER       { $$ = new IR::ID(@1, $1); }
    | TYPE_IDENTIFIER  { $$ = new IR::ID(@1, $1); }
    | APPLY            { $$ = new IR::ID(@1, "apply"); }
    | STATE            { $$ = new IR::ID(@1, "state"); }
    | TYPE             { $$ = new IR::ID(@1, "type"); }
    ;

optCONST
    : /* empty */ { $$ = OptionalConst{false}; }
    | CONST       { $$ = OptionalConst{true}; }
    ;

optAnnotations
    : /* empty */ { $$ = IR::Annotations::empty; }
    | annotations { $$ = new IR::Annotations(@1, *$1); }
    ;

annotations
    : annotation  { $$ = new IR::Vector<IR::Annotation>(); $$->push_back($1); }
    | annotations annotation { $$ = $1; $$->push_back($2); }
    ;

annotation
    : "@" name
        { // Initialize with an empty sequence of annotation tokens so that the
          // annotation node is marked as unparsed.
          IR::Vector<IR::AnnotationToken> body;
          $$ = new IR::Annotation(@1, *$2, body); }
    | "@" name "(" annotationBody ")"
        { $$ = new IR::Annotation(@1, *$2, *$4); }
    // Experimental: backwards compatibility with P4-14 pragmas (which
    // themselves are experimental!)
    | PRAGMA name annotationBody END_PRAGMA
                                      { $$ = new IR::Annotation(@1, *$2, *$3); }
    ;

annotationBody
    : /* empty */
        { $$ = new IR::Vector<IR::AnnotationToken>; }
    | annotationBody "(" annotationBody ")"
        { $$ = $1;
          $$->push_back(new IR::AnnotationToken(@2, $2.type, $2.text));
          $$->append(*$3);
          $$->push_back(new IR::AnnotationToken(@4, $4.type, $4.text)); }
    | annotationBody annotationToken
        { $$ = $1;
          $$->push_back(new IR::AnnotationToken(@2, $2.type, $2.text, $2.unparsedConstant)); }
    ;

annotationToken
    : UNEXPECTED_TOKEN { $$ = $1; }
    | ABSTRACT         { $$ = $1; }
    | ACTION           { $$ = $1; }
    | ACTIONS          { $$ = $1; }
    | APPLY            { $$ = $1; }
    | BOOL             { $$ = $1; }
    | BIT              { $$ = $1; }
    | CONST            { $$ = $1; }
    | CONTROL          { $$ = $1; }
    | DEFAULT          { $$ = $1; }
    | ELSE             { $$ = $1; }
    | ENTRIES          { $$ = $1; }
    | ENUM             { $$ = $1; }
    | ERROR            { $$ = $1; }
    | EXIT             { $$ = $1; }
    | EXTERN           { $$ = $1; }
    | FALSE            { $$ = $1; }
    | HEADER           { $$ = $1; }
    | HEADER_UNION     { $$ = $1; }
    | IF               { $$ = $1; }
    | IN               { $$ = $1; }
    | INOUT            { $$ = $1; }
    | INT              { $$ = $1; }
    | KEY              { $$ = $1; }
    | MATCH_KIND       { $$ = $1; }
    | TYPE             { $$ = $1; }
    | OUT              { $$ = $1; }
    | PARSER           { $$ = $1; }
    | PACKAGE          { $$ = $1; }
    | PRAGMA           { $$ = $1; }
    | RETURN           { $$ = $1; }
    | SELECT           { $$ = $1; }
    | STATE            { $$ = $1; }
    | STRUCT           { $$ = $1; }
    | SWITCH           { $$ = $1; }
    | TABLE            { $$ = $1; }
    | THIS             { $$ = $1; }
    | TRANSITION       { $$ = $1; }
    | TRUE             { $$ = $1; }
    | TUPLE            { $$ = $1; }
    | TYPEDEF          { $$ = $1; }
    | VARBIT           { $$ = $1; }
    | VALUESET         { $$ = $1; }
    | VOID             { $$ = $1; }
    | "_"              { $$ = $1; }

    | IDENTIFIER       { $$ = Token(token::TOK_IDENTIFIER, $1); }
    | TYPE_IDENTIFIER  { $$ = Token(token::TOK_TYPE_IDENTIFIER, $1); }
    | STRING_LITERAL   { $$ = Token(token::TOK_STRING_LITERAL, $1); }
    | INTEGER          { $$ = Token(token::TOK_INTEGER, $1); }

    | "&&&"            { $$ = $1; }
    | ".."             { $$ = $1; }
    | "<<"             { $$ = $1; }
    | "&&"             { $$ = $1; }
    | "||"             { $$ = $1; }
    | "=="             { $$ = $1; }
    | "!="             { $$ = $1; }
    | ">="             { $$ = $1; }
    | "<="             { $$ = $1; }
    | "++"             { $$ = $1; }

    | "+"              { $$ = $1; }
    | "|+|"            { $$ = $1; }
    | "-"              { $$ = $1; }
    | "|-|"            { $$ = $1; }
    | "*"              { $$ = $1; }
    | "/"              { $$ = $1; }
    | "%"              { $$ = $1; }

    | "|"              { $$ = $1; }
    | "&"              { $$ = $1; }
    | "^"              { $$ = $1; }
    | "~"              { $$ = $1; }

    // Omit parens. These are handled in annotationBody, since they must be
    // balanced.
    // | "("              { $$ = $1; }
    // | ")"              { $$ = $1; }

    | "["              { $$ = $1; }
    | "]"              { $$ = $1; }
    | "{"              { $$ = $1; }
    | "}"              { $$ = $1; }
    | "<"              { $$ = $1; }
    | ">"              { $$ = $1; }

    | "!"              { $$ = $1; }
    | ":"              { $$ = $1; }
    | ","              { $$ = $1; }
    | "?"              { $$ = $1; }
    | "."              { $$ = $1; }
    | "="              { $$ = $1; }
    | ";"              { $$ = $1; }
    | "@"              { $$ = $1; }
    ;

kvList
    : kvPair                          { $$ = new IR::IndexedVector<IR::NamedExpression>; $$->push_back($1); }
    | kvList "," kvPair               { $$ = $1; $$->push_back($3); }
    ;

kvPair
    : name "=" expression             { $$ = new IR::NamedExpression(@1, *$1, $3); }
    ;

parameterList
    : /* empty */                        { $$ = new IR::IndexedVector<IR::Parameter>(); }
    | nonEmptyParameterList              { $$ = $1; }
    ;

nonEmptyParameterList
    : parameter                           { $$ = new IR::IndexedVector<IR::Parameter>();
                                            $$->push_back($1); }
    | nonEmptyParameterList "," parameter { $$ = $1; $$->push_back($3); }
    ;

parameter
    : optAnnotations direction typeRef name { $$ = new IR::Parameter(@4, *$4, $1, $2, $3, nullptr); }
    | optAnnotations direction typeRef name "=" expression { $$ = new IR::Parameter(@4, *$4, $1, $2, $3, $6); }
    ;

direction
    : IN           { $$ = IR::Direction::In; }
    | OUT          { $$ = IR::Direction::Out; }
    | INOUT        { $$ = IR::Direction::InOut; }
    | /* empty */  { $$ = IR::Direction::None; }
    ;

packageTypeDeclaration
    : optAnnotations PACKAGE name { driver.structure->pushContainerType(*$3, false); }
      optTypeParameters { driver.structure->declareTypes(&$5->parameters); }
      "(" parameterList ")"        { auto pl = new IR::ParameterList(@8, *$8);
                                     $$ = new IR::Type_Package(@3, *$3, $1, $5, pl); }
    ;

instantiation
      : annotations typeRef "(" argumentList ")" name ";"
                     { $$ = new IR::Declaration_Instance(@6, *$6, new IR::Annotations(*$1),
                                                         $2, $4);
                       driver.structure->declareObject(*$6); }
      | typeRef "(" argumentList ")" name ";"
                     { $$ = new IR::Declaration_Instance(@5, *$5, $1, $3);
                       driver.structure->declareObject(*$5); }
      /* experimental */
      | annotations typeRef "(" argumentList ")" name "=" objInitializer ";"
                     { $$ = new IR::Declaration_Instance(@6, *$6, new IR::Annotations(*$1),
                                                         $2, $4, $8);
                       driver.structure->declareObject(*$6); }
      /* experimental */
      | typeRef "(" argumentList ")" name "=" objInitializer ";"
                     { $$ = new IR::Declaration_Instance(@5, *$5, $1, $3, $7);
                       driver.structure->declareObject(*$5); }
    ;

/* experimental; includes the following 3 productions */
objInitializer
    : "{" { driver.structure->pushNamespace(@1, false); } objDeclarations "}"
                               { driver.structure->pop();
                                 $$ = new IR::BlockStatement(@1+@4, *$3); }
    ;

objDeclarations
    : /* empty */                    { $$ = new IR::IndexedVector<IR::StatOrDecl>(); }
    | objDeclarations objDeclaration { $$ = $1; $1->push_back($2); }
    ;

objDeclaration
    : functionDeclaration      { $$ = $1; }
    | instantiation            { $$ = $1; }
    ;

optConstructorParameters
    : /* empty */            { $$ = new IR::IndexedVector<IR::Parameter>(); }
    | "(" parameterList ")"  { $$ = $2; }
    ;

dotPrefix
    : "."                      { driver.structure->startAbsolutePath(); }
    ;

/**************************** PARSER ******************************/

parserDeclaration
    : parserTypeDeclaration optConstructorParameters
      "{" parserLocalElements parserStates "}"
                             { driver.structure->pop();
                               auto pl = new IR::ParameterList(@2, *$2);
                               $$ = new IR::P4Parser($1->name.srcInfo, $1->name,
                                                     $1, pl, *$4, *$5);}
    ;

parserLocalElements
    : /* empty */                     { $$ = new IR::IndexedVector<IR::Declaration>(); }
    | parserLocalElements parserLocalElement { $$ = $1; $$->push_back($2); }
    ;

parserLocalElement
    : constantDeclaration             { $$ = $1; }
    | instantiation                   { $$ = $1; }
    | variableDeclaration             { $$ = $1; }
    | valueSetDeclaration             { $$ = $1; }
    ;

parserTypeDeclaration
    : optAnnotations
        PARSER name       { driver.structure->pushContainerType(*$3, false); }
        optTypeParameters { driver.structure->declareTypes(&$5->parameters); }
        "(" parameterList ")" { auto pl = new IR::ParameterList(@8, *$8);
                                $$ = new IR::Type_Parser(@3, *$3, $1, $5, pl); }
    ;

parserStates
    : parserState                     { $$ = new IR::IndexedVector<IR::ParserState>();
                                        $$->push_back($1); }
    | parserStates parserState        { $$ = $1; $$->push_back($2); }
    ;

parserState
    : optAnnotations STATE name { driver.structure->pushContainerType(*$3, false); }
      "{" parserStatements transitionStatement "}"
                                      { driver.structure->pop();
                                        $$ = new IR::ParserState(@3, *$3, $1, *$6, $7); }
    ;

parserStatements
    : /* empty */                      { $$ = new IR::IndexedVector<IR::StatOrDecl>(); }
    | parserStatements parserStatement { $$ = $1; $1->push_back($2); }
    ;

parserStatement
    : assignmentOrMethodCallStatement { $$ = $1; }
    | directApplication               { $$ = $1; }
    | variableDeclaration             { $$ = $1; }
    | constantDeclaration             { $$ = $1; }
    | parserBlockStatement            { $$ = $1; }
    ;

parserBlockStatement
    : optAnnotations "{" parserStatements "}"
      { $$ = new IR::BlockStatement(@1+@4, $1, *$3); }
    ;

transitionStatement
    : /* empty */                 { $$ = nullptr; }
    | TRANSITION stateExpression  { $$ = $2; }
    ;

stateExpression
    : name ";"         { $$ = new IR::PathExpression(*$1); }
    | selectExpression { $$ = $1; }
    ;

selectExpression
    : SELECT "(" expressionList ")" "{" selectCaseList "}"
                              { $$ = new IR::SelectExpression(@1 + @7,
                                     new IR::ListExpression(@3, *$3), std::move(*$6)); }
    ;

selectCaseList
    : /* empty */                { $$ = new IR::Vector<IR::SelectCase>(); }
    | selectCaseList selectCase  { $$ = $1; $$->push_back($2); }
    ;

selectCase
    : keysetExpression ":" name ";"
      { auto expr = new IR::PathExpression(*$3);
        $$ = new IR::SelectCase(@1 + @3, $1, expr); }
    ;

keysetExpression
    : tupleKeysetExpression     { $$ = new IR::ListExpression(@1, *$1); }
    | simpleKeysetExpression    { $$ = $1; }
    ;

tupleKeysetExpression
    /* at least two elements in the tuple */
    : "(" simpleKeysetExpression "," simpleExpressionList ")"
                                { $$ = $4; $4->insert($4->begin(), $2); }
    ;

simpleExpressionList
    : simpleKeysetExpression { $$ = new IR::Vector<IR::Expression>(); $$->push_back($1); }
    | simpleExpressionList "," simpleKeysetExpression { $$ = $1; $$->push_back($3); }
    ;

simpleKeysetExpression
    : expression                  { $$ = $1; }
    | expression "&&&" expression { $$ = new IR::Mask(@1 + @3, $1, $3); }
    | expression ".." expression  { $$ = new IR::Range(@1 + @3, $1, $3); }
    | DEFAULT                     { $$ = new IR::DefaultExpression(@1); }
    | "_"                         { $$ = new IR::DefaultExpression(@1); }
    ;

valueSetDeclaration
    : optAnnotations
        VALUESET "<" baseType ">" "(" expression ")" name ";"
        { $$ = new IR::P4ValueSet(@9, *$9, $1, $4, $7); }
    | optAnnotations
        VALUESET "<" tupleType ">" "(" expression ")" name ";"
        { $$ = new IR::P4ValueSet(@9, *$9, $1, $4, $7); }
    | optAnnotations
        VALUESET "<" typeName ">" "(" expression ")" name ";"
        { $$ = new IR::P4ValueSet(@9, *$9, $1, $4, $7); }
    ;

/*************************** CONTROL ************************/

controlDeclaration
    : controlTypeDeclaration optConstructorParameters
      "{" controlLocalDeclarations APPLY controlBody "}"
        { driver.structure->pop();
          auto pl = new IR::ParameterList(@2, *$2);
          $$ = new IR::P4Control($1->name.srcInfo, $1->name, $1, pl, *$4, $6); }
    ;

controlTypeDeclaration
    : optAnnotations
        CONTROL name { driver.structure->pushContainerType(*$3, false); }
        optTypeParameters { driver.structure->declareTypes(&$5->parameters); }
        "(" parameterList ")" { auto pl = new IR::ParameterList(@8, *$8);
                                $$ = new IR::Type_Control(@3, *$3, $1, $5, pl); }
    ;

controlLocalDeclarations
    : /* empty */               { $$ = new IR::IndexedVector<IR::Declaration>(); }
    | controlLocalDeclarations controlLocalDeclaration { $$ = $1; $$->push_back($2); }
    ;

controlLocalDeclaration
    : constantDeclaration      { $$ = $1; }
    | actionDeclaration        { $$ = $1; }
    | tableDeclaration         { $$ = $1; }
    | instantiation            { $$ = $1; }
    | variableDeclaration      { $$ = $1; }
    ;

controlBody
    : blockStatement { $$ = $1; }
    ;

/*************************** EXTERN *************************/

externDeclaration
    : optAnnotations
        EXTERN nonTypeName { driver.structure->pushContainerType(*$3, true); }
        optTypeParameters { driver.structure->declareTypes(&$5->parameters); }
        "{" methodPrototypes "}" { driver.structure->pop();
                                   $$ = new IR::Type_Extern(@3, *$3, $5, *$8, $1); }
    | optAnnotations EXTERN functionPrototype ";" { $$ = $3; $3->annotations = $1; }
    | optAnnotations EXTERN name ";" {
            // forward declaration;
            driver.structure->pushContainerType(*$3, true);
            driver.structure->pop();
            $$ = nullptr; }
    ;

methodPrototypes
    : /* empty */                      { $$ = new IR::Vector<IR::Method>(); }
    | methodPrototypes methodPrototype { $$ = $1; $1->push_back($2); }
    ;

functionPrototype
    : typeOrVoid
        name optTypeParameters { driver.structure->pushNamespace(@2, false);
                                 driver.structure->declareTypes(&$3->parameters); }
        "(" parameterList ")" { driver.structure->pop(); }
                           { auto params = new IR::ParameterList(@6, *$6);
                             auto mt = new IR::Type_Method(@2, $3, $1, params);
                             $$ = new IR::Method(@2, *$2, mt); }
    ;

methodPrototype
    : optAnnotations functionPrototype ";" { $$ = $2; $2->annotations = $1; }
    | optAnnotations ABSTRACT functionPrototype ";"    { $$ = $3; $$->setAbstract();
                                                         $3->annotations = $1; }  // experimental
    | optAnnotations TYPE_IDENTIFIER "(" parameterList ")" ";"  // constructor
                                        { auto par = new IR::ParameterList(@4, *$4);
                                          auto mt = new IR::Type_Method(@2, par);
                                          $$ = new IR::Method(@2, IR::ID(@2, $2), mt, $1); }
    ;

/************************** TYPES ****************************/

typeRef
    : baseType                         { $$ = $1; }
    | typeName                         { $$ = $1; }
    | specializedType                  { $$ = $1; }
    | headerStackType                  { $$ = $1; }
    | tupleType                        { $$ = $1; }
    ;

namedType
    : typeName                         { $$ = $1; }
    | specializedType                  { $$ = $1; }
    ;

prefixedType
    : TYPE_IDENTIFIER                  { $$ = new IR::Path(IR::ID(@1, $1)); }
    | dotPrefix TYPE_IDENTIFIER        { $$ = new IR::Path(IR::ID(@2, $2), true);
                                         driver.structure->clearPath(); }
    ;

typeName
    : prefixedType                     { $$ = new IR::Type_Name(@1, $1); }
    ;

tupleType
    : TUPLE "<" typeArgumentList ">"    { $$ = new IR::Type_Tuple(@1+@4, *$3); }
    ;

headerStackType
    : typeName "[" expression "]"       { $$ = new IR::Type_Stack(@1+@4, $1, $3); }
    ;

specializedType
    : typeName "<" typeArgumentList ">" { $$ = new IR::Type_Specialized(@1 + @4, $1, $3); }
    ;

baseType
    : BOOL   { $$ = IR::Type_Boolean::get(); }
    | ERROR  { $$ = new IR::Type_Name(@1, new IR::Path(IR::ID(@1, "error"))); }
    | BIT    { $$ = IR::Type::Bits::get(@1, 1); }
    | INT    { $$ = new IR::Type_InfInt(); }
    | BIT "<" INTEGER ">"
      { $$ = IR::Type::Bits::get(@1+@4, parseConstantChecked(@3, $3), false); }
    | INT "<" INTEGER ">"
      { $$ = IR::Type::Bits::get(@1+@4, parseConstantChecked(@3, $3), true); }
    | VARBIT "<" INTEGER ">"
      { $$ = IR::Type::Varbits::get(@1+@4, parseConstantChecked(@3, $3)); }

    | BIT "<" "(" expression ")" ">"
      { $$ = new IR::Type_Bits(@1+@6, $4, false); }
    | INT "<" "(" expression ")" ">"
      { $$ = new IR::Type_Bits(@1+@6, $4, true); }
    | VARBIT "<" "(" expression ")" ">"
      { $$ = new IR::Type_Varbits(@1+@6, $4); }
    ;

typeOrVoid
    : typeRef     { $$ = $1; }
    | VOID        { $$ = IR::Type_Void::get(); }
    | IDENTIFIER  { $$ = new IR::Type_Name(@1, new IR::Path(*(new IR::ID(@1, $1)))); }
        // This is necessary because template arguments may introduce the return type
    ;

optTypeParameters
    : /* empty */               { $$ = new IR::TypeParameters(); }
    | "<" typeParameterList ">" { $$ = new IR::TypeParameters(@1+@3, *$2); }
    ;

typeParameterList
    : name                           { $$ = new IR::IndexedVector<IR::Type_Var>();
                                       $$->push_back(new IR::Type_Var(@1, *$1)); }
    | typeParameterList "," name     { ($$=$1)->push_back(new IR::Type_Var(@3, *$3)); }
    ;

typeArg
    : typeRef                     { $$ = $1; }
    | nonTypeName                 { $$ = new IR::Type_Name(@1, new IR::Path(*$1)); }
        // This is necessary because template arguments may introduce the return type
    | VOID                        { $$ = IR::Type_Void::get(); }
    | "_"                         { $$ = new IR::Type_Dontcare(@1); }
    ;

typeArgumentList
    : /* empty */                    { $$ = new IR::Vector<IR::Type>(); }
    | typeArg                        { $$ = new IR::Vector<IR::Type>(); $$->push_back($1); }
    | typeArgumentList "," typeArg   { $$ = $1; $$->push_back($3); }
    ;

realTypeArg
    : typeRef                     { $$ = $1; }
    | VOID                        { $$ = IR::Type_Void::get(); }
    | "_"                         { $$ = new IR::Type_Dontcare(@1); }
    ;

// For use in contexts where the `<` might be a less-than rather than introducing a type
// argument list -- we only allow the token after `<` to be a TYPE_IDENTIFIER, not an ID
realTypeArgumentList
    : realTypeArg                        { $$ = new IR::Vector<IR::Type>(); $$->push_back($1); }
    | realTypeArgumentList "," typeArg   { $$ = $1; $$->push_back($3); }
    ;

typeDeclaration
    : derivedTypeDeclaration     { $$ = $1; }
    | typedefDeclaration ";"     { $$ = $1; }
    | parserTypeDeclaration ";"  { driver.structure->pop(); $$ = $1; }
    | controlTypeDeclaration ";" { driver.structure->pop(); $$ = $1; }
    | packageTypeDeclaration ";" { driver.structure->pop(); $$ = $1; }
    ;

derivedTypeDeclaration
    : headerTypeDeclaration            { $$ = $1; }
    | headerUnionDeclaration           { $$ = $1; }
    | structTypeDeclaration            { $$ = $1; }
    | enumDeclaration                  { $$ = $1; }
    ;

headerTypeDeclaration
    : optAnnotations
        HEADER name { driver.structure->declareType(*$3); }
        "{" structFieldList "}" { $$ = new IR::Type_Header(@3, *$3, $1, *$6); }
    ;

structTypeDeclaration
    : optAnnotations
        STRUCT name { driver.structure->declareType(*$3); }
        "{" structFieldList "}" { $$ = new IR::Type_Struct(@3, *$3, $1, *$6); }
    ;

headerUnionDeclaration
    : optAnnotations
        HEADER_UNION name { driver.structure->declareType(*$3); }
        "{" structFieldList "}" { $$ = new IR::Type_HeaderUnion(@3, *$3, $1, *$6); }
    ;

structFieldList
    : /* empty */                      { $$ = new IR::IndexedVector<IR::StructField>(); }
    | structFieldList structField      { $$ = $1; $1->push_back($2); }
    ;

structField
    : optAnnotations typeRef name ";"  { $$ = new IR::StructField(@3, *$3, $1, $2); }
    ;

enumDeclaration
    : optAnnotations
        ENUM name { driver.structure->declareType(*$3); }
        "{" identifierList "}" { $$ = new IR::Type_Enum(@3, *$3, *$6); }
    | optAnnotations ENUM BIT "<" INTEGER ">" name { driver.structure->declareType(*$7); }
        "{" specifiedIdentifierList "}" {
            auto type = IR::Type::Bits::get(@3+@6, parseConstantChecked(@5, $5));
            $$ = new IR::Type_SerEnum(@7, *$7, type, *$10); }
    ;

specifiedIdentifierList
    : specifiedIdentifier     { $$ = new IR::IndexedVector<IR::SerEnumMember>(); $$->push_back($1); }
    | specifiedIdentifierList "," specifiedIdentifier { $$ = $1; $1->push_back($3); }
    ;

specifiedIdentifier
    : name "=" initializer    { $$ = new IR::SerEnumMember(@1+@3, *$1, $3); }
    ;

errorDeclaration
    : ERROR "{" identifierList "}"
        { $$ = new IR::Type_Error(@1 + @4, IR::ID(@1, "error"), *$3); }
    ;

matchKindDeclaration
    : MATCH_KIND "{" identifierList "}"
        { $$ = new IR::Declaration_MatchKind(@1 + @4, *$3); }
    ;

identifierList
    : name                    { $$ = new IR::IndexedVector<IR::Declaration_ID>();
                                $$->push_back(new IR::Declaration_ID(@1, *$1));}
    | identifierList "," name { $$ = $1; $$->push_back(new IR::Declaration_ID(@3, *$3)); }
    ;

typedefDeclaration
    : optAnnotations TYPEDEF typeRef name   { driver.structure->declareType(*$4);
          $$ = new IR::Type_Typedef(@4, *$4, new IR::Annotations(*$1), $3); }
    | optAnnotations TYPEDEF derivedTypeDeclaration name   { driver.structure->declareType(*$4);
                        $$ = new IR::Type_Typedef(@4, *$4, new IR::Annotations(*$1), $3); }
    | optAnnotations TYPE typeRef name   { driver.structure->declareType(*$4);
          $$ = new IR::Type_Newtype(@4, *$4, new IR::Annotations(*$1), $3); }
    | optAnnotations TYPE derivedTypeDeclaration name   { driver.structure->declareType(*$4);
                        $$ = new IR::Type_Newtype(@4, *$4, new IR::Annotations(*$1), $3); }
    ;

/*************************** STATEMENTS *************************/

assignmentOrMethodCallStatement
    // These rules are overly permissive, but they avoid some conflicts
    : lvalue "(" argumentList ")" ";"
        { auto mc = new IR::MethodCallExpression(@1 + @4, $1,
                                                 new IR::Vector<IR::Type>(), $3);
          $$ = new IR::MethodCallStatement(@1 + @4, mc); }

    | lvalue "<" typeArgumentList ">" "(" argumentList ")" ";"
        { auto mc = new IR::MethodCallExpression(@1 + @7,
                                                 $1, $3, $6);
          $$ = new IR::MethodCallStatement(@1 + @7, mc); }

    | lvalue "=" expression ";"
        { $$ = new IR::AssignmentStatement(@2, $1, $3); }

    ;

emptyStatement
    : ";"      { $$ = new IR::EmptyStatement(@1); }
    ;

exitStatement
    : EXIT ";" { $$ = new IR::ExitStatement(@1); }
    ;

returnStatement
    : RETURN ";"            { $$ = new IR::ReturnStatement(@1, nullptr); }
    | RETURN expression ";" { $$ = new IR::ReturnStatement(@1, $2); }
    ;

conditionalStatement
    : IF "(" expression ")" statement                 %prec THEN
        { $$ = new IR::IfStatement(@1, $3, $5, nullptr); }
    | IF "(" expression ")" statement ELSE statement  %prec THEN
        { $$ = new IR::IfStatement(@1, $3, $5, $7); }
    ;

// To support direct invocation of a control or parser without instantiation
directApplication
    : typeName "." APPLY "(" argumentList ")" ";" {
                                  auto method = new IR::Member(
                                      @1 + @3, new IR::TypeNameExpression($1), IR::ID(@3, "apply"));
                                  auto mce = new IR::MethodCallExpression(@1 + @6, method, $5);
                                  $$ = new IR::MethodCallStatement(@1 + @6, mce); }
    ;

statement
    : assignmentOrMethodCallStatement  { $$ = $1; }
    | directApplication                { $$ = $1; }
    | conditionalStatement             { $$ = $1; }
    | emptyStatement                   { $$ = $1; }
    | blockStatement                   { $$ = $1; }
    | returnStatement                  { $$ = $1; }
    | exitStatement                    { $$ = $1; }
    | switchStatement                  { $$ = $1; }
    ;

blockStatement
    : optAnnotations "{" { driver.structure->pushNamespace(@2, false); }
      statOrDeclList "}" { driver.structure->pop();
                           $$ = new IR::BlockStatement(@1 + @5, $1, *$4); }
    ;

statOrDeclList
    : /* empty */                           { $$ = new IR::IndexedVector<IR::StatOrDecl>(); }
    | statOrDeclList statementOrDeclaration { $$ = $1; $$->push_back($2); }
    ;

switchStatement
    : SWITCH "(" expression ")" "{" switchCases "}" {
            $$ = new IR::SwitchStatement(@1, $3, std::move(*$6)); }
    ;

switchCases
    : /* empty */              { $$ = new IR::Vector<IR::SwitchCase>(); }
    | switchCases switchCase   { $$ = $1; $$->push_back($2); }
    ;

switchCase
    : switchLabel ":" blockStatement { $$ = new IR::SwitchCase(@1 + @3, $1, $3); }
    | switchLabel ":" { $$ = new IR::SwitchCase(@1, $1, nullptr); }
    ;

switchLabel
    : name                     { $$ = new IR::PathExpression(*$1); }
    | DEFAULT                  { $$ = new IR::DefaultExpression(@1); }
    ;

statementOrDeclaration
    : variableDeclaration      { $$ = $1; }
    | constantDeclaration      { $$ = $1; }
    | statement                { $$ = $1; }
    | instantiation            { $$ = $1; }
    ;

/************************* TABLE *********************************/

tableDeclaration
    : optAnnotations
        TABLE name "{" tablePropertyList "}"
          { $$ = new IR::P4Table(@3, *$3, $1, new IR::TableProperties(@5, *$5)); }
    ;

tablePropertyList
    : tableProperty                      { $$ = new IR::IndexedVector<IR::Property>();
                                           $$->push_back($1); }
    | tablePropertyList tableProperty    { $$ = $1; $$->push_back($2); }
    ;

tableProperty
    : KEY "=" "{" keyElementList "}"
        { auto v = new IR::Key(@4, *$4);
          auto id = IR::ID(@1, "key");
          $$ = new IR::Property( @1 + @5, id, v, false); }
    | ACTIONS "=" "{" actionList "}"
        { auto v = new IR::ActionList(@4, *$4);
          auto id = IR::ID(@1, "actions");
          $$ = new IR::Property(@1 + @5, id, v, false); }
    | optAnnotations optCONST ENTRIES "=" "{" entriesList "}"
        { auto l = new IR::EntriesList(@3, *$6);
          auto id = IR::ID(@3+@7, "entries");
          $$ = new IR::Property(@3, id, $1, l, $2.isConst); }
    | optAnnotations optCONST nonTableKwName "=" initializer ";"
        { auto v = new IR::ExpressionValue(@5, $5);
          auto id = *$3;
          $$ = new IR::Property($3->srcInfo, id, $1, v, $2.isConst); }
    ;

keyElementList
    : /* empty */                        { $$ = new IR::Vector<IR::KeyElement>(); }
    | keyElementList keyElement          { $$ = $1; $$->push_back($2); }
    ;

keyElement
    : expression ":" name optAnnotations ";"
                                         { auto expr = new IR::PathExpression(*$3);
                                           $$ = new IR::KeyElement(@1, $4, $1, expr); }
    ;

actionList
    : /* empty */                        { $$ = new IR::IndexedVector<IR::ActionListElement>(); }
    | actionList actionRef ";"           { $$ = $1; $$->push_back($2); }
    ;

actionRef
    : optAnnotations name                { auto expr = new IR::PathExpression(*$2);
                                           $$ = new IR::ActionListElement(@2, $1, expr);}
    | optAnnotations name "(" argumentList ")"
                                         { auto method = new IR::PathExpression(*$2);
                                           auto mce = new IR::MethodCallExpression(
                                               @2+@4, method, $4);
                                           $$ = new IR::ActionListElement(@2, $1, mce); }
    ;

entry
    : keysetExpression ":" actionBinding optAnnotations ";"
                                         {
                                           assert($3->is<IR::MethodCallExpression>());
                                           if (auto l = $1->to<IR::ListExpression>())
                                             $$ = new IR::Entry(@1+@4, $4, l, $3);
                                           else {  // if not a tuple, make it a list of 1
                                             IR::Vector<IR::Expression> le($1);
                                             $$ = new IR::Entry(@1+@4, $4,
                                                                new IR::ListExpression(@1, le),
                                                                $3);
                                           }
                                         }
    ;

actionBinding
    : lvalue "(" argumentList ")"
        { $$ = new IR::MethodCallExpression(@1 + @4, $1,
                                            new IR::Vector<IR::Type>(), $3); }
    | lvalue "<" typeArgumentList ">" "(" argumentList ")"
        { $$ = new IR::MethodCallExpression(@1 + @7, $1, $3, $6); }

entriesList
    : entry                          { $$ = new IR::Vector<IR::Entry>(); $$->push_back($1); }
    | entriesList entry              { $$ = $1; $$->push_back($2); }
    ;

/************************* ACTION ********************************/

actionDeclaration
    : optAnnotations ACTION name "(" parameterList ")" blockStatement
        { auto pl = new IR::ParameterList(@5, *$5);
          $$ = new IR::P4Action(@3, *$3, $1, pl, $7); }
    ;

/************************* VARIABLES *****************************/

variableDeclaration
    : annotations typeRef name optInitializer ";"
                                     { auto ann = new IR::Annotations(@1, *$1);
                                       $$ = new IR::Declaration_Variable(@1+@4, *$3, ann, $2, $4);
                                       driver.structure->declareObject(*$3); }
    | typeRef name optInitializer ";"
                                     { $$ = new IR::Declaration_Variable(@1+@4, *$2, $1, $3);
                                       driver.structure->declareObject(*$2); }
    ;

constantDeclaration
    : optAnnotations CONST typeRef name "=" initializer ";"
                                     { $$ = new IR::Declaration_Constant(@1+@6, *$4, $1, $3, $6);
                                       driver.structure->declareObject(*$4); }
    ;

optInitializer
    : /* empty */                      { $$ = nullptr; }
    | "=" initializer                  { $$ = $2; }
    ;

initializer
    : expression                          { $$ = $1; }
    ;

/**************** Expressions ****************/

functionDeclaration
    : functionPrototype blockStatement   { $$ = new IR::Function($1->srcInfo, $1->name, $1->type, $2); }
    ;

argumentList
    : /* empty */                        { $$ = new IR::Vector<IR::Argument>(); }
    | nonEmptyArgList                    { $$ = $1; }
    ;

nonEmptyArgList
    : argument                           { $$ = new IR::Vector<IR::Argument>();
                                           $$->push_back($1); }
    | nonEmptyArgList "," argument       { $$ = $1; $$->push_back($3); }
    ;

argument
    : expression                         { $$ = new IR::Argument(@1, $1); }
    | name "=" expression                { $$ = new IR::Argument(@1, *$1, $3); }
    | "_"                                { $$ = new IR::Argument(@1, new IR::DefaultExpression(@1)); }
    ;

expressionList
    : /* empty */                        { $$ = new IR::Vector<IR::Expression>(); }
    | expression                         { $$ = new IR::Vector<IR::Expression>();
                                           $$->push_back($1); }
    | expressionList "," expression      { $$ = $1; $$->push_back($3); }
    ;

prefixedNonTypeName
    : nonTypeName                        { $$ = new IR::Path(*$1); }
    | dotPrefix nonTypeName              { $$ = new IR::Path(*$2, true);
                                           driver.structure->clearPath(); }
    ;

lvalue
    : prefixedNonTypeName                { $$ = new IR::PathExpression($1); }
    | THIS                               { $$ = new IR::This(@1); }  // experimental
    | lvalue "." name                    { $$ = new IR::Member(@1 + @3, $1, *$3); }
    | lvalue "[" expression "]"          { $$ = new IR::ArrayIndex(@1 + @4, $1, $3); }
    | lvalue "[" expression ":" expression "]" { $$ = new IR::Slice(@1 + @6, $1, $3, $5); }
    ;

expression
    : INTEGER                            { $$ = parseConstant(@1, $1, 0); }
    | STRING_LITERAL                     { $$ = new IR::StringLiteral(@1, $1); }
    | TRUE                               { $$ = new IR::BoolLiteral(@1, true); }
    | FALSE                              { $$ = new IR::BoolLiteral(@1, false); }
    | THIS                               { $$ = new IR::This(@1); }  // experimental
    | nonTypeName                        { $$ = new IR::PathExpression(*$1); }
    | dotPrefix nonTypeName              { $$ = new IR::PathExpression(new IR::Path(*$2, true)); driver.structure->clearPath(); }
    | expression "[" expression "]"      { $$ = new IR::ArrayIndex(@1 + @4, $1, $3); }
    | expression "[" expression ":" expression "]" { $$ = new IR::Slice(@1 + @6, $1, $3, $5); }
    | "{" expressionList "}"             { $$ = new IR::ListExpression(@1 + @3, *$2); }
| typeName "{" kvList "}"                { $$ = new IR::StructInitializerExpression(@1 + @4, IR::Type::Unknown::get(), $1, *$3); }  // experimental
    | "{" kvList "}"                     { $$ = new IR::StructInitializerExpression(
                                                  @1 + @3, IR::Type::Unknown::get(), (IR::Type_Name*)nullptr, *$2); }  // experimental
    | "(" expression ")"                 { $$ = $2; }
    | "!" expression %prec PREFIX        { $$ = new IR::LNot(@1 + @2, $2); }
    | "~" expression %prec PREFIX        { $$ = new IR::Cmpl(@1 + @2, $2); }
    | "-" expression %prec PREFIX        { $$ = new IR::Neg(@1 + @2, $2); }
    | "+" expression %prec PREFIX        { $$ = $2; }
    | typeName "." name
        { $$ = new IR::Member(@1 + @3, new IR::TypeNameExpression(@1, $1), *$3); }
    | ERROR "." name
        { auto typeName = new IR::Type_Name(@1, new IR::Path(IR::ID(@1, "error")));
          $$ = new IR::Member(@1+@3, new IR::TypeNameExpression(@1+@3, typeName), *$3); }
    | expression "." name                { $$ = new IR::Member(@1 + @3, $1, *$3); }
    | expression "*" expression          { $$ = new IR::Mul(@1 + @3, $1, $3); }
    | expression "/" expression          { $$ = new IR::Div(@1 + @3, $1, $3); }
    | expression "%" expression          { $$ = new IR::Mod(@1 + @3, $1, $3); }
    | expression "+" expression          { $$ = new IR::Add(@1 + @3, $1, $3); }
    | expression "-" expression          { $$ = new IR::Sub(@1 + @3, $1, $3); }
    | expression "|+|" expression        { $$ = new IR::AddSat(@1 + @3, $1, $3); }
    | expression "|-|" expression        { $$ = new IR::SubSat(@1 + @3, $1, $3); }
    | expression "<<" expression         { $$ = new IR::Shl(@1 + @3, $1, $3); }
    | expression ">" ">" expression
        { driver.checkShift(@2, @3); $$ = new IR::Shr(@1 + @4, $1, $4); }
    | expression "<=" expression         { $$ = new IR::Leq(@1 + @3, $1, $3); }
    | expression ">=" expression         { $$ = new IR::Geq(@1 + @3, $1, $3); }
    | expression "<" expression          { $$ = new IR::Lss(@1 + @3, $1, $3); }
    | expression ">" expression          { $$ = new IR::Grt(@1 + @3, $1, $3); }
    | expression "!=" expression         { $$ = new IR::Neq(@1 + @3, $1, $3); }
    | expression "==" expression         { $$ = new IR::Equ(@1 + @3, $1, $3); }
    | expression "&" expression          { $$ = new IR::BAnd(@1 + @3, $1, $3); }
    | expression "^" expression          { $$ = new IR::BXor(@1 + @3, $1, $3); }
    | expression "|" expression          { $$ = new IR::BOr(@1 + @3, $1, $3); }
    | expression "++" expression         { $$ = new IR::Concat(@1 + @3, $1, $3); }
    | expression "&&" expression         { $$ = new IR::LAnd(@1 + @2 + @3, $1, $3); }
    | expression "||" expression         { $$ = new IR::LOr(@1 + @2 + @3, $1, $3); }
    | expression "?" expression ":" expression { $$ = new IR::Mux(@1 + @5, $1, $3, $5); }
    | expression "<" realTypeArgumentList ">" "(" argumentList ")"
        { $$ = new IR::MethodCallExpression(@1 + @4, $1, $3, $6); }
    // FIXME: the previous rule has the wrong precedence, and parses with
    // precedence weaker than casts.  There is no easy way to fix this in bison.
    | expression "(" argumentList ")"
        { $$ = new IR::MethodCallExpression(@1 + @4, $1, $3); }
    | namedType "(" argumentList ")"
        { $$ = new IR::ConstructorCallExpression(@1 + @4, $1, $3); }
    | "(" typeRef ")" expression %prec PREFIX { $$ = new IR::Cast(@1 + @4, $2, $4); }
    ;

/*****************************************************************************/

%%

void P4::P4Parser::error(const Util::SourceInfo& location,
                         const std::string& message) {
    driver.onParseError(location, message);
}
