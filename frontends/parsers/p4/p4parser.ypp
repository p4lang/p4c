/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Use Bison's C++ mode.
%skeleton "lalr1.cc" /* -*-C++-*- */
%require "3.0.0"

// Set up names.
%defines
%define api.namespace {P4}
%define parser_class_name {P4Parser}

// Use the C++-native variant representation of tokens.
%define api.token.constructor
%define api.value.type variant

// Add asserts to ensure that we use the API correctly.
%define parse.assert true

// Enable verbose error reporting.
%error-verbose

// Declare dependencies.
%code requires {
#include <cassert>   // NOLINT(build/include_order)
#include <iostream>  // NOLINT(build/include_order)

#include "frontends/common/constantParsing.h"
#include "frontends/common/options.h"
#include "ir/ir.h"
#include "lib/cstring.h"
#include "lib/source_file.h"

namespace P4 {
class AbstractP4Lexer;
class P4ParserDriver;

// This is a workaround for an UndefinedBehaviorSanitizer issue triggered by
// Bison's variant implementation. When variant::move() is used to move a value
// from an initialized instance of variant to an uninitialized instance, it uses
// placement new to initialize the uninitialized instance, then calls
// variant::swap(), then destroys the moved-from instance. The problem is that
// placement new does not perform any initialization for primitive types, and
// for bool or enum types that can result in a value that isn't a valid element
// of those types, which UndefinedBehaviorSanitizer doesn't like.
struct OptionalConst {
    OptionalConst() = default;
    explicit OptionalConst(bool isConst) : isConst(isConst) { }
    bool isConst = false;
};
}  // namespace P4

inline std::ostream& operator<<(std::ostream& out, const P4::OptionalConst& oc) {
    out << "OptionalConst(" << oc.isConst << ')';
    return out;
}

// Bison uses the types you provide to %type to make constructors for the
// variant type it uses under the hood, but its code generation is a little
// naive and it always prepends 'const' to the type. This is problematic when
// the symbol type we want is itself const, since duplicate const qualifiers are
// forbidden in C++. We avoid the problem using a typedef.
typedef const IR::Type ConstType;

#ifndef YYDEBUG
#define YYDEBUG 1
#endif

#define YY_NULLPTR nullptr

namespace P4 {
class Token {
 public:
    int type;
    cstring text;
    UnparsedConstant* unparsedConstant;

    explicit Token() { }
    explicit Token(int type, cstring text) : Token(type, text, nullptr) { }
    explicit Token(int type, UnparsedConstant unparsedConstant)
            : Token(type, unparsedConstant.text,
                    new UnparsedConstant(unparsedConstant)) { }

 private:
    explicit Token(int type, cstring text, UnparsedConstant* unparsedConstant)
            : type(type), text(text), unparsedConstant(unparsedConstant) { }
};

} // namespace P4

inline std::ostream& operator<<(std::ostream& out, const P4::Token& t) {
    out << t.text;
    return out;
}
}

%param { P4::P4ParserDriver& driver }
%parse-param { P4::AbstractP4Lexer& lexer }

// Use location tracking with our custom location type.
%locations
%define api.location.type {Util::SourceInfo}

%{ /* -*-C++-*- */
#include "frontends/parsers/parserDriver.h"
#include "frontends/parsers/p4/p4lexer.hpp"
#include "frontends/parsers/p4/p4parser.hpp"

#define YYLLOC_DEFAULT(Cur, Rhs, N)                                             \
    ((Cur) = (N) ? YYRHSLOC(Rhs, 1) + YYRHSLOC(Rhs, N)                          \
                 : Util::SourceInfo(driver.sources, YYRHSLOC(Rhs, 0).getEnd()))

#undef yylex
#define yylex lexer.yylex

%}

// Use iostreams to print all values.
%printer { yyoutput << $$; } <*>;

%define api.token.prefix {TOK_}
%token             START_PROGRAM

                   // Lists
                   START_EXPRESSION_LIST
                   START_KV_LIST
                   START_INTEGER_LIST
                   START_INTEGER_OR_STRING_LITERAL_LIST
                   START_STRING_LITERAL_LIST

                   // Singletons
                   START_EXPRESSION
                   START_INTEGER
                   START_INTEGER_OR_STRING_LITERAL
                   START_STRING_LITERAL

                   // Pairs
                   START_EXPRESSION_PAIR
                   START_INTEGER_PAIR
                   START_STRING_LITERAL_PAIR

                   // Triples
                   START_EXPRESSION_TRIPLE
                   START_INTEGER_TRIPLE
                   START_STRING_LITERAL_TRIPLE

                   // P4Runtime annotations
                   START_P4RT_TRANSLATION_ANNOTATION  // @p4runtime_translation

%token             END END_ANNOTATION


///////////////////////////////////////////////////////////////////////////////
//
// Language token definitions.
//
// NB: Tokens defined here should be added to the annotationToken production.
//
///////////////////////////////////////////////////////////////////////////////

%token<Token>      UNEXPECTED_TOKEN END_PRAGMA
%token<Token>      LE "<="
%token<Token>      GE ">="
%token<Token>      SHL "<<"
%token<Token>      AND "&&"
%token<Token>      OR "||"
%token<Token>      NE "!="
%token<Token>      EQ "=="
%token<Token>      PLUS "+"
%token<Token>      MINUS "-"
%token<Token>      PLUS_SAT "|+|"
%token<Token>      MINUS_SAT "|-|"
%token<Token>      MUL "*"
%token<Token>      DIV "/"
%token<Token>      MOD "%"
%token<Token>      BIT_OR "|"
%token<Token>      BIT_AND "&"
%token<Token>      BIT_XOR "^"
%token<Token>      COMPLEMENT "~"
%token<Token>      L_BRACKET "["
%token<Token>      R_BRACKET "]"
%token<Token>      L_BRACE "{"
%token<Token>      R_BRACE "}"
%token<Token>      L_ANGLE "<"
%token<Token>      L_ANGLE_ARGS    // < where template args are expected
%token<Token>      R_ANGLE ">"
%token<Token>      R_ANGLE_SHIFT   // > immediately followed by another >
%token<Token>      L_PAREN "("
%token<Token>      R_PAREN ")"
%token<Token>      NOT "!"
%token<Token>      COLON ":"
%token<Token>      COMMA ","
%token<Token>      QUESTION "?"
%token<Token>      DOT "."
%token<Token>      ASSIGN "="
%token<Token>      SEMICOLON ";"
%token<Token>      AT "@"
%token<Token>      PP "++"
%token<Token>      DONTCARE "_"
%token<Token>      MASK "&&&"
%token<Token>      RANGE ".."
%token<Token>      TRUE FALSE THIS
%token<Token>      ABSTRACT ACTION ACTIONS APPLY BOOL BIT CONST CONTROL DEFAULT
                   ELSE ENTRIES ENUM ERROR EXIT EXTERN HEADER HEADER_UNION IF IN INOUT
                   INT KEY SELECT MATCH_KIND TYPE OUT PACKAGE PARSER PRAGMA RETURN STATE
                   STRING STRUCT SWITCH TABLE TRANSITION TUPLE TYPEDEF VARBIT VALUESET VOID

%token<cstring> IDENTIFIER TYPE_IDENTIFIER STRING_LITERAL
%token<UnparsedConstant>  INTEGER

// End of token definitions ///////////////////////////////////////////////////


%type<IR::ID*>              name dot_name nonTypeName nonTableKwName
%type<IR::Direction>        direction
%type<IR::Path*>            prefixedNonTypeName prefixedType
%type<IR::IndexedVector<IR::Type_Var>*>  typeParameterList
%type<IR::TypeParameters*>  optTypeParameters
%type<IR::Expression*>      expression lvalue keysetExpression selectExpression
                            stateExpression optInitializer initializer
                            simpleKeysetExpression transitionStatement switchLabel
                            p4rtControllerType
%type<ConstType*>           baseType typeOrVoid specializedType headerStackType
                            typeRef tupleType typeArg realTypeArg namedType
%type<IR::Type_Name*>       typeName
%type<IR::Argument*>        argument
%type<IR::Vector<IR::Argument>*>  argumentList nonEmptyArgList
%type<IR::Parameter*>       parameter
%type<OptionalConst>        optCONST
%type<IR::Annotations*>     optAnnotations
%type<IR::Vector<IR::Annotation>*>  annotations
%type<IR::Annotation*>      annotation
%type<IR::Vector<IR::AnnotationToken>*> annotationBody
%type<Token>                annotationToken
%type<IR::IndexedVector<IR::Parameter>*>  parameterList nonEmptyParameterList
                                          optConstructorParameters
%type<IR::Vector<IR::Expression>*>        expressionList
                                          simpleExpressionList tupleKeysetExpression
%type<IR::IndexedVector<IR::Declaration_ID>*>  identifierList
%type<IR::SelectCase*>      selectCase
%type<IR::Vector<IR::SelectCase>*>  selectCaseList
%type<IR::Statement*>       statement emptyStatement returnStatement
                            switchStatement exitStatement
                            assignmentOrMethodCallStatement conditionalStatement
                            directApplication
%type<IR::BlockStatement*>  blockStatement parserBlockStatement controlBody
                            objInitializer
%type<IR::StatOrDecl*>      statementOrDeclaration parserStatement
%type<IR::IndexedVector<IR::StatOrDecl>*>  objDeclarations statOrDeclList
                                           parserStatements
%type<IR::SwitchCase*>      switchCase
%type<IR::Vector<IR::SwitchCase>*>  switchCases
%type<IR::Vector<IR::Type>*>  typeArgumentList realTypeArgumentList
%type<IR::ParserState*>     parserState
%type<IR::IndexedVector<IR::ParserState>*>  parserStates
%type<IR::Declaration*>     constantDeclaration actionDeclaration
                            variableDeclaration instantiation functionDeclaration
                            objDeclaration tableDeclaration controlLocalDeclaration
                            parserLocalElement valueSetDeclaration
%type<IR::Type_Declaration*>  headerTypeDeclaration structTypeDeclaration
                              headerUnionDeclaration derivedTypeDeclaration
                              parserDeclaration controlDeclaration enumDeclaration
                              typedefDeclaration packageTypeDeclaration typeDeclaration
%type<IR::Type_Error*>      errorDeclaration
%type<IR::Node*>            fragment
%type<IR::Node*>            declaration externDeclaration matchKindDeclaration
%type<IR::Type_Parser*>     parserTypeDeclaration
%type<IR::Type_Control*>    controlTypeDeclaration
%type<IR::IndexedVector<IR::Declaration>*>  parserLocalElements controlLocalDeclarations
%type<IR::StructField*>     structField
%type<IR::IndexedVector<IR::StructField>*>  structFieldList
%type<IR::IndexedVector<IR::SerEnumMember>*> specifiedIdentifierList
%type<IR::SerEnumMember*>   specifiedIdentifier
%type<IR::Method*>          methodPrototype functionPrototype
%type<IR::Vector<IR::Method>*>  methodPrototypes
%type<IR::Property*>        tableProperty
%type<IR::IndexedVector<IR::Property>*>  tablePropertyList
%type<IR::KeyElement*>      keyElement
%type<IR::Vector<IR::KeyElement>*>  keyElementList
%type<IR::Expression*>  actionRef
%type<IR::IndexedVector<IR::ActionListElement>*>  actionList
%type<IR::Entry*>           entry
%type<IR::Vector<IR::Entry>*>  entriesList
%type<IR::IndexedVector<IR::NamedExpression>*> kvList
%type<IR::NamedExpression*> kvPair
%type<IR::Vector<IR::Expression>*> intList
%type<IR::Vector<IR::Expression>*> intOrStrList
%type<IR::Vector<IR::Expression>*> strList
%type<IR::Expression*> intOrStr

%left COMMA
%nonassoc QUESTION
%nonassoc COLON
%left OR
%left AND
%left EQ NE
%left L_ANGLE R_ANGLE LE GE
%left BIT_OR
%left BIT_XOR
%left BIT_AND
%left SHL R_ANGLE_SHIFT
%left PP PLUS MINUS PLUS_SAT MINUS_SAT
%left MUL DIV MOD
%right PREFIX
%nonassoc R_BRACKET L_PAREN L_BRACKET L_ANGLE_ARGS
%left DOT

%right THEN ELSE /* THEN is a fake token */

/*
FIXME -- we need this %destructor for correct error recovery, but because of the
broken bison C++ skeleton, it gets declarations in the wrong order and it won't
compile.  Not having it (just) means that the symbol table may get confused after
a syntax error causing a spurious error cascade, which isn't too bad.

%destructor { driver.structure->pop(); } functionPrototype parserTypeDeclaration
                                         controlTypeDeclaration
*/

%%

/*
   This grammar may look weird in some places, but a lot of effort was put into
   eliminating conflicts.  This sometimes required having the grammar be more
   lenient than necessary.  Moreover, the grammar is context-sensitive, and it
   needs some rudiments of type information to properly perform parsing.  This
   is done with the help of P4ParserDriver's "structure" object, which keeps
   track of which identifiers represent types, and which represent namespaces.
*/

// Simulate multiple start symbols to allow the parser to be reused for
// annotation bodies.
start
    : fragment END_ANNOTATION { driver.nodes->push_back($1->getNode()); YYACCEPT; }
    | START_PROGRAM program
    ;

fragment
      // Lists
    : START_EXPRESSION_LIST expressionList              { $$ = $2; }
    | START_KV_LIST kvList                              { $$ = $2; }
    | START_INTEGER_LIST intList                        { $$ = $2; }
    | START_INTEGER_OR_STRING_LITERAL_LIST intOrStrList { $$ = $2; }
    | START_STRING_LITERAL_LIST strList                 { $$ = $2; }

      // Singletons
    | START_EXPRESSION expression                       { $$ = $2; }
    | START_INTEGER INTEGER                             { $$ = parseConstant(@2, $2, 0); }
    | START_INTEGER_OR_STRING_LITERAL intOrStr          { $$ = $2; }
    | START_STRING_LITERAL STRING_LITERAL               { $$ = new IR::StringLiteral(@2, $2); }

      // Pairs
    | START_EXPRESSION_PAIR expression "," expression
        { auto* result = new IR::Vector<IR::Expression>();
          result->push_back($2);
          result->push_back($4);
          $$ = result; }
    | START_INTEGER_PAIR INTEGER "," INTEGER
        { auto* result = new IR::Vector<IR::Expression>();
          result->push_back(parseConstant(@2, $2, 0));
          result->push_back(parseConstant(@4, $4, 0));
          $$ = result; }
    | START_STRING_LITERAL_PAIR STRING_LITERAL "," STRING_LITERAL
        { auto* result = new IR::Vector<IR::Expression>();
          result->push_back(new IR::StringLiteral(@2, $2));
          result->push_back(new IR::StringLiteral(@4, $4));
          $$ = result; }

      // Triples
    | START_EXPRESSION_TRIPLE expression "," expression "," expression
        { auto* result = new IR::Vector<IR::Expression>();
          result->push_back($2);
          result->push_back($4);
          result->push_back($6);
          $$ = result; }
    | START_INTEGER_TRIPLE INTEGER "," INTEGER "," INTEGER
        { auto* result = new IR::Vector<IR::Expression>();
          result->push_back(parseConstant(@2, $2, 0));
          result->push_back(parseConstant(@4, $4, 0));
          result->push_back(parseConstant(@6, $6, 0));
          $$ = result; }
    | START_STRING_LITERAL_TRIPLE STRING_LITERAL "," STRING_LITERAL ","
      STRING_LITERAL
        { auto* result = new IR::Vector<IR::Expression>();
          result->push_back(new IR::StringLiteral(@2, $2));
          result->push_back(new IR::StringLiteral(@4, $4));
          result->push_back(new IR::StringLiteral(@6, $6));
          $$ = result; }

      // P4Runtime annotations
    | START_P4RT_TRANSLATION_ANNOTATION STRING_LITERAL "," p4rtControllerType
        { auto* result = new IR::Vector<IR::Expression>();
          result->push_back(new IR::StringLiteral(@2, $2));
          result->push_back($4);
          $$ = result; }
    ;

// We want this to return an `IR::Type`, but we need it to return an
// `IR::Expression` for things to type-check. We thus use `IR::StringLiteral` to
// encode the type "string", and `IR::Constant(W)` to encode the type "bit<W>".
// TODO: Could this be redesigned to avoid this hack?
p4rtControllerType
    : STRING
        { $$ = new IR::StringLiteral(@1, ""); }
    | BIT l_angle INTEGER r_angle
        { $$ = new IR::Constant(parseConstantChecked(@3, $3)); }
    // Legacy syntax; to be removed in P4RT 2.0
    | INTEGER
        { $$ = new IR::Constant(parseConstantChecked(@1, $1)); }
    ;

program : input END { YYACCEPT; };

input
    : /* epsilon */
    | input declaration  { if ($2) driver.nodes->push_back($2->getNode()); }
    | input ";"          {}   // empty declaration
    ;

declaration
    : constantDeclaration     { $$ = $1; }
    | externDeclaration       { $$ = $1; }
    | actionDeclaration       { $$ = $1; }
    | parserDeclaration       { $$ = $1; }
    | typeDeclaration         { $$ = $1; }
    | controlDeclaration      { $$ = $1; }
    | instantiation           { $$ = $1; }
    | errorDeclaration        { driver.onReadErrorDeclaration($1); $$ = nullptr; }
    | matchKindDeclaration    { $$ = $1; }
    | functionDeclaration     { $$ = $1; }
    ;

nonTypeName
    : IDENTIFIER  { $$ = new IR::ID(@1, $1); }
    | APPLY       { $$ = new IR::ID(@1, "apply"); }
    | KEY         { $$ = new IR::ID(@1, "key"); }
    | ACTIONS     { $$ = new IR::ID(@1, "actions"); }
    | STATE       { $$ = new IR::ID(@1, "state"); }
    | ENTRIES     { $$ = new IR::ID(@1, "entries"); }
    | TYPE        { $$ = new IR::ID(@1, "type"); }
    ;

name
    : nonTypeName { $$ = $1; }
    | TYPE_IDENTIFIER  { $$ = new IR::ID(@1, $1); }
    ;

nonTableKwName
    : IDENTIFIER       { $$ = new IR::ID(@1, $1); }
    | TYPE_IDENTIFIER  { $$ = new IR::ID(@1, $1); }
    | APPLY            { $$ = new IR::ID(@1, "apply"); }
    | STATE            { $$ = new IR::ID(@1, "state"); }
    | TYPE             { $$ = new IR::ID(@1, "type"); }
    ;

optCONST
    : /* empty */ { $$ = OptionalConst{false}; }
    | CONST       { $$ = OptionalConst{true}; }
    ;

optAnnotations
    : /* empty */ { $$ = IR::Annotations::empty; }
    | annotations { $$ = new IR::Annotations(@1, *$1); }
    ;

annotations
    : annotation  {
       $$ = new IR::Vector<IR::Annotation>();
       if (! P4CContext::get().options().isAnnotationDisabled($1))
         $$->push_back($1); }
    | annotations annotation {
       $$ = $1;
       if (! P4CContext::get().options().isAnnotationDisabled($2))
          $$->push_back($2); }
    ;

annotation
    : "@" name
        { // Initialize with an empty sequence of annotation tokens so that the
          // annotation node is marked as unparsed.
          IR::Vector<IR::AnnotationToken> body;
          $$ = new IR::Annotation(@1, *$2, body); }
    | "@" name "(" annotationBody ")"
        { $$ = new IR::Annotation(@1, *$2, *$4); }
    | "@" name "[" expressionList "]"
        { $$ = new IR::Annotation(@1, *$2, *$4, true); }
    | "@" name "[" kvList "]"
        { $$ = new IR::Annotation(@1, *$2, *$4, true); }
    // Experimental: backwards compatibility with P4-14 pragmas (which
    // themselves are experimental!)
    | PRAGMA name annotationBody END_PRAGMA
        { $$ = new IR::Annotation(@1, *$2, *$3, false); }
    ;

annotationBody
    : /* empty */
        { $$ = new IR::Vector<IR::AnnotationToken>; }
    | annotationBody "(" annotationBody ")"
        { $$ = $1;
          $$->push_back(new IR::AnnotationToken(@2, $2.type, $2.text));
          $$->append(*$3);
          $$->push_back(new IR::AnnotationToken(@4, $4.type, $4.text)); }
    | annotationBody annotationToken
        { $$ = $1;
          $$->push_back(new IR::AnnotationToken(@2, $2.type, $2.text, $2.unparsedConstant)); }
    ;

annotationToken
    : UNEXPECTED_TOKEN { $$ = $1; }
    | ABSTRACT         { $$ = $1; }
    | ACTION           { $$ = $1; }
    | ACTIONS          { $$ = $1; }
    | APPLY            { $$ = $1; }
    | BOOL             { $$ = $1; }
    | BIT              { $$ = $1; }
    | CONST            { $$ = $1; }
    | CONTROL          { $$ = $1; }
    | DEFAULT          { $$ = $1; }
    | ELSE             { $$ = $1; }
    | ENTRIES          { $$ = $1; }
    | ENUM             { $$ = $1; }
    | ERROR            { $$ = $1; }
    | EXIT             { $$ = $1; }
    | EXTERN           { $$ = $1; }
    | FALSE            { $$ = $1; }
    | HEADER           { $$ = $1; }
    | HEADER_UNION     { $$ = $1; }
    | IF               { $$ = $1; }
    | IN               { $$ = $1; }
    | INOUT            { $$ = $1; }
    | INT              { $$ = $1; }
    | KEY              { $$ = $1; }
    | MATCH_KIND       { $$ = $1; }
    | TYPE             { $$ = $1; }
    | OUT              { $$ = $1; }
    | PARSER           { $$ = $1; }
    | PACKAGE          { $$ = $1; }
    | PRAGMA           { $$ = $1; }
    | RETURN           { $$ = $1; }
    | SELECT           { $$ = $1; }
    | STATE            { $$ = $1; }
    | STRING           { $$ = $1; }
    | STRUCT           { $$ = $1; }
    | SWITCH           { $$ = $1; }
    | TABLE            { $$ = $1; }
    | THIS             { $$ = $1; }
    | TRANSITION       { $$ = $1; }
    | TRUE             { $$ = $1; }
    | TUPLE            { $$ = $1; }
    | TYPEDEF          { $$ = $1; }
    | VARBIT           { $$ = $1; }
    | VALUESET         { $$ = $1; }
    | VOID             { $$ = $1; }
    | "_"              { $$ = $1; }

    | IDENTIFIER       { $$ = Token(token::TOK_IDENTIFIER, $1); }
    | TYPE_IDENTIFIER  { $$ = Token(token::TOK_TYPE_IDENTIFIER, $1); }
    | STRING_LITERAL   { $$ = Token(token::TOK_STRING_LITERAL, $1); }
    | INTEGER          { $$ = Token(token::TOK_INTEGER, $1); }

    | "&&&"            { $$ = $1; }
    | ".."             { $$ = $1; }
    | "<<"             { $$ = $1; }
    | "&&"             { $$ = $1; }
    | "||"             { $$ = $1; }
    | "=="             { $$ = $1; }
    | "!="             { $$ = $1; }
    | ">="             { $$ = $1; }
    | "<="             { $$ = $1; }
    | "++"             { $$ = $1; }

    | "+"              { $$ = $1; }
    | "|+|"            { $$ = $1; }
    | "-"              { $$ = $1; }
    | "|-|"            { $$ = $1; }
    | "*"              { $$ = $1; }
    | "/"              { $$ = $1; }
    | "%"              { $$ = $1; }

    | "|"              { $$ = $1; }
    | "&"              { $$ = $1; }
    | "^"              { $$ = $1; }
    | "~"              { $$ = $1; }

    // Omit parens. These are handled in annotationBody, since they must be
    // balanced.
    // | "("              { $$ = $1; }
    // | ")"              { $$ = $1; }

    | "["              { $$ = $1; }
    | "]"              { $$ = $1; }
    | "{"              { $$ = $1; }
    | "}"              { $$ = $1; }
    | "<"              { $$ = $1; }
    | L_ANGLE_ARGS     { $$ = $1; }
    | ">"              { $$ = $1; }
    | R_ANGLE_SHIFT    { $$ = $1; }

    | "!"              { $$ = $1; }
    | ":"              { $$ = $1; }
    | ","              { $$ = $1; }
    | "?"              { $$ = $1; }
    | "."              { $$ = $1; }
    | "="              { $$ = $1; }
    | ";"              { $$ = $1; }
    | "@"              { $$ = $1; }
    ;

kvList
    : kvPair                          { $$ = new IR::IndexedVector<IR::NamedExpression>; $$->push_back($1); }
    | kvList "," kvPair               { $$ = $1; $$->push_back($3); }
    ;

kvPair
    : name "=" expression             { $$ = new IR::NamedExpression(@1, *$1, $3); }
    ;

parameterList
    : /* empty */                        { $$ = new IR::IndexedVector<IR::Parameter>(); }
    | nonEmptyParameterList              { $$ = $1; }
    ;

nonEmptyParameterList
    : parameter                           { $$ = new IR::IndexedVector<IR::Parameter>();
                                            $$->push_back($1); }
    | nonEmptyParameterList "," parameter { $$ = $1; $$->push_back($3); }
    ;

parameter
    : optAnnotations direction typeRef name { $$ = new IR::Parameter(@4, *$4, $1, $2, $3, nullptr); }
    | optAnnotations direction typeRef name "=" expression { $$ = new IR::Parameter(@4, *$4, $1, $2, $3, $6); }
    ;

direction
    : IN           { $$ = IR::Direction::In; }
    | OUT          { $$ = IR::Direction::Out; }
    | INOUT        { $$ = IR::Direction::InOut; }
    | /* empty */  { $$ = IR::Direction::None; }
    ;

packageTypeDeclaration
    : optAnnotations PACKAGE name { driver.structure->pushContainerType(*$3, false); }
      optTypeParameters {
          if (!$5->empty()) driver.structure->markAsTemplate(*$3);
          driver.structure->declareTypes(&$5->parameters); }
      "(" parameterList ")"        {
          driver.structure->declareParameters($8);
          auto pl = new IR::ParameterList(@8, *$8);
          $$ = new IR::Type_Package(@3, *$3, $1, $5, pl); }
    ;

instantiation
      : annotations typeRef "(" argumentList ")" name ";"
                     { $$ = new IR::Declaration_Instance(@6, *$6, new IR::Annotations(*$1),
                                                         $2, $4);
                       driver.structure->declareObject(*$6, $2->toString()); }
      | typeRef "(" argumentList ")" name ";"
                     { $$ = new IR::Declaration_Instance(@5, *$5, $1, $3);
                       driver.structure->declareObject(*$5, $1->toString()); }
      /* experimental */
      | annotations typeRef "(" argumentList ")" name "=" objInitializer ";"
                     { $$ = new IR::Declaration_Instance(@6, *$6, new IR::Annotations(*$1),
                                                         $2, $4, $8);
                       driver.structure->declareObject(*$6, $2->toString()); }
      /* experimental */
      | typeRef "(" argumentList ")" name "=" objInitializer ";"
                     { $$ = new IR::Declaration_Instance(@5, *$5, $1, $3, $7);
                       driver.structure->declareObject(*$5, $1->toString()); }
    ;

/* experimental; includes the following 3 productions */
objInitializer
    : "{" { driver.structure->pushNamespace(@1, false); } objDeclarations "}"
                               { driver.structure->pop();
                                 $$ = new IR::BlockStatement(@1+@4, *$3); }
    ;

objDeclarations
    : /* empty */                    { $$ = new IR::IndexedVector<IR::StatOrDecl>(); }
    | objDeclarations objDeclaration { $$ = $1; $1->push_back($2); }
    ;

objDeclaration
    : functionDeclaration      { $$ = $1; }
    | instantiation            { $$ = $1; }
    ;

optConstructorParameters
    : /* empty */            { $$ = new IR::IndexedVector<IR::Parameter>(); }
    | "(" parameterList ")"  { $$ = $2; }
    ;

dotPrefix
    : "."                      { driver.structure->startAbsolutePath(); }
    ;

/**************************** PARSER ******************************/

parserDeclaration
    : parserTypeDeclaration optConstructorParameters
      "{" parserLocalElements parserStates "}"
                             { driver.structure->pop();
                               auto pl = new IR::ParameterList(@2, *$2);
                               $$ = new IR::P4Parser($1->name.srcInfo, $1->name,
                                                     $1, pl, *$4, *$5);}
    ;

parserLocalElements
    : /* empty */                     { $$ = new IR::IndexedVector<IR::Declaration>(); }
    | parserLocalElements parserLocalElement { $$ = $1; $$->push_back($2); }
    ;

parserLocalElement
    : constantDeclaration             { $$ = $1; }
    | instantiation                   { $$ = $1; }
    | variableDeclaration             { $$ = $1; }
    | valueSetDeclaration             { $$ = $1; }
    ;

parserTypeDeclaration
    : optAnnotations
        PARSER name       { driver.structure->pushContainerType(*$3, true); }
        optTypeParameters { if (!$5->empty()) driver.structure->markAsTemplate(*$3);
                            driver.structure->declareTypes(&$5->parameters); }
        "(" parameterList ")" { driver.structure->declareParameters($8);
                                auto pl = new IR::ParameterList(@8, *$8);
                                $$ = new IR::Type_Parser(@3, *$3, $1, $5, pl); }
    ;

parserStates
    : parserState                     { $$ = new IR::IndexedVector<IR::ParserState>();
                                        $$->push_back($1); }
    | parserStates parserState        { $$ = $1; $$->push_back($2); }
    ;

parserState
    : optAnnotations STATE name { driver.structure->pushContainerType(*$3, false); }
      "{" parserStatements transitionStatement "}"
                                      { driver.structure->pop();
                                        $$ = new IR::ParserState(@3, *$3, $1, *$6, $7); }
    ;

parserStatements
    : /* empty */                      { $$ = new IR::IndexedVector<IR::StatOrDecl>(); }
    | parserStatements parserStatement { $$ = $1; $1->push_back($2); }
    ;

parserStatement
    : assignmentOrMethodCallStatement { $$ = $1; }
    | directApplication               { $$ = $1; }
    | emptyStatement                  { $$ = $1; }
    | variableDeclaration             { $$ = $1; }
    | constantDeclaration             { $$ = $1; }
    | parserBlockStatement            { $$ = $1; }
    | conditionalStatement            { $$ = $1; }  // experimental
    ;

parserBlockStatement
    : optAnnotations "{" { driver.structure->pushNamespace(@2, false); }
      parserStatements "}" { driver.structure->pop(); $$ = new IR::BlockStatement(@1+@5, $1, *$4); }
    ;

transitionStatement
    : /* empty */                 { $$ = nullptr; }
    | TRANSITION stateExpression  { $$ = $2; }
    ;

stateExpression
    : name ";"         { $$ = new IR::PathExpression(*$1); }
    | selectExpression { $$ = $1; }
    ;

selectExpression
    : SELECT "(" expressionList ")" "{" selectCaseList "}"
                              { $$ = new IR::SelectExpression(@1 + @7,
                                     new IR::ListExpression(@3, *$3), std::move(*$6)); }
    ;

selectCaseList
    : /* empty */                { $$ = new IR::Vector<IR::SelectCase>(); }
    | selectCaseList selectCase  { $$ = $1; $$->push_back($2); }
    ;

selectCase
    : keysetExpression ":" name ";"
      { auto expr = new IR::PathExpression(*$3);
        $$ = new IR::SelectCase(@1 + @3, $1, expr); }
    ;

keysetExpression
    : tupleKeysetExpression     { $$ = new IR::ListExpression(@1, *$1); }
    | simpleKeysetExpression    { $$ = $1; }
    ;

tupleKeysetExpression
    /* at least two elements in the tuple */
    : "(" simpleKeysetExpression "," simpleExpressionList ")"
                                { $$ = $4; $4->insert($4->begin(), $2); }
    ;

simpleExpressionList
    : simpleKeysetExpression { $$ = new IR::Vector<IR::Expression>(); $$->push_back($1); }
    | simpleExpressionList "," simpleKeysetExpression { $$ = $1; $$->push_back($3); }
    ;

simpleKeysetExpression
    : expression                  { $$ = $1; }
    | expression "&&&" expression { $$ = new IR::Mask(@1 + @3, $1, $3); }
    | expression ".." expression  { $$ = new IR::Range(@1 + @3, $1, $3); }
    | DEFAULT                     { $$ = new IR::DefaultExpression(@1); }
    | "_"                         { $$ = new IR::DefaultExpression(@1); }
    ;

valueSetDeclaration
    : optAnnotations
        VALUESET l_angle baseType r_angle "(" expression ")" name ";"
        { $$ = new IR::P4ValueSet(@9, *$9, $1, $4, $7); }
    | optAnnotations
        VALUESET l_angle tupleType r_angle "(" expression ")" name ";"
        { $$ = new IR::P4ValueSet(@9, *$9, $1, $4, $7); }
    | optAnnotations
        VALUESET l_angle typeName r_angle "(" expression ")" name ";"
        { $$ = new IR::P4ValueSet(@9, *$9, $1, $4, $7); }
    ;

/*************************** CONTROL ************************/

controlDeclaration
    : controlTypeDeclaration optConstructorParameters
      "{" controlLocalDeclarations APPLY controlBody "}"
        { driver.structure->pop();
          auto pl = new IR::ParameterList(@2, *$2);
          $$ = new IR::P4Control($1->name.srcInfo, $1->name, $1, pl, *$4, $6); }
    ;

controlTypeDeclaration
    : optAnnotations
        CONTROL name { driver.structure->pushContainerType(*$3, true); }
        optTypeParameters { if (!$5->empty()) driver.structure->markAsTemplate(*$3);
                            driver.structure->declareTypes(&$5->parameters); }
        "(" parameterList ")" { driver.structure->declareParameters($8);
                                auto pl = new IR::ParameterList(@8, *$8);
                                $$ = new IR::Type_Control(@3, *$3, $1, $5, pl); }
    ;

controlLocalDeclarations
    : /* empty */               { $$ = new IR::IndexedVector<IR::Declaration>(); }
    | controlLocalDeclarations controlLocalDeclaration { $$ = $1; $$->push_back($2); }
    ;

controlLocalDeclaration
    : constantDeclaration      { $$ = $1; }
    | actionDeclaration        { $$ = $1; }
    | tableDeclaration         { $$ = $1; }
    | instantiation            { $$ = $1; }
    | variableDeclaration      { $$ = $1; }
    ;

controlBody
    : blockStatement { $$ = $1; }
    ;

/*************************** EXTERN *************************/

externDeclaration
    : optAnnotations
        EXTERN nonTypeName { driver.structure->pushContainerType(*$3, true); }
        optTypeParameters { if (!$5->empty()) driver.structure->markAsTemplate(*$3);
                            driver.structure->declareTypes(&$5->parameters); }
        "{" methodPrototypes "}" { driver.structure->pop();
                                   $$ = new IR::Type_Extern(@3, *$3, $5, *$8, $1); }
    | optAnnotations EXTERN functionPrototype ";" {
            driver.structure->pop();
            $$ = $3;
            $3->annotations = $1; }
    | optAnnotations EXTERN name ";" {
            // forward declaration;
            driver.structure->pushContainerType(*$3, true);
            driver.structure->pop();
            $$ = nullptr; }
    ;

methodPrototypes
    : /* empty */                      { $$ = new IR::Vector<IR::Method>(); }
    | methodPrototypes methodPrototype { $$ = $1; $1->push_back($2); }
    ;

functionPrototype
    : typeOrVoid
        name optTypeParameters {
            driver.structure->declareObject(*$2, $1->toString());
            if (!$3->empty()) driver.structure->markAsTemplate(*$2);
            driver.structure->pushNamespace(@2, false);
            driver.structure->declareTypes(&$3->parameters); }
        "(" parameterList ")" { driver.structure->declareParameters($6);
                                auto params = new IR::ParameterList(@6, *$6);
                                auto mt = new IR::Type_Method(@2, $3, $1, params);
                                $$ = new IR::Method(@2, *$2, mt); }
    ;

methodPrototype
    : optAnnotations functionPrototype ";" {
            driver.structure->pop();
            $$ = $2; $2->annotations = $1; }
    | optAnnotations ABSTRACT functionPrototype ";" {
            driver.structure->pop();
            $$ = $3; $$->setAbstract();
            $3->annotations = $1; }  // experimental
    | optAnnotations TYPE_IDENTIFIER "(" parameterList ")" ";"  // constructor
                                        { auto par = new IR::ParameterList(@4, *$4);
                                          auto mt = new IR::Type_Method(@2, par);
                                          $$ = new IR::Method(@2, IR::ID(@2, $2), mt, $1); }
    ;

/************************** TYPES ****************************/

typeRef
    : baseType                         { $$ = $1; }
    | typeName                         { $$ = $1; }
    | specializedType                  { $$ = $1; }
    | headerStackType                  { $$ = $1; }
    | tupleType                        { $$ = $1; }
    ;

namedType
    : typeName                         { $$ = $1; }
    | specializedType                  { $$ = $1; }
    ;

prefixedType
    : TYPE_IDENTIFIER                  { $$ = new IR::Path(IR::ID(@1, $1)); }
    | dotPrefix TYPE_IDENTIFIER        { $$ = new IR::Path(IR::ID(@2, $2), true);
                                         driver.structure->clearPath(); }
    ;

typeName
    : prefixedType                     { $$ = new IR::Type_Name(@1, $1); }
    ;

tupleType
    : TUPLE l_angle typeArgumentList r_angle    { $$ = new IR::Type_Tuple(@1+@4, *$3); }
    ;

headerStackType
    : typeName "[" expression "]"       { $$ = new IR::Type_Stack(@1+@4, $1, $3); }
    ;

specializedType
    : typeName l_angle typeArgumentList r_angle { $$ = new IR::Type_Specialized(@1 + @4, $1, $3); }
    ;

baseType
    : BOOL   { $$ = IR::Type_Boolean::get(); }
    | ERROR  { $$ = new IR::Type_Name(@1, new IR::Path(IR::ID(@1, "error"))); }
    | BIT    { $$ = IR::Type::Bits::get(@1, 1); }
    | STRING { $$ = IR::Type::String::get(); }
    | INT    { $$ = new IR::Type_InfInt(); }
    | BIT l_angle INTEGER r_angle
      { $$ = IR::Type::Bits::get(@1+@4, parseConstantChecked(@3, $3), false); }
    | INT l_angle INTEGER r_angle
      { $$ = IR::Type::Bits::get(@1+@4, parseConstantChecked(@3, $3), true); }
    | VARBIT l_angle INTEGER r_angle
      { $$ = IR::Type::Varbits::get(@1+@4, parseConstantChecked(@3, $3)); }

    | BIT l_angle "(" expression ")" r_angle
      { $$ = new IR::Type_Bits(@1+@6, $4, false); }
    | INT l_angle "(" expression ")" r_angle
      { $$ = new IR::Type_Bits(@1+@6, $4, true); }
    | VARBIT l_angle "(" expression ")" r_angle
      { $$ = new IR::Type_Varbits(@1+@6, $4); }
    ;

typeOrVoid
    : typeRef     { $$ = $1; }
    | VOID        { $$ = IR::Type_Void::get(); }
    | IDENTIFIER  { $$ = new IR::Type_Name(@1, new IR::Path(*(new IR::ID(@1, $1)))); }
        // This is necessary because template arguments may introduce the return type
    ;

optTypeParameters
    : /* empty */               { $$ = new IR::TypeParameters(); }
    | l_angle typeParameterList r_angle { $$ = new IR::TypeParameters(@1+@3, *$2); }
    ;

typeParameterList
    : name                           { $$ = new IR::IndexedVector<IR::Type_Var>();
                                       $$->push_back(new IR::Type_Var(@1, *$1)); }
    | typeParameterList "," name     { ($$=$1)->push_back(new IR::Type_Var(@3, *$3)); }
    ;

typeArg
    : typeRef                     { $$ = $1; }
    | nonTypeName                 { $$ = new IR::Type_Name(@1, new IR::Path(*$1)); }
        // This is necessary because template arguments may introduce the return type
    | VOID                        { $$ = IR::Type_Void::get(); }
    | "_"                         { $$ = new IR::Type_Dontcare(@1); }
    ;

typeArgumentList
    : /* empty */                    { $$ = new IR::Vector<IR::Type>(); }
    | typeArg                        { $$ = new IR::Vector<IR::Type>(); $$->push_back($1); }
    | typeArgumentList "," typeArg   { $$ = $1; $$->push_back($3); }
    ;

realTypeArg
    : typeRef                     { $$ = $1; }
    | VOID                        { $$ = IR::Type_Void::get(); }
    | "_"                         { $$ = new IR::Type_Dontcare(@1); }
    ;

// For use in contexts where the `<` might be a less-than rather than introducing a type
// argument list -- we only allow the token after `<` to be a TYPE_IDENTIFIER, not an ID
realTypeArgumentList
    : realTypeArg                        { $$ = new IR::Vector<IR::Type>(); $$->push_back($1); }
    | realTypeArgumentList "," typeArg   { $$ = $1; $$->push_back($3); }
    ;

typeDeclaration
    : derivedTypeDeclaration     { $$ = $1; }
    | typedefDeclaration ";"     { $$ = $1; }
    | parserTypeDeclaration ";"  { driver.structure->pop(); $$ = $1; }
    | controlTypeDeclaration ";" { driver.structure->pop(); $$ = $1; }
    | packageTypeDeclaration ";" { driver.structure->pop(); $$ = $1; }
    ;

derivedTypeDeclaration
    : headerTypeDeclaration            { $$ = $1; }
    | headerUnionDeclaration           { $$ = $1; }
    | structTypeDeclaration            { $$ = $1; }
    | enumDeclaration                  { $$ = $1; }
    ;

headerTypeDeclaration
    : optAnnotations
        HEADER name { driver.structure->declareType(*$3); }
        "{" structFieldList "}" { $$ = new IR::Type_Header(@3, *$3, $1, *$6); }
    ;

structTypeDeclaration
    : optAnnotations
        STRUCT name { driver.structure->declareType(*$3); }
        "{" structFieldList "}" { $$ = new IR::Type_Struct(@3, *$3, $1, *$6); }
    ;

headerUnionDeclaration
    : optAnnotations
        HEADER_UNION name { driver.structure->declareType(*$3); }
        "{" structFieldList "}" { $$ = new IR::Type_HeaderUnion(@3, *$3, $1, *$6); }
    ;

structFieldList
    : /* empty */                      { $$ = new IR::IndexedVector<IR::StructField>(); }
    | structFieldList structField      { $$ = $1; $1->push_back($2); }
    ;

structField
    : optAnnotations typeRef name ";"  { $$ = new IR::StructField(@3, *$3, $1, $2); }
    ;

enumDeclaration
    : optAnnotations
        ENUM name { driver.structure->declareType(*$3); }
        "{" identifierList "}" { $$ = new IR::Type_Enum(@3, *$3, *$6); }
    | optAnnotations ENUM typeRef name { driver.structure->declareType(*$4); }
	 "{" specifiedIdentifierList "}" {
              auto type = $typeRef;
              $$ = new IR::Type_SerEnum(@4, *$4, type, *$7);
	  }
    ;

specifiedIdentifierList
    : specifiedIdentifier     { $$ = new IR::IndexedVector<IR::SerEnumMember>(); $$->push_back($1); }
    | specifiedIdentifierList "," specifiedIdentifier { $$ = $1; $1->push_back($3); }
    ;

specifiedIdentifier
    : name "=" initializer    { $$ = new IR::SerEnumMember(@1+@3, *$1, $3); }
    ;

errorDeclaration
    : ERROR "{" identifierList "}"
        { $$ = new IR::Type_Error(@1 + @4, IR::ID(@1, "error"), *$3); }
    ;

matchKindDeclaration
    : MATCH_KIND "{" identifierList "}"
        { $$ = new IR::Declaration_MatchKind(@1 + @4, *$3); }
    ;

identifierList
    : name                    { $$ = new IR::IndexedVector<IR::Declaration_ID>();
                                $$->push_back(new IR::Declaration_ID(@1, *$1));}
    | identifierList "," name { $$ = $1; $$->push_back(new IR::Declaration_ID(@3, *$3)); }
    ;

typedefDeclaration
    : optAnnotations TYPEDEF typeRef name   { driver.structure->declareType(*$4);
          $$ = new IR::Type_Typedef(@4, *$4, new IR::Annotations(*$1), $3); }
    | optAnnotations TYPEDEF derivedTypeDeclaration name   { driver.structure->declareType(*$4);
                        $$ = new IR::Type_Typedef(@4, *$4, new IR::Annotations(*$1), $3); }
    | optAnnotations TYPE typeRef name   { driver.structure->declareType(*$4);
          $$ = new IR::Type_Newtype(@4, *$4, new IR::Annotations(*$1), $3); }
    | optAnnotations TYPE derivedTypeDeclaration name   { driver.structure->declareType(*$4);
                        $$ = new IR::Type_Newtype(@4, *$4, new IR::Annotations(*$1), $3); }
    ;

/*************************** STATEMENTS *************************/

assignmentOrMethodCallStatement
    // These rules are overly permissive, but they avoid some conflicts
    : lvalue "(" argumentList ")" ";"
        { auto mc = new IR::MethodCallExpression(@1 + @4, $1,
                                                 new IR::Vector<IR::Type>(), $3);
          $$ = new IR::MethodCallStatement(@1 + @4, mc); }

    | lvalue l_angle typeArgumentList r_angle "(" argumentList ")" ";"
        { auto mc = new IR::MethodCallExpression(@1 + @7,
                                                 $1, $3, $6);
          $$ = new IR::MethodCallStatement(@1 + @7, mc); }

    | lvalue "=" expression ";"
        { $$ = new IR::AssignmentStatement(@2, $1, $3); }

    ;

emptyStatement
    : ";"      { $$ = new IR::EmptyStatement(@1); }
    ;

exitStatement
    : EXIT ";" { $$ = new IR::ExitStatement(@1); }
    ;

returnStatement
    : RETURN ";"            { $$ = new IR::ReturnStatement(@1, nullptr); }
    | RETURN expression ";" { $$ = new IR::ReturnStatement(@1, $2); }
    ;

conditionalStatement
    : IF "(" expression ")" statement                 %prec THEN
        { $$ = new IR::IfStatement(@1, $3, $5, nullptr); }
    | IF "(" expression ")" statement ELSE statement  %prec THEN
        { $$ = new IR::IfStatement(@1, $3, $5, $7); }
    ;

// To support direct invocation of a control or parser without instantiation
directApplication
    : typeName "." APPLY "(" argumentList ")" ";" {
                                  auto method = new IR::Member(
                                      @1 + @3, new IR::TypeNameExpression($1), IR::ID(@3, "apply"));
                                  auto mce = new IR::MethodCallExpression(@1 + @6, method, $5);
                                  $$ = new IR::MethodCallStatement(@1 + @6, mce); }
    ;

statement
    : assignmentOrMethodCallStatement  { $$ = $1; }
    | directApplication                { $$ = $1; }
    | conditionalStatement             { $$ = $1; }
    | emptyStatement                   { $$ = $1; }
    | blockStatement                   { $$ = $1; }
    | returnStatement                  { $$ = $1; }
    | exitStatement                    { $$ = $1; }
    | switchStatement                  { $$ = $1; }
    ;

blockStatement
    : optAnnotations "{" { driver.structure->pushNamespace(@2, false); }
      statOrDeclList "}" { driver.structure->pop();
                           $$ = new IR::BlockStatement(@1 + @5, $1, *$4); }
    ;

statOrDeclList
    : /* empty */                           { $$ = new IR::IndexedVector<IR::StatOrDecl>(); }
    | statOrDeclList statementOrDeclaration { $$ = $1; $$->push_back($2); }
    ;

switchStatement
    : SWITCH "(" expression ")" "{" switchCases "}" {
            $$ = new IR::SwitchStatement(@1, $3, std::move(*$6)); }
    ;

switchCases
    : /* empty */              { $$ = new IR::Vector<IR::SwitchCase>(); }
    | switchCases switchCase   { $$ = $1; $$->push_back($2); }
    ;

switchCase
    : switchLabel ":" blockStatement { $$ = new IR::SwitchCase(@1 + @3, $1, $3); }
    | switchLabel ":" { $$ = new IR::SwitchCase(@1, $1, nullptr); }
    ;

switchLabel
    : name                     { $$ = new IR::PathExpression(*$1); }
    | DEFAULT                  { $$ = new IR::DefaultExpression(@1); }
    ;

statementOrDeclaration
    : variableDeclaration      { $$ = $1; }
    | constantDeclaration      { $$ = $1; }
    | statement                { $$ = $1; }
    | instantiation            { $$ = $1; }
    ;

/************************* TABLE *********************************/

tableDeclaration
    : optAnnotations
        TABLE name "{" tablePropertyList "}"
          { $$ = new IR::P4Table(@3, *$3, $1, new IR::TableProperties(@5, *$5)); }
    ;

tablePropertyList
    : tableProperty                      { $$ = new IR::IndexedVector<IR::Property>();
                                           $$->push_back($1); }
    | tablePropertyList tableProperty    { $$ = $1; $$->push_back($2); }
    ;

tableProperty
    : KEY "=" "{" keyElementList "}"
        { auto v = new IR::Key(@4, *$4);
          auto id = IR::ID(@1, "key");
          $$ = new IR::Property( @1 + @5, id, v, false); }
    | ACTIONS "=" "{" actionList "}"
        { auto v = new IR::ActionList(@4, *$4);
          auto id = IR::ID(@1, "actions");
          $$ = new IR::Property(@1 + @5, id, v, false); }
    | optAnnotations optCONST ENTRIES "=" "{" entriesList "}"
        { auto l = new IR::EntriesList(@3, *$6);
          auto id = IR::ID(@3+@7, "entries");
          $$ = new IR::Property(@3, id, $1, l, $2.isConst); }
    | optAnnotations optCONST nonTableKwName "=" initializer ";"
        { auto v = new IR::ExpressionValue(@5, $5);
          auto id = *$3;
          $$ = new IR::Property($3->srcInfo, id, $1, v, $2.isConst); }
    ;

keyElementList
    : /* empty */                        { $$ = new IR::Vector<IR::KeyElement>(); }
    | keyElementList keyElement          { $$ = $1; $$->push_back($2); }
    ;

keyElement
    : expression ":" name optAnnotations ";"
                                         { auto expr = new IR::PathExpression(*$3);
                                           $$ = new IR::KeyElement(@1, $4, $1, expr); }
    ;

actionList
    : /* empty */                        { $$ = new IR::IndexedVector<IR::ActionListElement>(); }
    | actionList optAnnotations actionRef ";"
        { $$ = $1; $$->push_back(new IR::ActionListElement(@3, $2, $3)); }
    ;

actionRef
    : prefixedNonTypeName
        { $$ = new IR::PathExpression($1); }
    | prefixedNonTypeName "(" argumentList ")"
        { $$ = new IR::MethodCallExpression(@1+@3, new IR::PathExpression($1), $3); }
    ;

entry
    : keysetExpression ":" actionRef optAnnotations ";"
        { if (auto l = $1->to<IR::ListExpression>())
            $$ = new IR::Entry(@1+@4, $4, l, $3);
          else {  // if not a tuple, make it a list of 1
            IR::Vector<IR::Expression> le($1);
            $$ = new IR::Entry(@1+@4, $4,
                   new IR::ListExpression(@1, le),
                   $3);
          }
        }
    ;

entriesList
    : entry                          { $$ = new IR::Vector<IR::Entry>(); $$->push_back($1); }
    | entriesList entry              { $$ = $1; $$->push_back($2); }
    ;

/************************* ACTION ********************************/

actionDeclaration
    : optAnnotations ACTION name "(" parameterList ")" blockStatement
        { auto pl = new IR::ParameterList(@5, *$5);
          $$ = new IR::P4Action(@3, *$3, $1, pl, $7); }
    ;

/************************* VARIABLES *****************************/

variableDeclaration
    : annotations typeRef name optInitializer ";"
                                     { auto ann = new IR::Annotations(@1, *$1);
                                       $$ = new IR::Declaration_Variable(@1+@4, *$3, ann, $2, $4);
                                       driver.structure->declareObject(*$3, $2->toString()); }
    | typeRef name optInitializer ";"
                                     { $$ = new IR::Declaration_Variable(@1+@4, *$2, $1, $3);
                                       driver.structure->declareObject(*$2, $1->toString()); }
    ;

constantDeclaration
    : optAnnotations CONST typeRef name "=" initializer ";"
                                     { $$ = new IR::Declaration_Constant(@4, *$4, $1, $3, $6);
                                       driver.structure->declareObject(*$4, $3->toString()); }
    ;

optInitializer
    : /* empty */                      { $$ = nullptr; }
    | "=" initializer                  { $$ = $2; }
    ;

initializer
    : expression                          { $$ = $1; }
    ;

/**************** Expressions ****************/

functionDeclaration
    : functionPrototype blockStatement   {
            driver.structure->pop();
            $$ = new IR::Function($1->srcInfo, $1->name, $1->type, $2); }
    ;

argumentList
    : /* empty */                        { $$ = new IR::Vector<IR::Argument>(); }
    | nonEmptyArgList                    { $$ = $1; }
    ;

nonEmptyArgList
    : argument                           { $$ = new IR::Vector<IR::Argument>();
                                           $$->push_back($1); }
    | nonEmptyArgList "," argument       { $$ = $1; $$->push_back($3); }
    ;

argument
    : expression                         { $$ = new IR::Argument(@1, $1); }
    | name "=" expression                { $$ = new IR::Argument(@1, *$1, $3); }
    | "_"                                { $$ = new IR::Argument(@1, new IR::DefaultExpression(@1)); }
    ;

expressionList
    : /* empty */                        { $$ = new IR::Vector<IR::Expression>(); }
    | expression                         { $$ = new IR::Vector<IR::Expression>();
                                           $$->push_back($1); }
    | expressionList "," expression      { $$ = $1; $$->push_back($3); }
    ;

prefixedNonTypeName
    : nonTypeName                        { $$ = new IR::Path(*$1); }
    | dotPrefix nonTypeName              { $$ = new IR::Path(*$2, true);
                                           driver.structure->clearPath(); }
    ;

dot_name:
    "." { driver.structure->relativePathFromLastSymbol(); } name {
          driver.structure->clearPath(); $$ = $3; }

lvalue
    : prefixedNonTypeName                { $$ = new IR::PathExpression($1); }
    | THIS                               { $$ = new IR::This(@1); }  // experimental
    | lvalue dot_name %prec DOT          { $$ = new IR::Member(@1 + @2, $1, *$2); }
    | lvalue "[" expression "]"          { $$ = new IR::ArrayIndex(@1 + @4, $1, $3); }
    | lvalue "[" expression ":" expression "]" { $$ = new IR::Slice(@1 + @6, $1, $3, $5); }
    ;

expression
    : INTEGER                            { $$ = parseConstant(@1, $1, 0); }
    | STRING_LITERAL                     { $$ = new IR::StringLiteral(@1, $1); }
    | TRUE                               { $$ = new IR::BoolLiteral(@1, true); }
    | FALSE                              { $$ = new IR::BoolLiteral(@1, false); }
    | THIS                               { $$ = new IR::This(@1); }  // experimental
    | nonTypeName                        { $$ = new IR::PathExpression(*$1); }
    | dotPrefix nonTypeName              { $$ = new IR::PathExpression(new IR::Path(*$2, true)); driver.structure->clearPath(); }
    | expression "[" expression "]"      { $$ = new IR::ArrayIndex(@1 + @4, $1, $3); }
    | expression "[" expression ":" expression "]" { $$ = new IR::Slice(@1 + @6, $1, $3, $5); }
    | "{" expressionList "}"             { $$ = new IR::ListExpression(@1 + @3, *$2); }
    | "{" kvList "}"                     { $$ = new IR::StructExpression(
                                                  @1 + @3, IR::Type::Unknown::get(), (IR::Type_Name*)nullptr, *$2); }  // experimental
    | "(" expression ")"                 { $$ = $2; }
    | "!" expression %prec PREFIX        { $$ = new IR::LNot(@1 + @2, $2); }
    | "~" expression %prec PREFIX        { $$ = new IR::Cmpl(@1 + @2, $2); }
    | "-" expression %prec PREFIX        { $$ = new IR::Neg(@1 + @2, $2); }
    | "+" expression %prec PREFIX        { $$ = $2; }
    | typeName dot_name %prec DOT
        { $$ = new IR::Member(@1 + @2, new IR::TypeNameExpression(@1, $1), *$2); }
    | ERROR "." name
        { auto typeName = new IR::Type_Name(@1, new IR::Path(IR::ID(@1, "error")));
          $$ = new IR::Member(@1+@3, new IR::TypeNameExpression(@1+@3, typeName), *$3); }
    | expression dot_name %prec DOT      { $$ = new IR::Member(@1 + @2, $1, *$2); }
    | expression "*" expression          { $$ = new IR::Mul(@1 + @3, $1, $3); }
    | expression "/" expression          { $$ = new IR::Div(@1 + @3, $1, $3); }
    | expression "%" expression          { $$ = new IR::Mod(@1 + @3, $1, $3); }
    | expression "+" expression          { $$ = new IR::Add(@1 + @3, $1, $3); }
    | expression "-" expression          { $$ = new IR::Sub(@1 + @3, $1, $3); }
    | expression "|+|" expression        { $$ = new IR::AddSat(@1 + @3, $1, $3); }
    | expression "|-|" expression        { $$ = new IR::SubSat(@1 + @3, $1, $3); }
    | expression "<<" expression         { $$ = new IR::Shl(@1 + @3, $1, $3); }
    | expression R_ANGLE_SHIFT ">" expression %prec R_ANGLE_SHIFT
        { $$ = new IR::Shr(@1 + @4, $1, $4); }
    | expression "<=" expression         { $$ = new IR::Leq(@1 + @3, $1, $3); }
    | expression ">=" expression         { $$ = new IR::Geq(@1 + @3, $1, $3); }
    | expression l_angle expression %prec "<"
                                         { $$ = new IR::Lss(@1 + @3, $1, $3); }
    | expression ">" expression          { $$ = new IR::Grt(@1 + @3, $1, $3); }
    | expression "!=" expression         { $$ = new IR::Neq(@1 + @3, $1, $3); }
    | expression "==" expression         { $$ = new IR::Equ(@1 + @3, $1, $3); }
    | expression "&" expression          { $$ = new IR::BAnd(@1 + @3, $1, $3); }
    | expression "^" expression          { $$ = new IR::BXor(@1 + @3, $1, $3); }
    | expression "|" expression          { $$ = new IR::BOr(@1 + @3, $1, $3); }
    | expression "++" expression         { $$ = new IR::Concat(@1 + @3, $1, $3); }
    | expression "&&" expression         { $$ = new IR::LAnd(@1 + @2 + @3, $1, $3); }
    | expression "||" expression         { $$ = new IR::LOr(@1 + @2 + @3, $1, $3); }
    | expression "?" expression ":" expression { $$ = new IR::Mux(@1 + @5, $1, $3, $5); }
    | expression l_angle realTypeArgumentList r_angle "(" argumentList ")"
        { $$ = new IR::MethodCallExpression(@1 + @4, $1, $3, $6); }
    | expression "(" argumentList ")"
        { $$ = new IR::MethodCallExpression(@1 + @4, $1, $3); }
    | namedType "(" argumentList ")"
        { $$ = new IR::ConstructorCallExpression(@1 + @4, $1, $3); }
    | "(" typeRef ")" expression %prec PREFIX { $$ = new IR::Cast(@1 + @4, $2, $4); }
    ;

intOrStr
    : INTEGER                    { $$ = parseConstant(@1, $1, 0); }
    | STRING_LITERAL             { $$ = new IR::StringLiteral(@1, $1); }
    ;

intList
    : INTEGER                    { $$ = new IR::Vector<IR::Expression>();
                                   $$->push_back(parseConstant(@1, $1, 0)); }
    | intList "," INTEGER        { $$ = $1;
                                   $$->push_back(parseConstant(@3, $3, 0)); }
    ;

intOrStrList
    : intOrStr                   { $$ = new IR::Vector<IR::Expression>();
                                   $$->push_back($1); }
    | intOrStrList "," intOrStr  { $$ = $1;
                                   $$->push_back($3); }
    ;

strList
    : STRING_LITERAL             { $$ = new IR::Vector<IR::Expression>();
                                   $$->push_back(new IR::StringLiteral(@1, $1)); }
    | strList "," STRING_LITERAL { $$ = $1;
                                   $$->push_back(new IR::StringLiteral(@3, $3)); }
    ;

l_angle : "<" | L_ANGLE_ARGS ;
r_angle : ">" | R_ANGLE_SHIFT ;

/*****************************************************************************/

%%

void P4::P4Parser::error(const Util::SourceInfo& location,
                         const std::string& message) {
    driver.onParseError(location, message);
}
