<!-- HTML header for doxygen 1.12.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>P4 Compiler Documentation (P4C): ActionPhvConstraints Class Reference</title>
<link rel="icon" href="p4-fav.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!--  Add link to paragraphs   -->
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
  DoxygenAwesomeParagraphLink.init()
</script>
<!-- Add copy button to code fragments  -->
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
  DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add dark mode toggle -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
  DoxygenAwesomeDarkModeToggle.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="cards.css" rel="stylesheet" type="text/css"/>
<link href="flow.css" rel="stylesheet" type="text/css"/>
<link href="p4c_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="p4-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">P4C
   </div>
   <div id="projectbrief">The P4 Compiler</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_action_phv_constraints.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_action_phv_constraints-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ActionPhvConstraints Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="action__phv__constraints_8h_source.html">action_phv_constraints.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ActionPhvConstraints:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_action_phv_constraints__inherit__graph.svg" width="172" height="183"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:struct_action_phv_constraints_1_1_action_sources" id="r_struct_action_phv_constraints_1_1_action_sources"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#struct_action_phv_constraints_1_1_action_sources">ActionSources</a></td></tr>
<tr class="separator:struct_action_phv_constraints_1_1_action_sources"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abe92f4256f7448c6914aecb75c8e983f" id="r_abe92f4256f7448c6914aecb75c8e983f"><td class="memItemLeft" align="right" valign="top"><a id="abe92f4256f7448c6914aecb75c8e983f" name="abe92f4256f7448c6914aecb75c8e983f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ActionPhvConstraints</b> (const <a class="el" href="class_phv_info.html">PhvInfo</a> &amp;p, const <a class="el" href="class_phv_use.html">PhvUse</a> &amp;u, const <a class="el" href="class_pack_conflicts.html">PackConflicts</a> &amp;c, const <a class="el" href="class_map_tables_to_actions.html">MapTablesToActions</a> &amp;m, const <a class="el" href="struct_dependency_graph.html">DependencyGraph</a> &amp;d)</td></tr>
<tr class="separator:abe92f4256f7448c6914aecb75c8e983f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268250cb72e8d56151714ebc536af80f" id="r_a268250cb72e8d56151714ebc536af80f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a268250cb72e8d56151714ebc536af80f">actionReads</a> (const IR::MAU::Action *act) const</td></tr>
<tr class="separator:a268250cb72e8d56151714ebc536af80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26982a00b9450936b6ca9da996d47a2" id="r_ad26982a00b9450936b6ca9da996d47a2"><td class="memItemLeft" align="right" valign="top"><a id="ad26982a00b9450936b6ca9da996d47a2" name="ad26982a00b9450936b6ca9da996d47a2"></a>
const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_field_slice.html">PHV::FieldSlice</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>actionReadsSlices</b> (const IR::MAU::Action *act) const</td></tr>
<tr class="separator:ad26982a00b9450936b6ca9da996d47a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2446984b1cba092f28df8b538bac9f" id="r_a7b2446984b1cba092f28df8b538bac9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const IR::MAU::Action * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b2446984b1cba092f28df8b538bac9f">actions_reading_fields</a> (const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *f) const</td></tr>
<tr class="separator:a7b2446984b1cba092f28df8b538bac9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865b4a620e4470a5ffea446c7580b291" id="r_a865b4a620e4470a5ffea446c7580b291"><td class="memItemLeft" align="right" valign="top"><a id="a865b4a620e4470a5ffea446c7580b291" name="a865b4a620e4470a5ffea446c7580b291"></a>
<a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const IR::MAU::Action * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>actions_writing_fields</b> (const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;slice) const</td></tr>
<tr class="separator:a865b4a620e4470a5ffea446c7580b291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93738003f5db10bf0c6b853d1508d7f5" id="r_a93738003f5db10bf0c6b853d1508d7f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const IR::MAU::Action * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93738003f5db10bf0c6b853d1508d7f5">actions_writing_fields</a> (const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *f) const</td></tr>
<tr class="separator:a93738003f5db10bf0c6b853d1508d7f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13566eb833e2d88a7fb52100dcd54e38" id="r_a13566eb833e2d88a7fb52100dcd54e38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13566eb833e2d88a7fb52100dcd54e38">actionWrites</a> (const IR::MAU::Action *act) const</td></tr>
<tr class="separator:a13566eb833e2d88a7fb52100dcd54e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc02d9515d1b68219bc509a252af01ec" id="r_abc02d9515d1b68219bc509a252af01ec"><td class="memItemLeft" align="right" valign="top"><a id="abc02d9515d1b68219bc509a252af01ec" name="abc02d9515d1b68219bc509a252af01ec"></a>
const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_field_slice.html">PHV::FieldSlice</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>actionWritesSlices</b> (const IR::MAU::Action *act) const</td></tr>
<tr class="separator:abc02d9515d1b68219bc509a252af01ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c191e51dfba637d945c2e8ad305e9b" id="r_a52c191e51dfba637d945c2e8ad305e9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52c191e51dfba637d945c2e8ad305e9b">all_field_slices_written_together</a> (const <a class="el" href="class_p4_1_1ordered__set.html">PHV::Allocation::MutuallyLiveSlices</a> &amp;container_state, const <a class="el" href="class_p4_1_1ordered__set.html">PHV::ActionSet</a> &amp;set_of_actions, const <a class="el" href="class_p4_1_1ordered__map.html">PHV::Allocation::LiveRangeShrinkingMap</a> &amp;initActions) const</td></tr>
<tr class="separator:a52c191e51dfba637d945c2e8ad305e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce9c19c5b2c19f185b335d0f2fd1979" id="r_afce9c19c5b2c19f185b335d0f2fd1979"><td class="memItemLeft" align="right" valign="top">CanPackReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afce9c19c5b2c19f185b335d0f2fd1979">can_pack</a> (const <a class="el" href="class_p_h_v_1_1_allocation.html">PHV::Allocation</a> &amp;alloc, const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;slices, const <a class="el" href="class_p4_1_1ordered__set.html">PHV::Allocation::MutuallyLiveSlices</a> &amp;original_container_state, const <a class="el" href="class_p4_1_1ordered__map.html">PHV::Allocation::LiveRangeShrinkingMap</a> &amp;initActions) const</td></tr>
<tr class="separator:afce9c19c5b2c19f185b335d0f2fd1979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1398b50e6ed193d21acc6d13e517e67" id="r_aa1398b50e6ed193d21acc6d13e517e67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1398b50e6ed193d21acc6d13e517e67">can_pack_pov</a> (const PHV::SuperCluster::SliceList *slice_list, const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *f) const</td></tr>
<tr class="separator:aa1398b50e6ed193d21acc6d13e517e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ae2f5307c3259184beb815cc5ed9f3" id="r_a05ae2f5307c3259184beb815cc5ed9f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_can_pack_error_v2.html">CanPackErrorV2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05ae2f5307c3259184beb815cc5ed9f3">can_pack_v2</a> (const <a class="el" href="class_p_h_v_1_1_allocation.html">PHV::Allocation</a> &amp;alloc, const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;slices) const</td></tr>
<tr class="memdesc:a05ae2f5307c3259184beb815cc5ed9f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">can_pack_v2 checks whether allocating <code>slices</code> will violate any action constraints.  <br /></td></tr>
<tr class="separator:a05ae2f5307c3259184beb815cc5ed9f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5125745530996826b1a51483f8a593" id="r_afd5125745530996826b1a51483f8a593"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd5125745530996826b1a51483f8a593">cannot_initialize</a> (const <a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a> &amp;c, const IR::MAU::Action *action, const <a class="el" href="class_p_h_v_1_1_allocation.html">PHV::Allocation</a> &amp;alloc) const</td></tr>
<tr class="separator:afd5125745530996826b1a51483f8a593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2feeb920483db306750496913c3c784" id="r_ad2feeb920483db306750496913c3c784"><td class="memItemLeft" align="right" valign="top">CanPackErrorCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2feeb920483db306750496913c3c784">check_ara_move_constraints</a> (const <a class="el" href="class_p_h_v_1_1_allocation.html">PHV::Allocation</a> &amp;alloc, const <a class="el" href="class_p4_1_1ordered__set.html">PHV::Allocation::MutuallyLiveSlices</a> &amp;container_state, const <a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a> &amp;c, const <a class="el" href="class_p4_1_1ordered__map.html">PHV::Allocation::LiveRangeShrinkingMap</a> &amp;initActions) const</td></tr>
<tr class="separator:ad2feeb920483db306750496913c3c784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3a5cd47c75ac587c90c3cecc71ba26" id="r_a9c3a5cd47c75ac587c90c3cecc71ba26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_can_pack_error_v2.html">CanPackErrorV2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c3a5cd47c75ac587c90c3cecc71ba26">check_bitwise_and_basic_move_constraints</a> (const <a class="el" href="class_p4_1_1ordered__set.html">PHV::ActionSet</a> &amp;actions, const <a class="el" href="class_p4_1_1ordered__set.html">PHV::Allocation::MutuallyLiveSlices</a> &amp;container_state, const <a class="el" href="class_p4_1_1ordered__map.html">ActionPropertyMap</a> *action_props) const</td></tr>
<tr class="separator:a9c3a5cd47c75ac587c90c3cecc71ba26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26bc0fcaf2f1b09467119b8996097b5f" id="r_a26bc0fcaf2f1b09467119b8996097b5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_can_pack_error_v2.html">CanPackErrorV2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26bc0fcaf2f1b09467119b8996097b5f">check_move_constraints</a> (const <a class="el" href="class_p_h_v_1_1_allocation.html">PHV::Allocation</a> &amp;alloc, const IR::MAU::Action *action, const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;slices, const <a class="el" href="class_p4_1_1ordered__set.html">PHV::Allocation::MutuallyLiveSlices</a> &amp;container_state, const <a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a> &amp;c, const <a class="el" href="class_p4_1_1ordered__map.html">PHV::Allocation::LiveRangeShrinkingMap</a> &amp;initActions) const</td></tr>
<tr class="separator:a26bc0fcaf2f1b09467119b8996097b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662ae4ecf525a59810243d8004165fc5" id="r_a662ae4ecf525a59810243d8004165fc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_can_pack_error_v2.html">CanPackErrorV2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a662ae4ecf525a59810243d8004165fc5">check_move_constraints_from_read</a> (const <a class="el" href="class_p_h_v_1_1_allocation.html">PHV::Allocation</a> &amp;alloc, const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;candidates, const <a class="el" href="class_p4_1_1ordered__map.html">PHV::Allocation::LiveRangeShrinkingMap</a> &amp;initActions) const</td></tr>
<tr class="separator:a662ae4ecf525a59810243d8004165fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bfb1109b933b280c965c3f220db902a" id="r_a7bfb1109b933b280c965c3f220db902a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_can_pack_error_v2.html">CanPackErrorV2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7bfb1109b933b280c965c3f220db902a">check_read_action_move_constraints</a> (const <a class="el" href="class_p_h_v_1_1_allocation.html">PHV::Allocation</a> &amp;alloc, const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;candidates, const IR::MAU::Action *action, const <a class="el" href="class_p4_1_1ordered__map.html">PHV::Allocation::LiveRangeShrinkingMap</a> &amp;initActions) const</td></tr>
<tr class="separator:a7bfb1109b933b280c965c3f220db902a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9335a9e9af73f607dcf7ae30fc54735d" id="r_a9335a9e9af73f607dcf7ae30fc54735d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_can_pack_error_v2.html">CanPackErrorV2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9335a9e9af73f607dcf7ae30fc54735d">check_read_action_num_source_constraints</a> (const <a class="el" href="class_p_h_v_1_1_allocation.html">PHV::Allocation</a> &amp;alloc, const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;candidates, const IR::MAU::Action *action) const</td></tr>
<tr class="separator:a9335a9e9af73f607dcf7ae30fc54735d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67508ae1d92af87f486f1988b2f8816" id="r_ae67508ae1d92af87f486f1988b2f8816"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae67508ae1d92af87f486f1988b2f8816">checkBridgedPackingConstraints</a> (const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> * &gt; &amp;packing) const</td></tr>
<tr class="separator:ae67508ae1d92af87f486f1988b2f8816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ebd3f30e764c9bd1aa340514e40668" id="r_ad8ebd3f30e764c9bd1aa340514e40668"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt; const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8ebd3f30e764c9bd1aa340514e40668">compute_sources_first_order</a> (const <a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt; const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *, std::vector&lt; <a class="el" href="class_p_h_v_1_1_field_slice.html">PHV::FieldSlice</a> &gt; &gt; &amp;fields) const</td></tr>
<tr class="separator:ad8ebd3f30e764c9bd1aa340514e40668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ad21b47525847ceea35a831964ed2e" id="r_a16ad21b47525847ceea35a831964ed2e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16ad21b47525847ceea35a831964ed2e">count_bitmasked_set_instructions</a> (const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;slices, const <a class="el" href="class_p4_1_1ordered__map.html">PHV::Allocation::LiveRangeShrinkingMap</a> &amp;initActions) const</td></tr>
<tr class="separator:a16ad21b47525847ceea35a831964ed2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385c222c6ba2ebd5414c55af97139183" id="r_a385c222c6ba2ebd5414c55af97139183"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a385c222c6ba2ebd5414c55af97139183">creates_container_conflicts</a> (const <a class="el" href="class_p4_1_1ordered__set.html">PHV::Allocation::MutuallyLiveSlices</a> &amp;container_state, const <a class="el" href="class_p4_1_1ordered__map.html">PHV::Allocation::LiveRangeShrinkingMap</a> &amp;initActions, const <a class="el" href="class_map_tables_to_actions.html">MapTablesToActions</a> &amp;tableActionsMap) const</td></tr>
<tr class="separator:a385c222c6ba2ebd5414c55af97139183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac8134738d54b1241024f45386a1d32" id="r_a2ac8134738d54b1241024f45386a1d32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ac8134738d54b1241024f45386a1d32">dest_first_sort</a> (std::vector&lt; const PHV::SuperCluster::SliceList * &gt; &amp;slice_list) const</td></tr>
<tr class="separator:a2ac8134738d54b1241024f45386a1d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139620ff2ccc8075fb0f31bc36e9577f" id="r_a139620ff2ccc8075fb0f31bc36e9577f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a139620ff2ccc8075fb0f31bc36e9577f">diagnoseSuperCluster</a> (const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const PHV::SuperCluster::SliceList * &gt; &amp;sc, const <a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt; <a class="el" href="class_p_h_v_1_1_field_slice.html">PHV::FieldSlice</a>, unsigned &gt; &amp;fieldAlignments, std::stringstream &amp;error_msg) const</td></tr>
<tr class="separator:a139620ff2ccc8075fb0f31bc36e9577f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d4b2d4b4330d09735a19785a6c9c92" id="r_ae1d4b2d4b4330d09735a19785a6c9c92"><td class="memItemLeft" align="right" valign="top">std::optional&lt; const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1d4b2d4b4330d09735a19785a6c9c92">field_destination</a> (const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *f, const IR::MAU::Action *action) const</td></tr>
<tr class="separator:ae1d4b2d4b4330d09735a19785a6c9c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38bf0da12dd8d189c86fcc1a3847305" id="r_ab38bf0da12dd8d189c86fcc1a3847305"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#struct_action_phv_constraints_1_1_action_sources">ActionSources</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab38bf0da12dd8d189c86fcc1a3847305">getActionSources</a> (const IR::MAU::Action *act, const <a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a> &amp;c, <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;new_slices, const <a class="el" href="class_p_h_v_1_1_allocation.html">PHV::Allocation</a> &amp;alloc) const</td></tr>
<tr class="separator:ab38bf0da12dd8d189c86fcc1a3847305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582dcb8f0dcb1c5fced325816fc3c033" id="r_a582dcb8f0dcb1c5fced325816fc3c033"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a582dcb8f0dcb1c5fced325816fc3c033">hasPackConflict</a> (const <a class="el" href="class_p_h_v_1_1_field_slice.html">PHV::FieldSlice</a> fs1, const <a class="el" href="class_p_h_v_1_1_field_slice.html">PHV::FieldSlice</a> fs2) const</td></tr>
<tr class="separator:a582dcb8f0dcb1c5fced325816fc3c033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb879ac2887daf9c838cc8fa17034ace" id="r_acb879ac2887daf9c838cc8fa17034ace"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb879ac2887daf9c838cc8fa17034ace">hasSpecialityReads</a> (const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *f) const</td></tr>
<tr class="separator:acb879ac2887daf9c838cc8fa17034ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909d6aedfd50dbcc52755a0e10e569db" id="r_a909d6aedfd50dbcc52755a0e10e569db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a909d6aedfd50dbcc52755a0e10e569db">is_bitmasked_set</a> (const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;container_state, const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;fields_not_written_to) const</td></tr>
<tr class="separator:a909d6aedfd50dbcc52755a0e10e569db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a392d86b3a8cb847644ea955b93d55797" id="r_a392d86b3a8cb847644ea955b93d55797"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a392d86b3a8cb847644ea955b93d55797">is_in_action_to_writes</a> (const IR::MAU::Action *, <a class="el" href="class_p4_1_1cstring.html">cstring</a>) const</td></tr>
<tr class="separator:a392d86b3a8cb847644ea955b93d55797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55336904351353410bc135c9773750a4" id="r_a55336904351353410bc135c9773750a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55336904351353410bc135c9773750a4">is_in_field_writes_to_actions</a> (<a class="el" href="class_p4_1_1cstring.html">cstring</a>, const IR::MAU::Action *) const</td></tr>
<tr class="separator:a55336904351353410bc135c9773750a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad50de392fdd593b42e8f072cc7fd87" id="r_a8ad50de392fdd593b42e8f072cc7fd87"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ad50de392fdd593b42e8f072cc7fd87">is_in_write_to_reads</a> (<a class="el" href="class_p4_1_1cstring.html">cstring</a>, const IR::MAU::Action *, <a class="el" href="class_p4_1_1cstring.html">cstring</a>) const</td></tr>
<tr class="separator:a8ad50de392fdd593b42e8f072cc7fd87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2e8aa58565824f82e761883830cc47" id="r_a1b2e8aa58565824f82e761883830cc47"><td class="memItemLeft" align="right" valign="top"><a id="a1b2e8aa58565824f82e761883830cc47" name="a1b2e8aa58565824f82e761883830cc47"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_meter_color_destination</b> (const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *f) const</td></tr>
<tr class="memdesc:a1b2e8aa58565824f82e761883830cc47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Track all the meter color destination to prioritize 8-bit PHV for such field. <br /></td></tr>
<tr class="separator:a1b2e8aa58565824f82e761883830cc47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e349d810ebda3dc52dcd8edc7c5146" id="r_ad5e349d810ebda3dc52dcd8edc7c5146"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5e349d810ebda3dc52dcd8edc7c5146">is_meter_color_destination_8bit</a> (const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *f) const</td></tr>
<tr class="separator:ad5e349d810ebda3dc52dcd8edc7c5146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc4b410f1d8dcf23a558e5d06a56bb8" id="r_a4cc4b410f1d8dcf23a558e5d06a56bb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4cc4b410f1d8dcf23a558e5d06a56bb8">meter_color_dests</a> ()</td></tr>
<tr class="separator:a4cc4b410f1d8dcf23a558e5d06a56bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa95d677d9116aed381d8aa070ac5e3cd" id="r_aa95d677d9116aed381d8aa070ac5e3cd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa95d677d9116aed381d8aa070ac5e3cd">meter_color_dests</a> () const</td></tr>
<tr class="separator:aa95d677d9116aed381d8aa070ac5e3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa796d5821340fffc1753b9eb3c3b2f63" id="r_aa796d5821340fffc1753b9eb3c3b2f63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa796d5821340fffc1753b9eb3c3b2f63">meter_color_dests_8bit</a> ()</td></tr>
<tr class="separator:aa796d5821340fffc1753b9eb3c3b2f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe32404a6d3d10364d17e666ed5696a8" id="r_afe32404a6d3d10364d17e666ed5696a8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe32404a6d3d10364d17e666ed5696a8">meter_color_dests_8bit</a> () const</td></tr>
<tr class="separator:afe32404a6d3d10364d17e666ed5696a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57738309e084587c5868642d4242dc12" id="r_a57738309e084587c5868642d4242dc12"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57738309e084587c5868642d4242dc12">move_only_operations</a> (const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *f) const</td></tr>
<tr class="separator:a57738309e084587c5868642d4242dc12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a893d00b06048099c79b1e377a64856c3" id="r_a893d00b06048099c79b1e377a64856c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a893d00b06048099c79b1e377a64856c3">pack_conflicts_present</a> (const <a class="el" href="class_p4_1_1ordered__set.html">PHV::Allocation::MutuallyLiveSlices</a> &amp;container_state, const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;slices) const</td></tr>
<tr class="separator:a893d00b06048099c79b1e377a64856c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c3072019f6c8d673133e6f3cb486bb" id="r_a86c3072019f6c8d673133e6f3cb486bb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86c3072019f6c8d673133e6f3cb486bb">parser_constant_extract_satisfied</a> (const <a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a> &amp;c, const <a class="el" href="class_p4_1_1ordered__set.html">PHV::Allocation::MutuallyLiveSlices</a> &amp;container_state) const</td></tr>
<tr class="separator:a86c3072019f6c8d673133e6f3cb486bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564f5955ef5f5833cc478447bb005366" id="r_a564f5955ef5f5833cc478447bb005366"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a564f5955ef5f5833cc478447bb005366">slices_destinations</a> (const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *src, const std::vector&lt; <a class="el" href="class_p_h_v_1_1_field_slice.html">PHV::FieldSlice</a> &gt; &amp;slices) const</td></tr>
<tr class="separator:a564f5955ef5f5833cc478447bb005366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70022837027b6f070d80bb41963b1c5d" id="r_a70022837027b6f070d80bb41963b1c5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70022837027b6f070d80bb41963b1c5d">slices_sources</a> (const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *dest, const std::vector&lt; <a class="el" href="class_p_h_v_1_1_field_slice.html">PHV::FieldSlice</a> &gt; &amp;slices) const</td></tr>
<tr class="separator:a70022837027b6f070d80bb41963b1c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7144e43db7ba7c5f39b85eba2abdc415" id="r_a7144e43db7ba7c5f39b85eba2abdc415"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7144e43db7ba7c5f39b85eba2abdc415">sort</a> (std::list&lt; const PHV::SuperCluster::SliceList * &gt; &amp;slice_list) const</td></tr>
<tr class="separator:a7144e43db7ba7c5f39b85eba2abdc415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac288efc74364f32f062edd803adee649" id="r_ac288efc74364f32f062edd803adee649"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac288efc74364f32f062edd803adee649">sort</a> (std::vector&lt; <a class="el" href="class_p_h_v_1_1_field_slice.html">PHV::FieldSlice</a> &gt; &amp;slice_list) const</td></tr>
<tr class="separator:ac288efc74364f32f062edd803adee649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a897c76f54f2d12b94d835c57a3ab1b" id="r_a4a897c76f54f2d12b94d835c57a3ab1b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a897c76f54f2d12b94d835c57a3ab1b">written_by_ad_constant</a> (const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *f, const IR::MAU::Action *act) const</td></tr>
<tr class="separator:a4a897c76f54f2d12b94d835c57a3ab1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9907fae847d8f225e1e1c38d538b080e" id="r_a9907fae847d8f225e1e1c38d538b080e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9907fae847d8f225e1e1c38d538b080e">written_in</a> (const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;slice, const IR::MAU::Action *act) const</td></tr>
<tr class="separator:a9907fae847d8f225e1e1c38d538b080e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdbdfad9eb7462eea9ec83aa1d342f48" id="r_acdbdfad9eb7462eea9ec83aa1d342f48"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acdbdfad9eb7462eea9ec83aa1d342f48">written_in</a> (const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *f, const IR::MAU::Action *act) const</td></tr>
<tr class="separator:acdbdfad9eb7462eea9ec83aa1d342f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_p4_1_1_inspector"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_class_p4_1_1_inspector')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_p4_1_1_inspector.html">P4::Inspector</a></td></tr>
<tr class="memitem:a6b8ae65e8f2f29da879711e4c0455c58 inherit pub_methods_class_p4_1_1_inspector" id="r_a6b8ae65e8f2f29da879711e4c0455c58"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_p4_1_1_i_r_1_1_node.html">IR::Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4_1_1_inspector.html#a6b8ae65e8f2f29da879711e4c0455c58">apply_visitor</a> (const <a class="el" href="class_p4_1_1_i_r_1_1_node.html">IR::Node</a> *, const char *name=0) override</td></tr>
<tr class="separator:a6b8ae65e8f2f29da879711e4c0455c58 inherit pub_methods_class_p4_1_1_inspector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4329f6948ed92b92fdc0b124578da80d inherit pub_methods_class_p4_1_1_inspector" id="r_a4329f6948ed92b92fdc0b124578da80d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p4_1_1_visitor_1_1profile__t.html">profile_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4_1_1_inspector.html#a4329f6948ed92b92fdc0b124578da80d">init_apply</a> (const <a class="el" href="class_p4_1_1_i_r_1_1_node.html">IR::Node</a> *root) override</td></tr>
<tr class="separator:a4329f6948ed92b92fdc0b124578da80d inherit pub_methods_class_p4_1_1_inspector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b361e3d37ddcf9f2288f0dbe8ec1cf inherit pub_methods_class_p4_1_1_inspector" id="r_a54b361e3d37ddcf9f2288f0dbe8ec1cf"><td class="memItemLeft" align="right" valign="top">
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>loop_revisit</b> (const <a class="el" href="class_p4_1_1_i_r_1_1_node.html">IR::Node</a> *)</td></tr>
<tr class="separator:a54b361e3d37ddcf9f2288f0dbe8ec1cf inherit pub_methods_class_p4_1_1_inspector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e73533fc0068de635b0e645c1bb5298 inherit pub_methods_class_p4_1_1_inspector" id="r_a0e73533fc0068de635b0e645c1bb5298"><td class="memItemLeft" align="right" valign="top">
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>postorder</b> (const <a class="el" href="class_p4_1_1_i_r_1_1_node.html">IR::Node</a> *)</td></tr>
<tr class="separator:a0e73533fc0068de635b0e645c1bb5298 inherit pub_methods_class_p4_1_1_inspector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe077948e7d17a03c6037f6f5511c6ff inherit pub_methods_class_p4_1_1_inspector" id="r_afe077948e7d17a03c6037f6f5511c6ff"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4_1_1_inspector.html#afe077948e7d17a03c6037f6f5511c6ff">preorder</a> (const <a class="el" href="class_p4_1_1_i_r_1_1_node.html">IR::Node</a> *)</td></tr>
<tr class="separator:afe077948e7d17a03c6037f6f5511c6ff inherit pub_methods_class_p4_1_1_inspector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8abf13341302ac00c0e88be053c273e3 inherit pub_methods_class_p4_1_1_inspector" id="r_a8abf13341302ac00c0e88be053c273e3"><td class="memItemLeft" align="right" valign="top">
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>revisit</b> (const <a class="el" href="class_p4_1_1_i_r_1_1_node.html">IR::Node</a> *)</td></tr>
<tr class="separator:a8abf13341302ac00c0e88be053c273e3 inherit pub_methods_class_p4_1_1_inspector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746cd9ac08979f74160255ca9c6203ac inherit pub_methods_class_p4_1_1_inspector" id="r_a746cd9ac08979f74160255ca9c6203ac"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>revisit_visited</b> ()</td></tr>
<tr class="separator:a746cd9ac08979f74160255ca9c6203ac inherit pub_methods_class_p4_1_1_inspector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e30dcad259606d59172c06c9a55bbf inherit pub_methods_class_p4_1_1_inspector" id="r_a05e30dcad259606d59172c06c9a55bbf"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>visit_in_progress</b> (const <a class="el" href="class_p4_1_1_i_r_1_1_node.html">IR::Node</a> *n) const</td></tr>
<tr class="separator:a05e30dcad259606d59172c06c9a55bbf inherit pub_methods_class_p4_1_1_inspector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4c7d236f5097ec048e16ff1dbf46b0 inherit pub_methods_class_p4_1_1_inspector" id="r_a1a4c7d236f5097ec048e16ff1dbf46b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4_1_1_inspector.html#a1a4c7d236f5097ec048e16ff1dbf46b0">visitAgain</a> () const override</td></tr>
<tr class="separator:a1a4c7d236f5097ec048e16ff1dbf46b0 inherit pub_methods_class_p4_1_1_inspector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b4a620808c637197a58034b2a1847e inherit pub_methods_class_p4_1_1_inspector" id="r_a01b4a620808c637197a58034b2a1847e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4_1_1_inspector.html#a01b4a620808c637197a58034b2a1847e">visitOnce</a> () const override</td></tr>
<tr class="separator:a01b4a620808c637197a58034b2a1847e inherit pub_methods_class_p4_1_1_inspector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_p4_1_1_visitor"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_class_p4_1_1_visitor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_p4_1_1_visitor.html">P4::Visitor</a></td></tr>
<tr class="memitem:a2b92d3827b07662df506d1ed792c167a inherit pub_methods_class_p4_1_1_visitor" id="r_a2b92d3827b07662df506d1ed792c167a"><td class="memItemLeft" align="right" valign="top">
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>check_global</b> (<a class="el" href="class_p4_1_1cstring.html">cstring</a>)</td></tr>
<tr class="separator:a2b92d3827b07662df506d1ed792c167a inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0087b0a0a46d8df6fd5df184a3acedb inherit pub_methods_class_p4_1_1_visitor" id="r_af0087b0a0a46d8df6fd5df184a3acedb"><td class="memItemLeft" align="right" valign="top">
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>clear_globals</b> ()</td></tr>
<tr class="separator:af0087b0a0a46d8df6fd5df184a3acedb inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4a4cbeccb494423a6ffbb80ade109d inherit pub_methods_class_p4_1_1_visitor" id="r_a2f4a4cbeccb494423a6ffbb80ade109d"><td class="memItemLeft" align="right" valign="top">
virtual <a class="el" href="class_p4_1_1_visitor.html">Visitor</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>clone</b> () const</td></tr>
<tr class="separator:a2f4a4cbeccb494423a6ffbb80ade109d inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a5e2e28ca2bb741588ec144bd152c2 inherit pub_methods_class_p4_1_1_visitor" id="r_ac6a5e2e28ca2bb741588ec144bd152c2"><td class="memItemLeft" align="right" valign="top">
virtual <a class="el" href="class_p4_1_1_control_flow_visitor.html">ControlFlowVisitor</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>controlFlowVisitor</b> ()</td></tr>
<tr class="separator:ac6a5e2e28ca2bb741588ec144bd152c2 inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a404f3e8285e6275b774e83544ff04360 inherit pub_methods_class_p4_1_1_visitor" id="r_a404f3e8285e6275b774e83544ff04360"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4_1_1_visitor.html#a404f3e8285e6275b774e83544ff04360">end_apply</a> (const <a class="el" href="class_p4_1_1_i_r_1_1_node.html">IR::Node</a> *root)</td></tr>
<tr class="separator:a404f3e8285e6275b774e83544ff04360 inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72909367b71899602dbf19732bb15d8 inherit pub_methods_class_p4_1_1_visitor" id="r_ab72909367b71899602dbf19732bb15d8"><td class="memItemLeft" align="right" valign="top">
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>erase_global</b> (<a class="el" href="class_p4_1_1cstring.html">cstring</a>)</td></tr>
<tr class="separator:ab72909367b71899602dbf19732bb15d8 inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2abc6bd4637a87b3a46dba101e994b7 inherit pub_methods_class_p4_1_1_visitor" id="r_af2abc6bd4637a87b3a46dba101e994b7"><td class="memTemplParams" colspan="2">
template&lt;class T &gt; </td></tr>
<tr class="memitem:af2abc6bd4637a87b3a46dba101e994b7 inherit pub_methods_class_p4_1_1_visitor"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>findContext</b> () const</td></tr>
<tr class="separator:af2abc6bd4637a87b3a46dba101e994b7 inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee82dc86e079237a084534d222e378cb inherit pub_methods_class_p4_1_1_visitor" id="r_aee82dc86e079237a084534d222e378cb"><td class="memTemplParams" colspan="2">
template&lt;class T &gt; </td></tr>
<tr class="memitem:aee82dc86e079237a084534d222e378cb inherit pub_methods_class_p4_1_1_visitor"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>findContext</b> (const <a class="el" href="struct_p4_1_1_visitor___context.html">Context</a> *&amp;c) const</td></tr>
<tr class="separator:aee82dc86e079237a084534d222e378cb inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0986dcd73d71758697eaa5ba2bb31357 inherit pub_methods_class_p4_1_1_visitor" id="r_a0986dcd73d71758697eaa5ba2bb31357"><td class="memTemplParams" colspan="2">
template&lt;class T &gt; </td></tr>
<tr class="memitem:a0986dcd73d71758697eaa5ba2bb31357 inherit pub_methods_class_p4_1_1_visitor"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>findOrigCtxt</b> () const</td></tr>
<tr class="separator:a0986dcd73d71758697eaa5ba2bb31357 inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ec427f6d17187e669976176082241c inherit pub_methods_class_p4_1_1_visitor" id="r_a74ec427f6d17187e669976176082241c"><td class="memTemplParams" colspan="2">
template&lt;class T &gt; </td></tr>
<tr class="memitem:a74ec427f6d17187e669976176082241c inherit pub_methods_class_p4_1_1_visitor"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>findOrigCtxt</b> (const <a class="el" href="struct_p4_1_1_visitor___context.html">Context</a> *&amp;c) const</td></tr>
<tr class="separator:a74ec427f6d17187e669976176082241c inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62a8f8314506f7f7fc82a481503004a inherit pub_methods_class_p4_1_1_visitor" id="r_af62a8f8314506f7f7fc82a481503004a"><td class="memItemLeft" align="right" valign="top">
virtual <a class="el" href="class_p4_1_1_visitor.html">Visitor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>flow_clone</b> ()</td></tr>
<tr class="separator:af62a8f8314506f7f7fc82a481503004a inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa444d0de8abca03aa85b441b672a45a6 inherit pub_methods_class_p4_1_1_visitor" id="r_aa444d0de8abca03aa85b441b672a45a6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4_1_1_visitor.html#aa444d0de8abca03aa85b441b672a45a6">flow_merge</a> (<a class="el" href="class_p4_1_1_visitor.html">Visitor</a> &amp;)</td></tr>
<tr class="separator:aa444d0de8abca03aa85b441b672a45a6 inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80200515610d22a53ff5123d0e854256 inherit pub_methods_class_p4_1_1_visitor" id="r_a80200515610d22a53ff5123d0e854256"><td class="memItemLeft" align="right" valign="top">
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>flow_merge_closure</b> (<a class="el" href="class_p4_1_1_visitor.html">Visitor</a> &amp;)</td></tr>
<tr class="separator:a80200515610d22a53ff5123d0e854256 inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd244381d64b160f8cd5c60621ece639 inherit pub_methods_class_p4_1_1_visitor" id="r_acd244381d64b160f8cd5c60621ece639"><td class="memItemLeft" align="right" valign="top">
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>flow_merge_global_from</b> (<a class="el" href="class_p4_1_1cstring.html">cstring</a>)</td></tr>
<tr class="separator:acd244381d64b160f8cd5c60621ece639 inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e64448ceb66f08068beb55ab7028f12 inherit pub_methods_class_p4_1_1_visitor" id="r_a2e64448ceb66f08068beb55ab7028f12"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4_1_1_visitor.html#a2e64448ceb66f08068beb55ab7028f12">flow_merge_global_to</a> (<a class="el" href="class_p4_1_1cstring.html">cstring</a>)</td></tr>
<tr class="separator:a2e64448ceb66f08068beb55ab7028f12 inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e1c0a5a2740f50c1fa7c281eeb6dcd inherit pub_methods_class_p4_1_1_visitor" id="r_af5e1c0a5a2740f50c1fa7c281eeb6dcd"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="struct_p4_1_1_visitor___context.html">Context</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getChildContext</b> () const</td></tr>
<tr class="separator:af5e1c0a5a2740f50c1fa7c281eeb6dcd inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae932c7e0a3a62ae548998b61d6b138c1 inherit pub_methods_class_p4_1_1_visitor" id="r_ae932c7e0a3a62ae548998b61d6b138c1"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>getChildrenVisited</b> () const</td></tr>
<tr class="separator:ae932c7e0a3a62ae548998b61d6b138c1 inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7114d5ed389957f4d45262b29eddef06 inherit pub_methods_class_p4_1_1_visitor" id="r_a7114d5ed389957f4d45262b29eddef06"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="struct_p4_1_1_visitor___context.html">Context</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getContext</b> () const</td></tr>
<tr class="separator:a7114d5ed389957f4d45262b29eddef06 inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079420ada0ad4f4be8bcf82dce9f4b08 inherit pub_methods_class_p4_1_1_visitor" id="r_a079420ada0ad4f4be8bcf82dce9f4b08"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>getContextDepth</b> () const</td></tr>
<tr class="separator:a079420ada0ad4f4be8bcf82dce9f4b08 inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f5bd264f47bfad006f8456f4e53130 inherit pub_methods_class_p4_1_1_visitor" id="r_a12f5bd264f47bfad006f8456f4e53130"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_p4_1_1_i_r_1_1_node.html">IR::Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4_1_1_visitor.html#a12f5bd264f47bfad006f8456f4e53130">getCurrentNode</a> () const</td></tr>
<tr class="separator:a12f5bd264f47bfad006f8456f4e53130 inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab819179a1a6a63fe4818e814c2486ac2 inherit pub_methods_class_p4_1_1_visitor" id="r_ab819179a1a6a63fe4818e814c2486ac2"><td class="memTemplParams" colspan="2">
template&lt;class T &gt; </td></tr>
<tr class="memitem:ab819179a1a6a63fe4818e814c2486ac2 inherit pub_methods_class_p4_1_1_visitor"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getCurrentNode</b> () const</td></tr>
<tr class="separator:ab819179a1a6a63fe4818e814c2486ac2 inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b7a30e5c29579996f307fdfe58a663 inherit pub_methods_class_p4_1_1_visitor" id="r_a38b7a30e5c29579996f307fdfe58a663"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="class_p4_1_1_i_r_1_1_node.html">IR::Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getOriginal</b> () const</td></tr>
<tr class="separator:a38b7a30e5c29579996f307fdfe58a663 inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cda8122ce98019423cd99756fddd280 inherit pub_methods_class_p4_1_1_visitor" id="r_a4cda8122ce98019423cd99756fddd280"><td class="memTemplParams" colspan="2">
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4cda8122ce98019423cd99756fddd280 inherit pub_methods_class_p4_1_1_visitor"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getOriginal</b> () const</td></tr>
<tr class="separator:a4cda8122ce98019423cd99756fddd280 inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f9612efad8c6d8a1448ec4fa436b7d inherit pub_methods_class_p4_1_1_visitor" id="r_a03f9612efad8c6d8a1448ec4fa436b7d"><td class="memTemplParams" colspan="2">
template&lt;class T &gt; </td></tr>
<tr class="memitem:a03f9612efad8c6d8a1448ec4fa436b7d inherit pub_methods_class_p4_1_1_visitor"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getParent</b> () const</td></tr>
<tr class="separator:a03f9612efad8c6d8a1448ec4fa436b7d inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65dc025befbbfdeabcc6edccc5a956bd inherit pub_methods_class_p4_1_1_visitor" id="r_a65dc025befbbfdeabcc6edccc5a956bd"><td class="memItemLeft" align="right" valign="top">
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_flow_joins</b> () const</td></tr>
<tr class="separator:a65dc025befbbfdeabcc6edccc5a956bd inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f2f7e8614d27ed28400a7e57653c70 inherit pub_methods_class_p4_1_1_visitor" id="r_af0f2f7e8614d27ed28400a7e57653c70"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="class_p4_1_1_visitor_1_1profile__t.html">profile_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>init_apply</b> (const <a class="el" href="class_p4_1_1_i_r_1_1_node.html">IR::Node</a> *root, const <a class="el" href="struct_p4_1_1_visitor___context.html">Context</a> *parent_context)</td></tr>
<tr class="separator:af0f2f7e8614d27ed28400a7e57653c70 inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a904b78dd012db5d096c7c8ab15aaff inherit pub_methods_class_p4_1_1_visitor" id="r_a5a904b78dd012db5d096c7c8ab15aaff"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isInContext</b> (const <a class="el" href="class_p4_1_1_i_r_1_1_node.html">IR::Node</a> *n) const</td></tr>
<tr class="separator:a5a904b78dd012db5d096c7c8ab15aaff inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121e82186f4d85a28b0d0acf1f8c82b7 inherit pub_methods_class_p4_1_1_visitor" id="r_a121e82186f4d85a28b0d0acf1f8c82b7"><td class="memItemLeft" align="right" valign="top">
virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><b>name</b> () const</td></tr>
<tr class="separator:a121e82186f4d85a28b0d0acf1f8c82b7 inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bbed061515153ebd2df24847cf6cc4d inherit pub_methods_class_p4_1_1_visitor" id="r_a7bbed061515153ebd2df24847cf6cc4d"><td class="memTemplParams" colspan="2">
template&lt;class T &gt; </td></tr>
<tr class="memitem:a7bbed061515153ebd2df24847cf6cc4d inherit pub_methods_class_p4_1_1_visitor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_visit</b> (const <a class="el" href="class_p4_1_1_i_r_1_1_vector.html">IR::Vector</a>&lt; T &gt; &amp;v, const char *name, int cidx)</td></tr>
<tr class="separator:a7bbed061515153ebd2df24847cf6cc4d inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8735bb94f4897f9f326e439816cef9 inherit pub_methods_class_p4_1_1_visitor" id="r_aed8735bb94f4897f9f326e439816cef9"><td class="memTemplParams" colspan="2">
template&lt;class T &gt; </td></tr>
<tr class="memitem:aed8735bb94f4897f9f326e439816cef9 inherit pub_methods_class_p4_1_1_visitor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_visit</b> (const <a class="el" href="class_p4_1_1_i_r_1_1_vector.html">IR::Vector</a>&lt; T &gt; &amp;v, const char *name=0)</td></tr>
<tr class="separator:aed8735bb94f4897f9f326e439816cef9 inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292d2adc68a45a6b7cc9ead223034e89 inherit pub_methods_class_p4_1_1_visitor" id="r_a292d2adc68a45a6b7cc9ead223034e89"><td class="memTemplParams" colspan="2">
template&lt;class T &gt; </td></tr>
<tr class="memitem:a292d2adc68a45a6b7cc9ead223034e89 inherit pub_methods_class_p4_1_1_visitor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_visit</b> (<a class="el" href="class_p4_1_1_i_r_1_1_vector.html">IR::Vector</a>&lt; T &gt; &amp;v, const char *name, int cidx)</td></tr>
<tr class="separator:a292d2adc68a45a6b7cc9ead223034e89 inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1896a45b73a43ef66d9d9f3e85a6dd91 inherit pub_methods_class_p4_1_1_visitor" id="r_a1896a45b73a43ef66d9d9f3e85a6dd91"><td class="memTemplParams" colspan="2">
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1896a45b73a43ef66d9d9f3e85a6dd91 inherit pub_methods_class_p4_1_1_visitor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_visit</b> (<a class="el" href="class_p4_1_1_i_r_1_1_vector.html">IR::Vector</a>&lt; T &gt; &amp;v, const char *name=0)</td></tr>
<tr class="separator:a1896a45b73a43ef66d9d9f3e85a6dd91 inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9205d8245569eb020cc3639295817a6 inherit pub_methods_class_p4_1_1_visitor" id="r_ad9205d8245569eb020cc3639295817a6"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>print_context</b> () const</td></tr>
<tr class="separator:ad9205d8245569eb020cc3639295817a6 inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba7a57652b8f55a258f289c59aa5d821 inherit pub_methods_class_p4_1_1_visitor" id="r_aba7a57652b8f55a258f289c59aa5d821"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="class_p4_1_1_visitor.html">Visitor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>setCalledBy</b> (const <a class="el" href="class_p4_1_1_visitor.html">Visitor</a> *visitor)</td></tr>
<tr class="separator:aba7a57652b8f55a258f289c59aa5d821 inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52cabfb8fe19ee4b6f48b4f8f78edf49 inherit pub_methods_class_p4_1_1_visitor" id="r_a52cabfb8fe19ee4b6f48b4f8f78edf49"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>setName</b> (const char *name)</td></tr>
<tr class="separator:a52cabfb8fe19ee4b6f48b4f8f78edf49 inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00281189117b47480438200cafc95be inherit pub_methods_class_p4_1_1_visitor" id="r_ac00281189117b47480438200cafc95be"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (const <a class="el" href="class_p4_1_1_i_r_1_1_node.html">IR::Node</a> &amp;n, const char *name, int cidx)</td></tr>
<tr class="separator:ac00281189117b47480438200cafc95be inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a459fabd67f526e184dc01bb9c025c6b7 inherit pub_methods_class_p4_1_1_visitor" id="r_a459fabd67f526e184dc01bb9c025c6b7"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (const <a class="el" href="class_p4_1_1_i_r_1_1_node.html">IR::Node</a> &amp;n, const char *name=0)</td></tr>
<tr class="separator:a459fabd67f526e184dc01bb9c025c6b7 inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ba8b9aeaf1e25bbe51efbf49428f5b inherit pub_methods_class_p4_1_1_visitor" id="r_a61ba8b9aeaf1e25bbe51efbf49428f5b"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (const <a class="el" href="class_p4_1_1_i_r_1_1_node.html">IR::Node</a> *&amp;n, const char *name, int cidx)</td></tr>
<tr class="separator:a61ba8b9aeaf1e25bbe51efbf49428f5b inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc6e2787f130abd8ccaa7d2482d71ed inherit pub_methods_class_p4_1_1_visitor" id="r_aabc6e2787f130abd8ccaa7d2482d71ed"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (const <a class="el" href="class_p4_1_1_i_r_1_1_node.html">IR::Node</a> *&amp;n, const char *name=0)</td></tr>
<tr class="separator:aabc6e2787f130abd8ccaa7d2482d71ed inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1188276981fba6992d14f3dbea0aa15 inherit pub_methods_class_p4_1_1_visitor" id="r_ae1188276981fba6992d14f3dbea0aa15"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (const <a class="el" href="class_p4_1_1_i_r_1_1_node.html">IR::Node</a> *const &amp;n, const char *name, int cidx)</td></tr>
<tr class="separator:ae1188276981fba6992d14f3dbea0aa15 inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5959eb5494d6e03e56199af6e14d9695 inherit pub_methods_class_p4_1_1_visitor" id="r_a5959eb5494d6e03e56199af6e14d9695"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (const <a class="el" href="class_p4_1_1_i_r_1_1_node.html">IR::Node</a> *const &amp;n, const char *name=0)</td></tr>
<tr class="separator:a5959eb5494d6e03e56199af6e14d9695 inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86c8451a5cc5e9d16bad3f0b79252eb inherit pub_methods_class_p4_1_1_visitor" id="r_ae86c8451a5cc5e9d16bad3f0b79252eb"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (<a class="el" href="class_p4_1_1_i_r_1_1_node.html">IR::Node</a> &amp;n, const char *name, int cidx)</td></tr>
<tr class="separator:ae86c8451a5cc5e9d16bad3f0b79252eb inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d9c64bcf69b64a2d78979f202591ea inherit pub_methods_class_p4_1_1_visitor" id="r_aa0d9c64bcf69b64a2d78979f202591ea"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (<a class="el" href="class_p4_1_1_i_r_1_1_node.html">IR::Node</a> &amp;n, const char *name=0)</td></tr>
<tr class="separator:aa0d9c64bcf69b64a2d78979f202591ea inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14111395bc16d58a346e2351dac2c4b6 inherit pub_methods_class_p4_1_1_visitor" id="r_a14111395bc16d58a346e2351dac2c4b6"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (<a class="el" href="class_p4_1_1_i_r_1_1_node.html">IR::Node</a> *&amp;, const char *=0, int=0)</td></tr>
<tr class="separator:a14111395bc16d58a346e2351dac2c4b6 inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b8a4bdba2e0c0600ad87496a199d33 inherit pub_methods_class_p4_1_1_visitor" id="r_a12b8a4bdba2e0c0600ad87496a199d33"><td class="memTemplParams" colspan="2">
template&lt;class T , typename  = std::enable_if_t&lt;Util::has_SourceInfo_v&lt;T&gt; &amp;&amp; !std::is_pointer_v&lt;T&gt;&gt;, class... Args&gt; </td></tr>
<tr class="memitem:a12b8a4bdba2e0c0600ad87496a199d33 inherit pub_methods_class_p4_1_1_visitor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>warn</b> (const int kind, const char *format, const T &amp;node, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a12b8a4bdba2e0c0600ad87496a199d33 inherit pub_methods_class_p4_1_1_visitor"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const ref variant of the above. <br /></td></tr>
<tr class="separator:a12b8a4bdba2e0c0600ad87496a199d33 inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647556f1c95e9850dc8ac09637145089 inherit pub_methods_class_p4_1_1_visitor" id="r_a647556f1c95e9850dc8ac09637145089"><td class="memTemplParams" colspan="2">
template&lt;class T , typename  = std::enable_if_t&lt;Util::has_SourceInfo_v&lt;T&gt;&gt;, class... Args&gt; </td></tr>
<tr class="memitem:a647556f1c95e9850dc8ac09637145089 inherit pub_methods_class_p4_1_1_visitor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>warn</b> (const int kind, const char *format, const T *node, Args &amp;&amp;...args)</td></tr>
<tr class="separator:a647556f1c95e9850dc8ac09637145089 inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a855598301a9252de50b2a46715286605 inherit pub_methods_class_p4_1_1_visitor" id="r_a855598301a9252de50b2a46715286605"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4_1_1_visitor.html#a855598301a9252de50b2a46715286605">warning_enabled</a> (int warning_kind) const</td></tr>
<tr class="separator:a855598301a9252de50b2a46715286605 inherit pub_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a95ea82a4d6b24ff16dcd5ec176987031" id="r_a95ea82a4d6b24ff16dcd5ec176987031"><td class="memItemLeft" align="right" valign="top"><a id="a95ea82a4d6b24ff16dcd5ec176987031" name="a95ea82a4d6b24ff16dcd5ec176987031"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const ActionPhvConstraints::ClassifiedSource &amp;src)</td></tr>
<tr class="separator:a95ea82a4d6b24ff16dcd5ec176987031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac06f1d140bb5dc373d80bb847e7439ef" id="r_ac06f1d140bb5dc373d80bb847e7439ef"><td class="memItemLeft" align="right" valign="top"><a id="ac06f1d140bb5dc373d80bb847e7439ef" name="ac06f1d140bb5dc373d80bb847e7439ef"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const ActionPhvConstraints::OperandInfo &amp;<a class="el" href="namespace_p4.html#ac88f69b11f3155bdc0cabc0b2d684eb9">info</a>)</td></tr>
<tr class="separator:ac06f1d140bb5dc373d80bb847e7439ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b5f1d5bf33db3d5730ac11ab29c1a2" id="r_ac8b5f1d5bf33db3d5730ac11ab29c1a2"><td class="memItemLeft" align="right" valign="top"><a id="ac8b5f1d5bf33db3d5730ac11ab29c1a2" name="ac8b5f1d5bf33db3d5730ac11ab29c1a2"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const <a class="el" href="class_p4_1_1safe__vector.html">safe_vector</a>&lt; ActionPhvConstraints::OperandInfo &gt; &amp;<a class="el" href="namespace_p4.html#ac88f69b11f3155bdc0cabc0b2d684eb9">info</a>)</td></tr>
<tr class="separator:ac8b5f1d5bf33db3d5730ac11ab29c1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_class_p4_1_1_visitor"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_types_class_p4_1_1_visitor')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="class_p4_1_1_visitor.html">P4::Visitor</a></td></tr>
<tr class="memitem:a61af39e88e7fc94bc5865c6d6b0ca6ec inherit pub_types_class_p4_1_1_visitor" id="r_a61af39e88e7fc94bc5865c6d6b0ca6ec"><td class="memItemLeft" align="right" valign="top">
typedef <a class="el" href="struct_p4_1_1_visitor___context.html">Visitor_Context</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Context</b></td></tr>
<tr class="separator:a61af39e88e7fc94bc5865c6d6b0ca6ec inherit pub_types_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_class_p4_1_1_visitor"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_static_methods_class_p4_1_1_visitor')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="class_p4_1_1_visitor.html">P4::Visitor</a></td></tr>
<tr class="memitem:acc1e5976fdbd48c1d087e5b037325978 inherit pub_static_methods_class_p4_1_1_visitor" id="r_acc1e5976fdbd48c1d087e5b037325978"><td class="memItemLeft" align="right" valign="top">
static <a class="el" href="class_p4_1_1cstring.html">cstring</a>&#160;</td><td class="memItemRight" valign="bottom"><b>demangle</b> (const char *)</td></tr>
<tr class="separator:acc1e5976fdbd48c1d087e5b037325978 inherit pub_static_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6b7d83c083c4fbfb1b9cd414abdc67 inherit pub_static_methods_class_p4_1_1_visitor" id="r_ade6b7d83c083c4fbfb1b9cd414abdc67"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4_1_1_visitor.html#ade6b7d83c083c4fbfb1b9cd414abdc67">warning_enabled</a> (const <a class="el" href="class_p4_1_1_visitor.html">Visitor</a> *visitor, int warning_kind)</td></tr>
<tr class="separator:ade6b7d83c083c4fbfb1b9cd414abdc67 inherit pub_static_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_class_p4_1_1_visitor"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_attribs_class_p4_1_1_visitor')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="class_p4_1_1_visitor.html">P4::Visitor</a></td></tr>
<tr class="memitem:a77790b8548086cf62140b5b5579ac455 inherit pub_attribs_class_p4_1_1_visitor" id="r_a77790b8548086cf62140b5b5579ac455"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="class_p4_1_1_visitor.html">Visitor</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>called_by</b> = nullptr</td></tr>
<tr class="separator:a77790b8548086cf62140b5b5579ac455 inherit pub_attribs_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd80529c2f1861b5c47d7034c5d1582 inherit pub_attribs_class_p4_1_1_visitor" id="r_afcd80529c2f1861b5c47d7034c5d1582"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="class_p4_1_1cstring.html">cstring</a>&#160;</td><td class="memItemRight" valign="bottom"><b>internalName</b></td></tr>
<tr class="separator:afcd80529c2f1861b5c47d7034c5d1582 inherit pub_attribs_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d9241864c1690334664877e1700226 inherit pub_attribs_class_p4_1_1_visitor" id="r_a08d9241864c1690334664877e1700226"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="class_p4_1_1_split_flow_visit__base.html">SplitFlowVisit_base</a> *&amp;&#160;</td><td class="memItemRight" valign="bottom"><b>split_link</b></td></tr>
<tr class="separator:a08d9241864c1690334664877e1700226 inherit pub_attribs_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5fbe40632b94fd5f81268281e92c262 inherit pub_attribs_class_p4_1_1_visitor" id="r_ad5fbe40632b94fd5f81268281e92c262"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="class_p4_1_1_split_flow_visit__base.html">SplitFlowVisit_base</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>split_link_mem</b> = nullptr</td></tr>
<tr class="separator:ad5fbe40632b94fd5f81268281e92c262 inherit pub_attribs_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_p4_1_1_visitor"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_class_p4_1_1_visitor')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_p4_1_1_visitor.html">P4::Visitor</a></td></tr>
<tr class="memitem:a16268c6a9909821e47b5c6313c75d35e inherit pro_methods_class_p4_1_1_visitor" id="r_a16268c6a9909821e47b5c6313c75d35e"><td class="memItemLeft" align="right" valign="top">
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>init_join_flows</b> (const <a class="el" href="class_p4_1_1_i_r_1_1_node.html">IR::Node</a> *)</td></tr>
<tr class="separator:a16268c6a9909821e47b5c6313c75d35e inherit pro_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7dead1386c1bd5727307f5ae131aad7 inherit pro_methods_class_p4_1_1_visitor" id="r_ae7dead1386c1bd5727307f5ae131aad7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4_1_1_visitor.html#ae7dead1386c1bd5727307f5ae131aad7">join_flows</a> (const <a class="el" href="class_p4_1_1_i_r_1_1_node.html">IR::Node</a> *)</td></tr>
<tr class="separator:ae7dead1386c1bd5727307f5ae131aad7 inherit pro_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dbe3feb775de2157cab17104691d606 inherit pro_methods_class_p4_1_1_visitor" id="r_a5dbe3feb775de2157cab17104691d606"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p4_1_1_visitor.html#a5dbe3feb775de2157cab17104691d606">post_join_flows</a> (const <a class="el" href="class_p4_1_1_i_r_1_1_node.html">IR::Node</a> *, const <a class="el" href="class_p4_1_1_i_r_1_1_node.html">IR::Node</a> *)</td></tr>
<tr class="separator:a5dbe3feb775de2157cab17104691d606 inherit pro_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a56c27a883ef67322ea4d8a01ace0de inherit pro_methods_class_p4_1_1_visitor" id="r_a6a56c27a883ef67322ea4d8a01ace0de"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit_children</b> (const <a class="el" href="class_p4_1_1_i_r_1_1_node.html">IR::Node</a> *, std::function&lt; void()&gt; fn)</td></tr>
<tr class="separator:a6a56c27a883ef67322ea4d8a01ace0de inherit pro_methods_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_p4_1_1_visitor"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_attribs_class_p4_1_1_visitor')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_p4_1_1_visitor.html">P4::Visitor</a></td></tr>
<tr class="memitem:acfef9a2a08634af0bbad5d5134d84c56 inherit pro_attribs_class_p4_1_1_visitor" id="r_acfef9a2a08634af0bbad5d5134d84c56"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>dontForwardChildrenBeforePreorder</b> = false</td></tr>
<tr class="separator:acfef9a2a08634af0bbad5d5134d84c56 inherit pro_attribs_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0faafbf35168a5a7f22ab34b02fb4170 inherit pro_attribs_class_p4_1_1_visitor" id="r_a0faafbf35168a5a7f22ab34b02fb4170"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>joinFlows</b> = false</td></tr>
<tr class="separator:a0faafbf35168a5a7f22ab34b02fb4170 inherit pro_attribs_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609ed9bc5d421210d591474f234d5e88 inherit pro_attribs_class_p4_1_1_visitor" id="r_a609ed9bc5d421210d591474f234d5e88"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>visitDagOnce</b> = true</td></tr>
<tr class="separator:a609ed9bc5d421210d591474f234d5e88 inherit pro_attribs_class_p4_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class is meant to gather action information as well as provide information to PHV analysis through function calls. Methods in AllocatePHV query the information contained in class members here to determine constraints on packing induced by MAU actions. </p><dl class="section pre"><dt>Precondition</dt><dd>Must be run after InstructionSelection, as it is dependent on ActionAnalysis </dd></dl>
</div><hr/><h2 class="groupheader">Class Documentation</h2>
<a name="struct_action_phv_constraints_1_1_action_sources" id="struct_action_phv_constraints_1_1_action_sources"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_action_phv_constraints_1_1_action_sources">&#9670;&#160;</a></span>ActionPhvConstraints::ActionSources</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ActionPhvConstraints::ActionSources</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="afeb4136305c0605c5715108eb7943b47" name="afeb4136305c0605c5715108eb7943b47"></a><a class="el" href="class_p4_1_1bitvec.html">bitvec</a></td>
<td class="fieldname">
dest_bits</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a4cd7d721ed4be92505326afc45410346" name="a4cd7d721ed4be92505326afc45410346"></a>bool</td>
<td class="fieldname">
has_ad = false</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a73d3f6d469ceb79136dd5d745b9f05e8" name="a73d3f6d469ceb79136dd5d745b9f05e8"></a>bool</td>
<td class="fieldname">
has_const = false</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a0eeb2b2d76a52244962359d49a4cca97" name="a0eeb2b2d76a52244962359d49a4cca97"></a><a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; Container &gt;</td>
<td class="fieldname">
phv</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a84dbf53c21bf523d2810c0b8143e4dd2" name="a84dbf53c21bf523d2810c0b8143e4dd2"></a>int</td>
<td class="fieldname">
unalloc = 0</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a268250cb72e8d56151714ebc536af80f" name="a268250cb72e8d56151714ebc536af80f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a268250cb72e8d56151714ebc536af80f">&#9670;&#160;</a></span>actionReads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> * &gt; ActionPhvConstraints::actionReads </td>
          <td>(</td>
          <td class="paramtype">const IR::MAU::Action *</td>          <td class="paramname"><span class="paramname"><em>act</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the set of fields that are read in action <code>act</code> </dd></dl>

</div>
</div>
<a id="a7b2446984b1cba092f28df8b538bac9f" name="a7b2446984b1cba092f28df8b538bac9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b2446984b1cba092f28df8b538bac9f">&#9670;&#160;</a></span>actions_reading_fields()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const IR::MAU::Action * &gt; ActionPhvConstraints::actions_reading_fields </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the set of all actions which read field <code>f</code>. </dd></dl>

</div>
</div>
<a id="a93738003f5db10bf0c6b853d1508d7f5" name="a93738003f5db10bf0c6b853d1508d7f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93738003f5db10bf0c6b853d1508d7f5">&#9670;&#160;</a></span>actions_writing_fields()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const IR::MAU::Action * &gt; ActionPhvConstraints::actions_writing_fields </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the set of all the actions which write field <code>f</code>. </dd></dl>

</div>
</div>
<a id="a13566eb833e2d88a7fb52100dcd54e38" name="a13566eb833e2d88a7fb52100dcd54e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13566eb833e2d88a7fb52100dcd54e38">&#9670;&#160;</a></span>actionWrites()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> * &gt; ActionPhvConstraints::actionWrites </td>
          <td>(</td>
          <td class="paramtype">const IR::MAU::Action *</td>          <td class="paramname"><span class="paramname"><em>act</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the set of fields that are written in action <code>act</code> </dd></dl>

</div>
</div>
<a id="a52c191e51dfba637d945c2e8ad305e9b" name="a52c191e51dfba637d945c2e8ad305e9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52c191e51dfba637d945c2e8ad305e9b">&#9670;&#160;</a></span>all_field_slices_written_together()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ActionPhvConstraints::all_field_slices_written_together </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1ordered__set.html">PHV::Allocation::MutuallyLiveSlices</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>container_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1ordered__set.html">PHV::ActionSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>set_of_actions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1ordered__map.html">PHV::Allocation::LiveRangeShrinkingMap</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>initActions</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if: for every slice s in <code>container_state</code>, if an action a in <code>set_of_actions</code> writes that slice, then all other slices in <code>container_state</code> are also written by a; and if an action b in <code>set_of_actions</code> does not write slice s, then all other slices in <code>container_state</code> are also not written by action b. </dd></dl>

</div>
</div>
<a id="afce9c19c5b2c19f185b335d0f2fd1979" name="afce9c19c5b2c19f185b335d0f2fd1979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce9c19c5b2c19f185b335d0f2fd1979">&#9670;&#160;</a></span>can_pack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CanPackReturnType ActionPhvConstraints::can_pack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_allocation.html">PHV::Allocation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>slices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1ordered__set.html">PHV::Allocation::MutuallyLiveSlices</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>original_container_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1ordered__map.html">PHV::Allocation::LiveRangeShrinkingMap</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>initActions</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether packing <code>slices</code> into a container will violate MAU action constraints. <code>initActions</code> is the map of fields to the actions where those fields must be initialized to enable metadata overlay.</p>
<dl class="section return"><dt>Returns</dt><dd>bit positions at which unallocated slices must be allocated for the proposed packing to be valid, or std::nullopt if no packing is possible. An empty map indicates the proposed packing is unconditionally valid.</dd></dl>
<p>TODO: Right now, the packing constraints generated by can_pack() have one limitation. Suppose there are n sources related to moves for a container in a particular action, and 2 of the sources (s1 and s2) are already allocated. In that case, valid packing requires the remaining n-2 sources to be packed with either s1 or s2. Right now, s1, s2, and all the other sources are put in the same set in the UnionFind. The allocator needs to be aware of this case. </p>
<p>check and generate conditional constraints.</p>

</div>
</div>
<a id="aa1398b50e6ed193d21acc6d13e517e67" name="aa1398b50e6ed193d21acc6d13e517e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1398b50e6ed193d21acc6d13e517e67">&#9670;&#160;</a></span>can_pack_pov()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ActionPhvConstraints::can_pack_pov </td>
          <td>(</td>
          <td class="paramtype">const PHV::SuperCluster::SliceList *</td>          <td class="paramname"><span class="paramname"><em>slice_list</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the POV bit <code>f</code> can be packed in the same container and the next position in <code>slice_list</code>. </dd></dl>

</div>
</div>
<a id="a05ae2f5307c3259184beb815cc5ed9f3" name="a05ae2f5307c3259184beb815cc5ed9f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ae2f5307c3259184beb815cc5ed9f3">&#9670;&#160;</a></span>can_pack_v2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_can_pack_error_v2.html">CanPackErrorV2</a> ActionPhvConstraints::can_pack_v2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_allocation.html">PHV::Allocation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>slices</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>can_pack_v2 checks whether allocating <code>slices</code> will violate any action constraints. </p>
<p>TODO: checks inherited from legacy code does not have detailed error message. For example, pack_conflicts_present, stateful_destinations_constraints_violated and ...</p>

</div>
</div>
<a id="afd5125745530996826b1a51483f8a593" name="afd5125745530996826b1a51483f8a593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd5125745530996826b1a51483f8a593">&#9670;&#160;</a></span>cannot_initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ActionPhvConstraints::cannot_initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IR::MAU::Action *</td>          <td class="paramname"><span class="paramname"><em>action</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_allocation.html">PHV::Allocation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if metadata initialization can be done for a field in container <code>c</code> at action <code>action</code>. </dd></dl>

</div>
</div>
<a id="ad2feeb920483db306750496913c3c784" name="ad2feeb920483db306750496913c3c784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2feeb920483db306750496913c3c784">&#9670;&#160;</a></span>check_ara_move_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CanPackErrorCode ActionPhvConstraints::check_ara_move_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_allocation.html">PHV::Allocation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1ordered__set.html">PHV::Allocation::MutuallyLiveSlices</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>container_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1ordered__map.html">PHV::Allocation::LiveRangeShrinkingMap</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>initActions</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Besides actual actions, we need to check always run actions: (1) always run action does not overwrite other fields. For example, if we have two sources to one destination in one ARA, we need verify there's no other field in destination that are not mutex. (2) TODO: always run action can be synthesized: we cannot do it now because we don't have a way to get all ARA instructions for a specific point, and because we do table placement after PHV, it's always possible to have any ARA, so the check here is trying to avoid introducing new dependencies. table placement will add new stages when multiple instruction cannot be synthesized in one always run action. </p>

</div>
</div>
<a id="a9c3a5cd47c75ac587c90c3cecc71ba26" name="a9c3a5cd47c75ac587c90c3cecc71ba26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c3a5cd47c75ac587c90c3cecc71ba26">&#9670;&#160;</a></span>check_bitwise_and_basic_move_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_can_pack_error_v2.html">CanPackErrorV2</a> ActionPhvConstraints::check_bitwise_and_basic_move_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1ordered__set.html">PHV::ActionSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>actions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1ordered__set.html">PHV::Allocation::MutuallyLiveSlices</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>container_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1ordered__map.html">ActionPropertyMap</a> *</td>          <td class="paramname"><span class="paramname"><em>action_props</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns an eroor when any action constraint of <code>actions</code> are violated if the destination container has slices in <code>container_state</code>. </p>

</div>
</div>
<a id="a26bc0fcaf2f1b09467119b8996097b5f" name="a26bc0fcaf2f1b09467119b8996097b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26bc0fcaf2f1b09467119b8996097b5f">&#9670;&#160;</a></span>check_move_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_can_pack_error_v2.html">CanPackErrorV2</a> ActionPhvConstraints::check_move_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_allocation.html">PHV::Allocation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IR::MAU::Action *</td>          <td class="paramname"><span class="paramname"><em>action</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>slices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1ordered__set.html">PHV::Allocation::MutuallyLiveSlices</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>container_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1ordered__map.html">PHV::Allocation::LiveRangeShrinkingMap</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>initActions</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether packing <code>slices</code> into a container will violate MAU action constraints for all move-based instructions, using an action move constraint solver for normal container destination. For mocha and dark container, check basic constraints that: (1) mocha container can only be written in whole by ad/constant/container. (2) dark container can only be written in while by container. </p>

</div>
</div>
<a id="a662ae4ecf525a59810243d8004165fc5" name="a662ae4ecf525a59810243d8004165fc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a662ae4ecf525a59810243d8004165fc5">&#9670;&#160;</a></span>check_move_constraints_from_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_can_pack_error_v2.html">CanPackErrorV2</a> ActionPhvConstraints::check_move_constraints_from_read </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_allocation.html">PHV::Allocation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>candidates</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1ordered__map.html">PHV::Allocation::LiveRangeShrinkingMap</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>initActions</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check action move constraints when a source slice is allocated in <code>slices</code>. It will iterate over all actions that has read any in <code>slices</code> and run move constraint checker on its destination container, with fields during the action. </p>

</div>
</div>
<a id="a7bfb1109b933b280c965c3f220db902a" name="a7bfb1109b933b280c965c3f220db902a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bfb1109b933b280c965c3f220db902a">&#9670;&#160;</a></span>check_read_action_move_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_can_pack_error_v2.html">CanPackErrorV2</a> ActionPhvConstraints::check_read_action_move_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_allocation.html">PHV::Allocation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>candidates</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IR::MAU::Action *</td>          <td class="paramname"><span class="paramname"><em>action</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1ordered__map.html">PHV::Allocation::LiveRangeShrinkingMap</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>initActions</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use action constraint solver to check move-based instruction constraints from reader-side, i.e., <code>candidates</code> are sources of instructions. </p>

</div>
</div>
<a id="a9335a9e9af73f607dcf7ae30fc54735d" name="a9335a9e9af73f607dcf7ae30fc54735d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9335a9e9af73f607dcf7ae30fc54735d">&#9670;&#160;</a></span>check_read_action_num_source_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_can_pack_error_v2.html">CanPackErrorV2</a> ActionPhvConstraints::check_read_action_num_source_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_allocation.html">PHV::Allocation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>candidates</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IR::MAU::Action *</td>          <td class="paramname"><span class="paramname"><em>action</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>error if the number of sources is more than allowed for in <code>action</code>, when we allocate sources <code>candidates</code> to <code>alloc</code>. </dd></dl>

</div>
</div>
<a id="ae67508ae1d92af87f486f1988b2f8816" name="ae67508ae1d92af87f486f1988b2f8816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae67508ae1d92af87f486f1988b2f8816">&#9670;&#160;</a></span>checkBridgedPackingConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ActionPhvConstraints::checkBridgedPackingConstraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>packing</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the candidate bridged metadata packing <code>packing</code> satisfies action constraints </dd></dl>

</div>
</div>
<a id="ad8ebd3f30e764c9bd1aa340514e40668" name="ad8ebd3f30e764c9bd1aa340514e40668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8ebd3f30e764c9bd1aa340514e40668">&#9670;&#160;</a></span>compute_sources_first_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt; const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *, int &gt; ActionPhvConstraints::compute_sources_first_order </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt; const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *, std::vector&lt; <a class="el" href="class_p_h_v_1_1_field_slice.html">PHV::FieldSlice</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fields</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>compute_sources_first_order returns a mapping from field to an integer which represents the priority (lower number higher priority) if we need to allocate source fields first. Because fields can form a strongly connected component, i.e. a loop, in terms of writes, e.g. two fields write to each other, we will run a Tarjan algorithm first to replace those SCCs with a single node and then we run a topological sort. For example, Assume a &lt;- b represents b writes to a, and we have</p>
<p>a &lt;- b &lt;- c &lt;-&gt; e ^ | d</p>
<p>will be converted to, a &lt;- b &lt;- {c, e} ^ | d</p>
<p>and the output will be, d, c, e: 1 b: 2 a: 3</p>
<p>i.e. we encounter a loop, convert that loop into one node. </p>

</div>
</div>
<a id="a16ad21b47525847ceea35a831964ed2e" name="a16ad21b47525847ceea35a831964ed2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16ad21b47525847ceea35a831964ed2e">&#9670;&#160;</a></span>count_bitmasked_set_instructions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ActionPhvConstraints::count_bitmasked_set_instructions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>slices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1ordered__map.html">PHV::Allocation::LiveRangeShrinkingMap</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>initActions</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Counts the number of bitmasked-set instructions corresponding to <code>slices</code> in container <code>c</code> and allocation object <code>alloc</code>. </p>

</div>
</div>
<a id="a385c222c6ba2ebd5414c55af97139183" name="a385c222c6ba2ebd5414c55af97139183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a385c222c6ba2ebd5414c55af97139183">&#9670;&#160;</a></span>creates_container_conflicts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ActionPhvConstraints::creates_container_conflicts </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1ordered__set.html">PHV::Allocation::MutuallyLiveSlices</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>container_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1ordered__map.html">PHV::Allocation::LiveRangeShrinkingMap</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>initActions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_map_tables_to_actions.html">MapTablesToActions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tableActionsMap</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if this packing would create container conflicts because of metadata initialization issues. </dd></dl>

</div>
</div>
<a id="a2ac8134738d54b1241024f45386a1d32" name="a2ac8134738d54b1241024f45386a1d32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ac8134738d54b1241024f45386a1d32">&#9670;&#160;</a></span>dest_first_sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ActionPhvConstraints::dest_first_sort </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; const PHV::SuperCluster::SliceList * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>slice_list</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>sort <code>slice_lists</code> by</p><ol type="1">
<li>a topographical order of their data flow graph, where destinations will be sorted to the front. Strongly-connected-components will be converted to one node. Every slice lists will be represented by the highest priority field (deepest in source to destination flow, i.e., like the <code>last destination</code>) of the list.</li>
<li>number of actions that write to the slice list.</li>
<li>lo part of the same-field list will be allcoated first. </li>
</ol>

</div>
</div>
<a id="a139620ff2ccc8075fb0f31bc36e9577f" name="a139620ff2ccc8075fb0f31bc36e9577f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a139620ff2ccc8075fb0f31bc36e9577f">&#9670;&#160;</a></span>diagnoseSuperCluster()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ActionPhvConstraints::diagnoseSuperCluster </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const PHV::SuperCluster::SliceList * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt; <a class="el" href="class_p_h_v_1_1_field_slice.html">PHV::FieldSlice</a>, unsigned &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fieldAlignments</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::stringstream &amp;</td>          <td class="paramname"><span class="paramname"><em>error_msg</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Diagnose PHV allocation failure for supercluster <code>sc</code> containing field slices in slice lists with alignment <code>sliceAlignments</code>. </p><dl class="section return"><dt>Returns</dt><dd>true if a concrete error violation is detected. Populates <code>error_msg</code> with the appropriate error message. </dd></dl>

</div>
</div>
<a id="ae1d4b2d4b4330d09735a19785a6c9c92" name="ae1d4b2d4b4330d09735a19785a6c9c92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1d4b2d4b4330d09735a19785a6c9c92">&#9670;&#160;</a></span>field_destination()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> * &gt; ActionPhvConstraints::field_destination </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IR::MAU::Action *</td>          <td class="paramname"><span class="paramname"><em>action</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the destination of field <code>f</code> in action <code>action</code>. </dd>
<dd>
std::nullopt if <code>f</code> is not written in <code>action</code>. </dd></dl>

</div>
</div>
<a id="ab38bf0da12dd8d189c86fcc1a3847305" name="ab38bf0da12dd8d189c86fcc1a3847305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab38bf0da12dd8d189c86fcc1a3847305">&#9670;&#160;</a></span>getActionSources()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#struct_action_phv_constraints_1_1_action_sources">ActionPhvConstraints::ActionSources</a> ActionPhvConstraints::getActionSources </td>
          <td>(</td>
          <td class="paramtype">const IR::MAU::Action *</td>          <td class="paramname"><span class="paramname"><em>act</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>new_slices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_allocation.html">PHV::Allocation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find all sources of an action that write to a given container</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">act</td><td>action for which to find the sources </td></tr>
    <tr><td class="paramname">c</td><td>destination container of interest for the action </td></tr>
    <tr><td class="paramname">new_slices</td><td>slices to be added to the allocation </td></tr>
    <tr><td class="paramname">alloc</td><td>current Allocation object containing allocated slices</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an ActionSources struct with the source information</dd></dl>
<p>FIXME: This function can be made non-public once live range shrinking/dark overlay functionality is merged and all initialization points are correctly exposed. </p>

</div>
</div>
<a id="a582dcb8f0dcb1c5fced325816fc3c033" name="a582dcb8f0dcb1c5fced325816fc3c033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a582dcb8f0dcb1c5fced325816fc3c033">&#9670;&#160;</a></span>hasPackConflict()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ActionPhvConstraints::hasPackConflict </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_field_slice.html">PHV::FieldSlice</a></td>          <td class="paramname"><span class="paramname"><em>fs1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_field_slice.html">PHV::FieldSlice</a></td>          <td class="paramname"><span class="paramname"><em>fs2</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the fieldslice <code>fs1</code> and <code>fs2</code> have a pack conflict. </dd></dl>

</div>
</div>
<a id="acb879ac2887daf9c838cc8fa17034ace" name="acb879ac2887daf9c838cc8fa17034ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb879ac2887daf9c838cc8fa17034ace">&#9670;&#160;</a></span>hasSpecialityReads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ActionPhvConstraints::hasSpecialityReads </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the field <code>f</code> is written using a speciality read (METER_ALU, HASH_DIST, RANDOM, or METER_COLOR). </dd></dl>

</div>
</div>
<a id="a909d6aedfd50dbcc52755a0e10e569db" name="a909d6aedfd50dbcc52755a0e10e569db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a909d6aedfd50dbcc52755a0e10e569db">&#9670;&#160;</a></span>is_bitmasked_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ActionPhvConstraints::is_bitmasked_set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>container_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fields_not_written_to</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the allocation <code>container_state</code> in a particular container, where slices in <code>fields_not_written_to</code> are not written in the given action, would result in the synthesis of a bitmasked-set instruction. </dd></dl>

</div>
</div>
<a id="a392d86b3a8cb847644ea955b93d55797" name="a392d86b3a8cb847644ea955b93d55797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a392d86b3a8cb847644ea955b93d55797">&#9670;&#160;</a></span>is_in_action_to_writes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ActionPhvConstraints::is_in_action_to_writes </td>
          <td>(</td>
          <td class="paramtype">const IR::MAU::Action *</td>          <td class="paramname"><span class="paramname"><em>action</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1cstring.html">cstring</a></td>          <td class="paramname"><span class="paramname"><em>write</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For GTest function. Checks if the action_to_writes ordered_map entry is valid or not </p>

</div>
</div>
<a id="a55336904351353410bc135c9773750a4" name="a55336904351353410bc135c9773750a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55336904351353410bc135c9773750a4">&#9670;&#160;</a></span>is_in_field_writes_to_actions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ActionPhvConstraints::is_in_field_writes_to_actions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p4_1_1cstring.html">cstring</a></td>          <td class="paramname"><span class="paramname"><em>write</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IR::MAU::Action *</td>          <td class="paramname"><span class="paramname"><em>action</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For GTest function. Checks if the field_writes_to_actions ordered_map entry is valid or not </p>

</div>
</div>
<a id="a8ad50de392fdd593b42e8f072cc7fd87" name="a8ad50de392fdd593b42e8f072cc7fd87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad50de392fdd593b42e8f072cc7fd87">&#9670;&#160;</a></span>is_in_write_to_reads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ActionPhvConstraints::is_in_write_to_reads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p4_1_1cstring.html">cstring</a></td>          <td class="paramname"><span class="paramname"><em>write</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IR::MAU::Action *</td>          <td class="paramname"><span class="paramname"><em>act</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1cstring.html">cstring</a></td>          <td class="paramname"><span class="paramname"><em>read</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For GTest function. Checks if the write_to_reads_per_action ordered_map entry is valid or not </p>

</div>
</div>
<a id="ad5e349d810ebda3dc52dcd8edc7c5146" name="ad5e349d810ebda3dc52dcd8edc7c5146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5e349d810ebda3dc52dcd8edc7c5146">&#9670;&#160;</a></span>is_meter_color_destination_8bit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ActionPhvConstraints::is_meter_color_destination_8bit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>[Relaxed Artificial Constraint]: Right now action bus allocation requires any destination written by meter colors to be allocated to a 8-bit PHV if the result of the operation can't be rotated. This set keeps a track of all such destinations. </p>

</div>
</div>
<a id="a4cc4b410f1d8dcf23a558e5d06a56bb8" name="a4cc4b410f1d8dcf23a558e5d06a56bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cc4b410f1d8dcf23a558e5d06a56bb8">&#9670;&#160;</a></span>meter_color_dests() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> * &gt; &amp; ActionPhvConstraints::meter_color_dests </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>all the fields that are written using meter color fields. </dd></dl>

</div>
</div>
<a id="aa95d677d9116aed381d8aa070ac5e3cd" name="aa95d677d9116aed381d8aa070ac5e3cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa95d677d9116aed381d8aa070ac5e3cd">&#9670;&#160;</a></span>meter_color_dests() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> * &gt; &amp; ActionPhvConstraints::meter_color_dests </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>all the fields that are written using meter color fields. </dd></dl>

</div>
</div>
<a id="aa796d5821340fffc1753b9eb3c3b2f63" name="aa796d5821340fffc1753b9eb3c3b2f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa796d5821340fffc1753b9eb3c3b2f63">&#9670;&#160;</a></span>meter_color_dests_8bit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> * &gt; &amp; ActionPhvConstraints::meter_color_dests_8bit </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>all the fields that are written using meter color fields that cannot be rotated. </dd></dl>

</div>
</div>
<a id="afe32404a6d3d10364d17e666ed5696a8" name="afe32404a6d3d10364d17e666ed5696a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe32404a6d3d10364d17e666ed5696a8">&#9670;&#160;</a></span>meter_color_dests_8bit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> * &gt; &amp; ActionPhvConstraints::meter_color_dests_8bit </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>all the fields that are written using meter color fields that cannot be rotated. </dd></dl>

</div>
</div>
<a id="a57738309e084587c5868642d4242dc12" name="a57738309e084587c5868642d4242dc12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57738309e084587c5868642d4242dc12">&#9670;&#160;</a></span>move_only_operations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ActionPhvConstraints::move_only_operations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the field <code>f</code> is only ever written by move operations. </dd></dl>

</div>
</div>
<a id="a893d00b06048099c79b1e377a64856c3" name="a893d00b06048099c79b1e377a64856c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a893d00b06048099c79b1e377a64856c3">&#9670;&#160;</a></span>pack_conflicts_present()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ActionPhvConstraints::pack_conflicts_present </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1ordered__set.html">PHV::Allocation::MutuallyLiveSlices</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>container_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>slices</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if there is a no-pack conflict between the fields in <code>container_state</code>. </dd></dl>

</div>
</div>
<a id="a86c3072019f6c8d673133e6f3cb486bb" name="a86c3072019f6c8d673133e6f3cb486bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c3072019f6c8d673133e6f3cb486bb">&#9670;&#160;</a></span>parser_constant_extract_satisfied()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ActionPhvConstraints::parser_constant_extract_satisfied </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p4_1_1ordered__set.html">PHV::Allocation::MutuallyLiveSlices</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>container_state</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if parser constant extract constraints are satisfied for the candidate packing. This only applies to Tofino, where fields written to using constant extractors in the same parser state must be allocated within 4 consecutive bits of the same 16-bit container, and within consecutive 3 bits of the same 32 bit container. Note that this method will always return true for Tofino2, because no fields are marked as parser constant extract candidates by the ParserConstantExtract pass. </dd></dl>

</div>
</div>
<a id="a564f5955ef5f5833cc478447bb005366" name="a564f5955ef5f5833cc478447bb005366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a564f5955ef5f5833cc478447bb005366">&#9670;&#160;</a></span>slices_destinations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> * &gt; ActionPhvConstraints::slices_destinations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_p_h_v_1_1_field_slice.html">PHV::FieldSlice</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>slices</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the set of fields which are destinations of <code>slices</code> of <code>f</code> across all actions. NOTE: destination are returned iff it completely read from some slice in <code>slices</code>. e.g., assume we have f&lt;32&gt;[0:28] = a&lt;32&gt;[0:28]; slices_destinations(a, {a[0:31]}) will return {} instead of {f}, because the operation does not completely write any source slice. </dd></dl>

</div>
</div>
<a id="a70022837027b6f070d80bb41963b1c5d" name="a70022837027b6f070d80bb41963b1c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70022837027b6f070d80bb41963b1c5d">&#9670;&#160;</a></span>slices_sources()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> * &gt; ActionPhvConstraints::slices_sources </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_p_h_v_1_1_field_slice.html">PHV::FieldSlice</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>slices</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the set of fields which are sources of <code>slices</code> of <code>f</code> across all actions. NOTE: sources are returned iff it completely writes some slice in <code>slices</code>. e.g., assume we have f&lt;32&gt;[0:28] = a&lt;28&gt;; slices_sources(f, {f[0:31]}) will return {} instead of {a}, because the operation does not completely write any source slice. </dd></dl>

</div>
</div>
<a id="a7144e43db7ba7c5f39b85eba2abdc415" name="a7144e43db7ba7c5f39b85eba2abdc415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7144e43db7ba7c5f39b85eba2abdc415">&#9670;&#160;</a></span>sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ActionPhvConstraints::sort </td>
          <td>(</td>
          <td class="paramtype">std::list&lt; const PHV::SuperCluster::SliceList * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>slice_list</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Approximates a topographical sorting of field lists such that all source-only slice lists are considered for allocation before destination-only slice lists. Sorts a given list of slice list such that the slice lists used the least times as sources are first allocated containers. If the number of times fields in a slice list is used as sources is the same as another slice list, the slice list which is written to in more actions ranks earlier in the sorting. </p>

</div>
</div>
<a id="ac288efc74364f32f062edd803adee649" name="ac288efc74364f32f062edd803adee649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac288efc74364f32f062edd803adee649">&#9670;&#160;</a></span>sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ActionPhvConstraints::sort </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_p_h_v_1_1_field_slice.html">PHV::FieldSlice</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>slice_list</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Approximates a topographical sorting of FieldSlices such that all FieldSlices used only as sources are considered for allocation before destination-only FieldSlices </p>

</div>
</div>
<a id="a4a897c76f54f2d12b94d835c57a3ab1b" name="a4a897c76f54f2d12b94d835c57a3ab1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a897c76f54f2d12b94d835c57a3ab1b">&#9670;&#160;</a></span>written_by_ad_constant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ActionPhvConstraints::written_by_ad_constant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IR::MAU::Action *</td>          <td class="paramname"><span class="paramname"><em>act</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if field <code>f</code> is written in action <code>act</code> by action data/constant source. </dd></dl>

</div>
</div>
<a id="a9907fae847d8f225e1e1c38d538b080e" name="a9907fae847d8f225e1e1c38d538b080e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9907fae847d8f225e1e1c38d538b080e">&#9670;&#160;</a></span>written_in() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ActionPhvConstraints::written_in </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slice</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IR::MAU::Action *</td>          <td class="paramname"><span class="paramname"><em>act</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if field slice <code>slice</code> is written in action <code>act</code>. </dd></dl>

</div>
</div>
<a id="acdbdfad9eb7462eea9ec83aa1d342f48" name="acdbdfad9eb7462eea9ec83aa1d342f48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdbdfad9eb7462eea9ec83aa1d342f48">&#9670;&#160;</a></span>written_in() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ActionPhvConstraints::written_in </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IR::MAU::Action *</td>          <td class="paramname"><span class="paramname"><em>act</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if field <code>f</code> is written in action <code>act</code>. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.12.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_action_phv_constraints.html">ActionPhvConstraints</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
