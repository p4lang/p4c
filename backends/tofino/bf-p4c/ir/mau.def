/**
 * Copyright (C) 2024 Intel Corporation
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed
 * under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations under the License.
 * 
 * 
 * SPDX-License-Identifier: Apache-2.0
 */


/* -*-C++-*- */

#emit
struct TableResourceAlloc;
#include <optional>
#include "lib/bitvec.h"
#include "lib/ltbitmatrix.h"
#include "bf-p4c/ir/ir_enums.h"
#include "bf-p4c/ir/unique_id.h"
#include "bf-p4c/mau/hash_function.h"
#include "bf-p4c/lib/error_macros.h"
#end
#emit_impl
#include "bf-p4c/mau/resource.h"
#end

namespace MAU {

/** A Tofino logical table (group) -- a gateway and/or match table
 * along with whatever attached tables are run.  The basic scheduling
 * unit for tofino; there are 16 such 'logical' tables available in
 * each stage, which will run simultaneously and have their results
 * predicated by the predicate mask calculated from the next tables */
class Table : BFN::Unit, IAnnotated  {
    // FIXME -- a number of fields here are ignored by operator==, but most should not be.
    // FIXME -- we SHOULD just get rid of the cusrom operator== and use the autogenerated one
    // FIXME -- (which compares everything) but that causes random crashes due to bugs elsewhere
    cstring                                     name;
    gress_t                                     gress;
    cstring                                     gateway_name;
    cstring                                     gateway_cond;
    // Post table placement this stores the tag with which the gateway was
    // merged with the match table
    cstring                                     gateway_result_tag;
    /// The stage to which this table is assigned, if any.
    std::optional<unsigned>                     stage_ = std::nullopt;
    /// The logical ID within the stage to which this table is assigned.
    std::optional<unsigned>                     logical_id = std::nullopt;
    // The split within the stage for an atcam/dleft table
    int                                         stage_split = -1;
    int                                         logical_split = -1;
    int                                         logical_tables_in_stage = -1;
    int                                         atcam_entries_in_stage = -1;
    /**
     * each gateway_row is an expression for a single row of the gateway,
     * with the string being a tag to run in 'next' for next table, or null
     * if the match_table should run.  The last row (only) may have a NULL
     * expression for 'always' -- corresponding to the gateway miss action
     * (taken if no gateway rows match).  If this last row NULL expression
     * is not present, the default action is to run the table.
     */
    safe_vector<std::pair<Expression, cstring>> gateway_rows;

    /**
     * If the gateway inhibits the match_table (gateway_row.second != NULL), then the gateway
     * can also run an action directly, via the payload.  All rows must be the same action on
     * tofino1, but tofino2 allows different actions for different rows.
     *
     * The gateway payload key value pair is:
     *     the key corresponds to gateway_row.second which inhibits the table.  These also
     *     appear as the keys in the next map.
     *     the value is a pair of two items.  The first item is the key of the corresponding
     *     action in the actions map.  The vector of Constants is the value of parameters
     *     of the action
     */
    std::map<cstring, std::pair<cstring, std::vector<Constant>>> gateway_payload;

    // For now we are keeping the keys even for gateway inhibited tables
    // (only for populating context.json, due to current driver needs)
    inline Vector<TableKey>                     gateway_constant_entries_key;

    // match_table never visited, keys are in match_key, default action also in action
    NullOK IR::P4Table                          match_table;
    inline Vector<BackendAttached>              attached;
    // ordered_map is used because assembly assumes the order of actions
    // matches to the next table name in the hit list.
    inline ordered_map<cstring, Action>         actions;
    inline ordered_map<cstring, TableSeq>       next;
    inline Vector<TableKey>                     match_key;
    // Symmetric key information here, as the selector key is on the match table
    LTBitMatrix                                 sel_symmetric_keys = {};
    int                                         random_seed = -1;
    bool                                        dynamic_key_masks = false;
    NullOK EntriesList                          entries_list;
    int                                         first_entry_list_priority = 0;
    // Indicates whether this is a "starter pistol" table generated during table placement.
    bool                                        created_during_tp = false;
    // Flag to indicate the table is compiler generated. This flag is passed on
    // the assembly and context json as 'p4_hidden' to disable PD API generation
    // on this table
    bool                                        is_compiler_generated = false;
    // true, if we insert initialization to/from dark containers in this table. In that case, we
    // cannot split these tables.
    bool                                        has_dark_init = false;
    AlwaysRun                                   always_run = AlwaysRun::NONE;
    bool                                        suppress_context_json = false;
    bool                                        run_before_exit = false;
    bool                                        is_detached_attached_tbl = false;

    class IndirectAddress {
        bool shifter_enabled = false;
        int address_bits = 0;
        bool per_flow_enable = false;
        int meter_type_bits = 0;
#emit
        IndirectAddress &operator+=(const IndirectAddress &a);
#end
        int total_bits() const {
           int rv = address_bits + meter_type_bits;
           rv = per_flow_enable ? rv + 1 : rv;
           return rv;
        }
    }

    class Layout {
        /* POD type */
        int   entries                      = 0;
        bool  pre_classifier               = false;
        bool  gateway                      = false;
        bool  exact                        = false;
        bool  ternary                      = false;
        bool  hash_action                  = false;
        bool  gateway_match                = false;  // match table moved into gateway test
        bool  atcam                        = false;
        bool  alpm                         = false;
        bool  has_range                    = false;
        bool  proxy_hash                   = false;
        bool  requires_versioning          = true;
        bool  is_lamb                      = false;
        bool  is_direct                    = false;
        bool  is_local_tind                = false;
        int   entries_per_set              = 0;
        int   sets_per_word                = 0;
        int   ixbar_bytes                  = 0;
        int   match_bytes                  = 0;
        int   ixbar_width_bits             = 0;
        int   match_width_bits             = 0;
        int   ghost_bytes                  = 0;
        int   action_data_bytes            = 0;
        int   action_data_bytes_in_table   = 0;
        int   pre_classifer_number_entries = 0;
        int   overhead_bits                = 0;
        int   immediate_bits               = 0;
        int   valid_bits                   = 0;
        int   partition_bits               = 0;
        int   partition_count              = 0;
        int   subtrees_per_partition       = 0;
        int   atcam_subset_width           = 0;
        int   shift_granularity            = 0;
        int   total_actions                = 0;
        int   sel_len_bits                 = 0;
        int   proxy_hash_width             = 0;
        HashFunction proxy_hash_algorithm  = {};
        inline IndirectAddress meter_addr  = {};
        inline IndirectAddress stats_addr  = {};
        inline IndirectAddress action_addr = {};
        std::map<cstring, int> excluded_field_msb_bits = {};

        bool is_lamb_direct() const { return is_lamb && is_direct; }
        int get_subword_bits() const {
            if (is_lamb) return ceil_log2(sets_per_word);
            return 0;
        }

        int get_sram_depth() const {
            if (is_lamb) return Memories::LAMB_DEPTH;
            return Memories::SRAM_DEPTH;
        }

        /**
         * @brief Equivalent to get_sram_depth() for non-ATCAM tables.
         *
         * @return min(partition_count, get_sram_depth()) for ATCAM tables
         */
        int words_per_sram() const {
            return std::min(atcam ? partition_count : INT_MAX, get_sram_depth());
        }

        int get_ram_line_select_bits() const {
            if (is_lamb) return IXBar::LAMB_LINE_SELECT_BITS;
            return IXBar::RAM_LINE_SELECT_BITS;
        }

        int get_ram_ghost_bits() const {
            return get_ram_line_select_bits();
        }

        bool direct_ad_required() const {
            if (action_addr.address_bits > 0)
                return false;
            if (action_data_bytes == 0)
                return false;
            return action_data_bytes_in_table > 0;
        }
        bool ternary_indirect_required() const { return ternary && overhead_bits > 0; }
        bool no_match_data() const {
            return ixbar_width_bits == 0;
        }
        bool no_match_rams() const {
            return no_match_data() || hash_action;
        }
        /** no match tables that need hash_dist need to go through the hit path; all others
         *  can use the miss path
         */
        bool no_match_hit_path() const {
            return no_match_rams() && hash_action;
        }
        /** Any keyless table that has parameters that can be adjusted during runtime, such
         *  as action or action data must go through the miss pathway, as those are the registers
         *  configured by the driver when the control plane requests a change
         */
        bool no_match_miss_path() const {
            return no_match_rams() && !no_match_hit_path() && !gateway_match;
        }
#emit
        friend std::ostream &operator<<(std::ostream &out, Layout&layout) {
            Log::TempIndent indent;
            out << "layout: " << layout.entries << indent;
            if (layout.pre_classifier) out << 'c';
            if (layout.gateway) out << 'g';
            if (layout.exact) out << 'e';
            if (layout.ternary) out << 't';
            if (layout.hash_action) out << 'h';
            if (layout.gateway_match) out << 'G';
            if (layout.atcam) out << 'T';
            if (layout.alpm) out << 'L';
            if (layout.has_range) out << 'r';
            if (layout.proxy_hash) out << 'P';
            if (layout.requires_versioning) out << 'V';
            out << " ixbar:" << layout.ixbar_bytes << "B/" << layout.ixbar_width_bits << "b";
            out << " match:" << layout.match_bytes << "B/" << layout.match_width_bits << "b";
            if (layout.ghost_bytes) out << " gh:" << layout.ghost_bytes;
            if (layout.action_data_bytes || layout.action_data_bytes_in_table) {
                out << " adb:" << layout.action_data_bytes;
                if (layout.action_data_bytes_in_table)
                    out << "/" << layout.action_data_bytes_in_table; }
            if (layout.overhead_bits) out << " ov:" << layout.overhead_bits;
            if (layout.immediate_bits) out << " imm:" << layout.immediate_bits;
            if (layout.partition_bits) out << " part:" << layout.partition_bits;
            return out;
        }
        friend std::ostream &operator<<(std::ostream &out, const Layout&layout) {
            Log::TempIndent indent;
            out << "layout: " << layout.entries << indent;
            if (layout.pre_classifier) out << 'c';
            if (layout.gateway) out << 'g';
            if (layout.exact) out << 'e';
            if (layout.ternary) out << 't';
            if (layout.hash_action) out << 'h';
            if (layout.gateway_match) out << 'G';
            if (layout.atcam) out << 'T';
            if (layout.alpm) out << 'L';
            if (layout.has_range) out << 'r';
            if (layout.proxy_hash) out << 'P';
            if (layout.requires_versioning) out << 'V';
            out << " ixbar:" << layout.ixbar_bytes << "B/" << layout.ixbar_width_bits << "b";
            out << " match:" << layout.match_bytes << "B/" << layout.match_width_bits << "b";
            if (layout.ghost_bytes) out << " gh:" << layout.ghost_bytes;
            if (layout.action_data_bytes || layout.action_data_bytes_in_table) {
                out << " adb:" << layout.action_data_bytes;
                if (layout.action_data_bytes_in_table)
                    out << "/" << layout.action_data_bytes_in_table; }
            if (layout.overhead_bits) out << " ov:" << layout.overhead_bits;
            if (layout.immediate_bits) out << " imm:" << layout.immediate_bits;
            if (layout.partition_bits) out << " part:" << layout.partition_bits;
            return out;
        }
        Layout &operator+=(const Layout &a);
#end
    }
    Layout layout;
    class Way {
        /* POD type */
        int             match_groups = 0;
        int             entries = 0;
        int             width = 0;
    }
    safe_vector<Way>    ways;
    const TableResourceAlloc            *resources = nullptr;
    bool is_placed() const { return resources != nullptr; }
    bool hit_miss_p4() const;
    bool action_chain() const;
    bool has_default_path() const;
    int action_next_paths() const;
    int get_placement_priority_int() const;
    std::set<cstring> get_placement_priority_string() const;
    int get_provided_stage(int geq_stage = -1, int *req_entries = 0, int *flags = 0) const;
    int hit_actions() const;
    bool has_exit_action() const;
    Action get_default_action() const;
    std::vector<Action> get_exit_actions() const;
    bool has_non_exit_action() const;
    bool is_exit_table() const; // will the table always exit?
    bool has_exit_recursive() const;  // is there an exit here or any control dependent table?
    int get_random_seed() const;
    int get_pragma_max_actions() const;
    unsigned get_match_key_width() const;
#emit
    // Two pragmas can be used to control the usage of the immediate usage. "immediate" pragma
    // can be set as 0 to force the usage of action data table. "force_immediate" pragma can be
    // set to 1 to pack action data in match overhead. The combination of both result in 3 possible
    // configuration as listed by this enum.
    enum ImmediateControl_t { COMPILER, FORCE_IMMEDIATE, FORCE_NON_IMMEDIATE };
#end
    ImmediateControl_t get_immediate_ctrl() const;
    bool has_match_data() const;
    bool for_dleft() const;
    bool is_always_run_action() const { return always_run == IR::MAU::AlwaysRun::ACTION; }
    Annotations getAnnotations() const override;
    Annotation getAnnotation(cstring name) const override;
    Expression getExprAnnotation(cstring name) const;
    bool getAnnotation(cstring name, int &val) const;
    bool getAnnotation(cstring name, bool &val) const;
    bool getAnnotation(cstring name, ID &val) const;
    bool getAnnotation(cstring name, std::vector<ID> &val) const;
    cstring externalName() const;  // name to use in error messages
    void remove_gateway();

    UniqueId pp_unique_id(AttachedMemory at = nullptr,
       bool is_gw = false, int stage_table = -1, int logical_table = -1,
       UniqueAttachedId::pre_placed_type_t ppt = UniqueAttachedId::NO_PP) const;

    UniqueId unique_id(AttachedMemory at = nullptr, bool is_gw = false) const;
    UniqueId get_uid(AttachedMemory at = nullptr, bool is_gw = false) const;
    BackendAttached get_attached(UniqueId id) const;
    BackendAttached get_attached(AttachedMemory am) const;
#emit
    template<class T> const T *get_attached() const;
#end


#noconstructor
    Table(cstring n, gress_t gr) : name(n), gress(gr) {}
    Table(cstring n, gress_t gr, IR::P4Table t)
    : BFN::Unit(t->srcInfo), name(n), gress(gr), match_table(t) {}
#emit
    Table(cstring n, gress_t gr, const Expression *gw)
    : BFN::Unit(gw->srcInfo), name(n), gress(gr),
      gateway_rows{ std::make_pair(gw, "$true"_cs), std::make_pair(nullptr, "$false"_cs) } {}
    // ir-generator can't parse {}-initializer (thinks it is the ctor body
#end

    /** Returns the global logical ID for this table. Each stage has 16 slots
     * for tables.  Global logical IDs are numbered from 0 (Stage 0, Slot 0) to
     * N * 16 + 15 (Stage N, Slot 15).
     */
    std::optional<int> global_id() const {
        if (stage_ && logical_id) return *stage_ * StageUse::MAX_LOGICAL_IDS + *logical_id;
        return std::nullopt;
    }
    void set_global_id(int id) {
        stage_ = id / StageUse::MAX_LOGICAL_IDS;
        logical_id = id % StageUse::MAX_LOGICAL_IDS;
    }
    int logical_order() const { return *global_id() + gress * 4096; }
    Table *clone_rename(cstring ext) const {
        Table *rv = clone();
        rv->name += ext;
        return rv; }
#nooperator==
#emit
    bool operator==(const Table &a) const override;
    bool operator==(const IR::BFN::Unit &a) const override { return a == *this; }
    bool operator==(const IR::Node &a) const override { return a == *this; }
#end
    cstring get_table_type_string() const;
    bool uses_gateway() const { return !gateway_rows.empty(); }
    bool uses_gateway_payload() const {
        for (auto row : gateway_rows) {
            if (row.second) return true;
        }

        return false;
    }
    bool conditional_gateway_only() const;
    bool is_a_gateway_table_only() const;
    cstring build_gateway_name() const {
        auto gName = gateway_name.isNullOrEmpty() ? name : gateway_name;
        // Add '-gateway' suffix to table name if gateway_name is not unique
        if (!gName.startsWith("cond")) gName = gName + "-gateway";
        return gName; }
    bool uses_idletime() const {
        for (auto back_at : attached)
            if (back_at->attached->is<IR::MAU::IdleTime>()) return true;
        return false; }
    int stage() const override { return stage_ ? *stage_ : -1; }
    gress_t thread() const override { return gress; }
    toString { return "table "_cs + externalName(); }
    validate {
        std::set<cstring> gw_next;
        if (always_run == AlwaysRun::ACTION) {
            // This table represents an always-run action, so a few things should be empty here.
            BUG_CHECK(gateway_rows.empty(),
                "always-run action %s is ill-formed: cannot have gateway rows", name);
            BUG_CHECK(attached.empty(),
                "always-run action %s is ill-formed: cannot have attached tables", name);
            BUG_CHECK(match_key.empty(),
                "always-run action %s is ill-formed: cannot have match keys", name);
            BUG_CHECK(next.empty(),
                "always-run action %s is ill-formed: cannot have next tables", name);
            BUG_CHECK(gateway_payload.empty(),
                "always-run action %s is ill-formed: cannot have gateway payloads", name);

            // Also ensure we just have a single action in the table.
            BUG_CHECK(actions.size() == 1,
                "always-run action %s is ill-formed: must have exactly one action", name);
        }
        for (auto &gw : gateway_rows) {
            if (&gw != &gateway_rows.back())
                CHECK_NULL(gw.first);
            else if (gw.first)
                gw_next.emplace(cstring());
            gw_next.emplace(gw.second); }
        if (gateway_rows.empty())
            gw_next.emplace(cstring());
        if (created_during_tp && !conditional_gateway_only())
            BUG("starter-pistol table %s cannot have a match table", name);
        if (created_during_tp && uses_gateway_payload())
            BUG("starter-pistol table %s cannot have a gateway payload", name);
        if (!created_during_tp && conditional_gateway_only() && gw_next.count(cstring()))
            BUG("gateway with no match table wants to run match table");
        if (!is_a_gateway_table_only() && uses_gateway() && !gw_next.count(cstring()))
            BUG("gateway always overrides match table");
        std::set<cstring> payload_act;
        for (auto &payload : gateway_payload) {
            BUG_CHECK(gw_next.count(payload.first), "payload tag %s not in gateway", payload.first);
            BUG_CHECK(actions.count(payload.second.first), "payload action %s not in table",
                      payload.second.first);
            payload_act.insert(payload.second.first); }
        if (!gw_next.count(cstring()) && 0) {
            // FIXME -- we currently sometimes get dead actions in tables.  They should
            // eventually get deadcode eliminated, but might be in the IR until then
            for (auto &act : actions)
                BUG_CHECK(payload_act.count(act.first), "Unused action in gateway table"); }
        for (auto &nxt : next) {
            if (nxt.first == "$default") {
            } else if (nxt.first == "$hit" || nxt.first == "$miss"
                       || nxt.first == "$try_next_stage") {
                if (!match_table)
                    BUG("%s next on table with no match_table", nxt.first);
            } else if (!gw_next.count(nxt.first) && !actions.count(nxt.first)) {
                BUG("%s next on table with no such action or gw result", nxt.first);
            }
            if (!conditional_gateway_only() && !layout.gateway_match) {
                if (next.count("$hit"_cs) || next.count("$miss"_cs)) {
                    BUG_CHECK(!action_chain() && !has_default_path(),
                              "Somehow have a hit/miss table combined with an action chain");
                }
            }
        }
        for (auto &act : actions) {
            BUG_CHECK(act.first == act.second->name.originalName,
                      "name mismatch '%s' != '%s' for action %s",
                      act.first, act.second->name.originalName, act.second->name.name);
            if (act.second->exitAction)
                BUG_CHECK(next.count(act.first) == 0,
                          "action %s is an early exit and has next", act.first); }
    }

    // Delegates to the static version of the method. We don't implement this here because
    // C++ requires the definitions and instantiations of function templates to be in the same
    // compilation unit.
    visit_children;

#emit
    // We use a template to obtain polymorphism on the constness of `this`.
    template<class THIS>
    static void visit_children(THIS*, Visitor& v);

    struct payload_info_t; // data to pass between the below helper methods
    /// Helper for visit_children. Visits the match table for when it is not
    /// gateway-inhibited.
    // We use a template to obtain polymorphism on the constness of `this`.
    template<class THIS>
    static void visit_match_table(THIS* self, Visitor& v, payload_info_t &);

    /// Helper for visit_children. Visits the gateway payload, for when the
    /// match table is gateway-inhibited.
    // We use a template to obtain polymorphism on the constness of `this`.
    template<class THIS>
    static void visit_gateway_inhibited(THIS* self, Visitor& v, payload_info_t &);
#end
#apply
}

// attachement of an AttachedMemory table to a match table -- different match tables
// may attach the same AttachedMemory table with different BackendAttached, as long as
// the match tables are mutually exclusive
class BackendAttached {
    NullOK HashDist hash_dist = nullptr;
    int entries = -1;
    StatefulUse use = StatefulUse::NO_USE;
    AddrLocation addr_location = AddrLocation::NOT_SET;
    PfeLocation pfe_location = PfeLocation::NOT_SET;
    TypeLocation type_location = TypeLocation::NOT_SET;
    AttachedMemory attached;
    bool chain_vpn = false;
}


abstract AttachedMemory : Attached {
    bool direct = false;
    int size = 0;
    virtual bool indexed() const override { return !direct; }
    virtual UniqueAttachedId::type_t get_id_type() const = 0;
    UniqueAttachedId unique_id() const { return UniqueAttachedId(name, direct, get_id_type()); }
    virtual cstring externType() const = 0;
    cstring toString() const override { return externType() + " " + name.toString(); }
    virtual bool usesMeterBus() const { return false; }
    virtual bool usesStatsBus() const { return false; }
    virtual int get_min_size() const { return Memories::SRAM_DEPTH; }
}

/** Any attached table that has a keeps stateful information about flows.
 */
abstract Synth2Port : AttachedMemory {
    ID table = {};
    bool saturating = false;
    int width = 0;
    int bytecount_adjust = 0;
    DataAggregation type = DataAggregation::NONE;
    void settype(cstring t) {
        if (strcasecmp(t.c_str(), "packets") == 0) type = DataAggregation::PACKETS;
        else if (strcasecmp(t.c_str(), "bytes") == 0) type = DataAggregation::BYTES;
        else if (strcasecmp(t.c_str(), "packets_and_bytes") == 0 ||
                 strcasecmp(t.c_str(), "packetsandbytes") == 0) type = DataAggregation::BOTH;
        else error("%s: Unknown type %s", srcInfo, t); }  // NOLINT
    int get_bytecount_adjust() const {
        if (type == DataAggregation::BYTES || type == DataAggregation::BOTH)
            return bytecount_adjust;
        return 0;
    }
    int get_min_size() const override {
        return ((TableFormat::SINGLE_RAM_BITS / width) * Memories::SRAM_DEPTH); 
    }
}

class Counter : Synth2Port {
    int min_width = -1;
    int max_width = -1; // Perhaps to play with a range of widths
    int threshold = -1;
    int interval = -1;
    bool true_egress_accounting = false;

    const char *kind() const override { return "stats"; }
#nodbprint
    const Type *getType() const override { return Type_Counter::get(); }
    UniqueAttachedId::type_t get_id_type() const override { return UniqueAttachedId::COUNTER; }
    cstring externType() const override { return direct ? "DirectCounter"_cs : "Counter"_cs; }
    bool usesStatsBus() const override { return true; }
}

abstract MeterBus2Port : Synth2Port { // synth2port addressed via meter bus
    bool usesMeterBus() const override { return true; }
}

class Meter : MeterBus2Port {
    int red_drop_value = -1;
    int red_nodrop_value = -1;
    int green_value = -1;
    int yellow_value = -1;
    int red_value = -1;
    int profile = -1;
    int sweep_interval = -1;
    bool true_egress_accounting = false;

    NullOK Expression  result = nullptr;     // Field which meter writes, eventually be deprecated
                                             // as it should be contained in AttachedOutput
    NullOK HashDist    pre_color = nullptr;  // Field to pre-color the meter.  Eventually
                                             // brought through hash distribution
    NullOK Expression  input = nullptr;      // LPF and WRED have 32 bit inputs
    ID                 implementation = {};  // Normal, LPF, WRED
    unsigned           possible_mapram_address = 0;

    const char *kind() const override { return "meter"; }
    const Type *getType() const override { return Type_Meter::get(); }
    UniqueAttachedId::type_t get_id_type() const override { return UniqueAttachedId::METER; }
    bool alu_output() const { return implementation.name == "lpf"
                               || implementation.name == "wred"; }
    bool color_output() const { return implementation.name == "normal"
                                 || implementation.name.isNull(); }
    bool mapram_possible(IR::MAU::ColorMapramAddress cma) const {
        return possible_mapram_address & (1U << static_cast<int>(cma));
    }
    cstring externType() const override { return direct ? "DirectMeter"_cs : "Meter"_cs; }

#nodbprint
}

/** Configuration for a stateful table -- a register object (for the memory) plus
 * the associated stateful alu instructions and config */
class StatefulAlu : MeterBus2Port {
    // The single register or action_selector extern used in this stateful alu
    optional NullOK Declaration_Instance                reg = nullptr;
    optional NullOK Selector                            selector = nullptr;
    bool                                                dual = false;  // dual mode
        // if dual is true, the ALU width is half the Register width (field)
        // if dual is false, the ALU width is equal to the Register width
        // this means that ALU width can be calculated as `width >> dual`
    // The possible stateful_alu externs executed in this table
    inline NameMap<SaluAction, ordered_map>             instruction = {};
    // The stateful_alu externs executed for each table-action pair string in
    // the match table We make table-action pairs to distinguish action calls
    // from same vs different tables
    ordered_map<cstring, cstring>                       action_map = {};
    // The register file expressed as a map indexing rows by the name
    // of corresponding register param
    ordered_map<cstring, SaluRegfileRow>                regfile = {};
    // overflow and underflow actions, if any
    cstring                                             overflow = {};
    cstring                                             underflow = {};
    // chain to subsequent stage  FIXME -- do we need more info here -- the field used to chain
    // the address?  Or perhaps put this in Synth2Port if other such tables can also chain
    bool                                                chain_vpn = false;
    int                                                 chain_total_size = size;
    big_int                                             init_reg_lo = 0;
    big_int                                             init_reg_hi = 0;
    cstring                                             reduction_or_group = {};
    bool        learn_action = false;  // if any action is a LearnAction
    bool        synthetic_for_selector = false;  // created for the driver to set selector
    int         pred_shift = -1;
    int         pred_comb_shift = -1;
    // params for fast clear.
    bitvec      clear_value = {};
    uint32_t    busy_value = 0;

    class MathUnit {
        bool            valid = false;
        bool            exp_invert = false;
        int             exp_shift = 0;
        int             scale = 0;
        int[16]         table = { 0 };
        dbprint { out << valid; }
#emit
        friend std::ostream &operator<<(std::ostream &out, const MathUnit &mu) {
            out << mu.valid;
            return out;
        }
#end
    }
    MathUnit            math = MathUnit();

    const char *kind() const override { return "stateful"; }
    const Type *getType() const override { return Type_Register::get(); }
    UniqueAttachedId::type_t get_id_type() const override { return UniqueAttachedId::STATEFUL_ALU; }
    bool alu_output() const;   // has output to VLIW alus via action data bus
    SaluAction calledAction(Table tbl, Action act) const;
    bool for_dleft() const {
        for (auto *act : Values(instruction))
            if (act->learn_action) return true;
        return false; }

    int source_width() const;
    int alu_width() const { return std::min(32, source_width()); }
    cstring externType() const override { return direct ? "DirectRegister"_cs : "Register"_cs; }
}

class Selector : AttachedMemory {
    ID type = {};
    SelectorMode mode = SelectorMode::FAIR;
    HashFunction algorithm = {};
    const char *kind() const override { return "selector"; }
    UniqueAttachedId::type_t get_id_type() const override { return UniqueAttachedId::SELECTOR; }
    int num_pools = 0;
    int max_pool_size = 0;
    bool sps_scramble = true;  // Indicates if non-linear hash (SPS scramble) should be used.
    NullOK HashDist hash_mod = nullptr;
    cstring externType() const override { return "ActionSelector"_cs; }
    bool usesMeterBus() const override { return true; }
#nodbprint
}


/** Tofino-specific attached table type **/

/** Ternary indirect table used to hold overhead (adressing pointers and next table info)
 * of ternary match tables */
class TernaryIndirect : AttachedMemory {
#noconstructor
#nodbprint
    TernaryIndirect(cstring tbl_name) { name = IR::ID(tbl_name + "$tind"_cs); direct = true; }
    const char *kind() const override { return "indirect"; }
    UniqueAttachedId::type_t get_id_type() const override {
        return UniqueAttachedId::TERNARY_INDIRECT;
    }
    cstring externType() const override { return "ternary indirect"_cs; }
}

/** Action data table used to hold action parameters */
class ActionData : AttachedMemory {
#nodbprint
    const char *kind() const override { return "action"; }
    bool indexed() const override { return !direct; }
    UniqueAttachedId::type_t get_id_type() const override {
        return UniqueAttachedId::ACTION_DATA;
    }
    cstring externType() const override { return "ActionProfile"_cs; }
}

/** Idletime table **/
class IdleTime : AttachedMemory {
    int precision = 3;
    int interval = 7;
#emit
    cstring two_way_notification = "enable"_cs;
#end
    bool per_flow_idletime = true;
#noconstructor
#nodbprint
    IdleTime(cstring tbl_name) { name = IR::ID(tbl_name + "$idletime"_cs); direct = true; }
    const char *kind() const override { return "idletime"; }
    UniqueAttachedId::type_t get_id_type() const override {
        return UniqueAttachedId::IDLETIME;
    }
    cstring externType() const override { return "idletime"_cs; }
}

// a sequence of tables -- may be reordered if deps allow.
// deps(i,j) is true iff tables[i] is dependent on tables[j]
// (so must have j < i) */
class TableSeq {
    static int                  uid_ctr;
    inline Vector<Table>        tables;
    LTBitMatrix                 deps;
    int                         seq_uid;  // try to track TableSeq across transforms
#noconstructor
    TableSeq() { seq_uid = ++uid_ctr; }
    TableSeq(Table a) {
        seq_uid = ++uid_ctr;
        if (a) tables.push_back(a); }
    TableSeq(Table a, Table b) {
        seq_uid = ++uid_ctr;
        if (a) tables.push_back(a);
        if (b) tables.push_back(b); }
    TableSeq(TableSeq a, Table b) {
        seq_uid = ++uid_ctr;
        if (a) tables.insert(tables.end(), a->tables.begin(), a->tables.end());
        if (b) tables.push_back(b); }
    bool empty() const { return tables.empty(); }
    Table front() const { return tables.empty() ? nullptr : tables.front(); }
    Table back() const { return tables.empty() ? nullptr : tables.back(); }
    size_t size() const { return tables.size(); }
    validate {
        bool first = true;
        gress_t gress;
        for (auto t : tables) {
            if (first) { gress = t->gress; first = false; }
            else if (t->gress != gress) BUG("TableSeq consists of tables of different gress?"); }
    }

    // ignore seq_uid field when comparing
    // FIXME -- should add irgenerator field modifier to get it ignored in autogen code
    operator== { return tables == a.tables && deps == a.deps; }
    equiv { return tables.equiv(a.tables) && deps == a.deps; }
#apply
}

class Primitive : IR::Primitive {
    bool in_hash = false;
#emit
    using IR::Primitive::Primitive;
#end
#nodbprint
#apply
}

/// A primitive function, optionally annotated with its front end type.
class TypedPrimitive : Primitive {
#nodbprint
#noconstructor
    IR::Type method_type;

    std::map<unsigned, cstring> op_names;
    TypedPrimitive(cstring name)
    : Primitive(name), method_type(nullptr) { }
    TypedPrimitive(Util::SourceInfo srcInfo, const IR::Type* return_type, const IR::Type* m_type, cstring name)
    : Primitive(srcInfo, return_type, name), method_type(m_type) { }

    visit_children { Primitive::visit_children(v); }
}

/// A single MAU instruction.  For the most part instructions look exactly like Primitives,
/// just with more constraints applied.  For example, an "add" instruction has the same
/// destination and two sources as an "add" primitive, with the additional constraints that
/// the dest and first source are PHV while second source can be PHV, action bus, or constant.
/// We convert the primitive into an instruction when we check those constraints
class Instruction : Primitive {
#nodbprint
#emit
    using Primitive::Primitive;
#end
    // This is a vector, filled after BackendCopyPropagation, indicating which operands
    // have been copy propagated from an earlier instruction.  Copy propagated operands
    // don't have to be checked in order to guarantee parallelism
    bitvec copy_propagated = {};
    Instruction(const Primitive &p) : Primitive(p) {}
    Instruction(cstring op, const std::vector<Expression> &args) : Primitive(op) {
        for (auto a : args) operands.push_back(a); }
    Instruction(Util::SourceInfo si, cstring op, const std::vector<Expression> &args)
        : Primitive(si, op) { for (auto a : args) operands.push_back(a); }
    bool isOutput(int operand_index) const override { return operand_index == 0; }
    virtual Expression getOutput() const { return operands.empty() ? nullptr : operands.at(0); }
    validate { BUG_CHECK(name, "empty name in instruction"); }
}

// SALU Instructions are mostly like other MAU instructions, so we reuse them.  One
// difference is they might have predicates before the destination (or no destination at all)
class SaluInstruction : Instruction {
    int output_operand;  // which operand (index) is the dest of this instruction, generally:
                         // -1 : no destination (an output instruction with implicit dest, or nop
                         //  0 : first operand (no predicate)
                         //  1 : second operand (first operand is predicate)
#nodbprint
#noconstructor
    SaluInstruction(cstring op) : Instruction(op), output_operand(-1) {}
    SaluInstruction(cstring op, int out, const std::vector<Expression> &args)
    : Instruction(op, args), output_operand(out) {}
    SaluInstruction(cstring op, int out, Vector<Expression> args)
    : Instruction(op, args), output_operand(out) {}
    SaluInstruction(Util::SourceInfo si, cstring op, int out, const std::vector<Expression> &args)
    : Instruction(si, op, args), output_operand(out) {}
    SaluInstruction(Util::SourceInfo si, cstring op, int out, Vector<Expression> args)
    : Instruction(si, op, args), output_operand(out) {}
    SaluInstruction(cstring op, int out, Expression a1)
    : Instruction(op, a1), output_operand(out) {}
    SaluInstruction(cstring op, int out, Expression a1, Expression a2)
    : Instruction(op, a1, a2), output_operand(out) {}
    SaluInstruction(cstring op, int out, Expression a1, Expression a2, Expression a3)
    : Instruction(op, a1, a2, a3), output_operand(out) {}

    bool isOutput(int operand_index) const override { return operand_index == output_operand; }
    Expression getOutput() const override {
        return output_operand >= 0.? operands.at(output_operand) : nullptr; }
}

/// The IR::MAU::Action argument.
class ActionArg : Expression, IAnnotated {
    cstring     action_name;
    ID          name;
    optional Annotations        annotations = Annotations::empty;

    Annotations getAnnotations() const override { return annotations; }

    ActionArg { if (!srcInfo) srcInfo = name.srcInfo; }
    dbprint { out << action_name << ':' << name; }
    toString { return name.toString(); }
}

class ConditionalArg : ActionArg {
    ActionArg   orig_arg;
    dbprint { ActionArg::dbprint(out);  out << " = orig " << orig_arg; }
    bool one_on_true = true;
}

class StatefulCounter : Expression {
    AttachedMemory     attached;
    dbprint { out << "stful_cnt(" << type << ")"; }
}

class StatefulCall {
    // This will always be null after InstructionSelection is complete.  Everything
    // currently used for DefUse analysis is saved within the rest of the call
    optional NullOK Primitive prim = nullptr;
    AttachedMemory  attached_callee;
    optional NullOK Expression index = nullptr;
}

/// The base class for MAU::Action and MAU::SaluAction, both represent a wide VLIW action.
abstract VLIWInstruction {
}

/// The Action part of an action table -- basically a single VLIW instruction, which is a
/// set of instructions on different PHV containers that all run simultaneously
class Action : VLIWInstruction, IAnnotated {
    optional ID                 name;
    unsigned                    handle = 0;
    inline Vector<Primitive>    action = {};
    safe_vector<ActionArg>      args = {};
    optional Annotations        annotations = Annotations::empty;
    bool init_default = false;
    bool hit_allowed = true;  // action is allowed to be used with table hit
    bool default_allowed = false;  // action is allowed to be used with table miss
    bool is_constant_action = false;
    // Currently if a table used hash distribution or the RNG, then the table must go
    // go through the hit pathway.  However, due to different driver implementation, this
    // could be different than being table_only, and thus it is left out of the
    // visit_children of the table.
    bool hit_path_imp_only = false;
#emit
    cstring hit_disallowed_reason = "none"_cs;
    cstring disallowed_reason = "none"_cs;
#end
    inline Vector<Argument> default_params = {};
    bool exitAction = false;  // should exit pipeline after action (next == EOP)
    bool parallel = false;    // visit children parallelly?

    // Separate stateful primitives from actions, as they aren't instructions
    // as such.

    std::set<UniqueAttachedId> per_flow_enables = {};
    std::map<UniqueAttachedId, MeterType> meter_types = {};

    inline Vector<StatefulCall>    stateful_calls = {};
    const StatefulCall *stateful_call(cstring name) const {
        for (auto sc : stateful_calls)
            if (sc->attached_callee->name == name)
                return sc;
        return nullptr; }

    cstring externalName() const;
    bool hit_only() const { return !default_allowed; }
    bool miss_only() const { return !hit_allowed; }

    Annotations getAnnotations() const override { return annotations; }

    toString { return name.toString(); }
    validate {
        ERROR_CHECK(!(hit_only() && miss_only()), "Action %s cannot be both a hit only and a "
                    "miss only action.  Can only be at most one of those categories", name);
    }

    visit_children {
        VLIWInstruction::visit_children(v);
        if (parallel)
            action.parallel_visit_children(v);
        else
            action.visit_children(v);
        v.visit(annotations, "annotations");
        default_params.visit_children(v);
        stateful_calls.visit_children(v);
    }
#apply
}

/// A stateful ALU VLIW instruction -- multiple instructions that all run together
/// "simultaneously" in different ALUs (certain ALUs are actually later in the pipeline)
/// in the stateful ALU block (there are 2 comparison, 4 "normal" and 1 output alus)
class SaluAction : VLIWInstruction {
    IR::ID                              name;
    int                                 inst_code = -1;
    inline Vector<SaluInstruction>      action = {};
    safe_vector<ActionArg>              args = {};
    optional Annotations                annotations = Annotations::empty;
    NullOK Expression  output_dst = nullptr;  // implicit write of output to this lvalue
    bool                        learn_action = false;  // comes from LearnAction
        // FIXME -- the flag is needed to get ixbar alloc right when an SALU is shared
        // between a dleft and non-dleft table, as the dleft digest hash needs to be in the
        // SALU ixbar rather than the match table's ixbar.  But the info for the dleft
        // digest is in the match table's key, so we need to make sure the SALU ixbar is
        // setup from the dleft table and not the non-dleft table.  Maybe should be
        // called 'needs_dleft_digest' instead?

    // The original P4 function that underwent SaluAction translation. Not
    // visited. This is here so that a higher level representation of the
    // function is available to tools that consume the JSON representation of
    // the back-end IR.
    optional NullOK Function p4func = nullptr;

    // If we're returning an enum in the predicate, this records how it is encoded
    // Tofino stateful ALUs can't return (general) constants, but can return a 1-hot
    // encoding of the CMP ALU results (2^n bits for n alus).  So if we output enum
    // tags, we can infer which tag it is based on the predicate output.
    class ReturnEnumEncoding {
        Type_Enum                       return_type;
        std::map<cstring, unsigned>     tag_used = {};  // bits that might be set for each tag
        unsigned                        cmp_used = 0;   // bits that might be set for instr
        bool operator<=(const ReturnEnumEncoding &a) const;  // partial ordering
        const ReturnEnumEncoding *merge(const ReturnEnumEncoding *a) const;
    }
    const ReturnEnumEncoding *return_encoding = nullptr;
    unsigned return_predicate_words = 0;  // which output words have the 1-hot encoded predicate
    // output.  This is always shifted up by (at least) 4, so we need to insert a slice to
    // downshift it properly
    // FIXME -- should be std::bitset<4>, but irgen chokes on that currently.

    // Mapping of output parameters to output ALUs.
    std::map<int, int> output_param_to_alu = {};

    visit_children {
        VLIWInstruction::visit_children(v);
        action.visit_children(v);
        v.visit(annotations, "annotations");
        v.visit(output_dst, "output_dst");
    }

    toString {
        return cstring("action ") + name + " {\n" +
                 cstring::join(action.begin(), action.end(), ";\n") +
                 " }"; }
}


class FieldListExpression : ListExpression {
    ID id;
    bool rotateable = false;
    bool permutable = false;
    LTBitMatrix symmetric_keys = {};

    dbprint { out << id << " : ";  ListExpression::dbprint(out); }
}

/**
 * An expression that goes through the match ixbar and generates a hash function.  The eventual
 * goal is to extend this function to the entirety of any thing that goes through the hash
 * pathway in Tofino, i.e. Selectors, Inputs to Stateful ALU, and Table Keys, and obsolete
 * IXBarExpression and TableKey.  But that is future work.
 */
class HashGenExpression : Expression {
    Expression expr;
    ID id;
    bool dynamic = false;
    HashFunction algorithm;
    bool any_alg_allowed = false;
    NullOK NameList alg_names = nullptr;

    // for dyn_hash, not sure if it can be summarized within type
    int hash_output_width = 0;
    HashGenExpression(Util::SourceInfo si, const IR::Type *type, Expression e, HashFunction a)
        : Expression(si, type), expr(e), id("$hash" + std::to_string(nextId++)), algorithm(a) {}
    HashGenExpression(Expression e, HashFunction a = IR::MAU::HashFunction::identity())
        : HashGenExpression(e->srcInfo, e->type, e, a) {}

    dbprint { out << id << "(" << expr << ")"; }

    equiv {
        bool rv = expr->equiv(*a.expr) && dynamic == a.dynamic &&
                  algorithm == a.algorithm && hash_output_width == a.hash_output_width;
        rv &= alg_names
                  ?  (a.alg_names ? alg_names->equiv(*a.alg_names) : false)
                  : a.alg_names == nullptr;
        rv &= dynamic && a.dynamic ? id == a.id : true;
        return rv;
    }

 private:
    /**
     * For static hashes, each hash call is a unique ID, in order potentially for later
     * comparisons and tracking.  With each statc HashGeneExpression created, the nextId
     * increases
     */
    static int nextId;
}

/** Hash Distribution Unit, used to bring PHV information directly into Match Central for
 *  action data lookup or action data itself.  Uses include addressing a table by a PHV field
 *  as well as a calculated hash to be used by PHV
 */
class HashDist : Operation_Unary {
    // Can be a HashGenExpression or a Slice of one
    safe_vector<int> units = {};

    bool allocated() const { return !units.empty(); }
    dbprint {
        out << "hash_dist(" << expr << ")";
        if (allocated())
            out << units;
    }
    stringOp = "hash_dist ";
}

/** Expression computed in the input xbar, generally in the GF matrix
 * These can be used in VLIW instructions, passed to the VLIW alus via the immediate path
 * and the Action Data bus, or in SaluAction instructions.  They are useful for 'breaking'
 * constraint violations on fields that are needed in two different sized MAU PHV groups, as
 * well as computing various things (concatenations, sign extension, bit twiddling) that
 * can't be easily done in an ALU.  They can also be used for things that could be in an ALU,
 * but doing so would require an extra stage of dependency.
 *
 * TODO: Hopefully will be obsoleted by the HashGenExpression
 */
class IXBarExpression : Expression {
    Expression          expr;
    int                 bit;    // where in the ixbar output

#noconstructor
    IXBarExpression(Expression e, int b = 0) : Expression(e->srcInfo, e->type), expr(e), bit(b) {}
    dbprint { out << "ixbar(" << expr << ")"; }
}

class ActionDataConstant : Expression {
    cstring name;
    Constant constant;

    ActionDataConstant { type = constant->type; }
    dbprint { out << "action data constant " << constant; }
}

class RandomNumber : Expression {
    cstring name;
    /**
     * 2 units per stage, one per logical table, on a byte by byte basis
     */
    int     rng_unit = -1;
    bool allocated() const { return rng_unit >= 0; }
    dbprint { out << "rng(" << name << ", " << type << ")"; }
}

/// A use of an attached table output; an operand of an instruction
class AttachedOutput : Expression {
    AttachedMemory     attached;
    dbprint { out << attached->name; }
}

/// reference to a fixed Stateful ALU resource -- these can only appear in SALU Instructions
class SaluReg : Expression {
    cstring                name;
    bool                   hi;     // corresponds to the high half of the alus
    NullOK Expression      phv_src = nullptr;
    dbprint { out << name << (hi ? " {hi}" : ""); }
    toString { return name; }
}
class SaluCmpReg : SaluReg {
    int         index;
    SaluCmpReg(cstring name, int idx) : SaluReg(Type::Bits::get(1), name, idx & 1), index(idx) {}
    #nodbprint
}

class SaluFunction : Operation_Unary {
    cstring             name;
    stringOp = "function";  // unused
    dbprint { out << name << "(" << expr << ")"; }
}

/**
 * Represents constants configurable at run time from control plane
 * stored in the register file of a SALU. They are represented by
 * RegisterParam externs in P4 code.
 */
class SaluRegfileRow : Expression {
    int index;                      // Index of the row in the register file
    int64_t initial_value;          // Initial value loaded into the register row
    optional ID name;               // Name of the corresponding RegisterActionParam
    optional cstring externalName;  // External name for context.json
    dbprint { out << "regfile(index=" << index << ", "
                  << "initial_value=" << initial_value << ", "
                  << "name=" << name.name << ", "
                  << "externalName=" << externalName << ")"; }
}

class MultiOperand : ListExpression {
     dbprint { out << name; }
     cstring name;
     bool is_phv;
     MultiOperand(ListExpression &le, cstring n, bool ip)
        : ListExpression(le), name(n), is_phv(ip) {}
}

class WrappedSlice : Operation_Ternary {
    precedence = DBPrint::Prec_Postfix;
    stringOp = "[:]";
    validate {
        if (e1 && e2 && e1->is<IR::Constant>() && e2->is<IR::Constant>()) {
            BUG_CHECK(e1->is<IR::Constant>() && e2->is<IR::Constant>(),
                      "Wrapped Slices must have constants as slice portion");
            BUG_CHECK(e1->to<IR::Constant>()->asUnsigned() < e2->to<IR::Constant>()->asUnsigned(),
                      "Wrapped Slices must have a higher lo than hi");
            BUG_CHECK(e0->is<IR::MAU::MultiOperand>(), "Wrapped Slices only make sense on "
                      "wrapped values");
        }
    }
    WrappedSlice(Expression a, int hi, int lo, int wrap_size)
    : Operation_Ternary(IR::Type::Bits::get(wrap_size - (lo - hi) + 1), a, new Constant(hi),
                       new Constant(lo)) {}
    int getL() const { return e2->to<IR::Constant>()->asInt(); }
    dbprint { out << e0 << "(" << e1 << ".." << e2 << ")"; }
}

/**
 * TODO: Obsoleted by the HashGenExpression eventually
 */
class TableKey : Expression, IAnnotated {
    Expression expr;
    ID match_type;
    int p4_param_order = -1;
    bool from_mask = false;
    bool partition_index = false;
    bool used_in_alpm = false;

    // @ixbar_group_num is used to bind a table key to a specific ixbar group
    int ixbar_group_num = -1;

    bool for_selection() const { return match_type.name == "selector"; }
    bool for_dleft() const { return match_type.name == "dleft_hash"; }
    bool for_atcam_partition_index() const { return match_type.name == "atcam_partition_index"; }
    bool for_alpm_partition_index() const { return match_type.name == "atcam_partition_index" &&
                                                   used_in_alpm == true; }
    bool for_range() const { return match_type.name == "range"; }
    bool for_match() const { return !for_selection() && !for_dleft(); }
    int get_ixbar_group_num() const { return ixbar_group_num; }

    dbprint { out << expr << ": " << match_type.name; }

    optional Annotations        annotations = Annotations::empty;
    Annotations getAnnotations() const override { return annotations; }
}

}  // end namespace MAU

class RangeMatch : Operation_Unary {
    // range match -- use operand (up to 4 bits) as index into constant (up to 16 bits)
    // to extract a single bit.  Result is boolean.
    unsigned    data;
    RangeMatch { type = Type::Boolean::get(); }
    precedence = DBPrint::Prec_Equ;
    stringOp = " in ";
}

#emit
// defined down here to resolve order of declaration issues
template<class T> inline const T *IR::MAU::Table::get_attached() const {
    for (auto *at : attached)
        if (auto rv = at->attached->to<T>())
            return rv;
    return nullptr; }
#end
