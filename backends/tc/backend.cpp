/*
Copyright (C) 2023 Intel Corporation

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions
and limitations under the License.
*/

#include "backend.h"

#include <filesystem>

#include "backends/ebpf/ebpfOptions.h"
#include "backends/ebpf/target.h"
#include "ir/dump.h"

namespace TC {

const cstring Extern::dropPacket = "drop_packet";
const cstring Extern::sendToPort = "send_to_port";

cstring pnaMainParserInputMetaFields[TC::MAX_PNA_PARSER_META] = {"recirculated", "input_port"};

cstring pnaMainInputMetaFields[TC::MAX_PNA_INPUT_META] = {
    "recirculated", "timestamp", "parser_error", "class_of_service", "input_port"};

cstring pnaMainOutputMetaFields[TC::MAX_PNA_OUTPUT_META] = {"class_of_service"};

const cstring pnaParserMeta = "pna_main_parser_input_metadata_t";
const cstring pnaInputMeta = "pna_main_input_metadata_t";
const cstring pnaOutputMeta = "pna_main_output_metadata_t";

typedef struct mchain MCHAIN;
struct mchain {
    const MCHAIN *ulink;  // towards root
    const MCHAIN *dlink;  // towards leaf
    const IR::Type_StructLike *str;
    int fieldno;
};

// This probably should be a class, with kids being a std::vector.
// I'm not good enough at C++ to get that right.
typedef enum { W_LEAF, W_NODE } WKIND;
typedef struct written WRITTEN;
struct written {
    WKIND kind;
    union {
        // nothing if W_LEAF; presence is enough
        struct {  // if W_NODE
            int n;
            WRITTEN **v;
        } node;
    };
};

static WRITTEN *written_leaf() {
    WRITTEN *w;

    w = new WRITTEN;
    w->kind = W_LEAF;
    return (w);
}

static WRITTEN *written_node(int nkids) {
    WRITTEN *w;
    int i;

    w = new WRITTEN;
    w->kind = W_NODE;
    w->node.n = nkids;
    w->node.v = new WRITTEN *[nkids];
    for (i = nkids - 1; i >= 0; i--) w->node.v[i] = 0;
    return (w);
}

/*
 * XXX
 *
 * record should not be static.  But I'm not sure how else to get
 *  something generated by the tree walk and readable by the deparser
 *  code generator.  It probably should be attached to the header type
 *  somehow.  "First make it work...".
 */
class setting_optimizer : public Inspector {
 public:
    bool preorder(const IR::P4Control *);
    void postorder(const IR::P4Control *);
    bool preorder(const IR::AssignmentStatement *);
    P4::TypeMap *typeMap;
    setting_optimizer(P4::TypeMap *m) : typeMap(m), incontrol(0) {}
    static WRITTEN *record;
    static const IR::Type_StructLike *par_type;
    static const P4::TypeMap *type_map;

 private:
    int incontrol;
};
WRITTEN *setting_optimizer::record = 0;
const IR::Type_StructLike *setting_optimizer::par_type = 0;
const P4::TypeMap *setting_optimizer::type_map = 0;

static void indent(int n) {
    int i;

    for (i = n; i > 0; i--) std::cout << ' ';
}

static void gen_member_chain(const IR::Expression *e, const cstring *mem,
                             void (*fn)(void *, const MCHAIN *), void *arg, int depth = 0,
                             MCHAIN *below = 0) {
    MCHAIN mc;
    int i;

    indent(depth);
    std::cout << "gen_member_chain\n";
    indent(depth + 2);
    std::cout << "expr (" << e << ") [" << e->node_type_name()
              << "] = " << static_cast<const void *>(e) << '\n';
    indent(depth + 2);
    std::cout << "member = " << *mem << '\n';
    indent(depth + 2);
    std::cout << "below = " << static_cast<const void *>(below) << '\n';
    mc.str = e->type->to<const IR::Type_StructLike>();
    if (!mc.str) {
        std::cout << "expr isn't struct-like" << std::endl;
        abort();
    }
    mc.fieldno = -1;
    for (i = mc.str->fields.size() - 1; i >= 0; i--) {
        auto f = mc.str->fields[i];
        if (f->name.name == *mem) {
            mc.fieldno = i;
            break;
        }
    }
    if (mc.fieldno < 0) {
        std::cout << "Can't find field in StructLike" << std::endl;
        abort();
    }
    mc.dlink = below;
    mc.ulink = 0;
    if (below) below->ulink = &mc;
    indent(depth + 2);
    std::cout << "found field (" << mc.fieldno << "), recursing\n";
    if (e->is<const IR::Member>()) {
        const IR::Member *m;
        m = e->to<const IR::Member>();
        if (!m) {
            std::cout << "Expr is member but can't convert" << std::endl;
            abort();
        }
        indent(depth + 2);
        std::cout << "expr is Member, recursing\n";
        gen_member_chain(m->expr, &m->member.name, fn, arg, depth + 4, &mc);
        return;
    }
    indent(depth + 2);
    std::cout << "root (not Member)\n";
    std::cout << "chain:\n";
    {
        const MCHAIN *m;
        for (m = &mc; m; m = m->dlink) {
            std::cout << "  " << static_cast<const void *>(m)
                      << " u=" << static_cast<const void *>(m->ulink)
                      << " d=" << static_cast<const void *>(m->dlink) << " f=" << m->fieldno
                      << '\n';
        }
    }
    (*fn)(arg, &mc);
}

typedef struct rwrv RWRV;
struct rwrv {
    const IR::Type_StructLike *sl;
    WRITTEN **w;
};

/*
 * The return statements would normally specify constructor
 *  expressions, like
 *
 *	return((RWRV){.sl=f->type->to<Type_StructLike>(),.w=&rv.w[0]->kids[i]});
 *
 * But that draws an error about how "C++ designated initializers only
 *  available with '-std=c++20' or '-std=gnu++20'".  So much for C++
 *  being a "better C". :-Ã¾  So we have to declare a variable, assign
 *  to its fields, and then return it.  Ugh.
 */
static RWRV record_write_core(const IR::Member *m, int depth) {
    RWRV rv;

    indent(depth);
    std::cout << "record_write_core: member " << m << ", depth = " << depth << '\n';
    auto e = m->expr;
    if (e->is<IR::Member>()) {
        rv = record_write_core(e->to<IR::Member>(), depth + 4);
    } else {
        rv.sl = setting_optimizer::par_type;
        rv.w = &setting_optimizer::record;
    }
    int sz = rv.sl->fields.size();
    int i;
    for (i = 0; i < sz; i++) {
        auto f = rv.sl->fields[i];
        if (f->name.name == m->member.name) {
            indent(depth);
            std::cout << "field [" << i << "]\n";
            if (!rv.w[0]) rv.w[0] = written_node(sz);
            // See function comment header
            rv.sl = f->type->to<const IR::Type_StructLike>();
            rv.w = &rv.w[0]->node.v[i];
            return (rv);
        }
    }
    abort();
}

static void do_record_write(void *arg __attribute__((__unused__)), const MCHAIN *ch) {
    WRITTEN **w;

    std::cout << "do_record_write:";
    for (const MCHAIN *t = ch; t; t = t->dlink) {
        std::cout << " [field " << t->fieldno << '/' << t->str->fields.size() << ']';
    }
    std::cout << '\n';
    w = &setting_optimizer::record;
    for (const MCHAIN *t = ch; t; t = t->dlink) {
        std::cout << "top of loop: t = " << static_cast<const void *>(t)
                  << ", w = " << static_cast<void *>(w) << ", *w = " << static_cast<void *>(*w)
                  << '\n';
        if (!*w) {
            std::cout << "not leaf, no node\n";
            *w = written_node(t->str->fields.size());
        } else {
            std::cout << "not leaf, node exists\n";
            if (w[0]->kind != W_NODE) {
                std::cout << std::flush;
                abort();
            }
            if (static_cast<int>(t->str->fields.size()) != w[0]->node.n) {
                std::cout << std::flush;
                abort();
            }
        }
        std::cout << "non-leaf: w = " << static_cast<void *>(w)
                  << ", *w = " << static_cast<void *>(*w) << '\n';
        w = &w[0]->node.v[t->fieldno];
        std::cout << " updated: w = " << static_cast<void *>(w)
                  << ", *w = " << static_cast<void *>(*w) << '\n';
    }
    std::cout << "   leaf: w = " << static_cast<void *>(w) << ", *w = " << static_cast<void *>(*w)
              << '\n';
    if (!*w)
        *w = written_leaf();
    else if (w[0]->kind != W_LEAF)
        abort();
    std::cout << "updated: w = " << static_cast<void *>(w) << ", *w = " << static_cast<void *>(*w)
              << '\n';
}

static void record_write(const IR::Member *m) {
    gen_member_chain(m->expr, &m->member.name, &do_record_write, 0);
}

static void dump_record(WRITTEN *w = setting_optimizer::record) {
    int i;

    if (!w) {
        std::cout << '-';
        return;
    }
    switch (w->kind) {
        case W_LEAF:
            std::cout << '*';
            break;
        case W_NODE:
            std::cout << '[';
            for (i = 0; i < w->node.n; i++) {
                if (i) std::cout << ' ';
                dump_record(w->node.v[i]);
            }
            std::cout << ']';
            break;
        default:
            abort();
            break;
    }
}

typedef struct w2w W2W;
struct w2w {
    int *wantp;
    cstring &lastfield;
};

static void set_want(void *arg, const MCHAIN *ch) {
    WRITTEN *w;

    std::cout << "set_want:";
    for (const MCHAIN *t = ch; t; t = t->dlink) {
        std::cout << ' ' << t->fieldno;
    }
    std::cout << '\n';
    w = setting_optimizer::record;
    for (const MCHAIN *t = ch; t; t = t->dlink) {
        if (!w) {
            std::cout << "w is nil, returning 0\n";
            *(int *)arg = 0;
            return;
        }
        if (w->kind != W_NODE) {
            std::cout << "not end of chain, but type isn't node" << std::endl;
            abort();
        }
        if (static_cast<int>(t->str->fields.size()) != w->node.n) {
            std::cout << "field count mismatch" << std::endl;
            abort();
        }
        if ((t->fieldno < 0) || (t->fieldno >= w->node.n)) {
            std::cout << "field number " << t->fieldno << "out of range [0.." << w->node.n << ")"
                      << std::endl;
            abort();
        }
        w = w->node.v[t->fieldno];
    }
    std::cout << "returning " << (w ? 1 : 0) << '\n';
    *(int *)arg = w ? 1 : 0;
}

// XXX Maybe should check that the type is correct somehow?
bool want_to_write(const IR::Expression *e, const cstring *field) {
    int want;

    std::cout << "checking want_to_write for [" << e->node_type_name() << "] = " << e << ", field "
              << *field << '\n';
    if (!e->is<IR::Member>()) return (1);
    want = 1;
    gen_member_chain(e, field, &set_want, &want);
    return (want);
}

// ::preorder returns true -> call down
// ::preorder returns false -> don't call down

bool setting_optimizer::preorder(const IR::P4Control *c) {
    if (incontrol) abort();
    incontrol = 1;
    std::cout << "Entering P4Control " << static_cast<const void *>(c) << '\n';
    return (true);
}

void setting_optimizer::postorder(const IR::P4Control *c) {
    if (!incontrol) abort();
    incontrol = 0;
    std::cout << "Leaving P4Control " << static_cast<const void *>(c) << '\n';
    dump_record();
    std::cout << std::endl;
}

bool setting_optimizer::preorder(const IR::AssignmentStatement *s) {
    if (!incontrol) return (true);
    std::cout << "================\n";
    std::cout << "Assignment [" << s->node_type_name() << "] (" << static_cast<const void *>(s)
              << "): " << s << '\n';
    std::cout << "  LHS (" << static_cast<const void *>(s->left) << ") is " << s->left << '\n';
    std::cout << "  RHS (" << static_cast<const void *>(s->right) << ") is " << s->right << '\n';
    if (s->left->is<IR::Member>()) {
        const IR::Node *n;
        for (n = s->left; n->is<IR::Member>(); n = n->to<IR::Member>()->expr) {
            std::cout << "Member name " << n->to<IR::Member>()->member.name << '\n';
        }
        if (n->is<IR::PathExpression>()) {
            auto px = n->to<IR::PathExpression>();
            std::cout << "Member base path is " << static_cast<const void *>(px->path) << '\n';
            std::cout << "Path name is " << px->path->name << ", absolute = " << px->path->absolute
                      << '\n';
            auto ctx = setting_optimizer::getContext();
            dump(ctx);
            auto ctl = setting_optimizer::findContext<IR::P4Control>();
            if (ctl != nullptr) {
                std::cout << "Found P4Control [" << ctl->node_type_name() << "] ("
                          << static_cast<const void *>(ctl) << ")\n";
                std::cout << "  name = " << ctl->getName().name << '\n'
                          << "  type = " << ctl->type << '\n'
                          << "  constructorParams = " << ctl->constructorParams << '\n'
                          << "  controlLocals = " << ctl->controlLocals << '\n'
                          << "  getAnnotations() = " << ctl->getAnnotations() << '\n'
                          << "  getTypeParameters() = " << ctl->getTypeParameters() << '\n'
                          << "  getNestedNamespaces() = " << ctl->getNestedNamespaces() << '\n'
                          << "  getDeclarations() = " << ctl->getDeclarations() << '\n'
                          << "  getApplyMethodType() = " << ctl->getApplyMethodType() << '\n'
                          << "  getApplyParameters() = " << ctl->getApplyParameters() << '\n'
                          << "  getConstructorMethodType() = " << ctl->getConstructorMethodType()
                          << '\n'
                          << "  getConstructorParameters() = " << ctl->getConstructorParameters()
                          << '\n'
                          << "  getType() = " << ctl->getType() << '\n';
                auto ap = ctl->getApplyParameters();
                // ap is IR::IndexedVector<IR::Parameter> *
                auto par = ap->parameters[0];
                // par is an IR::Parameter
                std::cout << "  [0] = " << par << '\n';
                std::cout << "    direction = " << par->direction << '\n'
                          << "    type = " << par->type << '\n'
                          << "    name = " << par->name << '\n';
                // This check works only because of the misfeature elsewhere
                //  which disallows shadowing parameters.  Otherwise we'd
                //  have to figure out how to tell whether we've got the
                //  correct variable of this name.
                if (par->name == px->path->name) {
                    auto pt = par->type;
                    std::cout << "Is parameter 0\n";
                    auto tn = pt->to<const IR::Type_Name>();
                    if (tn) {
                        auto st = typeMap->getTypeType(tn, true);
                        if (st) {
                            auto sl = st->to<IR::Type_StructLike>();
                            if (sl) {
                                par_type = sl;
                                type_map = typeMap;
                                record_write(s->left->to<const IR::Member>());
                                par_type = 0;
                            }
                        }
                    }
                } else {
                    std::cout << "Not parameter 0\n";
                }
            } else {
                std::cout << "No P4Control";
            }
        } else {
            std::cout << "Member base isn't PathExpression\n";
        }
    } else {
        std::cout << "LHS isn't Member\n";
    }
    std::cout << "================\n";
    return (true);
}

bool Backend::process() {
    std::cout << "Backend::process beginning" << std::endl;
    CHECK_NULL(toplevel);
    if (toplevel->getMain() == nullptr) {
        ::error("main is missing in the package");
        std::cout << "Backend::process returning false (no main)" << std::endl;
        return false;  //  no main
    }
    auto refMapEBPF = refMap;
    auto typeMapEBPF = typeMap;
    parseTCAnno = new ParseTCAnnotations();
    tcIR = new ConvertToBackendIR(toplevel, pipeline, refMap, typeMap, options);
    genIJ = new IntrospectionGenerator(pipeline, refMap, typeMap);
    addPasses({parseTCAnno, new P4::ResolveReferences(refMap),
               new P4::TypeInference(refMap, typeMap), tcIR, genIJ,
               new setting_optimizer(typeMap)});
    toplevel->getProgram()->apply(*this);
    if (::errorCount() > 0) {
        std::cout << "Backend::process returning false (errors in processing)" << std::endl;
        return false;
    }
    if (!ebpfCodeGen(refMapEBPF, typeMapEBPF)) {
        std::cout << "Backend::process returning false (codegen failed)" << std::endl;
        return false;
    }
    std::cout << "Backend::process returning true" << std::endl;
    return true;
}

bool Backend::ebpfCodeGen(P4::ReferenceMap *refMapEBPF, P4::TypeMap *typeMapEBPF) {
    target = new EBPF::P4TCTarget(options.emitTraceMessages);
    ebpfOption.xdp2tcMode = options.xdp2tcMode;
    ebpfOption.exe_name = options.exe_name;
    ebpfOption.file = options.file;
    PnaProgramStructure structure(refMapEBPF, typeMapEBPF);
    auto parsePnaArch = new ParsePnaArchitecture(&structure);
    auto main = toplevel->getMain();
    if (!main) return false;

    if (main->type->name != "PNA_NIC") {
        ::warning(ErrorType::WARN_INVALID,
                  "%1%: the main package should be called PNA_NIC"
                  "; are you using the wrong architecture?",
                  main->type->name);
        return false;
    }

    main->apply(*parsePnaArch);
    auto evaluator = new P4::EvaluatorPass(refMapEBPF, typeMapEBPF);
    auto program = toplevel->getProgram();

    PassManager rewriteToEBPF = {
        evaluator,
        new VisitFunctor([this, evaluator, structure]() { top = evaluator->getToplevelBlock(); }),
    };

    auto hook = options.getDebugHook();
    rewriteToEBPF.addDebugHook(hook, true);
    program = program->apply(rewriteToEBPF);

    // map IR node to compile-time allocated resource blocks.
    top->apply(*new BMV2::BuildResourceMap(&structure.resourceMap));

    main = top->getMain();
    if (!main) return false;  // no main
    main->apply(*parsePnaArch);
    program = top->getProgram();

    EBPF::EBPFTypeFactory::createFactory(typeMapEBPF);
    auto convertToEbpf = new ConvertToEbpfPNA(ebpfOption, refMapEBPF, typeMapEBPF, tcIR);
    PassManager toEBPF = {
        new BMV2::DiscoverStructure(&structure),
        new InspectPnaProgram(refMapEBPF, typeMapEBPF, &structure),
        // convert to EBPF objects
        new VisitFunctor([evaluator, convertToEbpf]() {
            auto tlb = evaluator->getToplevelBlock();
            tlb->apply(*convertToEbpf);
        }),
    };

    toEBPF.addDebugHook(hook, true);
    program = program->apply(toEBPF);

    ebpf_program = convertToEbpf->getEBPFProgram();

    return true;
}

void Backend::serialize() const {
    cstring progName = tcIR->getPipelineName();
    if (ebpf_program == nullptr) return;
    EBPF::CodeBuilder c(target), p(target), h(target);
    ebpf_program->emit(&c);
    ebpf_program->emitParser(&p);
    ebpf_program->emitHeader(&h);
    if (::errorCount() > 0) {
        return;
    }
    cstring outputFile = progName + ".template";
    if (!options.outputFolder.isNullOrEmpty()) {
        outputFile = options.outputFolder + outputFile;
    }
    auto outstream = openFile(outputFile, false);
    if (outstream != nullptr) {
        *outstream << pipeline->toString();
        outstream->flush();
        std::filesystem::permissions(outputFile.c_str(),
                                     std::filesystem::perms::owner_all |
                                         std::filesystem::perms::group_all |
                                         std::filesystem::perms::others_all,
                                     std::filesystem::perm_options::add);
    }
    cstring parserFile = progName + "_parser.c";
    cstring postParserFile = progName + "_control_blocks.c";
    cstring headerFile = progName + "_parser.h";
    if (!options.outputFolder.isNullOrEmpty()) {
        parserFile = options.outputFolder + parserFile;
        postParserFile = options.outputFolder + postParserFile;
        headerFile = options.outputFolder + headerFile;
    }
    auto cstream = openFile(postParserFile, false);
    auto pstream = openFile(parserFile, false);
    auto hstream = openFile(headerFile, false);
    if (cstream == nullptr) {
        ::error("Unable to open File %1%", postParserFile);
        return;
    }
    if (pstream == nullptr) {
        ::error("Unable to open File %1%", parserFile);
        return;
    }
    if (hstream == nullptr) {
        ::error("Unable to open File %1%", headerFile);
        return;
    }
    *cstream << c.toString();
    *pstream << p.toString();
    *hstream << h.toString();
    cstream->flush();
    pstream->flush();
    hstream->flush();
}

bool Backend::serializeIntrospectionJson(std::ostream &out) const {
    if (genIJ->serializeIntrospectionJson(out)) {
        out.flush();
        return true;
    }
    return false;
}

void ConvertToBackendIR::setPipelineName() {
    cstring path = options.file;
    if (path != nullptr) {
        pipelineName = path;
    } else {
        ::error("filename is not given in command line option");
        return;
    }
    auto fileName = path.findlast('/');
    if (fileName) {
        pipelineName = fileName;
        pipelineName = pipelineName.replace("/", "");
    }
    auto fileext = pipelineName.find(".");
    pipelineName = pipelineName.replace(fileext, "");
    pipelineName = pipelineName.trim();
}

bool ConvertToBackendIR::preorder(const IR::P4Program *p) {
    if (p != nullptr) {
        setPipelineName();
        return true;
    }
    return false;
}

cstring ConvertToBackendIR::externalName(const IR::IDeclaration *declaration) const {
    cstring name = declaration->externalName();
    if (name.startsWith(".")) name = name.substr(1);
    auto Name = name.replace('.', '/');
    return Name;
}

bool ConvertToBackendIR::isDuplicateOrNoAction(const IR::P4Action *action) {
    auto actionName = externalName(action);
    if (actions.find(actionName) != actions.end()) return true;
    if (actionName == P4::P4CoreLibrary::instance().noAction.name) return true;
    return false;
}

void ConvertToBackendIR::postorder(const IR::P4Action *action) {
    if (action != nullptr) {
        if (isDuplicateOrNoAction(action)) return;
        auto actionName = externalName(action);
        actions.emplace(actionName, action);
        actionCount++;
        unsigned int actionId = actionCount;
        IR::TCAction *tcAction = new IR::TCAction(actionName);
        tcAction->setPipelineName(pipelineName);
        tcAction->setActionId(actionId);
        actionIDList.emplace(actionId, actionName);
        auto paramList = action->getParameters();
        if (paramList != nullptr && !paramList->empty()) {
            for (auto param : paramList->parameters) {
                auto paramType = typeMap->getType(param);
                IR::TCActionParam *tcActionParam = new IR::TCActionParam();
                tcActionParam->setParamName(param->name.originalName);
                if (!paramType->is<IR::Type_Bits>()) {
                    ::error(ErrorType::ERR_UNSUPPORTED_ON_TARGET,
                            "%1% parameter with type other than bit is not supported", param);
                    return;
                } else {
                    auto paramTypeName = paramType->to<IR::Type_Bits>()->baseName();
                    if (paramTypeName != "bit") {
                        ::error(ErrorType::ERR_UNSUPPORTED_ON_TARGET,
                                "%1% parameter with type other than bit is not supported", param);
                        return;
                    }
                    tcActionParam->setDataType(TC::BIT_TYPE);
                    unsigned int width = paramType->to<IR::Type_Bits>()->width_bits();
                    tcActionParam->setBitSize(width);
                }
                auto annoList = param->getAnnotations()->annotations;
                for (auto anno : annoList) {
                    if (anno->name != ParseTCAnnotations::tcType) continue;
                    auto expr = anno->expr[0];
                    if (auto typeLiteral = expr->to<IR::StringLiteral>()) {
                        auto val = getTcType(typeLiteral);
                        if (val != TC::BIT_TYPE) {
                            tcActionParam->setDataType(val);
                        } else {
                            ::error(ErrorType::ERR_INVALID,
                                    "tc_type annotation cannot have '%1%' as value", expr);
                        }
                    } else {
                        ::error(ErrorType::ERR_INVALID,
                                "tc_type annotation cannot have '%1%' as value", expr);
                    }
                }
                tcAction->addActionParams(tcActionParam);
            }
        }
        tcPipeline->addActionDefinition(tcAction);
    }
}

void ConvertToBackendIR::updateTimerProfiles(IR::TCTable *tabledef) {
    if (options.timerProfiles > DEFAULT_TIMER_PROFILES) {
        tabledef->addTimerProfiles(options.timerProfiles);
    }
}
void ConvertToBackendIR::updateConstEntries(const IR::P4Table *t, IR::TCTable *tabledef) {
    // Check if there are const entries.
    auto entriesList = t->getEntries();
    if (entriesList == nullptr) return;
    auto keys = t->getKey();
    if (keys == nullptr) {
        return;
    }
    for (auto e : entriesList->entries) {
        auto keyset = e->getKeys();
        if (keyset->components.size() != keys->keyElements.size()) {
            ::error(ErrorType::ERR_INVALID,
                    "No of keys in const_entries should be same as no of keys in the table.");
            return;
        }
        ordered_map<cstring, cstring> keyList;
        for (size_t itr = 0; itr < keyset->components.size(); itr++) {
            auto keyElement = keys->keyElements.at(itr);
            auto keyString = keyElement->expression->toString();
            auto annotations = keyElement->getAnnotations();
            if (annotations) {
                if (auto anno = annotations->getSingle("name")) {
                    keyString = anno->expr.at(0)->to<IR::StringLiteral>()->value;
                }
            }
            auto keySetElement = keyset->components.at(itr);
            auto key = keySetElement->toString();
            if (keySetElement->is<IR::DefaultExpression>()) {
                key = "default";
            } else if (keySetElement->is<IR::Constant>()) {
                big_int kValue = keySetElement->to<IR::Constant>()->value;
                int kBase = keySetElement->to<IR::Constant>()->base;
                std::stringstream value;
                switch (kBase) {
                    case 2:
                        value << "0b";
                        break;
                    case 8:
                        value << "0o";
                        break;
                    case 16:
                        value << "0x";
                        break;
                    case 10:
                        break;
                    default:
                        BUG("Unexpected base %1%", kBase);
                }
                std::deque<char> buf;
                do {
                    const int digit = static_cast<int>(static_cast<big_int>(kValue % kBase));
                    kValue = kValue / kBase;
                    buf.push_front(Util::DigitToChar(digit));
                } while (kValue > 0);
                for (auto ch : buf) value << ch;
                key = value.str().c_str();
            } else if (keySetElement->is<IR::Range>()) {
                auto left = keySetElement->to<IR::Range>()->left;
                auto right = keySetElement->to<IR::Range>()->right;
                auto operand = keySetElement->to<IR::Range>()->getStringOp();
                key = left->toString() + operand + right->toString();
            } else if (keySetElement->is<IR::Mask>()) {
                auto left = keySetElement->to<IR::Mask>()->left;
                auto right = keySetElement->to<IR::Mask>()->right;
                auto operand = keySetElement->to<IR::Mask>()->getStringOp();
                key = left->toString() + operand + right->toString();
            }
            keyList.emplace(keyString, key);
        }
        cstring actionName;
        if (const auto *path = e->action->to<IR::PathExpression>())
            actionName = path->toString();
        else if (const auto *mce = e->action->to<IR::MethodCallExpression>())
            actionName = mce->method->toString();
        else
            BUG("Unexpected entry action type.");
        IR::TCEntry *constEntry = new IR::TCEntry(actionName, keyList);
        tabledef->addConstEntries(constEntry);
    }
}

void ConvertToBackendIR::updateDefaultMissAction(const IR::P4Table *t, IR::TCTable *tabledef) {
    auto defaultAction = t->getDefaultAction();
    if (defaultAction == nullptr || !defaultAction->is<IR::MethodCallExpression>()) return;
    auto methodexp = defaultAction->to<IR::MethodCallExpression>();
    auto mi = P4::MethodInstance::resolve(methodexp, refMap, typeMap);
    auto actionCall = mi->to<P4::ActionCall>();
    if (actionCall == nullptr) return;
    auto actionName = externalName(actionCall->action);
    if (actionName != P4::P4CoreLibrary::instance().noAction.name) {
        for (auto tcAction : tcPipeline->actionDefs) {
            if (actionName == tcAction->actionName) {
                tabledef->setDefaultMissAction(tcAction);
                auto defaultActionProperty =
                    t->properties->getProperty(IR::TableProperties::defaultActionPropertyName);
                if (defaultActionProperty->isConstant) {
                    tabledef->setDefaultMissConst(true);
                }
                bool isTCMayOverride = false;
                const IR::Annotation *overrideAnno =
                    defaultActionProperty->getAnnotations()->getSingle(
                        ParseTCAnnotations::tcMayOverride);
                if (overrideAnno) {
                    isTCMayOverride = true;
                }
                bool directionParamPresent = false;
                auto paramList = actionCall->action->getParameters();
                for (auto param : paramList->parameters) {
                    if (param->direction != IR::Direction::None) directionParamPresent = true;
                }
                if (!directionParamPresent) {
                    auto i = 0;
                    if (isTCMayOverride) {
                        if (paramList->parameters.empty())
                            ::warning(ErrorType::WARN_INVALID,
                                      "%1% annotation cannot be used with default_action without "
                                      "parameters",
                                      overrideAnno);
                        else
                            tabledef->setTcMayOverride();
                    }
                    for (auto param : paramList->parameters) {
                        auto defaultParam = new IR::TCDefaultActionParam();
                        for (auto actionParam : tcAction->actionParams) {
                            if (actionParam->paramName == param->name.originalName) {
                                defaultParam->setParamDetail(actionParam);
                            }
                        }
                        auto defaultArg = methodexp->arguments->at(i++);
                        if (auto constVal = defaultArg->expression->to<IR::Constant>()) {
                            if (!isTCMayOverride)
                                defaultParam->setDefaultValue(
                                    Util::toString(constVal->value, 0, true, constVal->base));
                            tabledef->defaultMissActionParams.push_back(defaultParam);
                        }
                    }
                } else {
                    if (isTCMayOverride)
                        ::warning(ErrorType::WARN_INVALID,
                                  "%1% annotation cannot be used with default_action with "
                                  "directional parameters",
                                  overrideAnno);
                }
            }
        }
    }
}

void ConvertToBackendIR::updateDefaultHitAction(const IR::P4Table *t, IR::TCTable *tabledef) {
    auto actionlist = t->getActionList();
    if (actionlist != nullptr) {
        unsigned int defaultHit = 0;
        unsigned int defaultHitConst = 0;
        cstring defaultActionName = nullptr;
        for (auto action : actionlist->actionList) {
            auto annoList = action->getAnnotations()->annotations;
            bool isTableOnly = false;
            bool isDefaultHit = false;
            bool isDefaultHitConst = false;
            for (auto anno : annoList) {
                if (anno->name == IR::Annotation::tableOnlyAnnotation) {
                    isTableOnly = true;
                }
                if (anno->name == ParseTCAnnotations::defaultHit) {
                    isDefaultHit = true;
                    defaultHit++;
                    auto adecl = refMap->getDeclaration(action->getPath(), true);
                    defaultActionName = externalName(adecl);
                }
                if (anno->name == ParseTCAnnotations::defaultHitConst) {
                    isDefaultHitConst = true;
                    defaultHitConst++;
                    auto adecl = refMap->getDeclaration(action->getPath(), true);
                    defaultActionName = externalName(adecl);
                }
            }
            if (isTableOnly && isDefaultHit && isDefaultHitConst) {
                ::error(ErrorType::ERR_INVALID,
                        "Table '%1%' has an action reference '%2%' which is "
                        "annotated with '@tableonly', '@default_hit' and '@default_hit_const'",
                        t->name.originalName, action->getName().originalName);
                break;
            } else if (isTableOnly && isDefaultHit) {
                ::error(ErrorType::ERR_INVALID,
                        "Table '%1%' has an action reference '%2%' which is "
                        "annotated with '@tableonly' and '@default_hit'",
                        t->name.originalName, action->getName().originalName);
                break;
            } else if (isTableOnly && isDefaultHitConst) {
                ::error(ErrorType::ERR_INVALID,
                        "Table '%1%' has an action reference '%2%' which is "
                        "annotated with '@tableonly' and '@default_hit_const'",
                        t->name.originalName, action->getName().originalName);
                break;
            } else if (isDefaultHit && isDefaultHitConst) {
                ::error(ErrorType::ERR_INVALID,
                        "Table '%1%' has an action reference '%2%' which is "
                        "annotated with '@default_hit' and '@default_hit_const'",
                        t->name.originalName, action->getName().originalName);
                break;
            }
        }
        if (::errorCount() > 0) {
            return;
        }
        if ((defaultHit > 0) && (defaultHitConst > 0)) {
            ::error(ErrorType::ERR_INVALID,
                    "Table '%1%' cannot have both '@default_hit' action "
                    "and '@default_hit_const' action",
                    t->name.originalName);
            return;
        } else if (defaultHit > 1) {
            ::error(ErrorType::ERR_INVALID, "Table '%1%' can have only one '@default_hit' action",
                    t->name.originalName);
            return;
        } else if (defaultHitConst > 1) {
            ::error(ErrorType::ERR_INVALID,
                    "Table '%1%' can have only one '@default_hit_const' action",
                    t->name.originalName);
            return;
        }
        if (defaultActionName != nullptr &&
            defaultActionName != P4::P4CoreLibrary::instance().noAction.name) {
            for (auto tcAction : tcPipeline->actionDefs) {
                if (defaultActionName == tcAction->actionName) {
                    tabledef->setDefaultHitAction(tcAction);
                    if (defaultHitConst == 1) {
                        tabledef->setDefaultHitConst(true);
                    }
                }
            }
        }
    }
}

void ConvertToBackendIR::postorder(const IR::P4Table *t) {
    if (t != nullptr) {
        tableCount++;
        unsigned int tId = tableCount;
        auto tName = t->name.originalName;
        tableIDList.emplace(tId, tName);
        auto ctrl = findContext<IR::P4Control>();
        auto cName = ctrl->name.originalName;
        IR::TCTable *tableDefinition = new IR::TCTable(tId, tName, cName, pipelineName);
        auto tEntriesCount = TC::DEFAULT_TABLE_ENTRIES;
        auto sizeProperty = t->getSizeProperty();
        if (sizeProperty) {
            if (sizeProperty->fitsUint64()) {
                tEntriesCount = sizeProperty->asUint64();
            } else {
                ::error(ErrorType::ERR_UNSUPPORTED_ON_TARGET,
                        "table with size %1% cannot be supported", t->getSizeProperty());
                return;
            }
        }
        tableDefinition->setTableEntriesCount(tEntriesCount);
        unsigned int keySize = 0;
        unsigned int keyCount = 0;
        auto key = t->getKey();
        if (key != nullptr && key->keyElements.size()) {
            for (auto k : key->keyElements) {
                auto keyExp = k->expression;
                auto keyExpType = typeMap->getType(keyExp);
                auto widthBits = keyExpType->width_bits();
                keySize += widthBits;
                keyCount++;
            }
        }
        tableDefinition->setKeySize(keySize);
        tableKeysizeList.emplace(tId, keySize);
        auto annoList = t->getAnnotations()->annotations;
        for (auto anno : annoList) {
            if (anno->name != ParseTCAnnotations::numMask) continue;
            auto expr = anno->expr[0];
            if (auto val = expr->to<IR::Constant>()) {
                tableDefinition->setNumMask(val->asUint64());
            } else {
                ::error(ErrorType::ERR_INVALID,
                        "nummask annotation cannot have '%1%' as value. Only integer "
                        "constants are allowed",
                        expr);
            }
        }
        auto actionlist = t->getActionList();
        for (auto action : actionlist->actionList) {
            for (auto actionDef : tcPipeline->actionDefs) {
                auto adecl = refMap->getDeclaration(action->getPath(), true);
                auto actionName = externalName(adecl);
                if (actionName != actionDef->actionName) continue;
                auto annoList = action->getAnnotations()->annotations;
                unsigned int tableFlag = TC::TABLEDEFAULT;
                for (auto anno : annoList) {
                    if (anno->name == IR::Annotation::tableOnlyAnnotation) {
                        tableFlag = TC::TABLEONLY;
                    }
                    if (anno->name == IR::Annotation::defaultOnlyAnnotation) {
                        tableFlag = TC::DEFAULTONLY;
                    }
                }
                tableDefinition->addAction(actionDef, tableFlag);
            }
        }
        updateDefaultHitAction(t, tableDefinition);
        updateDefaultMissAction(t, tableDefinition);
        updateMatchType(t, tableDefinition);
        updateConstEntries(t, tableDefinition);
        updateTimerProfiles(tableDefinition);
        tcPipeline->addTableDefinition(tableDefinition);
    }
}

void ConvertToBackendIR::postorder(const IR::P4Program *p) {
    if (p != nullptr) {
        tcPipeline->setPipelineName(pipelineName);
        tcPipeline->setNumTables(tableCount);
    }
}

/**
 * This function is used for checking whether given member is PNA Parser metadata
 */
bool ConvertToBackendIR::isPnaParserMeta(const IR::Member *mem) {
    if (mem->expr != nullptr && mem->expr->type != nullptr) {
        if (auto str_type = mem->expr->type->to<IR::Type_Struct>()) {
            if (str_type->name == pnaParserMeta) return true;
        }
    }
    return false;
}

bool ConvertToBackendIR::isPnaMainInputMeta(const IR::Member *mem) {
    if (mem->expr != nullptr && mem->expr->type != nullptr) {
        if (auto str_type = mem->expr->type->to<IR::Type_Struct>()) {
            if (str_type->name == pnaInputMeta) return true;
        }
    }
    return false;
}

bool ConvertToBackendIR::isPnaMainOutputMeta(const IR::Member *mem) {
    if (mem->expr != nullptr && mem->expr->type != nullptr) {
        if (auto str_type = mem->expr->type->to<IR::Type_Struct>()) {
            if (str_type->name == pnaOutputMeta) return true;
        }
    }
    return false;
}

unsigned int ConvertToBackendIR::findMappedKernelMeta(const IR::Member *mem) {
    if (isPnaParserMeta(mem)) {
        for (auto i = 0; i < TC::MAX_PNA_PARSER_META; i++) {
            if (mem->member.name == pnaMainParserInputMetaFields[i]) {
                if (i == TC::PARSER_RECIRCULATED) {
                    return TC::SKBREDIR;
                } else if (i == TC::PARSER_INPUT_PORT) {
                    return TC::SKBIIF;
                }
            }
        }
    } else if (isPnaMainInputMeta(mem)) {
        for (auto i = 0; i < TC::MAX_PNA_INPUT_META; i++) {
            if (mem->member.name == pnaMainInputMetaFields[i]) {
                switch (i) {
                    case TC::INPUT_RECIRCULATED:
                        return TC::SKBREDIR;
                    case TC::INPUT_TIMESTAMP:
                        return TC::SKBTSTAMP;
                    case TC::INPUT_PARSER_ERROR:
                        ::error(ErrorType::ERR_UNSUPPORTED_ON_TARGET,
                                "%1% is not supported in this target", mem);
                        return TC::UNSUPPORTED;
                    case TC::INPUT_CLASS_OF_SERVICE:
                        return TC::SKBPRIO;
                    case TC::INPUT_INPUT_PORT:
                        return TC::SKBIIF;
                }
            }
        }
    } else if (isPnaMainOutputMeta(mem)) {
        if (mem->member.name == pnaMainOutputMetaFields[TC::OUTPUT_CLASS_OF_SERVICE]) {
            return TC::SKBPRIO;
        }
    }
    return TC::UNDEFINED;
}

const IR::Expression *ConvertToBackendIR::ExtractExpFromCast(const IR::Expression *exp) {
    const IR::Expression *castexp = exp;
    while (castexp->is<IR::Cast>()) {
        castexp = castexp->to<IR::Cast>()->expr;
    }
    return castexp;
}

unsigned ConvertToBackendIR::getTcType(const IR::StringLiteral *sl) {
    auto value = sl->value;
    auto typeVal = TC::BIT_TYPE;
    if (value == "dev") {
        typeVal = TC::DEV_TYPE;
    } else if (value == "macaddr") {
        typeVal = TC::MACADDR_TYPE;
    } else if (value == "ipv4") {
        typeVal = TC::IPV4_TYPE;
    } else if (value == "ipv6") {
        typeVal = TC::IPV6_TYPE;
    } else if (value == "be16") {
        typeVal = TC::BE16_TYPE;
    } else if (value == "be32") {
        typeVal = TC::BE32_TYPE;
    } else if (value == "be64") {
        typeVal = TC::BE64_TYPE;
    }
    return typeVal;
}

unsigned ConvertToBackendIR::getTableId(cstring tableName) const {
    for (auto t : tableIDList) {
        if (t.second == tableName) return t.first;
    }
    return 0;
}

unsigned ConvertToBackendIR::getActionId(cstring actionName) const {
    for (auto a : actionIDList) {
        if (a.second == actionName) return a.first;
    }
    return 0;
}

unsigned ConvertToBackendIR::getTableKeysize(unsigned tableId) const {
    auto itr = tableKeysizeList.find(tableId);
    if (itr != tableKeysizeList.end()) return itr->second;
    return 0;
}

void ConvertToBackendIR::updateMatchType(const IR::P4Table *t, IR::TCTable *tabledef) {
    auto key = t->getKey();
    auto tableMatchType = TC::EXACT_TYPE;
    if (key != nullptr && key->keyElements.size()) {
        if (key->keyElements.size() == 1) {
            auto matchTypeExp = key->keyElements[0]->matchType->path;
            auto mtdecl = refMap->getDeclaration(matchTypeExp, true);
            auto matchTypeInfo = mtdecl->getNode()->to<IR::Declaration_ID>();
            if (matchTypeInfo->name.name == P4::P4CoreLibrary::instance().exactMatch.name) {
                tableMatchType = TC::EXACT_TYPE;
            } else if (matchTypeInfo->name.name == P4::P4CoreLibrary::instance().lpmMatch.name) {
                tableMatchType = TC::LPM_TYPE;
            } else if (matchTypeInfo->name.name ==
                       P4::P4CoreLibrary::instance().ternaryMatch.name) {
                tableMatchType = TC::TERNARY_TYPE;
            } else if (matchTypeInfo->name.name == "range" ||
                       matchTypeInfo->name.name == "rangelist" ||
                       matchTypeInfo->name.name == "optional") {
                tableMatchType = TC::TERNARY_TYPE;
            } else {
                ::error(ErrorType::ERR_UNSUPPORTED_ON_TARGET,
                        "match type %1% is not supported in this target",
                        key->keyElements[0]->matchType);
                return;
            }
        } else {
            unsigned totalKey = key->keyElements.size();
            unsigned exactKey = 0;
            unsigned lpmKey = 0;
            unsigned ternaryKey = 0;
            unsigned keyCount = 0;
            unsigned lastkeyMatchType = TC::EXACT_TYPE;
            unsigned keyMatchType;
            for (auto k : key->keyElements) {
                auto matchTypeExp = k->matchType->path;
                auto mtdecl = refMap->getDeclaration(matchTypeExp, true);
                auto matchTypeInfo = mtdecl->getNode()->to<IR::Declaration_ID>();
                if (matchTypeInfo->name.name == P4::P4CoreLibrary::instance().exactMatch.name) {
                    keyMatchType = TC::EXACT_TYPE;
                    exactKey++;
                } else if (matchTypeInfo->name.name ==
                           P4::P4CoreLibrary::instance().lpmMatch.name) {
                    keyMatchType = TC::LPM_TYPE;
                    lpmKey++;
                } else if (matchTypeInfo->name.name ==
                           P4::P4CoreLibrary::instance().ternaryMatch.name) {
                    keyMatchType = TC::TERNARY_TYPE;
                    ternaryKey++;
                } else if (matchTypeInfo->name.name == "range" ||
                           matchTypeInfo->name.name == "rangelist" ||
                           matchTypeInfo->name.name == "optional") {
                    keyMatchType = TC::TERNARY_TYPE;
                    ternaryKey++;
                } else {
                    ::error(ErrorType::ERR_UNSUPPORTED_ON_TARGET,
                            "match type %1% is not supported in this target", k->matchType);
                    return;
                }
                keyCount++;
                if (keyCount == totalKey) {
                    lastkeyMatchType = keyMatchType;
                }
            }
            if (ternaryKey >= 1 || lpmKey > 1) {
                tableMatchType = TC::TERNARY_TYPE;
            } else if (exactKey == totalKey) {
                tableMatchType = TC::EXACT_TYPE;
            } else if (lpmKey == 1 && lastkeyMatchType == TC::LPM_TYPE) {
                tableMatchType = TC::LPM_TYPE;
            }
        }
    }
    tabledef->setMatchType(tableMatchType);
}

}  // namespace TC
