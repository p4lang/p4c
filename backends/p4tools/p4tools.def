/// Represents a reference to an object in a P4 program.
///
/// This is a thin wrapper around a 'const IR::Member*' to (1) enforce invariants on which forms of
/// Members can represent state variables and (2) enable the use of StateVariables as map keys.
class StateVariable : Expression {
    /// The wrapped member.
    const Member *member;

    /// Implicit conversions to allow implementations to be treated like a Member*.
#emit
    operator const IR::Member *() const { return member; }
#end
    Member const &operator*() const { return *member; }
    Member operator->() const { return member; }

    /// Implements comparisons so that StateVariables can be used as map keys.
    bool operator==(const StateVariable &other) const override {
        // Delegate to IR's notion of equality.
        return *member == *other.member;
    }

    /// Implements comparisons so that StateVariables can be used as map keys.
    bool operator<(const StateVariable &other) const {
        // We use a custom compare function.
        // TODO: Is there a faster way to implement this comparison?
        return compare(member, other.member) < 0;
    }

    int compare(const Expression *e1, const Expression *e2) const {
        // e1 is a Member.
        if (const auto *m1 = e1->to<Member>()) {
            if (const auto *m2 = e2->to<Member>()) {
                return compare(m1, m2);
            }
            if (e2->is<PathExpression>()) {
                return 1;
            }
        }
        // e1 is a PathExpression.
        if (const auto *p1 = e1->to<PathExpression>()) {
            if (const auto *p2 = e2->to<PathExpression>()) {
                return compare(p1, p2);
            }
            if (e2->is<Member>()) {
                return -1;
            }
        }
        BUG("Not a valid StateVariable: %1%", e1);
    }

    int compare(const Member *m1, const Member *m2) const {
        auto result = compare(m1->expr, m2->expr);
        if (result != 0) {
            return result;
        }
        if (m1->member.name < m2->member.name) {
            return -1;
        }
        if (m1->member.name > m2->member.name) {
            return 1;
        }
        return 0;
    }

    int compare(const PathExpression *p1, const PathExpression *p2) const {
        if (p1->path->name.name < p2->path->name.name) {
            return -1;
        }
        if (p1->path->name.name > p2->path->name.name) {
            return 1;
        }
        return 0;
    }

    toString { return member->toString(); }

    dbprint { member->dbprint(out); }
}

/// Signifies that a particular expression is tainted.
/// This tainted expression must be resolved explicitly.
class TaintExpression : Expression {
    toString { return "TaintedExpression(" + type->toString() + ")"; }

    dbprint { out << "TaintedExpression(" << type << ")"; }
}

/// This type replaces Type_Varbits and can store information about the current size
class Extracted_Varbits : Type_Bits {
    /// The assigned size of this varbit (assigned by extract calls).
    int assignedSize;

    /// Returns the current width this variable bit type has.
    int width_bits() const override { return assignedSize; }

    equiv {
        // Ignore the current size and only check for equivalence of the assigned size.
        return size == a.size;
    }

    operator== {
        // Ignore the current size and only check for equivalence of the assigned size.
        return size == a.size;
    }

    cstring baseName() const { return "SizedVarbit"; }

    toString {
        return baseName() + "<" + Util::toString(size) + ">" + "<" + Util::toString(assignedSize) +
               ">";
    }

    dbprint { out << toString(); }
}

/// Defines a concolic variable that may be part of expressions.
/// This variable must later be resolved and is converted in a symbolic expression.
class ConcolicVariable : Expression {
    /// The name of the concolic method that this variable targets.
    cstring concolicMethodName;

    /// Arguments to the concolic method.
    Vector<Argument> arguments;

    /// The unique identifier of the source the produces this concolic variable.
    int srcIdentifier;

    /// Some identifiers produce multiple concolic variables. This ID keeps track of the offsets.
    int concolicId;

    /// Nodes that are associated with this concolic variable. This may be declarations.
    optional inline IndexedVector<Node> associatedNodes;

    /// This is the member representation of this concolic variable.
    Member concolicMember = nullptr;

    toString {
        cstring argumentStr;
        cstring sep = "";
        for (auto arg : *arguments) {
            argumentStr += sep + arg->toString();
            sep = ", ";
        }
        return "Concolic_" + concolicMethodName + "_" + srcIdentifier + "_" + concolicId + "(" +
               argumentStr + ")";
    }

    dbprint {
        out << "Concolic_" << concolicMethodName << "_" << srcIdentifier << "_" << concolicId << "("
            << arguments << ")";
    }

    visit_children { v.visit(type, "type"); }

    ConcolicVariable {
        std::stringstream varName;
        varName << concolicMethodName << "_" << srcIdentifier;
        concolicMember =
            new Member(srcInfo, type, new PathExpression(new Path(varName.str().c_str())),
                       std::to_string(concolicId).c_str());
    }
}
