<!-- HTML header for doxygen 1.12.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>P4 Compiler Documentation (P4C): PHV::Allocation Class Reference</title>
<link rel="icon" href="p4-fav.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!--  Add link to paragraphs   -->
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
  DoxygenAwesomeParagraphLink.init()
</script>
<!-- Add copy button to code fragments  -->
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
  DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add dark mode toggle -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
  DoxygenAwesomeDarkModeToggle.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="cards.css" rel="stylesheet" type="text/css"/>
<link href="flow.css" rel="stylesheet" type="text/css"/>
<link href="p4c_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="p4-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">P4C
   </div>
   <div id="projectbrief">The P4 Compiler</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_p_h_v_1_1_allocation.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_p_h_v_1_1_allocation-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">PHV::Allocation Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="phv_2utils_2utils_8h_source.html">utils.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PHV::Allocation:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_p_h_v_1_1_allocation__inherit__graph.svg" width="344" height="110"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_h_v_1_1_allocation_1_1_available_spot.html">AvailableSpot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Available bits of this allocation.  <a href="struct_p_h_v_1_1_allocation_1_1_available_spot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_h_v_1_1_allocation_1_1_conditional_constraint_data.html">ConditionalConstraintData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_p_h_v_1_1_allocation_1_1_container_status" id="r_struct_p_h_v_1_1_allocation_1_1_container_status"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#struct_p_h_v_1_1_allocation_1_1_container_status">ContainerStatus</a></td></tr>
<tr class="separator:struct_p_h_v_1_1_allocation_1_1_container_status"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0d4a6570ed34bcfecd07dd0e876a2f17" id="r_a0d4a6570ed34bcfecd07dd0e876a2f17"><td class="memItemLeft" align="right" valign="top"><a id="a0d4a6570ed34bcfecd07dd0e876a2f17" name="a0d4a6570ed34bcfecd07dd0e876a2f17"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ConditionalConstraint</b> = <a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt;<a class="el" href="class_p_h_v_1_1_field_slice.html">PHV::FieldSlice</a>, <a class="el" href="struct_p_h_v_1_1_allocation_1_1_conditional_constraint_data.html">ConditionalConstraintData</a>&gt;</td></tr>
<tr class="separator:a0d4a6570ed34bcfecd07dd0e876a2f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d0bbe865535465257b366e6a0e96c6" id="r_a82d0bbe865535465257b366e6a0e96c6"><td class="memItemLeft" align="right" valign="top"><a id="a82d0bbe865535465257b366e6a0e96c6" name="a82d0bbe865535465257b366e6a0e96c6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ConditionalConstraints</b> = <a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt;int, <a class="el" href="class_p4_1_1ordered__map.html">ConditionalConstraint</a>&gt;</td></tr>
<tr class="separator:a82d0bbe865535465257b366e6a0e96c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4228d3c82940b63f39e52cdcca10e0" id="r_a1f4228d3c82940b63f39e52cdcca10e0"><td class="memItemLeft" align="right" valign="top"><a id="a1f4228d3c82940b63f39e52cdcca10e0" name="a1f4228d3c82940b63f39e52cdcca10e0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = <a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt;<a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a>, <a class="el" href="#struct_p_h_v_1_1_allocation_1_1_container_status">ContainerStatus</a>&gt;::const_iterator</td></tr>
<tr class="separator:a1f4228d3c82940b63f39e52cdcca10e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543630b9cf188be5b91caf2691b3e537" id="r_a543630b9cf188be5b91caf2691b3e537"><td class="memItemLeft" align="right" valign="top"><a id="a543630b9cf188be5b91caf2691b3e537" name="a543630b9cf188be5b91caf2691b3e537"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>ContainerAllocStatus</b> { <b>EMPTY</b>
, <b>PARTIAL</b>
, <b>FULL</b>
 }</td></tr>
<tr class="separator:a543630b9cf188be5b91caf2691b3e537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2674067d410169e068de4b8e1291bec1" id="r_a2674067d410169e068de4b8e1291bec1"><td class="memItemLeft" align="right" valign="top"><a id="a2674067d410169e068de4b8e1291bec1" name="a2674067d410169e068de4b8e1291bec1"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>ExtractSource</b> { <b>NONE</b>
, <b>PACKET</b>
, <b>NON_PACKET</b>
 }</td></tr>
<tr class="separator:a2674067d410169e068de4b8e1291bec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab118bc6dab99a1b9b3b236a7e168659d" id="r_ab118bc6dab99a1b9b3b236a7e168659d"><td class="memItemLeft" align="right" valign="top"><a id="ab118bc6dab99a1b9b3b236a7e168659d" name="ab118bc6dab99a1b9b3b236a7e168659d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>FieldStatus</b> = <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt;<a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a>&gt;</td></tr>
<tr class="separator:ab118bc6dab99a1b9b3b236a7e168659d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5731b4a8b7983b0808ae529b8b68140f" id="r_a5731b4a8b7983b0808ae529b8b68140f"><td class="memItemLeft" align="right" valign="top"><a id="a5731b4a8b7983b0808ae529b8b68140f" name="a5731b4a8b7983b0808ae529b8b68140f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>GressAssignment</b> = std::optional&lt;gress_t&gt;</td></tr>
<tr class="separator:a5731b4a8b7983b0808ae529b8b68140f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb1ff4f02f214a38f040c560c3c5269" id="r_a7fb1ff4f02f214a38f040c560c3c5269"><td class="memItemLeft" align="right" valign="top"><a id="a7fb1ff4f02f214a38f040c560c3c5269" name="a7fb1ff4f02f214a38f040c560c3c5269"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>LiveRangeShrinkingMap</b> = <a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt;const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *, <a class="el" href="class_p4_1_1ordered__set.html">ActionSet</a>&gt;</td></tr>
<tr class="separator:a7fb1ff4f02f214a38f040c560c3c5269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11c1702c2e02569913527d9f5e3a7c8" id="r_aa11c1702c2e02569913527d9f5e3a7c8"><td class="memItemLeft" align="right" valign="top"><a id="aa11c1702c2e02569913527d9f5e3a7c8" name="aa11c1702c2e02569913527d9f5e3a7c8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MutuallyLiveSlices</b> = <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt;<a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a>&gt;</td></tr>
<tr class="separator:aa11c1702c2e02569913527d9f5e3a7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a414d6139241b9ab2cf87e63f041f05d2" id="r_a414d6139241b9ab2cf87e63f041f05d2"><td class="memItemLeft" align="right" valign="top"><a id="a414d6139241b9ab2cf87e63f041f05d2" name="a414d6139241b9ab2cf87e63f041f05d2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addARAedge</b> (gress_t grs, const IR::MAU::Table *src, const IR::MAU::Table *dst) const</td></tr>
<tr class="memdesc:a414d6139241b9ab2cf87e63f041f05d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a pair of tables in the ara_edges for a new ARA table. <br /></td></tr>
<tr class="separator:a414d6139241b9ab2cf87e63f041f05d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2526eec575d043f847627f541c22dc1c" id="r_a2526eec575d043f847627f541c22dc1c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2526eec575d043f847627f541c22dc1c">addDarkAllocation</a> (const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &amp;slice)</td></tr>
<tr class="separator:a2526eec575d043f847627f541c22dc1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5037f1085345431b2a1be70a7dda4405" id="r_a5037f1085345431b2a1be70a7dda4405"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5037f1085345431b2a1be70a7dda4405">addMetadataInitialization</a> (<a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> slice, <a class="el" href="class_p4_1_1ordered__map.html">LiveRangeShrinkingMap</a> initNodes)</td></tr>
<tr class="separator:a5037f1085345431b2a1be70a7dda4405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30133c25b09e144d6bfc679f44ea017" id="r_aa30133c25b09e144d6bfc679f44ea017"><td class="memItemLeft" align="right" valign="top">virtual ContainerAllocStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa30133c25b09e144d6bfc679f44ea017">alloc_status</a> (<a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a> c) const</td></tr>
<tr class="separator:aa30133c25b09e144d6bfc679f44ea017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9155cdaf2ae07b68ee972f05ce2c0b3" id="r_ae9155cdaf2ae07b68ee972f05ce2c0b3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9155cdaf2ae07b68ee972f05ce2c0b3">allocate</a> (const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> slice, <a class="el" href="class_p4_1_1ordered__map.html">LiveRangeShrinkingMap</a> *initNodes=nullptr, bool singleGressParserGroup=false)</td></tr>
<tr class="separator:ae9155cdaf2ae07b68ee972f05ce2c0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629d9dae7262a33cfdf3a50eec9bd784" id="r_a629d9dae7262a33cfdf3a50eec9bd784"><td class="memItemLeft" align="right" valign="top"><a id="a629d9dae7262a33cfdf3a50eec9bd784" name="a629d9dae7262a33cfdf3a50eec9bd784"></a>
std::set&lt; <a class="el" href="struct_p_h_v_1_1_allocation_1_1_available_spot.html">AvailableSpot</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>available_spots</b> () const</td></tr>
<tr class="memdesc:a629d9dae7262a33cfdf3a50eec9bd784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a set of available spots of this allocation. <br /></td></tr>
<tr class="separator:a629d9dae7262a33cfdf3a50eec9bd784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92aafbaade8ebd6c412988524ec29562" id="r_a92aafbaade8ebd6c412988524ec29562"><td class="memItemLeft" align="right" valign="top">virtual const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92aafbaade8ebd6c412988524ec29562">begin</a> () const =0</td></tr>
<tr class="memdesc:a92aafbaade8ebd6c412988524ec29562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate through container--&gt;allocation slices.  <br /></td></tr>
<tr class="separator:a92aafbaade8ebd6c412988524ec29562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0230942e8a1ca47a46bb5ac4f9b3bd21" id="r_a0230942e8a1ca47a46bb5ac4f9b3bd21"><td class="memItemLeft" align="right" valign="top"><a id="a0230942e8a1ca47a46bb5ac4f9b3bd21" name="a0230942e8a1ca47a46bb5ac4f9b3bd21"></a>
virtual <a class="el" href="class_p4_1_1ordered__set.html">MutuallyLiveSlices</a>&#160;</td><td class="memItemRight" valign="bottom"><b>byteSlicesByLiveness</b> (const <a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a> c, const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &amp;sl, const <a class="el" href="group___lower_parser.html#class_pragma_no_init">PragmaNoInit</a> &amp;noInit) const</td></tr>
<tr class="separator:a0230942e8a1ca47a46bb5ac4f9b3bd21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e23c0cabc4de17b259abdedb7e595f" id="r_a49e23c0cabc4de17b259abdedb7e595f"><td class="memItemLeft" align="right" valign="top"><a id="a49e23c0cabc4de17b259abdedb7e595f" name="a49e23c0cabc4de17b259abdedb7e595f"></a>
<a class="el" href="class_p_h_v_1_1_transaction.html">Transaction</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>clone</b> (const <a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a> &amp;parent) const</td></tr>
<tr class="memdesc:a49e23c0cabc4de17b259abdedb7e595f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the child from the parent transaction and return a cloned version of the difference. <br /></td></tr>
<tr class="separator:a49e23c0cabc4de17b259abdedb7e595f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e75ef84cbe8e6bb55ffa1597eb296a" id="r_a36e75ef84cbe8e6bb55ffa1597eb296a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p4_1_1cstring.html">cstring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36e75ef84cbe8e6bb55ffa1597eb296a">commit</a> (<a class="el" href="class_p_h_v_1_1_transaction.html">Transaction</a> &amp;view)</td></tr>
<tr class="separator:a36e75ef84cbe8e6bb55ffa1597eb296a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa082d7f5634a91856d00d52a1670ba97" id="r_aa082d7f5634a91856d00d52a1670ba97"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa082d7f5634a91856d00d52a1670ba97">contains</a> (<a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a> c) const =0</td></tr>
<tr class="separator:aa082d7f5634a91856d00d52a1670ba97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34a2f4e1794dd7832c26aad15db005d" id="r_ae34a2f4e1794dd7832c26aad15db005d"><td class="memItemLeft" align="right" valign="top">virtual GressAssignment&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae34a2f4e1794dd7832c26aad15db005d">deparserGroupGress</a> (<a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a> c) const</td></tr>
<tr class="separator:ae34a2f4e1794dd7832c26aad15db005d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7314dd4bb09e74e6d2ec5bade4cad917" id="r_a7314dd4bb09e74e6d2ec5bade4cad917"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7314dd4bb09e74e6d2ec5bade4cad917">empty_containers</a> (<a class="el" href="namespace_p_h_v.html#a3ff115c4ef9dcfb7a3565ddc263f0ece">PHV::Size</a> <a class="el" href="#a9fd96fafd4733fda8591fb4d26a04ff7">size</a>) const</td></tr>
<tr class="separator:a7314dd4bb09e74e6d2ec5bade4cad917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b2f74a81096369b51b48d48179bd5c" id="r_a69b2f74a81096369b51b48d48179bd5c"><td class="memItemLeft" align="right" valign="top">virtual const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69b2f74a81096369b51b48d48179bd5c">end</a> () const =0</td></tr>
<tr class="separator:a69b2f74a81096369b51b48d48179bd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046a695f0ed867dcf749bfe6fa6e8117" id="r_a046a695f0ed867dcf749bfe6fa6e8117"><td class="memItemLeft" align="right" valign="top"><a id="a046a695f0ed867dcf749bfe6fa6e8117" name="a046a695f0ed867dcf749bfe6fa6e8117"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>foreach_slice</b> (const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *f, <a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> range, int stage, <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> access, std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &amp;)&gt; cb) const</td></tr>
<tr class="separator:a046a695f0ed867dcf749bfe6fa6e8117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad465467c224f87d9ca59e1ff763c70" id="r_a4ad465467c224f87d9ca59e1ff763c70"><td class="memItemLeft" align="right" valign="top"><a id="a4ad465467c224f87d9ca59e1ff763c70" name="a4ad465467c224f87d9ca59e1ff763c70"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>foreach_slice</b> (const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *f, <a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> range, std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &amp;)&gt; cb) const</td></tr>
<tr class="separator:a4ad465467c224f87d9ca59e1ff763c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba42e9eb9401a7a68ed6aec7f150adb2" id="r_aba42e9eb9401a7a68ed6aec7f150adb2"><td class="memItemLeft" align="right" valign="top"><a id="aba42e9eb9401a7a68ed6aec7f150adb2" name="aba42e9eb9401a7a68ed6aec7f150adb2"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>foreach_slice</b> (const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *f, std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &amp;)&gt; cb) const =0</td></tr>
<tr class="separator:aba42e9eb9401a7a68ed6aec7f150adb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a207215e50b272a26c3e3e8bd4a86df42" id="r_a207215e50b272a26c3e3e8bd4a86df42"><td class="memItemLeft" align="right" valign="top"><a id="a207215e50b272a26c3e3e8bd4a86df42" name="a207215e50b272a26c3e3e8bd4a86df42"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>foreach_slice</b> (<a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a> c, int stage, <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> access, std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &amp;)&gt; cb) const</td></tr>
<tr class="separator:a207215e50b272a26c3e3e8bd4a86df42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a0eb28d1133e782e2a2f5cf2b52b30" id="r_a39a0eb28d1133e782e2a2f5cf2b52b30"><td class="memItemLeft" align="right" valign="top"><a id="a39a0eb28d1133e782e2a2f5cf2b52b30" name="a39a0eb28d1133e782e2a2f5cf2b52b30"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>foreach_slice</b> (<a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a> c, <a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> range, int stage, <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> access, std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &amp;)&gt; cb) const</td></tr>
<tr class="separator:a39a0eb28d1133e782e2a2f5cf2b52b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718cd32b0930b663cdf93a14a042a17f" id="r_a718cd32b0930b663cdf93a14a042a17f"><td class="memItemLeft" align="right" valign="top"><a id="a718cd32b0930b663cdf93a14a042a17f" name="a718cd32b0930b663cdf93a14a042a17f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>foreach_slice</b> (<a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a> c, <a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> range, std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &amp;)&gt; cb) const</td></tr>
<tr class="separator:a718cd32b0930b663cdf93a14a042a17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f84828e044275af88679377fe7d5930" id="r_a0f84828e044275af88679377fe7d5930"><td class="memItemLeft" align="right" valign="top"><a id="a0f84828e044275af88679377fe7d5930" name="a0f84828e044275af88679377fe7d5930"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>foreach_slice</b> (<a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a> c, std::function&lt; void(const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &amp;)&gt; cb) const</td></tr>
<tr class="separator:a0f84828e044275af88679377fe7d5930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4b9afd61605eb535c39a9828f1de24" id="r_a0a4b9afd61605eb535c39a9828f1de24"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt; gress_t, <a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt; const IR::MAU::Table *, std::set&lt; const IR::MAU::Table * &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a4b9afd61605eb535c39a9828f1de24">getARAedges</a> () const</td></tr>
<tr class="separator:a0a4b9afd61605eb535c39a9828f1de24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7ae951612454702bf3ac04eed5f882" id="r_aee7ae951612454702bf3ac04eed5f882"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="class_p4_1_1ordered__set.html">ActionSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee7ae951612454702bf3ac04eed5f882">getInitPoints</a> (const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &amp;slice) const</td></tr>
<tr class="separator:aee7ae951612454702bf3ac04eed5f882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fca89a937887d44c96d01c39334221c" id="r_a4fca89a937887d44c96d01c39334221c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_p4_1_1ordered__set.html">ActionSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fca89a937887d44c96d01c39334221c">getInitPointsForField</a> (const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *f) const</td></tr>
<tr class="separator:a4fca89a937887d44c96d01c39334221c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a83fd8b7173dfdd069d892cb7495de2" id="r_a6a83fd8b7173dfdd069d892cb7495de2"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a83fd8b7173dfdd069d892cb7495de2">getMetadataInits</a> (const IR::MAU::Action *act) const</td></tr>
<tr class="separator:a6a83fd8b7173dfdd069d892cb7495de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e60ca0692e8dd2f86643c6bad0fcd1" id="r_ac7e60ca0692e8dd2f86643c6bad0fcd1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt; const IR::BFN::ParserState *, std::set&lt; <a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7e60ca0692e8dd2f86643c6bad0fcd1">getParserStateToContainers</a> (const <a class="el" href="class_phv_info.html">PhvInfo</a> &amp;phv, const <a class="el" href="class_map_field_to_parser_states.html">MapFieldToParserStates</a> &amp;field_to_parser_states) const</td></tr>
<tr class="separator:ac7e60ca0692e8dd2f86643c6bad0fcd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b15347949d3ed8d88e79c091dd389e" id="r_a49b15347949d3ed8d88e79c091dd389e"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="#struct_p_h_v_1_1_allocation_1_1_container_status">ContainerStatus</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49b15347949d3ed8d88e79c091dd389e">getStatus</a> (const <a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a> &amp;c) const =0</td></tr>
<tr class="separator:a49b15347949d3ed8d88e79c091dd389e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf850aa7fc96b8e40cf29820ca57cc87" id="r_acf850aa7fc96b8e40cf29820ca57cc87"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_p4_1_1ordered__set.html">FieldStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf850aa7fc96b8e40cf29820ca57cc87">getStatus</a> (const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *f) const =0</td></tr>
<tr class="separator:acf850aa7fc96b8e40cf29820ca57cc87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d297f039d7bc3588ba9892072fd4e21" id="r_a7d297f039d7bc3588ba9892072fd4e21"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d297f039d7bc3588ba9892072fd4e21">getTagalongCollectionsUsed</a> () const</td></tr>
<tr class="separator:a7d297f039d7bc3588ba9892072fd4e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d37b88acfc91d0adf03a629d429faca" id="r_a6d37b88acfc91d0adf03a629d429faca"><td class="memItemLeft" align="right" valign="top">virtual GressAssignment&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d37b88acfc91d0adf03a629d429faca">gress</a> (const <a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a> &amp;c) const</td></tr>
<tr class="separator:a6d37b88acfc91d0adf03a629d429faca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ba0b6c9e13daf3005e6f11cf00f183" id="r_a83ba0b6c9e13daf3005e6f11cf00f183"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83ba0b6c9e13daf3005e6f11cf00f183">isDarkReadAvailable</a> (<a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a> c, unsigned minStage, unsigned maxStage) const</td></tr>
<tr class="separator:a83ba0b6c9e13daf3005e6f11cf00f183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745173e74ecbc16198acc0b677a58177" id="r_a745173e74ecbc16198acc0b677a58177"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a745173e74ecbc16198acc0b677a58177">isDarkWriteAvailable</a> (<a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a> c, unsigned minStage, unsigned maxStage) const</td></tr>
<tr class="separator:a745173e74ecbc16198acc0b677a58177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9b9b8c0becc59fa98320cc2e06f240" id="r_a3d9b9b8c0becc59fa98320cc2e06f240"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_p4_1_1ordered__set.html">MutuallyLiveSlices</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d9b9b8c0becc59fa98320cc2e06f240">liverange_overlapped_slices</a> (const <a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a> c, const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &gt; &amp;<a class="el" href="#a679cf47cdd03452ae1c620e962db6cf0">slices</a>) const</td></tr>
<tr class="separator:a3d9b9b8c0becc59fa98320cc2e06f240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e7021614988fd7456cd5c9c9833970" id="r_af0e7021614988fd7456cd5c9c9833970"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_p_h_v_1_1_transaction.html">Transaction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0e7021614988fd7456cd5c9c9833970">makeTransaction</a> () const</td></tr>
<tr class="memdesc:af0e7021614988fd7456cd5c9c9833970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Transaction based on this Allocation.  <br /></td></tr>
<tr class="separator:af0e7021614988fd7456cd5c9c9833970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5a98bd2c457d1c9625c3f52e1773a9" id="r_a6a5a98bd2c457d1c9625c3f52e1773a9"><td class="memItemLeft" align="right" valign="top">virtual ExtractSource&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a5a98bd2c457d1c9625c3f52e1773a9">parserExtractGroupSource</a> (<a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a> c) const</td></tr>
<tr class="separator:a6a5a98bd2c457d1c9625c3f52e1773a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a668d3eadd190801a6ee8dc396bc21606" id="r_a668d3eadd190801a6ee8dc396bc21606"><td class="memItemLeft" align="right" valign="top">virtual GressAssignment&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a668d3eadd190801a6ee8dc396bc21606">parserGroupGress</a> (<a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a> c) const</td></tr>
<tr class="separator:a668d3eadd190801a6ee8dc396bc21606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e55e27e460311f915c2b56235aba510" id="r_a9e55e27e460311f915c2b56235aba510"><td class="memItemLeft" align="right" valign="top"><a id="a9e55e27e460311f915c2b56235aba510" name="a9e55e27e460311f915c2b56235aba510"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>printARAedges</b> () const</td></tr>
<tr class="separator:a9e55e27e460311f915c2b56235aba510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc594b3fc9913767a3c2c94fac70691" id="r_a2cc594b3fc9913767a3c2c94fac70691"><td class="memItemLeft" align="right" valign="top"><a id="a2cc594b3fc9913767a3c2c94fac70691" name="a2cc594b3fc9913767a3c2c94fac70691"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>removeAllocatedSlice</b> (const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; &amp;<a class="el" href="#a679cf47cdd03452ae1c620e962db6cf0">slices</a>)</td></tr>
<tr class="separator:a2cc594b3fc9913767a3c2c94fac70691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd96fafd4733fda8591fb4d26a04ff7" id="r_a9fd96fafd4733fda8591fb4d26a04ff7"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9fd96fafd4733fda8591fb4d26a04ff7">size</a> () const =0</td></tr>
<tr class="separator:a9fd96fafd4733fda8591fb4d26a04ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd80184eeda92f8cf62e1e90078a8dec" id="r_abd80184eeda92f8cf62e1e90078a8dec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd80184eeda92f8cf62e1e90078a8dec">slices</a> (const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *f) const</td></tr>
<tr class="separator:abd80184eeda92f8cf62e1e90078a8dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dadb76f0b3901b92eca32ead353a84c" id="r_a8dadb76f0b3901b92eca32ead353a84c"><td class="memItemLeft" align="right" valign="top"><a id="a8dadb76f0b3901b92eca32ead353a84c" name="a8dadb76f0b3901b92eca32ead353a84c"></a>
<a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>slices</b> (const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *f, int stage, <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> access) const</td></tr>
<tr class="separator:a8dadb76f0b3901b92eca32ead353a84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aedf1a20f9ffd1e087ca6f22bc25922" id="r_a8aedf1a20f9ffd1e087ca6f22bc25922"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8aedf1a20f9ffd1e087ca6f22bc25922">slices</a> (const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *f, <a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> range) const</td></tr>
<tr class="separator:a8aedf1a20f9ffd1e087ca6f22bc25922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96678af713bcfe93ad95f5428e1cd5a" id="r_af96678af713bcfe93ad95f5428e1cd5a"><td class="memItemLeft" align="right" valign="top"><a id="af96678af713bcfe93ad95f5428e1cd5a" name="af96678af713bcfe93ad95f5428e1cd5a"></a>
<a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>slices</b> (const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *f, <a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> range, int stage, <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> access) const</td></tr>
<tr class="separator:af96678af713bcfe93ad95f5428e1cd5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679cf47cdd03452ae1c620e962db6cf0" id="r_a679cf47cdd03452ae1c620e962db6cf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a679cf47cdd03452ae1c620e962db6cf0">slices</a> (<a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a> c) const</td></tr>
<tr class="separator:a679cf47cdd03452ae1c620e962db6cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485a70b4bd24c6f34642c485eb777533" id="r_a485a70b4bd24c6f34642c485eb777533"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a485a70b4bd24c6f34642c485eb777533">slices</a> (<a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a> c, int stage, <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> access) const</td></tr>
<tr class="separator:a485a70b4bd24c6f34642c485eb777533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae307cfa59fe838dab51d1e78f0c1d50b" id="r_ae307cfa59fe838dab51d1e78f0c1d50b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae307cfa59fe838dab51d1e78f0c1d50b">slices</a> (<a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a> c, <a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> range) const</td></tr>
<tr class="separator:ae307cfa59fe838dab51d1e78f0c1d50b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c296f6469eb7efa56c9b16ff4c0f74" id="r_ac2c296f6469eb7efa56c9b16ff4c0f74"><td class="memItemLeft" align="right" valign="top"><a id="ac2c296f6469eb7efa56c9b16ff4c0f74" name="ac2c296f6469eb7efa56c9b16ff4c0f74"></a>
<a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>slices</b> (<a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a> c, <a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a> range, int stage, <a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a> access) const</td></tr>
<tr class="separator:ac2c296f6469eb7efa56c9b16ff4c0f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70b1093b39166ce635238579630a10b" id="r_ac70b1093b39166ce635238579630a10b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_p4_1_1ordered__set.html">MutuallyLiveSlices</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac70b1093b39166ce635238579630a10b">slicesByLiveness</a> (const <a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a> c, const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &amp;sl) const</td></tr>
<tr class="separator:ac70b1093b39166ce635238579630a10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1826ddd63b099ef6610f0f8019e483" id="r_a0f1826ddd63b099ef6610f0f8019e483"><td class="memItemLeft" align="right" valign="top"><a id="a0f1826ddd63b099ef6610f0f8019e483" name="a0f1826ddd63b099ef6610f0f8019e483"></a>
virtual <a class="el" href="class_p4_1_1ordered__set.html">MutuallyLiveSlices</a>&#160;</td><td class="memItemRight" valign="bottom"><b>slicesByLiveness</b> (const <a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a> c, std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &gt; &amp;<a class="el" href="#a679cf47cdd03452ae1c620e962db6cf0">slices</a>) const</td></tr>
<tr class="separator:a0f1826ddd63b099ef6610f0f8019e483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fdccef4ce20ddcc7d600e7c270ee4f8" id="r_a9fdccef4ce20ddcc7d600e7c270ee4f8"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="class_p4_1_1ordered__set.html">MutuallyLiveSlices</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9fdccef4ce20ddcc7d600e7c270ee4f8">slicesByLiveness</a> (<a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a> c) const</td></tr>
<tr class="separator:a9fdccef4ce20ddcc7d600e7c270ee4f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8821ab69f8a0df68a922d6c864b7332" id="r_aa8821ab69f8a0df68a922d6c864b7332"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_p4_1_1cstring.html">cstring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8821ab69f8a0df68a922d6c864b7332">toString</a> () const</td></tr>
<tr class="separator:aa8821ab69f8a0df68a922d6c864b7332"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a720a7b1cea7d20d5d3dc6ed7be391cf7" id="r_a720a7b1cea7d20d5d3dc6ed7be391cf7"><td class="memItemLeft" align="right" valign="top"><a id="a720a7b1cea7d20d5d3dc6ed7be391cf7" name="a720a7b1cea7d20d5d3dc6ed7be391cf7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Allocation</b> (const <a class="el" href="class_phv_info.html">PhvInfo</a> &amp;phv, const <a class="el" href="class_phv_use.html">PhvUse</a> &amp;uses, bool isTrivial=false)</td></tr>
<tr class="separator:a720a7b1cea7d20d5d3dc6ed7be391cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5145402ae68af25b937ca6e3895517c" id="r_af5145402ae68af25b937ca6e3895517c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a>, <a class="el" href="class_p4_1_1ordered__set.html">ActionSet</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5145402ae68af25b937ca6e3895517c">get_meta_init_points</a> () const</td></tr>
<tr class="separator:af5145402ae68af25b937ca6e3895517c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a870e0419befbf6d30c4deade7608ad4d" id="r_a870e0419befbf6d30c4deade7608ad4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt; gress_t, <a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt; const IR::MAU::Table *, std::set&lt; const IR::MAU::Table * &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a870e0419befbf6d30c4deade7608ad4d">ara_edges</a></td></tr>
<tr class="separator:a870e0419befbf6d30c4deade7608ad4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df6d2fc66b75356bd7d425b86a7d7b0" id="r_a2df6d2fc66b75356bd7d425b86a7d7b0"><td class="memItemLeft" align="right" valign="top"><a id="a2df6d2fc66b75356bd7d425b86a7d7b0" name="a2df6d2fc66b75356bd7d425b86a7d7b0"></a>
<a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt; <a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a>, <a class="el" href="#struct_p_h_v_1_1_allocation_1_1_container_status">ContainerStatus</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>container_status_i</b></td></tr>
<tr class="separator:a2df6d2fc66b75356bd7d425b86a7d7b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e724f4b306a5a61a222f9a2f17e0e0" id="r_a78e724f4b306a5a61a222f9a2f17e0e0"><td class="memItemLeft" align="right" valign="top"><a id="a78e724f4b306a5a61a222f9a2f17e0e0" name="a78e724f4b306a5a61a222f9a2f17e0e0"></a>
<a class="el" href="classassoc_1_1hash__map.html">assoc::hash_map</a>&lt; <a class="el" href="namespace_p_h_v.html#a3ff115c4ef9dcfb7a3565ddc263f0ece">PHV::Size</a>, <a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt; ContainerAllocStatus, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>count_by_status_i</b></td></tr>
<tr class="separator:a78e724f4b306a5a61a222f9a2f17e0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c18259f94303669e58448a2414f056f" id="r_a2c18259f94303669e58448a2414f056f"><td class="memItemLeft" align="right" valign="top"><a id="a2c18259f94303669e58448a2414f056f" name="a2c18259f94303669e58448a2414f056f"></a>
<a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt; <a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a>, <a class="el" href="class_p4_1_1bitvec.html">bitvec</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>dark_containers_read_allocated_i</b></td></tr>
<tr class="separator:a2c18259f94303669e58448a2414f056f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485fa3f7938ef2e52fcb96a666c83c4c" id="r_a485fa3f7938ef2e52fcb96a666c83c4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt; <a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a>, <a class="el" href="class_p4_1_1bitvec.html">bitvec</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a485fa3f7938ef2e52fcb96a666c83c4c">dark_containers_write_allocated_i</a></td></tr>
<tr class="separator:a485fa3f7938ef2e52fcb96a666c83c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf1e3f6f412e34eb001499ec2e2875c" id="r_a1bf1e3f6f412e34eb001499ec2e2875c"><td class="memItemLeft" align="right" valign="top"><a id="a1bf1e3f6f412e34eb001499ec2e2875c" name="a1bf1e3f6f412e34eb001499ec2e2875c"></a>
<a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt; const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *, <a class="el" href="class_p4_1_1ordered__set.html">FieldStatus</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>field_status_i</b></td></tr>
<tr class="separator:a1bf1e3f6f412e34eb001499ec2e2875c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed59880f99ba17a670f56f17750c736" id="r_a8ed59880f99ba17a670f56f17750c736"><td class="memItemLeft" align="right" valign="top"><a id="a8ed59880f99ba17a670f56f17750c736" name="a8ed59880f99ba17a670f56f17750c736"></a>
DarkInitMap&#160;</td><td class="memItemRight" valign="bottom"><b>init_map_i</b></td></tr>
<tr class="memdesc:a8ed59880f99ba17a670f56f17750c736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization information about allocating to dark containers during certain stages. <br /></td></tr>
<tr class="separator:a8ed59880f99ba17a670f56f17750c736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcfb24182fa901919cd22604627da920" id="r_afcfb24182fa901919cd22604627da920"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt; const IR::MAU::Action *, <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afcfb24182fa901919cd22604627da920">init_writes_i</a></td></tr>
<tr class="separator:afcfb24182fa901919cd22604627da920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e759c6372718e291dcf71dc469d466" id="r_aa4e759c6372718e291dcf71dc469d466"><td class="memItemLeft" align="right" valign="top"><a id="aa4e759c6372718e291dcf71dc469d466" name="aa4e759c6372718e291dcf71dc469d466"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isTrivial</b></td></tr>
<tr class="separator:aa4e759c6372718e291dcf71dc469d466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142627ff4c74ef89f24652bbc4eece45" id="r_a142627ff4c74ef89f24652bbc4eece45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a>, <a class="el" href="class_p4_1_1ordered__set.html">ActionSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a142627ff4c74ef89f24652bbc4eece45">meta_init_points_i</a></td></tr>
<tr class="separator:a142627ff4c74ef89f24652bbc4eece45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7a101c1e9f483f512b17388754e384" id="r_aec7a101c1e9f483f512b17388754e384"><td class="memItemLeft" align="right" valign="top"><a id="aec7a101c1e9f483f512b17388754e384" name="aec7a101c1e9f483f512b17388754e384"></a>
const <a class="el" href="class_phv_info.html">PhvInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>phv_i</b></td></tr>
<tr class="separator:aec7a101c1e9f483f512b17388754e384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa92787f8b288fedd82d60576074e1470" id="r_aa92787f8b288fedd82d60576074e1470"><td class="memItemLeft" align="right" valign="top"><a id="aa92787f8b288fedd82d60576074e1470" name="aa92787f8b288fedd82d60576074e1470"></a>
<a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt; const IR::BFN::ParserState *, std::set&lt; <a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>state_to_containers_i</b></td></tr>
<tr class="memdesc:aa92787f8b288fedd82d60576074e1470"><td class="mdescLeft">&#160;</td><td class="mdescRight">parser state to containers <br /></td></tr>
<tr class="separator:aa92787f8b288fedd82d60576074e1470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573244f181949c3757a8164c3e294fa6" id="r_a573244f181949c3757a8164c3e294fa6"><td class="memItemLeft" align="right" valign="top"><a id="a573244f181949c3757a8164c3e294fa6" name="a573244f181949c3757a8164c3e294fa6"></a>
const <a class="el" href="class_phv_use.html">PhvUse</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>uses_i</b></td></tr>
<tr class="separator:a573244f181949c3757a8164c3e294fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a3cf6570fb288e44d482fd6e0b116b612" id="r_a3cf6570fb288e44d482fd6e0b116b612"><td class="memItemLeft" align="right" valign="top"><a id="a3cf6570fb288e44d482fd6e0b116b612" name="a3cf6570fb288e44d482fd6e0b116b612"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>AllocationReport</b></td></tr>
<tr class="separator:a3cf6570fb288e44d482fd6e0b116b612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49982aa325e19f0956d42fde9132caa2" id="r_a49982aa325e19f0956d42fde9132caa2"><td class="memItemLeft" align="right" valign="top"><a id="a49982aa325e19f0956d42fde9132caa2" name="a49982aa325e19f0956d42fde9132caa2"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Transaction</b></td></tr>
<tr class="separator:a49982aa325e19f0956d42fde9132caa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Keep track of the allocation of field slices to container slices, as well as the gress assignment of containers. Support speculative allocation and rollbacks with the Transaction mechanism. </p>
</div><hr/><h2 class="groupheader">Class Documentation</h2>
<a name="struct_p_h_v_1_1_allocation_1_1_container_status" id="struct_p_h_v_1_1_allocation_1_1_container_status"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_p_h_v_1_1_allocation_1_1_container_status">&#9670;&#160;</a></span>PHV::Allocation::ContainerStatus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct PHV::Allocation::ContainerStatus</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>This struct tracks PHV container state that can change during the course of allocation, such as the thread to which this container must be assigned, or the field slices that have been allocated to it. Because PHV allocation queries container status many, many times, this struct also contains a derived <code>alloc_status</code>, which summarizes the state of the container. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="ac25f41f666c8d6340b015ff122c86733" name="ac25f41f666c8d6340b015ff122c86733"></a>ContainerAllocStatus</td>
<td class="fieldname">
alloc_status</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="adb8b98b079afc1a42a1ee00ec5f7be6b" name="adb8b98b079afc1a42a1ee00ec5f7be6b"></a>GressAssignment</td>
<td class="fieldname">
deparserGroupGress</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="af157465d428274365afe8930f70824c5" name="af157465d428274365afe8930f70824c5"></a>GressAssignment</td>
<td class="fieldname">
gress</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a89d980b0c935aaa891e291ac1c9f3fb8" name="a89d980b0c935aaa891e291ac1c9f3fb8"></a>ExtractSource</td>
<td class="fieldname">
parserExtractGroupSource</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a46f7eaf89b3a144656c51d1eec83ca48" name="a46f7eaf89b3a144656c51d1eec83ca48"></a>GressAssignment</td>
<td class="fieldname">
parserGroupGress</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="aa020e2186fd62951834e42494cad4255" name="aa020e2186fd62951834e42494cad4255"></a><a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &gt;</td>
<td class="fieldname">
slices</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2526eec575d043f847627f541c22dc1c" name="a2526eec575d043f847627f541c22dc1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2526eec575d043f847627f541c22dc1c">&#9670;&#160;</a></span>addDarkAllocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PHV::Allocation::addDarkAllocation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slice</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add <code>slice</code> allocated to a dark container to the current Allocation object. </p><dl class="section return"><dt>Returns</dt><dd>true if the addition was successful. </dd></dl>

</div>
</div>
<a id="a5037f1085345431b2a1be70a7dda4405" name="a5037f1085345431b2a1be70a7dda4405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5037f1085345431b2a1be70a7dda4405">&#9670;&#160;</a></span>addMetadataInitialization()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PHV::Allocation::addMetadataInitialization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a></td>          <td class="paramname"><span class="paramname"><em>slice</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1ordered__map.html">LiveRangeShrinkingMap</a></td>          <td class="paramname"><span class="paramname"><em>initNodes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Uniform convenience abstraction for adding a metadata initialization node to the allocation object. </p>

</div>
</div>
<a id="aa30133c25b09e144d6bfc679f44ea017" name="aa30133c25b09e144d6bfc679f44ea017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa30133c25b09e144d6bfc679f44ea017">&#9670;&#160;</a></span>alloc_status()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PHV::Allocation::ContainerAllocStatus PHV::Allocation::alloc_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the allocation status of <code>c</code> and fails if <code>c</code> is not present. </dd></dl>

</div>
</div>
<a id="ae9155cdaf2ae07b68ee972f05ce2c0b3" name="ae9155cdaf2ae07b68ee972f05ce2c0b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9155cdaf2ae07b68ee972f05ce2c0b3">&#9670;&#160;</a></span>allocate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PHV::Allocation::allocate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a></td>          <td class="paramname"><span class="paramname"><em>slice</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p4_1_1ordered__map.html">LiveRangeShrinkingMap</a> *</td>          <td class="paramname"><span class="paramname"><em>initNodes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>singleGressParserGroup</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assign @slice to @slice.container, updating the gress information of the container and its MAU group if necessary. Fails if the gress of @slice.field does not match any gress in the MAU group.</p>
<p>Note that this adds new slices but does not remove or overwrite existing slices.</p>
<p>Assign <code>slice</code> to <code>slice.container</code>, updating the gress information of the container and its MAU group if necessary. Fails if the gress of <code>slice.field</code> does not match any gress in the MAU group. </p>

</div>
</div>
<a id="a92aafbaade8ebd6c412988524ec29562" name="a92aafbaade8ebd6c412988524ec29562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92aafbaade8ebd6c412988524ec29562">&#9670;&#160;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const_iterator PHV::Allocation::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate through container--&gt;allocation slices. </p>

<p>Implemented in <a class="el" href="class_p_h_v_1_1_concrete_allocation.html#abbe96e03d11b143798f8a3b507fa2c9f">PHV::ConcreteAllocation</a>, and <a class="el" href="class_p_h_v_1_1_transaction.html#ad398ec59f037c92f876e3ec0a61922bb">PHV::Transaction</a>.</p>

</div>
</div>
<a id="a36e75ef84cbe8e6bb55ffa1597eb296a" name="a36e75ef84cbe8e6bb55ffa1597eb296a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36e75ef84cbe8e6bb55ffa1597eb296a">&#9670;&#160;</a></span>commit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p4_1_1cstring.html">cstring</a> PHV::Allocation::commit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_h_v_1_1_transaction.html">Transaction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>view</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update this allocation with any new allocation in <code>view</code>. Note that this may add new slices but does not remove or overwrite existing slices. </p>

</div>
</div>
<a id="aa082d7f5634a91856d00d52a1670ba97" name="aa082d7f5634a91856d00d52a1670ba97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa082d7f5634a91856d00d52a1670ba97">&#9670;&#160;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PHV::Allocation::contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if this allocation owns <code>c</code>. </dd></dl>

<p>Implemented in <a class="el" href="class_p_h_v_1_1_concrete_allocation.html#a0130f2cdd5396c3c299b928aeb493072">PHV::ConcreteAllocation</a>, and <a class="el" href="class_p_h_v_1_1_transaction.html#a13c7d18a2027b690397f486db68c94e2">PHV::Transaction</a>.</p>

</div>
</div>
<a id="ae34a2f4e1794dd7832c26aad15db005d" name="ae34a2f4e1794dd7832c26aad15db005d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34a2f4e1794dd7832c26aad15db005d">&#9670;&#160;</a></span>deparserGroupGress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PHV::Allocation::GressAssignment PHV::Allocation::deparserGroupGress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the gress of <code>c's</code> deparser group, if any. If a container holds deparsed fields, then its gress must match that of its deparser group. </dd></dl>

</div>
</div>
<a id="a7314dd4bb09e74e6d2ec5bade4cad917" name="a7314dd4bb09e74e6d2ec5bade4cad917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7314dd4bb09e74e6d2ec5bade4cad917">&#9670;&#160;</a></span>empty_containers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PHV::Allocation::empty_containers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_p_h_v.html#a3ff115c4ef9dcfb7a3565ddc263f0ece">PHV::Size</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of empty containers of size <code>size</code>. </dd></dl>

</div>
</div>
<a id="a69b2f74a81096369b51b48d48179bd5c" name="a69b2f74a81096369b51b48d48179bd5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b2f74a81096369b51b48d48179bd5c">&#9670;&#160;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const_iterator PHV::Allocation::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="class_p_h_v_1_1_transaction.html#ae8ac8b111fe90d095a755acb571b22f1">PHV::Transaction</a>.</p>

</div>
</div>
<a id="af5145402ae68af25b937ca6e3895517c" name="af5145402ae68af25b937ca6e3895517c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5145402ae68af25b937ca6e3895517c">&#9670;&#160;</a></span>get_meta_init_points()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a>, <a class="el" href="class_p4_1_1ordered__set.html">ActionSet</a> &gt; &amp; PHV::Allocation::get_meta_init_points </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the meta_init_points_i map for the current allocation object. </dd></dl>

</div>
</div>
<a id="a0a4b9afd61605eb535c39a9828f1de24" name="a0a4b9afd61605eb535c39a9828f1de24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a4b9afd61605eb535c39a9828f1de24">&#9670;&#160;</a></span>getARAedges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt; gress_t, <a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt; const IR::MAU::Table *, std::set&lt; const IR::MAU::Table * &gt; &gt; &gt; &amp; PHV::Allocation::getARAedges </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the map of source tables to the set of target tables connected through the ARA overlays </dd></dl>

</div>
</div>
<a id="aee7ae951612454702bf3ac04eed5f882" name="aee7ae951612454702bf3ac04eed5f882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee7ae951612454702bf3ac04eed5f882">&#9670;&#160;</a></span>getInitPoints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="class_p4_1_1ordered__set.html">PHV::ActionSet</a> &gt; PHV::Allocation::getInitPoints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slice</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the set of actions where <code>slice</code> must be initialized for overlay enabled by live range shrinking. </dd></dl>

<p>Reimplemented in <a class="el" href="class_p_h_v_1_1_transaction.html#a404f5b93270fa448cc32e94c5994db3d">PHV::Transaction</a>.</p>

</div>
</div>
<a id="a4fca89a937887d44c96d01c39334221c" name="a4fca89a937887d44c96d01c39334221c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fca89a937887d44c96d01c39334221c">&#9670;&#160;</a></span>getInitPointsForField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p4_1_1ordered__set.html">PHV::ActionSet</a> PHV::Allocation::getInitPointsForField </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the set of initialization actions for the field <code>f</code>. </dd></dl>

<p>Reimplemented in <a class="el" href="class_p_h_v_1_1_transaction.html#a5cb3898eaaa4d2866ca651392dc29f20">PHV::Transaction</a>.</p>

</div>
</div>
<a id="a6a83fd8b7173dfdd069d892cb7495de2" name="a6a83fd8b7173dfdd069d892cb7495de2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a83fd8b7173dfdd069d892cb7495de2">&#9670;&#160;</a></span>getMetadataInits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> * &gt; PHV::Allocation::getMetadataInits </td>
          <td>(</td>
          <td class="paramtype">const IR::MAU::Action *</td>          <td class="paramname"><span class="paramname"><em>act</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>all the fields that must be initialized in action <code>act</code>. </dd></dl>

<p>Reimplemented in <a class="el" href="class_p_h_v_1_1_transaction.html#a234c40c1d59fafa92ab76883bccabfda">PHV::Transaction</a>.</p>

</div>
</div>
<a id="ac7e60ca0692e8dd2f86643c6bad0fcd1" name="ac7e60ca0692e8dd2f86643c6bad0fcd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7e60ca0692e8dd2f86643c6bad0fcd1">&#9670;&#160;</a></span>getParserStateToContainers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt; const IR::BFN::ParserState *, std::set&lt; <a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a> &gt; &gt; &amp; PHV::Allocation::getParserStateToContainers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_phv_info.html">PhvInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>phv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_map_field_to_parser_states.html">MapFieldToParserStates</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>field_to_parser_states</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>map from parser state to containers </dd></dl>

</div>
</div>
<a id="a49b15347949d3ed8d88e79c091dd389e" name="a49b15347949d3ed8d88e79c091dd389e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b15347949d3ed8d88e79c091dd389e">&#9670;&#160;</a></span>getStatus() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="#struct_p_h_v_1_1_allocation_1_1_container_status">ContainerStatus</a> * PHV::Allocation::getStatus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Uniform abstraction for accessing a container state. </p><dl class="section return"><dt>Returns</dt><dd>the ContainerStatus of this allocation, if present. Failing that, check its ancestors. If <code>has</code> no status yet, return nullptr. </dd></dl>

<p>Implemented in <a class="el" href="class_p_h_v_1_1_concrete_allocation.html#a90850fe616cef38fa07f2e5e45a95cfb">PHV::ConcreteAllocation</a>, and <a class="el" href="class_p_h_v_1_1_transaction.html#aeb2d08a968ebf95bcf9000c03210c29b">PHV::Transaction</a>.</p>

</div>
</div>
<a id="acf850aa7fc96b8e40cf29820ca57cc87" name="acf850aa7fc96b8e40cf29820ca57cc87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf850aa7fc96b8e40cf29820ca57cc87">&#9670;&#160;</a></span>getStatus() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_p4_1_1ordered__set.html">FieldStatus</a> PHV::Allocation::getStatus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Uniform abstraction for accessing field state. </p><dl class="section return"><dt>Returns</dt><dd>the FieldStatus of this allocation, if present. Failing that, check its ancestors. If <code>f</code> has no status yet, return an empty FieldStatus. </dd></dl>

<p>Implemented in <a class="el" href="class_p_h_v_1_1_concrete_allocation.html#ae5a6297b531da02c6ddf515793f6b4bc">PHV::ConcreteAllocation</a>, and <a class="el" href="class_p_h_v_1_1_transaction.html#ab454bfccd752bee93d6e35a3aaf791f7">PHV::Transaction</a>.</p>

</div>
</div>
<a id="a7d297f039d7bc3588ba9892072fd4e21" name="a7d297f039d7bc3588ba9892072fd4e21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d297f039d7bc3588ba9892072fd4e21">&#9670;&#160;</a></span>getTagalongCollectionsUsed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; unsigned &gt; PHV::Allocation::getTagalongCollectionsUsed </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>all tagalong collection IDs used </dd></dl>

</div>
</div>
<a id="a6d37b88acfc91d0adf03a629d429faca" name="a6d37b88acfc91d0adf03a629d429faca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d37b88acfc91d0adf03a629d429faca">&#9670;&#160;</a></span>gress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PHV::Allocation::GressAssignment PHV::Allocation::gress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the container status of <code>and</code> fails if <code>is</code> not present. </dd></dl>

</div>
</div>
<a id="a83ba0b6c9e13daf3005e6f11cf00f183" name="a83ba0b6c9e13daf3005e6f11cf00f183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83ba0b6c9e13daf3005e6f11cf00f183">&#9670;&#160;</a></span>isDarkReadAvailable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PHV::Allocation::isDarkReadAvailable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>minStage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>maxStage</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>false if a dark container is used for the read half cycle in between stages minStage and maxStage. </dd></dl>

<p>Reimplemented in <a class="el" href="class_p_h_v_1_1_transaction.html#ac2e082595990d6806e9f389289ebfddd">PHV::Transaction</a>.</p>

</div>
</div>
<a id="a745173e74ecbc16198acc0b677a58177" name="a745173e74ecbc16198acc0b677a58177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a745173e74ecbc16198acc0b677a58177">&#9670;&#160;</a></span>isDarkWriteAvailable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PHV::Allocation::isDarkWriteAvailable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>minStage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>maxStage</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>false if a dark container is used for the write half cycle in between stages minStage and maxStage. </dd></dl>

<p>Reimplemented in <a class="el" href="class_p_h_v_1_1_transaction.html#a8673e97e41ad8f8eaa99db7a7b50249f">PHV::Transaction</a>.</p>

</div>
</div>
<a id="a3d9b9b8c0becc59fa98320cc2e06f240" name="a3d9b9b8c0becc59fa98320cc2e06f240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d9b9b8c0becc59fa98320cc2e06f240">&#9670;&#160;</a></span>liverange_overlapped_slices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p4_1_1ordered__set.html">PHV::Allocation::MutuallyLiveSlices</a> PHV::Allocation::liverange_overlapped_slices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>slices</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a set of allocated slices that will live at the some stage in container <code>c</code> with any of the candidate slice in <code>slices</code>, i.e., not mutex and liverange not disjoint. </dd></dl>

</div>
</div>
<a id="af0e7021614988fd7456cd5c9c9833970" name="af0e7021614988fd7456cd5c9c9833970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e7021614988fd7456cd5c9c9833970">&#9670;&#160;</a></span>makeTransaction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p_h_v_1_1_transaction.html">PHV::Transaction</a> PHV::Allocation::makeTransaction </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a Transaction based on this Allocation. </p>
<dl class="section see"><dt>See also</dt><dd>PHV::Transaction for details. </dd></dl>

</div>
</div>
<a id="a6a5a98bd2c457d1c9625c3f52e1773a9" name="a6a5a98bd2c457d1c9625c3f52e1773a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5a98bd2c457d1c9625c3f52e1773a9">&#9670;&#160;</a></span>parserExtractGroupSource()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PHV::Allocation::ExtractSource PHV::Allocation::parserExtractGroupSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the source of <code>c's</code> parser extract group. All containers in a group must have the same source. </dd></dl>

</div>
</div>
<a id="a668d3eadd190801a6ee8dc396bc21606" name="a668d3eadd190801a6ee8dc396bc21606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a668d3eadd190801a6ee8dc396bc21606">&#9670;&#160;</a></span>parserGroupGress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PHV::Allocation::GressAssignment PHV::Allocation::parserGroupGress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the gress of <code>c's</code> parser group, if any. If a container holds extracted fields, then its gress must match that of its parser group. </dd></dl>

</div>
</div>
<a id="a9fd96fafd4733fda8591fb4d26a04ff7" name="a9fd96fafd4733fda8591fb4d26a04ff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd96fafd4733fda8591fb4d26a04ff7">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t PHV::Allocation::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of containers owned by this allocation. </dd></dl>

<p>Implemented in <a class="el" href="class_p_h_v_1_1_concrete_allocation.html#a1b374610810617fe162aef38c2dcbc24">PHV::ConcreteAllocation</a>, and <a class="el" href="class_p_h_v_1_1_transaction.html#a18cb6148f3c9f2622b14a2fb85d6a448">PHV::Transaction</a>.</p>

</div>
</div>
<a id="abd80184eeda92f8cf62e1e90078a8dec" name="abd80184eeda92f8cf62e1e90078a8dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd80184eeda92f8cf62e1e90078a8dec">&#9670;&#160;</a></span>slices() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; PHV::Allocation::slices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the set of slices allocated for the field <code>f</code> in this Allocation. May be empty (if <code>f</code> is not allocated) or contain slices that do not fully cover all bits of <code>f</code> (if <code>f</code> is only partially allocated). </dd></dl>

</div>
</div>
<a id="a8aedf1a20f9ffd1e087ca6f22bc25922" name="a8aedf1a20f9ffd1e087ca6f22bc25922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aedf1a20f9ffd1e087ca6f22bc25922">&#9670;&#160;</a></span>slices() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; PHV::Allocation::slices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a></td>          <td class="paramname"><span class="paramname"><em>range</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>all slices allocated for <code>f</code> that include any part of <code>range</code> in the field portion of the allocated slice. May be empty (if <code>f</code> is not allocated) or contain slices that do not fully cover all bits of <code>f</code> (if <code>f</code> is only partially allocated). </dd></dl>

</div>
</div>
<a id="a679cf47cdd03452ae1c620e962db6cf0" name="a679cf47cdd03452ae1c620e962db6cf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a679cf47cdd03452ae1c620e962db6cf0">&#9670;&#160;</a></span>slices() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; PHV::Allocation::slices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>all the slices allocated to <code>c</code>. </dd></dl>

</div>
</div>
<a id="a485a70b4bd24c6f34642c485eb777533" name="a485a70b4bd24c6f34642c485eb777533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a485a70b4bd24c6f34642c485eb777533">&#9670;&#160;</a></span>slices() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; PHV::Allocation::slices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>stage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_p_h_v_1_1_field_use.html">PHV::FieldUse</a></td>          <td class="paramname"><span class="paramname"><em>access</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>all the slices allocated to <code>c</code> and valid in the stage <code>stage</code>. </dd></dl>

</div>
</div>
<a id="ae307cfa59fe838dab51d1e78f0c1d50b" name="ae307cfa59fe838dab51d1e78f0c1d50b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae307cfa59fe838dab51d1e78f0c1d50b">&#9670;&#160;</a></span>slices() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt; <a class="el" href="class_p_h_v_1_1_alloc_slice.html">PHV::AllocSlice</a> &gt; PHV::Allocation::slices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_p4_1_1_closed_range.html">le_bitrange</a></td>          <td class="paramname"><span class="paramname"><em>range</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>all the slices allocated to <code>c</code> that overlap with <code>range</code>. </dd></dl>

</div>
</div>
<a id="ac70b1093b39166ce635238579630a10b" name="ac70b1093b39166ce635238579630a10b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac70b1093b39166ce635238579630a10b">&#9670;&#160;</a></span>slicesByLiveness() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p4_1_1ordered__set.html">PHV::Allocation::MutuallyLiveSlices</a> PHV::Allocation::slicesByLiveness </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sl</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a set of slices allocated to <code>c</code> that are all live at the same time as <code>sl</code> The previous function (slicesByLiveness(c)) constructs a vector of sets of slices that are live in the container at the same time; the same slice may be found in multiple sets in this case. By contrast, slicesByLiveness(c, sl) uses the mutex_i member to determine all the field slices that are not mutually exclusive with the candidate slice, and returns a set of all such slices. For example, suppose the following slices are allocated to a container c:</dd></dl>
<div class="fragment"><div class="line">c[4:7]&lt;--f2[0:3]</div>
<div class="line">c[4:7]&lt;--f3[0:3]</div>
</div><!-- fragment --><p>where f2 and f3 are overlaid and hence mutex_i(f2, f3) = true. If slice sl is f1[0:3], such that mutex_i(f1, f2) = false and mutex_i(f1, f3) = false, a call to slicesByLiveness(c,
       f1[0:3]) would return the set {f2[0:3], f3[0:3]}. </p>

</div>
</div>
<a id="a9fdccef4ce20ddcc7d600e7c270ee4f8" name="a9fdccef4ce20ddcc7d600e7c270ee4f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fdccef4ce20ddcc7d600e7c270ee4f8">&#9670;&#160;</a></span>slicesByLiveness() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_p4_1_1ordered__set.html">PHV::Allocation::MutuallyLiveSlices</a> &gt; PHV::Allocation::slicesByLiveness </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The allocation manager keeps a list of combinations of slices that are live in the container at the same time, as well as the thread assignment of the container (if any). For example, suppose the following slices are allocated to a container c:</p>
<p>c[0:3]&lt;&ndash;f1[0:3] c[4:7]&lt;&ndash;f2[0:3] c[4:7]&lt;&ndash;f3[0:3]</p>
<p>where f2 and f3 are overlaid. There are then two sets of slices that are live in the container at the same time:</p>
<p>c[0:3]&lt;&ndash;f1[0:3] c[4:7]&lt;&ndash;f2[0:3]</p>
<p>and</p>
<p>c[0:3]&lt;&ndash;f1[0:3] c[4:7]&lt;&ndash;f3[0:3]</p>
<p>When analyzing cohabit constraints, it's important to only compare fields that are live.</p>
<p>Note that the same slice may appear in more than one list.</p>
<dl class="section return"><dt>Returns</dt><dd>the sets of slices allocated to <code>that</code> can be live at the same time. </dd></dl>

</div>
</div>
<a id="aa8821ab69f8a0df68a922d6c864b7332" name="aa8821ab69f8a0df68a922d6c864b7332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8821ab69f8a0df68a922d6c864b7332">&#9670;&#160;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p4_1_1cstring.html">cstring</a> PHV::Allocation::toString </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a pretty-printed representation of this Allocation. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a870e0419befbf6d30c4deade7608ad4d" name="a870e0419befbf6d30c4deade7608ad4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a870e0419befbf6d30c4deade7608ad4d">&#9670;&#160;</a></span>ara_edges</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt;gress_t, <a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt;const IR::MAU::Table *, std::set&lt;const IR::MAU::Table *&gt; &gt; &gt; PHV::Allocation::ara_edges</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For each gress keep track of potential control flow edges implied from/to AlwaysRunAction tables </p>

</div>
</div>
<a id="a485fa3f7938ef2e52fcb96a666c83c4c" name="a485fa3f7938ef2e52fcb96a666c83c4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a485fa3f7938ef2e52fcb96a666c83c4c">&#9670;&#160;</a></span>dark_containers_write_allocated_i</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt;<a class="el" href="class_p_h_v_1_1_container.html">PHV::Container</a>, <a class="el" href="class_p4_1_1bitvec.html">bitvec</a>&gt; PHV::Allocation::dark_containers_write_allocated_i</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dark containers allocated in this allocation mapped to the stages that they are allocated to. The read map captures the allocation from the perspective of a read of that container while the write map captures the allocation from the perspective of a write to that container. </p>

</div>
</div>
<a id="afcfb24182fa901919cd22604627da920" name="afcfb24182fa901919cd22604627da920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcfb24182fa901919cd22604627da920">&#9670;&#160;</a></span>init_writes_i</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt;const IR::MAU::Action *, <a class="el" href="class_p4_1_1ordered__set.html">ordered_set</a>&lt;const <a class="el" href="class_p_h_v_1_1_field.html">PHV::Field</a> *&gt; &gt; PHV::Allocation::init_writes_i</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Structure that remembers actions at which metadata initialization for various fields has been added. </p>

</div>
</div>
<a id="a142627ff4c74ef89f24652bbc4eece45" name="a142627ff4c74ef89f24652bbc4eece45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142627ff4c74ef89f24652bbc4eece45">&#9670;&#160;</a></span>meta_init_points_i</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_p4_1_1ordered__map.html">ordered_map</a>&lt;<a class="el" href="class_p_h_v_1_1_alloc_slice.html">AllocSlice</a>, <a class="el" href="class_p4_1_1ordered__set.html">ActionSet</a>&gt; PHV::Allocation::meta_init_points_i</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Structure that remembers the actions at which metadata fields need to be initialized for a particular allocation object. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.12.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_p_h_v.html">PHV</a></li><li class="navelem"><a class="el" href="class_p_h_v_1_1_allocation.html">Allocation</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
